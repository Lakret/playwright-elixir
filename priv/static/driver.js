#!/usr/bin/env node
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/commander/lib/error.js
var require_error = __commonJS({
  "node_modules/commander/lib/error.js"(exports2) {
    var CommanderError = class extends Error {
      constructor(exitCode, code, message) {
        super(message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
        this.code = code;
        this.exitCode = exitCode;
        this.nestedError = void 0;
      }
    };
    var InvalidArgumentError = class extends CommanderError {
      constructor(message) {
        super(1, "commander.invalidArgument", message);
        Error.captureStackTrace(this, this.constructor);
        this.name = this.constructor.name;
      }
    };
    exports2.CommanderError = CommanderError;
    exports2.InvalidArgumentError = InvalidArgumentError;
  }
});

// node_modules/commander/lib/argument.js
var require_argument = __commonJS({
  "node_modules/commander/lib/argument.js"(exports2) {
    var { InvalidArgumentError } = require_error();
    var Argument = class {
      constructor(name, description) {
        this.description = description || "";
        this.variadic = false;
        this.parseArg = void 0;
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.argChoices = void 0;
        switch (name[0]) {
          case "<":
            this.required = true;
            this._name = name.slice(1, -1);
            break;
          case "[":
            this.required = false;
            this._name = name.slice(1, -1);
            break;
          default:
            this.required = true;
            this._name = name;
            break;
        }
        if (this._name.length > 3 && this._name.slice(-3) === "...") {
          this.variadic = true;
          this._name = this._name.slice(0, -3);
        }
      }
      name() {
        return this._name;
      }
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      choices(values) {
        this.argChoices = values;
        this.parseArg = (arg, previous) => {
          if (!values.includes(arg)) {
            throw new InvalidArgumentError(`Allowed choices are ${values.join(", ")}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      argRequired() {
        this.required = true;
        return this;
      }
      argOptional() {
        this.required = false;
        return this;
      }
    };
    function humanReadableArgName(arg) {
      const nameOutput = arg.name() + (arg.variadic === true ? "..." : "");
      return arg.required ? "<" + nameOutput + ">" : "[" + nameOutput + "]";
    }
    exports2.Argument = Argument;
    exports2.humanReadableArgName = humanReadableArgName;
  }
});

// node_modules/commander/lib/help.js
var require_help = __commonJS({
  "node_modules/commander/lib/help.js"(exports2) {
    var { humanReadableArgName } = require_argument();
    var Help = class {
      constructor() {
        this.helpWidth = void 0;
        this.sortSubcommands = false;
        this.sortOptions = false;
      }
      visibleCommands(cmd) {
        const visibleCommands = cmd.commands.filter((cmd2) => !cmd2._hidden);
        if (cmd._hasImplicitHelpCommand()) {
          const [, helpName, helpArgs] = cmd._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/);
          const helpCommand = cmd.createCommand(helpName).helpOption(false);
          helpCommand.description(cmd._helpCommandDescription);
          if (helpArgs)
            helpCommand.arguments(helpArgs);
          visibleCommands.push(helpCommand);
        }
        if (this.sortSubcommands) {
          visibleCommands.sort((a, b) => {
            return a.name().localeCompare(b.name());
          });
        }
        return visibleCommands;
      }
      visibleOptions(cmd) {
        const visibleOptions = cmd.options.filter((option) => !option.hidden);
        const showShortHelpFlag = cmd._hasHelpOption && cmd._helpShortFlag && !cmd._findOption(cmd._helpShortFlag);
        const showLongHelpFlag = cmd._hasHelpOption && !cmd._findOption(cmd._helpLongFlag);
        if (showShortHelpFlag || showLongHelpFlag) {
          let helpOption;
          if (!showShortHelpFlag) {
            helpOption = cmd.createOption(cmd._helpLongFlag, cmd._helpDescription);
          } else if (!showLongHelpFlag) {
            helpOption = cmd.createOption(cmd._helpShortFlag, cmd._helpDescription);
          } else {
            helpOption = cmd.createOption(cmd._helpFlags, cmd._helpDescription);
          }
          visibleOptions.push(helpOption);
        }
        if (this.sortOptions) {
          const getSortKey = (option) => {
            return option.short ? option.short.replace(/^-/, "") : option.long.replace(/^--/, "");
          };
          visibleOptions.sort((a, b) => {
            return getSortKey(a).localeCompare(getSortKey(b));
          });
        }
        return visibleOptions;
      }
      visibleArguments(cmd) {
        if (cmd._argsDescription) {
          cmd._args.forEach((argument) => {
            argument.description = argument.description || cmd._argsDescription[argument.name()] || "";
          });
        }
        if (cmd._args.find((argument) => argument.description)) {
          return cmd._args;
        }
        ;
        return [];
      }
      subcommandTerm(cmd) {
        const args = cmd._args.map((arg) => humanReadableArgName(arg)).join(" ");
        return cmd._name + (cmd._aliases[0] ? "|" + cmd._aliases[0] : "") + (cmd.options.length ? " [options]" : "") + (args ? " " + args : "");
      }
      optionTerm(option) {
        return option.flags;
      }
      argumentTerm(argument) {
        return argument.name();
      }
      longestSubcommandTermLength(cmd, helper) {
        return helper.visibleCommands(cmd).reduce((max, command) => {
          return Math.max(max, helper.subcommandTerm(command).length);
        }, 0);
      }
      longestOptionTermLength(cmd, helper) {
        return helper.visibleOptions(cmd).reduce((max, option) => {
          return Math.max(max, helper.optionTerm(option).length);
        }, 0);
      }
      longestArgumentTermLength(cmd, helper) {
        return helper.visibleArguments(cmd).reduce((max, argument) => {
          return Math.max(max, helper.argumentTerm(argument).length);
        }, 0);
      }
      commandUsage(cmd) {
        let cmdName = cmd._name;
        if (cmd._aliases[0]) {
          cmdName = cmdName + "|" + cmd._aliases[0];
        }
        let parentCmdNames = "";
        for (let parentCmd = cmd.parent; parentCmd; parentCmd = parentCmd.parent) {
          parentCmdNames = parentCmd.name() + " " + parentCmdNames;
        }
        return parentCmdNames + cmdName + " " + cmd.usage();
      }
      commandDescription(cmd) {
        return cmd.description();
      }
      subcommandDescription(cmd) {
        return cmd.description();
      }
      optionDescription(option) {
        const extraInfo = [];
        if (option.argChoices && !option.negate) {
          extraInfo.push(`choices: ${option.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
        }
        if (option.defaultValue !== void 0 && !option.negate) {
          extraInfo.push(`default: ${option.defaultValueDescription || JSON.stringify(option.defaultValue)}`);
        }
        if (option.envVar !== void 0) {
          extraInfo.push(`env: ${option.envVar}`);
        }
        if (extraInfo.length > 0) {
          return `${option.description} (${extraInfo.join(", ")})`;
        }
        return option.description;
      }
      argumentDescription(argument) {
        const extraInfo = [];
        if (argument.argChoices) {
          extraInfo.push(`choices: ${argument.argChoices.map((choice) => JSON.stringify(choice)).join(", ")}`);
        }
        if (argument.defaultValue !== void 0) {
          extraInfo.push(`default: ${argument.defaultValueDescription || JSON.stringify(argument.defaultValue)}`);
        }
        if (extraInfo.length > 0) {
          const extraDescripton = `(${extraInfo.join(", ")})`;
          if (argument.description) {
            return `${argument.description} ${extraDescripton}`;
          }
          return extraDescripton;
        }
        return argument.description;
      }
      formatHelp(cmd, helper) {
        const termWidth = helper.padWidth(cmd, helper);
        const helpWidth = helper.helpWidth || 80;
        const itemIndentWidth = 2;
        const itemSeparatorWidth = 2;
        function formatItem(term, description) {
          if (description) {
            const fullText = `${term.padEnd(termWidth + itemSeparatorWidth)}${description}`;
            return helper.wrap(fullText, helpWidth - itemIndentWidth, termWidth + itemSeparatorWidth);
          }
          return term;
        }
        ;
        function formatList(textArray) {
          return textArray.join("\n").replace(/^/gm, " ".repeat(itemIndentWidth));
        }
        let output = [`Usage: ${helper.commandUsage(cmd)}`, ""];
        const commandDescription = helper.commandDescription(cmd);
        if (commandDescription.length > 0) {
          output = output.concat([commandDescription, ""]);
        }
        const argumentList = helper.visibleArguments(cmd).map((argument) => {
          return formatItem(helper.argumentTerm(argument), helper.argumentDescription(argument));
        });
        if (argumentList.length > 0) {
          output = output.concat(["Arguments:", formatList(argumentList), ""]);
        }
        const optionList = helper.visibleOptions(cmd).map((option) => {
          return formatItem(helper.optionTerm(option), helper.optionDescription(option));
        });
        if (optionList.length > 0) {
          output = output.concat(["Options:", formatList(optionList), ""]);
        }
        const commandList = helper.visibleCommands(cmd).map((cmd2) => {
          return formatItem(helper.subcommandTerm(cmd2), helper.subcommandDescription(cmd2));
        });
        if (commandList.length > 0) {
          output = output.concat(["Commands:", formatList(commandList), ""]);
        }
        return output.join("\n");
      }
      padWidth(cmd, helper) {
        return Math.max(helper.longestOptionTermLength(cmd, helper), helper.longestSubcommandTermLength(cmd, helper), helper.longestArgumentTermLength(cmd, helper));
      }
      wrap(str, width, indent, minColumnWidth = 40) {
        if (str.match(/[\n]\s+/))
          return str;
        const columnWidth = width - indent;
        if (columnWidth < minColumnWidth)
          return str;
        const leadingStr = str.substr(0, indent);
        const columnText = str.substr(indent);
        const indentString = " ".repeat(indent);
        const regex = new RegExp(".{1," + (columnWidth - 1) + "}([\\s\u200B]|$)|[^\\s\u200B]+?([\\s\u200B]|$)", "g");
        const lines = columnText.match(regex) || [];
        return leadingStr + lines.map((line, i) => {
          if (line.slice(-1) === "\n") {
            line = line.slice(0, line.length - 1);
          }
          return (i > 0 ? indentString : "") + line.trimRight();
        }).join("\n");
      }
    };
    exports2.Help = Help;
  }
});

// node_modules/commander/lib/option.js
var require_option = __commonJS({
  "node_modules/commander/lib/option.js"(exports2) {
    var { InvalidArgumentError } = require_error();
    var Option = class {
      constructor(flags, description) {
        this.flags = flags;
        this.description = description || "";
        this.required = flags.includes("<");
        this.optional = flags.includes("[");
        this.variadic = /\w\.\.\.[>\]]$/.test(flags);
        this.mandatory = false;
        const optionFlags = splitOptionFlags(flags);
        this.short = optionFlags.shortFlag;
        this.long = optionFlags.longFlag;
        this.negate = false;
        if (this.long) {
          this.negate = this.long.startsWith("--no-");
        }
        this.defaultValue = void 0;
        this.defaultValueDescription = void 0;
        this.envVar = void 0;
        this.parseArg = void 0;
        this.hidden = false;
        this.argChoices = void 0;
      }
      default(value, description) {
        this.defaultValue = value;
        this.defaultValueDescription = description;
        return this;
      }
      env(name) {
        this.envVar = name;
        return this;
      }
      argParser(fn) {
        this.parseArg = fn;
        return this;
      }
      makeOptionMandatory(mandatory = true) {
        this.mandatory = !!mandatory;
        return this;
      }
      hideHelp(hide = true) {
        this.hidden = !!hide;
        return this;
      }
      _concatValue(value, previous) {
        if (previous === this.defaultValue || !Array.isArray(previous)) {
          return [value];
        }
        return previous.concat(value);
      }
      choices(values) {
        this.argChoices = values;
        this.parseArg = (arg, previous) => {
          if (!values.includes(arg)) {
            throw new InvalidArgumentError(`Allowed choices are ${values.join(", ")}.`);
          }
          if (this.variadic) {
            return this._concatValue(arg, previous);
          }
          return arg;
        };
        return this;
      }
      name() {
        if (this.long) {
          return this.long.replace(/^--/, "");
        }
        return this.short.replace(/^-/, "");
      }
      attributeName() {
        return camelcase(this.name().replace(/^no-/, ""));
      }
      is(arg) {
        return this.short === arg || this.long === arg;
      }
    };
    function camelcase(str) {
      return str.split("-").reduce((str2, word) => {
        return str2 + word[0].toUpperCase() + word.slice(1);
      });
    }
    function splitOptionFlags(flags) {
      let shortFlag;
      let longFlag;
      const flagParts = flags.split(/[ |,]+/);
      if (flagParts.length > 1 && !/^[[<]/.test(flagParts[1]))
        shortFlag = flagParts.shift();
      longFlag = flagParts.shift();
      if (!shortFlag && /^-[^-]$/.test(longFlag)) {
        shortFlag = longFlag;
        longFlag = void 0;
      }
      return { shortFlag, longFlag };
    }
    exports2.Option = Option;
    exports2.splitOptionFlags = splitOptionFlags;
  }
});

// node_modules/commander/lib/suggestSimilar.js
var require_suggestSimilar = __commonJS({
  "node_modules/commander/lib/suggestSimilar.js"(exports2) {
    var maxDistance = 3;
    function editDistance(a, b) {
      if (Math.abs(a.length - b.length) > maxDistance)
        return Math.max(a.length, b.length);
      const d = [];
      for (let i = 0; i <= a.length; i++) {
        d[i] = [i];
      }
      for (let j = 0; j <= b.length; j++) {
        d[0][j] = j;
      }
      for (let j = 1; j <= b.length; j++) {
        for (let i = 1; i <= a.length; i++) {
          let cost = 1;
          if (a[i - 1] === b[j - 1]) {
            cost = 0;
          } else {
            cost = 1;
          }
          d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
          if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
            d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + 1);
          }
        }
      }
      return d[a.length][b.length];
    }
    function suggestSimilar(word, candidates) {
      if (!candidates || candidates.length === 0)
        return "";
      candidates = Array.from(new Set(candidates));
      const searchingOptions = word.startsWith("--");
      if (searchingOptions) {
        word = word.slice(2);
        candidates = candidates.map((candidate) => candidate.slice(2));
      }
      let similar = [];
      let bestDistance = maxDistance;
      const minSimilarity = 0.4;
      candidates.forEach((candidate) => {
        if (candidate.length <= 1)
          return;
        const distance = editDistance(word, candidate);
        const length = Math.max(word.length, candidate.length);
        const similarity = (length - distance) / length;
        if (similarity > minSimilarity) {
          if (distance < bestDistance) {
            bestDistance = distance;
            similar = [candidate];
          } else if (distance === bestDistance) {
            similar.push(candidate);
          }
        }
      });
      similar.sort((a, b) => a.localeCompare(b));
      if (searchingOptions) {
        similar = similar.map((candidate) => `--${candidate}`);
      }
      if (similar.length > 1) {
        return `
(Did you mean one of ${similar.join(", ")}?)`;
      }
      if (similar.length === 1) {
        return `
(Did you mean ${similar[0]}?)`;
      }
      return "";
    }
    exports2.suggestSimilar = suggestSimilar;
  }
});

// node_modules/commander/lib/command.js
var require_command = __commonJS({
  "node_modules/commander/lib/command.js"(exports2) {
    var EventEmitter = require("events").EventEmitter;
    var childProcess = require("child_process");
    var path = require("path");
    var fs = require("fs");
    var { Argument, humanReadableArgName } = require_argument();
    var { CommanderError } = require_error();
    var { Help } = require_help();
    var { Option, splitOptionFlags } = require_option();
    var { suggestSimilar } = require_suggestSimilar();
    var Command = class extends EventEmitter {
      constructor(name) {
        super();
        this.commands = [];
        this.options = [];
        this.parent = null;
        this._allowUnknownOption = false;
        this._allowExcessArguments = true;
        this._args = [];
        this.args = [];
        this.rawArgs = [];
        this.processedArgs = [];
        this._scriptPath = null;
        this._name = name || "";
        this._optionValues = {};
        this._optionValueSources = {};
        this._storeOptionsAsProperties = false;
        this._actionHandler = null;
        this._executableHandler = false;
        this._executableFile = null;
        this._defaultCommandName = null;
        this._exitCallback = null;
        this._aliases = [];
        this._combineFlagAndOptionalValue = true;
        this._description = "";
        this._argsDescription = void 0;
        this._enablePositionalOptions = false;
        this._passThroughOptions = false;
        this._lifeCycleHooks = {};
        this._showHelpAfterError = false;
        this._showSuggestionAfterError = false;
        this._outputConfiguration = {
          writeOut: (str) => process.stdout.write(str),
          writeErr: (str) => process.stderr.write(str),
          getOutHelpWidth: () => process.stdout.isTTY ? process.stdout.columns : void 0,
          getErrHelpWidth: () => process.stderr.isTTY ? process.stderr.columns : void 0,
          outputError: (str, write) => write(str)
        };
        this._hidden = false;
        this._hasHelpOption = true;
        this._helpFlags = "-h, --help";
        this._helpDescription = "display help for command";
        this._helpShortFlag = "-h";
        this._helpLongFlag = "--help";
        this._addImplicitHelpCommand = void 0;
        this._helpCommandName = "help";
        this._helpCommandnameAndArgs = "help [command]";
        this._helpCommandDescription = "display help for command";
        this._helpConfiguration = {};
      }
      copyInheritedSettings(sourceCommand) {
        this._outputConfiguration = sourceCommand._outputConfiguration;
        this._hasHelpOption = sourceCommand._hasHelpOption;
        this._helpFlags = sourceCommand._helpFlags;
        this._helpDescription = sourceCommand._helpDescription;
        this._helpShortFlag = sourceCommand._helpShortFlag;
        this._helpLongFlag = sourceCommand._helpLongFlag;
        this._helpCommandName = sourceCommand._helpCommandName;
        this._helpCommandnameAndArgs = sourceCommand._helpCommandnameAndArgs;
        this._helpCommandDescription = sourceCommand._helpCommandDescription;
        this._helpConfiguration = sourceCommand._helpConfiguration;
        this._exitCallback = sourceCommand._exitCallback;
        this._storeOptionsAsProperties = sourceCommand._storeOptionsAsProperties;
        this._combineFlagAndOptionalValue = sourceCommand._combineFlagAndOptionalValue;
        this._allowExcessArguments = sourceCommand._allowExcessArguments;
        this._enablePositionalOptions = sourceCommand._enablePositionalOptions;
        this._showHelpAfterError = sourceCommand._showHelpAfterError;
        this._showSuggestionAfterError = sourceCommand._showSuggestionAfterError;
        return this;
      }
      command(nameAndArgs, actionOptsOrExecDesc, execOpts) {
        let desc = actionOptsOrExecDesc;
        let opts = execOpts;
        if (typeof desc === "object" && desc !== null) {
          opts = desc;
          desc = null;
        }
        opts = opts || {};
        const [, name, args] = nameAndArgs.match(/([^ ]+) *(.*)/);
        const cmd = this.createCommand(name);
        if (desc) {
          cmd.description(desc);
          cmd._executableHandler = true;
        }
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        cmd._hidden = !!(opts.noHelp || opts.hidden);
        cmd._executableFile = opts.executableFile || null;
        if (args)
          cmd.arguments(args);
        this.commands.push(cmd);
        cmd.parent = this;
        cmd.copyInheritedSettings(this);
        if (desc)
          return this;
        return cmd;
      }
      createCommand(name) {
        return new Command(name);
      }
      createHelp() {
        return Object.assign(new Help(), this.configureHelp());
      }
      configureHelp(configuration) {
        if (configuration === void 0)
          return this._helpConfiguration;
        this._helpConfiguration = configuration;
        return this;
      }
      configureOutput(configuration) {
        if (configuration === void 0)
          return this._outputConfiguration;
        Object.assign(this._outputConfiguration, configuration);
        return this;
      }
      showHelpAfterError(displayHelp = true) {
        if (typeof displayHelp !== "string")
          displayHelp = !!displayHelp;
        this._showHelpAfterError = displayHelp;
        return this;
      }
      showSuggestionAfterError(displaySuggestion = true) {
        this._showSuggestionAfterError = !!displaySuggestion;
        return this;
      }
      addCommand(cmd, opts) {
        if (!cmd._name)
          throw new Error("Command passed to .addCommand() must have a name");
        function checkExplicitNames(commandArray) {
          commandArray.forEach((cmd2) => {
            if (cmd2._executableHandler && !cmd2._executableFile) {
              throw new Error(`Must specify executableFile for deeply nested executable: ${cmd2.name()}`);
            }
            checkExplicitNames(cmd2.commands);
          });
        }
        checkExplicitNames(cmd.commands);
        opts = opts || {};
        if (opts.isDefault)
          this._defaultCommandName = cmd._name;
        if (opts.noHelp || opts.hidden)
          cmd._hidden = true;
        this.commands.push(cmd);
        cmd.parent = this;
        return this;
      }
      createArgument(name, description) {
        return new Argument(name, description);
      }
      argument(name, description, fn, defaultValue) {
        const argument = this.createArgument(name, description);
        if (typeof fn === "function") {
          argument.default(defaultValue).argParser(fn);
        } else {
          argument.default(fn);
        }
        this.addArgument(argument);
        return this;
      }
      arguments(names) {
        names.split(/ +/).forEach((detail) => {
          this.argument(detail);
        });
        return this;
      }
      addArgument(argument) {
        const previousArgument = this._args.slice(-1)[0];
        if (previousArgument && previousArgument.variadic) {
          throw new Error(`only the last argument can be variadic '${previousArgument.name()}'`);
        }
        if (argument.required && argument.defaultValue !== void 0 && argument.parseArg === void 0) {
          throw new Error(`a default value for a required argument is never used: '${argument.name()}'`);
        }
        this._args.push(argument);
        return this;
      }
      addHelpCommand(enableOrNameAndArgs, description) {
        if (enableOrNameAndArgs === false) {
          this._addImplicitHelpCommand = false;
        } else {
          this._addImplicitHelpCommand = true;
          if (typeof enableOrNameAndArgs === "string") {
            this._helpCommandName = enableOrNameAndArgs.split(" ")[0];
            this._helpCommandnameAndArgs = enableOrNameAndArgs;
          }
          this._helpCommandDescription = description || this._helpCommandDescription;
        }
        return this;
      }
      _hasImplicitHelpCommand() {
        if (this._addImplicitHelpCommand === void 0) {
          return this.commands.length && !this._actionHandler && !this._findCommand("help");
        }
        return this._addImplicitHelpCommand;
      }
      hook(event, listener) {
        const allowedValues = ["preAction", "postAction"];
        if (!allowedValues.includes(event)) {
          throw new Error(`Unexpected value for event passed to hook : '${event}'.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        if (this._lifeCycleHooks[event]) {
          this._lifeCycleHooks[event].push(listener);
        } else {
          this._lifeCycleHooks[event] = [listener];
        }
        return this;
      }
      exitOverride(fn) {
        if (fn) {
          this._exitCallback = fn;
        } else {
          this._exitCallback = (err) => {
            if (err.code !== "commander.executeSubCommandAsync") {
              throw err;
            } else {
            }
          };
        }
        return this;
      }
      _exit(exitCode, code, message) {
        if (this._exitCallback) {
          this._exitCallback(new CommanderError(exitCode, code, message));
        }
        process.exit(exitCode);
      }
      action(fn) {
        const listener = (args) => {
          const expectedArgsCount = this._args.length;
          const actionArgs = args.slice(0, expectedArgsCount);
          if (this._storeOptionsAsProperties) {
            actionArgs[expectedArgsCount] = this;
          } else {
            actionArgs[expectedArgsCount] = this.opts();
          }
          actionArgs.push(this);
          return fn.apply(this, actionArgs);
        };
        this._actionHandler = listener;
        return this;
      }
      createOption(flags, description) {
        return new Option(flags, description);
      }
      addOption(option) {
        const oname = option.name();
        const name = option.attributeName();
        let defaultValue = option.defaultValue;
        if (option.negate || option.optional || option.required || typeof defaultValue === "boolean") {
          if (option.negate) {
            const positiveLongFlag = option.long.replace(/^--no-/, "--");
            defaultValue = this._findOption(positiveLongFlag) ? this.getOptionValue(name) : true;
          }
          if (defaultValue !== void 0) {
            this.setOptionValueWithSource(name, defaultValue, "default");
          }
        }
        this.options.push(option);
        const handleOptionValue = (val, invalidValueMessage, valueSource) => {
          const oldValue = this.getOptionValue(name);
          if (val !== null && option.parseArg) {
            try {
              val = option.parseArg(val, oldValue === void 0 ? defaultValue : oldValue);
            } catch (err) {
              if (err.code === "commander.invalidArgument") {
                const message = `${invalidValueMessage} ${err.message}`;
                this._displayError(err.exitCode, err.code, message);
              }
              throw err;
            }
          } else if (val !== null && option.variadic) {
            val = option._concatValue(val, oldValue);
          }
          if (typeof oldValue === "boolean" || typeof oldValue === "undefined") {
            if (val == null) {
              this.setOptionValueWithSource(name, option.negate ? false : defaultValue || true, valueSource);
            } else {
              this.setOptionValueWithSource(name, val, valueSource);
            }
          } else if (val !== null) {
            this.setOptionValueWithSource(name, option.negate ? false : val, valueSource);
          }
        };
        this.on("option:" + oname, (val) => {
          const invalidValueMessage = `error: option '${option.flags}' argument '${val}' is invalid.`;
          handleOptionValue(val, invalidValueMessage, "cli");
        });
        if (option.envVar) {
          this.on("optionEnv:" + oname, (val) => {
            const invalidValueMessage = `error: option '${option.flags}' value '${val}' from env '${option.envVar}' is invalid.`;
            handleOptionValue(val, invalidValueMessage, "env");
          });
        }
        return this;
      }
      _optionEx(config, flags, description, fn, defaultValue) {
        const option = this.createOption(flags, description);
        option.makeOptionMandatory(!!config.mandatory);
        if (typeof fn === "function") {
          option.default(defaultValue).argParser(fn);
        } else if (fn instanceof RegExp) {
          const regex = fn;
          fn = (val, def) => {
            const m = regex.exec(val);
            return m ? m[0] : def;
          };
          option.default(defaultValue).argParser(fn);
        } else {
          option.default(fn);
        }
        return this.addOption(option);
      }
      option(flags, description, fn, defaultValue) {
        return this._optionEx({}, flags, description, fn, defaultValue);
      }
      requiredOption(flags, description, fn, defaultValue) {
        return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);
      }
      combineFlagAndOptionalValue(combine = true) {
        this._combineFlagAndOptionalValue = !!combine;
        return this;
      }
      allowUnknownOption(allowUnknown = true) {
        this._allowUnknownOption = !!allowUnknown;
        return this;
      }
      allowExcessArguments(allowExcess = true) {
        this._allowExcessArguments = !!allowExcess;
        return this;
      }
      enablePositionalOptions(positional = true) {
        this._enablePositionalOptions = !!positional;
        return this;
      }
      passThroughOptions(passThrough = true) {
        this._passThroughOptions = !!passThrough;
        if (!!this.parent && passThrough && !this.parent._enablePositionalOptions) {
          throw new Error("passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)");
        }
        return this;
      }
      storeOptionsAsProperties(storeAsProperties = true) {
        this._storeOptionsAsProperties = !!storeAsProperties;
        if (this.options.length) {
          throw new Error("call .storeOptionsAsProperties() before adding options");
        }
        return this;
      }
      getOptionValue(key) {
        if (this._storeOptionsAsProperties) {
          return this[key];
        }
        return this._optionValues[key];
      }
      setOptionValue(key, value) {
        if (this._storeOptionsAsProperties) {
          this[key] = value;
        } else {
          this._optionValues[key] = value;
        }
        return this;
      }
      setOptionValueWithSource(key, value, source) {
        this.setOptionValue(key, value);
        this._optionValueSources[key] = source;
        return this;
      }
      getOptionValueSource(key) {
        return this._optionValueSources[key];
      }
      _prepareUserArgs(argv, parseOptions) {
        if (argv !== void 0 && !Array.isArray(argv)) {
          throw new Error("first parameter to parse must be array or undefined");
        }
        parseOptions = parseOptions || {};
        if (argv === void 0) {
          argv = process.argv;
          if (process.versions && process.versions.electron) {
            parseOptions.from = "electron";
          }
        }
        this.rawArgs = argv.slice();
        let userArgs;
        switch (parseOptions.from) {
          case void 0:
          case "node":
            this._scriptPath = argv[1];
            userArgs = argv.slice(2);
            break;
          case "electron":
            if (process.defaultApp) {
              this._scriptPath = argv[1];
              userArgs = argv.slice(2);
            } else {
              userArgs = argv.slice(1);
            }
            break;
          case "user":
            userArgs = argv.slice(0);
            break;
          default:
            throw new Error(`unexpected parse option { from: '${parseOptions.from}' }`);
        }
        if (!this._scriptPath && require.main) {
          this._scriptPath = require.main.filename;
        }
        this._name = this._name || this._scriptPath && path.basename(this._scriptPath, path.extname(this._scriptPath));
        return userArgs;
      }
      parse(argv, parseOptions) {
        const userArgs = this._prepareUserArgs(argv, parseOptions);
        this._parseCommand([], userArgs);
        return this;
      }
      parseAsync(argv, parseOptions) {
        return __async(this, null, function* () {
          const userArgs = this._prepareUserArgs(argv, parseOptions);
          yield this._parseCommand([], userArgs);
          return this;
        });
      }
      _executeSubCommand(subcommand, args) {
        args = args.slice();
        let launchWithNode = false;
        const sourceExt = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
        this._checkForMissingMandatoryOptions();
        let scriptPath = this._scriptPath;
        if (!scriptPath && require.main) {
          scriptPath = require.main.filename;
        }
        let baseDir;
        try {
          const resolvedLink = fs.realpathSync(scriptPath);
          baseDir = path.dirname(resolvedLink);
        } catch (e) {
          baseDir = ".";
        }
        let bin = path.basename(scriptPath, path.extname(scriptPath)) + "-" + subcommand._name;
        if (subcommand._executableFile) {
          bin = subcommand._executableFile;
        }
        const localBin = path.join(baseDir, bin);
        if (fs.existsSync(localBin)) {
          bin = localBin;
        } else {
          sourceExt.forEach((ext) => {
            if (fs.existsSync(`${localBin}${ext}`)) {
              bin = `${localBin}${ext}`;
            }
          });
        }
        launchWithNode = sourceExt.includes(path.extname(bin));
        let proc;
        if (process.platform !== "win32") {
          if (launchWithNode) {
            args.unshift(bin);
            args = incrementNodeInspectorPort(process.execArgv).concat(args);
            proc = childProcess.spawn(process.argv[0], args, { stdio: "inherit" });
          } else {
            proc = childProcess.spawn(bin, args, { stdio: "inherit" });
          }
        } else {
          args.unshift(bin);
          args = incrementNodeInspectorPort(process.execArgv).concat(args);
          proc = childProcess.spawn(process.execPath, args, { stdio: "inherit" });
        }
        const signals = ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"];
        signals.forEach((signal) => {
          process.on(signal, () => {
            if (proc.killed === false && proc.exitCode === null) {
              proc.kill(signal);
            }
          });
        });
        const exitCallback = this._exitCallback;
        if (!exitCallback) {
          proc.on("close", process.exit.bind(process));
        } else {
          proc.on("close", () => {
            exitCallback(new CommanderError(process.exitCode || 0, "commander.executeSubCommandAsync", "(close)"));
          });
        }
        proc.on("error", (err) => {
          if (err.code === "ENOENT") {
            const executableMissing = `'${bin}' does not exist
 - if '${subcommand._name}' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead
 - if the default executable name is not suitable, use the executableFile option to supply a custom name`;
            throw new Error(executableMissing);
          } else if (err.code === "EACCES") {
            throw new Error(`'${bin}' not executable`);
          }
          if (!exitCallback) {
            process.exit(1);
          } else {
            const wrappedError = new CommanderError(1, "commander.executeSubCommandAsync", "(error)");
            wrappedError.nestedError = err;
            exitCallback(wrappedError);
          }
        });
        this.runningCommand = proc;
      }
      _dispatchSubcommand(commandName, operands, unknown) {
        const subCommand = this._findCommand(commandName);
        if (!subCommand)
          this.help({ error: true });
        if (subCommand._executableHandler) {
          this._executeSubCommand(subCommand, operands.concat(unknown));
        } else {
          return subCommand._parseCommand(operands, unknown);
        }
      }
      _checkNumberOfArguments() {
        this._args.forEach((arg, i) => {
          if (arg.required && this.args[i] == null) {
            this.missingArgument(arg.name());
          }
        });
        if (this._args.length > 0 && this._args[this._args.length - 1].variadic) {
          return;
        }
        if (this.args.length > this._args.length) {
          this._excessArguments(this.args);
        }
      }
      _processArguments() {
        const myParseArg = (argument, value, previous) => {
          let parsedValue = value;
          if (value !== null && argument.parseArg) {
            try {
              parsedValue = argument.parseArg(value, previous);
            } catch (err) {
              if (err.code === "commander.invalidArgument") {
                const message = `error: command-argument value '${value}' is invalid for argument '${argument.name()}'. ${err.message}`;
                this._displayError(err.exitCode, err.code, message);
              }
              throw err;
            }
          }
          return parsedValue;
        };
        this._checkNumberOfArguments();
        const processedArgs = [];
        this._args.forEach((declaredArg, index) => {
          let value = declaredArg.defaultValue;
          if (declaredArg.variadic) {
            if (index < this.args.length) {
              value = this.args.slice(index);
              if (declaredArg.parseArg) {
                value = value.reduce((processed, v) => {
                  return myParseArg(declaredArg, v, processed);
                }, declaredArg.defaultValue);
              }
            } else if (value === void 0) {
              value = [];
            }
          } else if (index < this.args.length) {
            value = this.args[index];
            if (declaredArg.parseArg) {
              value = myParseArg(declaredArg, value, declaredArg.defaultValue);
            }
          }
          processedArgs[index] = value;
        });
        this.processedArgs = processedArgs;
      }
      _chainOrCall(promise, fn) {
        if (promise && promise.then && typeof promise.then === "function") {
          return promise.then(() => fn());
        }
        return fn();
      }
      _chainOrCallHooks(promise, event) {
        let result = promise;
        const hooks = [];
        getCommandAndParents(this).reverse().filter((cmd) => cmd._lifeCycleHooks[event] !== void 0).forEach((hookedCommand) => {
          hookedCommand._lifeCycleHooks[event].forEach((callback) => {
            hooks.push({ hookedCommand, callback });
          });
        });
        if (event === "postAction") {
          hooks.reverse();
        }
        hooks.forEach((hookDetail) => {
          result = this._chainOrCall(result, () => {
            return hookDetail.callback(hookDetail.hookedCommand, this);
          });
        });
        return result;
      }
      _parseCommand(operands, unknown) {
        const parsed = this.parseOptions(unknown);
        this._parseOptionsEnv();
        operands = operands.concat(parsed.operands);
        unknown = parsed.unknown;
        this.args = operands.concat(unknown);
        if (operands && this._findCommand(operands[0])) {
          return this._dispatchSubcommand(operands[0], operands.slice(1), unknown);
        }
        if (this._hasImplicitHelpCommand() && operands[0] === this._helpCommandName) {
          if (operands.length === 1) {
            this.help();
          }
          return this._dispatchSubcommand(operands[1], [], [this._helpLongFlag]);
        }
        if (this._defaultCommandName) {
          outputHelpIfRequested(this, unknown);
          return this._dispatchSubcommand(this._defaultCommandName, operands, unknown);
        }
        if (this.commands.length && this.args.length === 0 && !this._actionHandler && !this._defaultCommandName) {
          this.help({ error: true });
        }
        outputHelpIfRequested(this, parsed.unknown);
        this._checkForMissingMandatoryOptions();
        const checkForUnknownOptions = () => {
          if (parsed.unknown.length > 0) {
            this.unknownOption(parsed.unknown[0]);
          }
        };
        const commandEvent = `command:${this.name()}`;
        if (this._actionHandler) {
          checkForUnknownOptions();
          this._processArguments();
          let actionResult;
          actionResult = this._chainOrCallHooks(actionResult, "preAction");
          actionResult = this._chainOrCall(actionResult, () => this._actionHandler(this.processedArgs));
          if (this.parent)
            this.parent.emit(commandEvent, operands, unknown);
          actionResult = this._chainOrCallHooks(actionResult, "postAction");
          return actionResult;
        }
        if (this.parent && this.parent.listenerCount(commandEvent)) {
          checkForUnknownOptions();
          this._processArguments();
          this.parent.emit(commandEvent, operands, unknown);
        } else if (operands.length) {
          if (this._findCommand("*")) {
            return this._dispatchSubcommand("*", operands, unknown);
          }
          if (this.listenerCount("command:*")) {
            this.emit("command:*", operands, unknown);
          } else if (this.commands.length) {
            this.unknownCommand();
          } else {
            checkForUnknownOptions();
            this._processArguments();
          }
        } else if (this.commands.length) {
          checkForUnknownOptions();
          this.help({ error: true });
        } else {
          checkForUnknownOptions();
          this._processArguments();
        }
      }
      _findCommand(name) {
        if (!name)
          return void 0;
        return this.commands.find((cmd) => cmd._name === name || cmd._aliases.includes(name));
      }
      _findOption(arg) {
        return this.options.find((option) => option.is(arg));
      }
      _checkForMissingMandatoryOptions() {
        for (let cmd = this; cmd; cmd = cmd.parent) {
          cmd.options.forEach((anOption) => {
            if (anOption.mandatory && cmd.getOptionValue(anOption.attributeName()) === void 0) {
              cmd.missingMandatoryOptionValue(anOption);
            }
          });
        }
      }
      parseOptions(argv) {
        const operands = [];
        const unknown = [];
        let dest = operands;
        const args = argv.slice();
        function maybeOption(arg) {
          return arg.length > 1 && arg[0] === "-";
        }
        let activeVariadicOption = null;
        while (args.length) {
          const arg = args.shift();
          if (arg === "--") {
            if (dest === unknown)
              dest.push(arg);
            dest.push(...args);
            break;
          }
          if (activeVariadicOption && !maybeOption(arg)) {
            this.emit(`option:${activeVariadicOption.name()}`, arg);
            continue;
          }
          activeVariadicOption = null;
          if (maybeOption(arg)) {
            const option = this._findOption(arg);
            if (option) {
              if (option.required) {
                const value = args.shift();
                if (value === void 0)
                  this.optionMissingArgument(option);
                this.emit(`option:${option.name()}`, value);
              } else if (option.optional) {
                let value = null;
                if (args.length > 0 && !maybeOption(args[0])) {
                  value = args.shift();
                }
                this.emit(`option:${option.name()}`, value);
              } else {
                this.emit(`option:${option.name()}`);
              }
              activeVariadicOption = option.variadic ? option : null;
              continue;
            }
          }
          if (arg.length > 2 && arg[0] === "-" && arg[1] !== "-") {
            const option = this._findOption(`-${arg[1]}`);
            if (option) {
              if (option.required || option.optional && this._combineFlagAndOptionalValue) {
                this.emit(`option:${option.name()}`, arg.slice(2));
              } else {
                this.emit(`option:${option.name()}`);
                args.unshift(`-${arg.slice(2)}`);
              }
              continue;
            }
          }
          if (/^--[^=]+=/.test(arg)) {
            const index = arg.indexOf("=");
            const option = this._findOption(arg.slice(0, index));
            if (option && (option.required || option.optional)) {
              this.emit(`option:${option.name()}`, arg.slice(index + 1));
              continue;
            }
          }
          if (maybeOption(arg)) {
            dest = unknown;
          }
          if ((this._enablePositionalOptions || this._passThroughOptions) && operands.length === 0 && unknown.length === 0) {
            if (this._findCommand(arg)) {
              operands.push(arg);
              if (args.length > 0)
                unknown.push(...args);
              break;
            } else if (arg === this._helpCommandName && this._hasImplicitHelpCommand()) {
              operands.push(arg);
              if (args.length > 0)
                operands.push(...args);
              break;
            } else if (this._defaultCommandName) {
              unknown.push(arg);
              if (args.length > 0)
                unknown.push(...args);
              break;
            }
          }
          if (this._passThroughOptions) {
            dest.push(arg);
            if (args.length > 0)
              dest.push(...args);
            break;
          }
          dest.push(arg);
        }
        return { operands, unknown };
      }
      opts() {
        if (this._storeOptionsAsProperties) {
          const result = {};
          const len = this.options.length;
          for (let i = 0; i < len; i++) {
            const key = this.options[i].attributeName();
            result[key] = key === this._versionOptionName ? this._version : this[key];
          }
          return result;
        }
        return this._optionValues;
      }
      _displayError(exitCode, code, message) {
        this._outputConfiguration.outputError(`${message}
`, this._outputConfiguration.writeErr);
        if (typeof this._showHelpAfterError === "string") {
          this._outputConfiguration.writeErr(`${this._showHelpAfterError}
`);
        } else if (this._showHelpAfterError) {
          this._outputConfiguration.writeErr("\n");
          this.outputHelp({ error: true });
        }
        this._exit(exitCode, code, message);
      }
      _parseOptionsEnv() {
        this.options.forEach((option) => {
          if (option.envVar && option.envVar in process.env) {
            const optionKey = option.attributeName();
            if (this.getOptionValue(optionKey) === void 0 || ["default", "config", "env"].includes(this.getOptionValueSource(optionKey))) {
              if (option.required || option.optional) {
                this.emit(`optionEnv:${option.name()}`, process.env[option.envVar]);
              } else {
                this.emit(`optionEnv:${option.name()}`);
              }
            }
          }
        });
      }
      missingArgument(name) {
        const message = `error: missing required argument '${name}'`;
        this._displayError(1, "commander.missingArgument", message);
      }
      optionMissingArgument(option) {
        const message = `error: option '${option.flags}' argument missing`;
        this._displayError(1, "commander.optionMissingArgument", message);
      }
      missingMandatoryOptionValue(option) {
        const message = `error: required option '${option.flags}' not specified`;
        this._displayError(1, "commander.missingMandatoryOptionValue", message);
      }
      unknownOption(flag) {
        if (this._allowUnknownOption)
          return;
        let suggestion = "";
        if (flag.startsWith("--") && this._showSuggestionAfterError) {
          let candidateFlags = [];
          let command = this;
          do {
            const moreFlags = command.createHelp().visibleOptions(command).filter((option) => option.long).map((option) => option.long);
            candidateFlags = candidateFlags.concat(moreFlags);
            command = command.parent;
          } while (command && !command._enablePositionalOptions);
          suggestion = suggestSimilar(flag, candidateFlags);
        }
        const message = `error: unknown option '${flag}'${suggestion}`;
        this._displayError(1, "commander.unknownOption", message);
      }
      _excessArguments(receivedArgs) {
        if (this._allowExcessArguments)
          return;
        const expected = this._args.length;
        const s = expected === 1 ? "" : "s";
        const forSubcommand = this.parent ? ` for '${this.name()}'` : "";
        const message = `error: too many arguments${forSubcommand}. Expected ${expected} argument${s} but got ${receivedArgs.length}.`;
        this._displayError(1, "commander.excessArguments", message);
      }
      unknownCommand() {
        const unknownName = this.args[0];
        let suggestion = "";
        if (this._showSuggestionAfterError) {
          const candidateNames = [];
          this.createHelp().visibleCommands(this).forEach((command) => {
            candidateNames.push(command.name());
            if (command.alias())
              candidateNames.push(command.alias());
          });
          suggestion = suggestSimilar(unknownName, candidateNames);
        }
        const message = `error: unknown command '${unknownName}'${suggestion}`;
        this._displayError(1, "commander.unknownCommand", message);
      }
      version(str, flags, description) {
        if (str === void 0)
          return this._version;
        this._version = str;
        flags = flags || "-V, --version";
        description = description || "output the version number";
        const versionOption = this.createOption(flags, description);
        this._versionOptionName = versionOption.attributeName();
        this.options.push(versionOption);
        this.on("option:" + versionOption.name(), () => {
          this._outputConfiguration.writeOut(`${str}
`);
          this._exit(0, "commander.version", str);
        });
        return this;
      }
      description(str, argsDescription) {
        if (str === void 0 && argsDescription === void 0)
          return this._description;
        this._description = str;
        if (argsDescription) {
          this._argsDescription = argsDescription;
        }
        return this;
      }
      alias(alias) {
        if (alias === void 0)
          return this._aliases[0];
        let command = this;
        if (this.commands.length !== 0 && this.commands[this.commands.length - 1]._executableHandler) {
          command = this.commands[this.commands.length - 1];
        }
        if (alias === command._name)
          throw new Error("Command alias can't be the same as its name");
        command._aliases.push(alias);
        return this;
      }
      aliases(aliases) {
        if (aliases === void 0)
          return this._aliases;
        aliases.forEach((alias) => this.alias(alias));
        return this;
      }
      usage(str) {
        if (str === void 0) {
          if (this._usage)
            return this._usage;
          const args = this._args.map((arg) => {
            return humanReadableArgName(arg);
          });
          return [].concat(this.options.length || this._hasHelpOption ? "[options]" : [], this.commands.length ? "[command]" : [], this._args.length ? args : []).join(" ");
        }
        this._usage = str;
        return this;
      }
      name(str) {
        if (str === void 0)
          return this._name;
        this._name = str;
        return this;
      }
      helpInformation(contextOptions) {
        const helper = this.createHelp();
        if (helper.helpWidth === void 0) {
          helper.helpWidth = contextOptions && contextOptions.error ? this._outputConfiguration.getErrHelpWidth() : this._outputConfiguration.getOutHelpWidth();
        }
        return helper.formatHelp(this, helper);
      }
      _getHelpContext(contextOptions) {
        contextOptions = contextOptions || {};
        const context = { error: !!contextOptions.error };
        let write;
        if (context.error) {
          write = (arg) => this._outputConfiguration.writeErr(arg);
        } else {
          write = (arg) => this._outputConfiguration.writeOut(arg);
        }
        context.write = contextOptions.write || write;
        context.command = this;
        return context;
      }
      outputHelp(contextOptions) {
        let deprecatedCallback;
        if (typeof contextOptions === "function") {
          deprecatedCallback = contextOptions;
          contextOptions = void 0;
        }
        const context = this._getHelpContext(contextOptions);
        getCommandAndParents(this).reverse().forEach((command) => command.emit("beforeAllHelp", context));
        this.emit("beforeHelp", context);
        let helpInformation = this.helpInformation(context);
        if (deprecatedCallback) {
          helpInformation = deprecatedCallback(helpInformation);
          if (typeof helpInformation !== "string" && !Buffer.isBuffer(helpInformation)) {
            throw new Error("outputHelp callback must return a string or a Buffer");
          }
        }
        context.write(helpInformation);
        this.emit(this._helpLongFlag);
        this.emit("afterHelp", context);
        getCommandAndParents(this).forEach((command) => command.emit("afterAllHelp", context));
      }
      helpOption(flags, description) {
        if (typeof flags === "boolean") {
          this._hasHelpOption = flags;
          return this;
        }
        this._helpFlags = flags || this._helpFlags;
        this._helpDescription = description || this._helpDescription;
        const helpFlags = splitOptionFlags(this._helpFlags);
        this._helpShortFlag = helpFlags.shortFlag;
        this._helpLongFlag = helpFlags.longFlag;
        return this;
      }
      help(contextOptions) {
        this.outputHelp(contextOptions);
        let exitCode = process.exitCode || 0;
        if (exitCode === 0 && contextOptions && typeof contextOptions !== "function" && contextOptions.error) {
          exitCode = 1;
        }
        this._exit(exitCode, "commander.help", "(outputHelp)");
      }
      addHelpText(position, text) {
        const allowedValues = ["beforeAll", "before", "after", "afterAll"];
        if (!allowedValues.includes(position)) {
          throw new Error(`Unexpected value for position to addHelpText.
Expecting one of '${allowedValues.join("', '")}'`);
        }
        const helpEvent = `${position}Help`;
        this.on(helpEvent, (context) => {
          let helpStr;
          if (typeof text === "function") {
            helpStr = text({ error: context.error, command: context.command });
          } else {
            helpStr = text;
          }
          if (helpStr) {
            context.write(`${helpStr}
`);
          }
        });
        return this;
      }
    };
    function outputHelpIfRequested(cmd, args) {
      const helpOption = cmd._hasHelpOption && args.find((arg) => arg === cmd._helpLongFlag || arg === cmd._helpShortFlag);
      if (helpOption) {
        cmd.outputHelp();
        cmd._exit(0, "commander.helpDisplayed", "(outputHelp)");
      }
    }
    function incrementNodeInspectorPort(args) {
      return args.map((arg) => {
        if (!arg.startsWith("--inspect")) {
          return arg;
        }
        let debugOption;
        let debugHost = "127.0.0.1";
        let debugPort = "9229";
        let match;
        if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
          debugOption = match[1];
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
          debugOption = match[1];
          if (/^\d+$/.test(match[3])) {
            debugPort = match[3];
          } else {
            debugHost = match[3];
          }
        } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
          debugOption = match[1];
          debugHost = match[3];
          debugPort = match[4];
        }
        if (debugOption && debugPort !== "0") {
          return `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
        }
        return arg;
      });
    }
    function getCommandAndParents(startCommand) {
      const result = [];
      for (let command = startCommand; command; command = command.parent) {
        result.push(command);
      }
      return result;
    }
    exports2.Command = Command;
  }
});

// node_modules/commander/index.js
var require_commander = __commonJS({
  "node_modules/commander/index.js"(exports2, module2) {
    var { Argument } = require_argument();
    var { Command } = require_command();
    var { CommanderError, InvalidArgumentError } = require_error();
    var { Help } = require_help();
    var { Option } = require_option();
    exports2 = module2.exports = new Command();
    exports2.program = exports2;
    exports2.Argument = Argument;
    exports2.Command = Command;
    exports2.CommanderError = CommanderError;
    exports2.Help = Help;
    exports2.InvalidArgumentError = InvalidArgumentError;
    exports2.InvalidOptionArgumentError = InvalidArgumentError;
    exports2.Option = Option;
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports2, module2) {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
      }
      if (!fs.lutimes) {
        patchLutimes(fs);
      }
      fs.chown = chownFix(fs.chown);
      fs.fchown = chownFix(fs.fchown);
      fs.lchown = chownFix(fs.lchown);
      fs.chmod = chmodFix(fs.chmod);
      fs.fchmod = chmodFix(fs.fchmod);
      fs.lchmod = chmodFix(fs.lchmod);
      fs.chownSync = chownFixSync(fs.chownSync);
      fs.fchownSync = chownFixSync(fs.fchownSync);
      fs.lchownSync = chownFixSync(fs.lchownSync);
      fs.chmodSync = chmodFixSync(fs.chmodSync);
      fs.fchmodSync = chmodFixSync(fs.fchmodSync);
      fs.lchmodSync = chmodFixSync(fs.lchmodSync);
      fs.stat = statFix(fs.stat);
      fs.fstat = statFix(fs.fstat);
      fs.lstat = statFix(fs.lstat);
      fs.statSync = statFixSync(fs.statSync);
      fs.fstatSync = statFixSync(fs.fstatSync);
      fs.lstatSync = statFixSync(fs.lstatSync);
      if (fs.chmod && !fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs.lchmodSync = function() {
        };
      }
      if (fs.chown && !fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs.rename = typeof fs.rename !== "function" ? fs.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs.rename);
      }
      fs.read = typeof fs.read !== "function" ? fs.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs.read);
      fs.readSync = typeof fs.readSync !== "function" ? fs.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs.readSync);
      function patchLchmod(fs2) {
        fs2.lchmod = function(path, mode, callback) {
          fs2.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
            if (err) {
              if (callback)
                callback(err);
              return;
            }
            fs2.fchmod(fd, mode, function(err2) {
              fs2.close(fd, function(err22) {
                if (callback)
                  callback(err2 || err22);
              });
            });
          });
        };
        fs2.lchmodSync = function(path, mode) {
          var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs2.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs2) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs2.futimes) {
          fs2.lutimes = function(path, at, mt, cb) {
            fs2.open(path, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs2.futimes(fd, at, mt, function(er2) {
                fs2.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs2.lutimesSync = function(path, at, mt) {
            var fd = fs2.openSync(path, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs2.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs2.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs2.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs2.futimes) {
          fs2.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs2.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports2, module2) {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path, options);
        Stream.call(this);
        var self2 = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if (typeof this.end !== "number") {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports2, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports2, module2) {
    var fs = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs, queue);
      fs.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs.close);
      fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs[gracefulQueue]);
          require("assert").equal(fs[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs[gracefulQueue]);
    }
    module2.exports = patch(clone(fs));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
      module2.exports = patch(fs);
      fs.__patched = true;
    }
    function patch(fs2) {
      polyfills(fs2);
      fs2.gracefulify = patch;
      fs2.createReadStream = createReadStream;
      fs2.createWriteStream = createWriteStream;
      var fs$readFile = fs2.readFile;
      fs2.readFile = readFile;
      function readFile(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path, options, cb);
        function go$readFile(path2, options2, cb2, startTime) {
          return fs$readFile(path2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs2.writeFile;
      fs2.writeFile = writeFile;
      function writeFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        function go$writeFile(path2, data2, options2, cb2, startTime) {
          return fs$writeFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs2.appendFile;
      if (fs$appendFile)
        fs2.appendFile = appendFile;
      function appendFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        function go$appendFile(path2, data2, options2, cb2, startTime) {
          return fs$appendFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs2.copyFile;
      if (fs$copyFile)
        fs2.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs2.readdir;
      fs2.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, fs$readdirCallback(path2, options2, cb2, startTime));
        } : function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, options2, fs$readdirCallback(path2, options2, cb2, startTime));
        };
        return go$readdir(path, options, cb);
        function fs$readdirCallback(path2, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path2, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs2);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs2.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs2.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs2, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs2, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs2, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs2, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path, options) {
        return new fs2.ReadStream(path, options);
      }
      function createWriteStream(path, options) {
        return new fs2.WriteStream(path, options);
      }
      var fs$open = fs2.open;
      fs2.open = open;
      function open(path, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        function go$open(path2, flags2, mode2, cb2, startTime) {
          return fs$open(path2, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs2;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs[gracefulQueue].length; ++i) {
        if (fs[gracefulQueue][i].length > 2) {
          fs[gracefulQueue][i][3] = now;
          fs[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs[gracefulQueue].length === 0)
        return;
      var elem = fs[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts;
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = new Date().getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(this._errors.length - 1, this._errors.length);
          this._timeouts = this._cachedTimeouts.slice(0);
          timeout = this._timeouts.shift();
        } else {
          return false;
        }
      }
      var self2 = this;
      var timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = new Date().getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports2) {
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && options.forever,
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports2, module2) {
    module2.exports = require_retry();
  }
});

// node_modules/signal-exit/signals.js
var require_signals = __commonJS({
  "node_modules/signal-exit/signals.js"(exports2, module2) {
    module2.exports = [
      "SIGABRT",
      "SIGALRM",
      "SIGHUP",
      "SIGINT",
      "SIGTERM"
    ];
    if (process.platform !== "win32") {
      module2.exports.push("SIGVTALRM", "SIGXCPU", "SIGXFSZ", "SIGUSR2", "SIGTRAP", "SIGSYS", "SIGQUIT", "SIGIOT");
    }
    if (process.platform === "linux") {
      module2.exports.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT", "SIGUNUSED");
    }
  }
});

// node_modules/signal-exit/index.js
var require_signal_exit = __commonJS({
  "node_modules/signal-exit/index.js"(exports2, module2) {
    var process2 = global.process;
    var processOk = function(process3) {
      return process3 && typeof process3 === "object" && typeof process3.removeListener === "function" && typeof process3.emit === "function" && typeof process3.reallyExit === "function" && typeof process3.listeners === "function" && typeof process3.kill === "function" && typeof process3.pid === "number" && typeof process3.on === "function";
    };
    if (!processOk(process2)) {
      module2.exports = function() {
        return function() {
        };
      };
    } else {
      assert = require("assert");
      signals = require_signals();
      isWin = /^win/i.test(process2.platform);
      EE = require("events");
      if (typeof EE !== "function") {
        EE = EE.EventEmitter;
      }
      if (process2.__signal_exit_emitter__) {
        emitter = process2.__signal_exit_emitter__;
      } else {
        emitter = process2.__signal_exit_emitter__ = new EE();
        emitter.count = 0;
        emitter.emitted = {};
      }
      if (!emitter.infinite) {
        emitter.setMaxListeners(Infinity);
        emitter.infinite = true;
      }
      module2.exports = function(cb, opts) {
        if (!processOk(global.process)) {
          return function() {
          };
        }
        assert.equal(typeof cb, "function", "a callback must be provided for exit handler");
        if (loaded === false) {
          load();
        }
        var ev = "exit";
        if (opts && opts.alwaysLast) {
          ev = "afterexit";
        }
        var remove = function() {
          emitter.removeListener(ev, cb);
          if (emitter.listeners("exit").length === 0 && emitter.listeners("afterexit").length === 0) {
            unload();
          }
        };
        emitter.on(ev, cb);
        return remove;
      };
      unload = function unload2() {
        if (!loaded || !processOk(global.process)) {
          return;
        }
        loaded = false;
        signals.forEach(function(sig) {
          try {
            process2.removeListener(sig, sigListeners[sig]);
          } catch (er) {
          }
        });
        process2.emit = originalProcessEmit;
        process2.reallyExit = originalProcessReallyExit;
        emitter.count -= 1;
      };
      module2.exports.unload = unload;
      emit = function emit2(event, code, signal) {
        if (emitter.emitted[event]) {
          return;
        }
        emitter.emitted[event] = true;
        emitter.emit(event, code, signal);
      };
      sigListeners = {};
      signals.forEach(function(sig) {
        sigListeners[sig] = function listener() {
          if (!processOk(global.process)) {
            return;
          }
          var listeners = process2.listeners(sig);
          if (listeners.length === emitter.count) {
            unload();
            emit("exit", null, sig);
            emit("afterexit", null, sig);
            if (isWin && sig === "SIGHUP") {
              sig = "SIGINT";
            }
            process2.kill(process2.pid, sig);
          }
        };
      });
      module2.exports.signals = function() {
        return signals;
      };
      loaded = false;
      load = function load2() {
        if (loaded || !processOk(global.process)) {
          return;
        }
        loaded = true;
        emitter.count += 1;
        signals = signals.filter(function(sig) {
          try {
            process2.on(sig, sigListeners[sig]);
            return true;
          } catch (er) {
            return false;
          }
        });
        process2.emit = processEmit;
        process2.reallyExit = processReallyExit;
      };
      module2.exports.load = load;
      originalProcessReallyExit = process2.reallyExit;
      processReallyExit = function processReallyExit2(code) {
        if (!processOk(global.process)) {
          return;
        }
        process2.exitCode = code || 0;
        emit("exit", process2.exitCode, null);
        emit("afterexit", process2.exitCode, null);
        originalProcessReallyExit.call(process2, process2.exitCode);
      };
      originalProcessEmit = process2.emit;
      processEmit = function processEmit2(ev, arg) {
        if (ev === "exit" && processOk(global.process)) {
          if (arg !== void 0) {
            process2.exitCode = arg;
          }
          var ret = originalProcessEmit.apply(this, arguments);
          emit("exit", process2.exitCode, null);
          emit("afterexit", process2.exitCode, null);
          return ret;
        } else {
          return originalProcessEmit.apply(this, arguments);
        }
      };
    }
    var assert;
    var signals;
    var isWin;
    var EE;
    var emitter;
    var unload;
    var emit;
    var sigListeners;
    var loaded;
    var load;
    var originalProcessReallyExit;
    var processReallyExit;
    var originalProcessEmit;
    var processEmit;
  }
});

// node_modules/proper-lockfile/lib/mtime-precision.js
var require_mtime_precision = __commonJS({
  "node_modules/proper-lockfile/lib/mtime-precision.js"(exports2, module2) {
    "use strict";
    var cacheSymbol = Symbol();
    function probe(file, fs, callback) {
      const cachedPrecision = fs[cacheSymbol];
      if (cachedPrecision) {
        return fs.stat(file, (err, stat) => {
          if (err) {
            return callback(err);
          }
          callback(null, stat.mtime, cachedPrecision);
        });
      }
      const mtime = new Date(Math.ceil(Date.now() / 1e3) * 1e3 + 5);
      fs.utimes(file, mtime, mtime, (err) => {
        if (err) {
          return callback(err);
        }
        fs.stat(file, (err2, stat) => {
          if (err2) {
            return callback(err2);
          }
          const precision = stat.mtime.getTime() % 1e3 === 0 ? "s" : "ms";
          Object.defineProperty(fs, cacheSymbol, { value: precision });
          callback(null, stat.mtime, precision);
        });
      });
    }
    function getMtime(precision) {
      let now = Date.now();
      if (precision === "s") {
        now = Math.ceil(now / 1e3) * 1e3;
      }
      return new Date(now);
    }
    module2.exports.probe = probe;
    module2.exports.getMtime = getMtime;
  }
});

// node_modules/proper-lockfile/lib/lockfile.js
var require_lockfile = __commonJS({
  "node_modules/proper-lockfile/lib/lockfile.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var fs = require_graceful_fs();
    var retry = require_retry2();
    var onExit = require_signal_exit();
    var mtimePrecision = require_mtime_precision();
    var locks = {};
    function getLockFile(file, options) {
      return options.lockfilePath || `${file}.lock`;
    }
    function resolveCanonicalPath(file, options, callback) {
      if (!options.realpath) {
        return callback(null, path.resolve(file));
      }
      options.fs.realpath(file, callback);
    }
    function acquireLock(file, options, callback) {
      const lockfilePath = getLockFile(file, options);
      options.fs.mkdir(lockfilePath, (err) => {
        if (!err) {
          return mtimePrecision.probe(lockfilePath, options.fs, (err2, mtime, mtimePrecision2) => {
            if (err2) {
              options.fs.rmdir(lockfilePath, () => {
              });
              return callback(err2);
            }
            callback(null, mtime, mtimePrecision2);
          });
        }
        if (err.code !== "EEXIST") {
          return callback(err);
        }
        if (options.stale <= 0) {
          return callback(Object.assign(new Error("Lock file is already being held"), { code: "ELOCKED", file }));
        }
        options.fs.stat(lockfilePath, (err2, stat) => {
          if (err2) {
            if (err2.code === "ENOENT") {
              return acquireLock(file, __spreadProps(__spreadValues({}, options), { stale: 0 }), callback);
            }
            return callback(err2);
          }
          if (!isLockStale(stat, options)) {
            return callback(Object.assign(new Error("Lock file is already being held"), { code: "ELOCKED", file }));
          }
          removeLock(file, options, (err3) => {
            if (err3) {
              return callback(err3);
            }
            acquireLock(file, __spreadProps(__spreadValues({}, options), { stale: 0 }), callback);
          });
        });
      });
    }
    function isLockStale(stat, options) {
      return stat.mtime.getTime() < Date.now() - options.stale;
    }
    function removeLock(file, options, callback) {
      options.fs.rmdir(getLockFile(file, options), (err) => {
        if (err && err.code !== "ENOENT") {
          return callback(err);
        }
        callback();
      });
    }
    function updateLock(file, options) {
      const lock2 = locks[file];
      if (lock2.updateTimeout) {
        return;
      }
      lock2.updateDelay = lock2.updateDelay || options.update;
      lock2.updateTimeout = setTimeout(() => {
        lock2.updateTimeout = null;
        options.fs.stat(lock2.lockfilePath, (err, stat) => {
          const isOverThreshold = lock2.lastUpdate + options.stale < Date.now();
          if (err) {
            if (err.code === "ENOENT" || isOverThreshold) {
              return setLockAsCompromised(file, lock2, Object.assign(err, { code: "ECOMPROMISED" }));
            }
            lock2.updateDelay = 1e3;
            return updateLock(file, options);
          }
          const isMtimeOurs = lock2.mtime.getTime() === stat.mtime.getTime();
          if (!isMtimeOurs) {
            return setLockAsCompromised(file, lock2, Object.assign(new Error("Unable to update lock within the stale threshold"), { code: "ECOMPROMISED" }));
          }
          const mtime = mtimePrecision.getMtime(lock2.mtimePrecision);
          options.fs.utimes(lock2.lockfilePath, mtime, mtime, (err2) => {
            const isOverThreshold2 = lock2.lastUpdate + options.stale < Date.now();
            if (lock2.released) {
              return;
            }
            if (err2) {
              if (err2.code === "ENOENT" || isOverThreshold2) {
                return setLockAsCompromised(file, lock2, Object.assign(err2, { code: "ECOMPROMISED" }));
              }
              lock2.updateDelay = 1e3;
              return updateLock(file, options);
            }
            lock2.mtime = mtime;
            lock2.lastUpdate = Date.now();
            lock2.updateDelay = null;
            updateLock(file, options);
          });
        });
      }, lock2.updateDelay);
      if (lock2.updateTimeout.unref) {
        lock2.updateTimeout.unref();
      }
    }
    function setLockAsCompromised(file, lock2, err) {
      lock2.released = true;
      if (lock2.updateTimeout) {
        clearTimeout(lock2.updateTimeout);
      }
      if (locks[file] === lock2) {
        delete locks[file];
      }
      lock2.options.onCompromised(err);
    }
    function lock(file, options, callback) {
      options = __spreadValues({
        stale: 1e4,
        update: null,
        realpath: true,
        retries: 0,
        fs,
        onCompromised: (err) => {
          throw err;
        }
      }, options);
      options.retries = options.retries || 0;
      options.retries = typeof options.retries === "number" ? { retries: options.retries } : options.retries;
      options.stale = Math.max(options.stale || 0, 2e3);
      options.update = options.update == null ? options.stale / 2 : options.update || 0;
      options.update = Math.max(Math.min(options.update, options.stale / 2), 1e3);
      resolveCanonicalPath(file, options, (err, file2) => {
        if (err) {
          return callback(err);
        }
        const operation = retry.operation(options.retries);
        operation.attempt(() => {
          acquireLock(file2, options, (err2, mtime, mtimePrecision2) => {
            if (operation.retry(err2)) {
              return;
            }
            if (err2) {
              return callback(operation.mainError());
            }
            const lock2 = locks[file2] = {
              lockfilePath: getLockFile(file2, options),
              mtime,
              mtimePrecision: mtimePrecision2,
              options,
              lastUpdate: Date.now()
            };
            updateLock(file2, options);
            callback(null, (releasedCallback) => {
              if (lock2.released) {
                return releasedCallback && releasedCallback(Object.assign(new Error("Lock is already released"), { code: "ERELEASED" }));
              }
              unlock(file2, __spreadProps(__spreadValues({}, options), { realpath: false }), releasedCallback);
            });
          });
        });
      });
    }
    function unlock(file, options, callback) {
      options = __spreadValues({
        fs,
        realpath: true
      }, options);
      resolveCanonicalPath(file, options, (err, file2) => {
        if (err) {
          return callback(err);
        }
        const lock2 = locks[file2];
        if (!lock2) {
          return callback(Object.assign(new Error("Lock is not acquired/owned by you"), { code: "ENOTACQUIRED" }));
        }
        lock2.updateTimeout && clearTimeout(lock2.updateTimeout);
        lock2.released = true;
        delete locks[file2];
        removeLock(file2, options, callback);
      });
    }
    function check(file, options, callback) {
      options = __spreadValues({
        stale: 1e4,
        realpath: true,
        fs
      }, options);
      options.stale = Math.max(options.stale || 0, 2e3);
      resolveCanonicalPath(file, options, (err, file2) => {
        if (err) {
          return callback(err);
        }
        options.fs.stat(getLockFile(file2, options), (err2, stat) => {
          if (err2) {
            return err2.code === "ENOENT" ? callback(null, false) : callback(err2);
          }
          return callback(null, !isLockStale(stat, options));
        });
      });
    }
    function getLocks() {
      return locks;
    }
    onExit(() => {
      for (const file in locks) {
        const options = locks[file].options;
        try {
          options.fs.rmdirSync(getLockFile(file, options));
        } catch (e) {
        }
      }
    });
    module2.exports.lock = lock;
    module2.exports.unlock = unlock;
    module2.exports.check = check;
    module2.exports.getLocks = getLocks;
  }
});

// node_modules/proper-lockfile/lib/adapter.js
var require_adapter = __commonJS({
  "node_modules/proper-lockfile/lib/adapter.js"(exports2, module2) {
    "use strict";
    var fs = require_graceful_fs();
    function createSyncFs(fs2) {
      const methods = ["mkdir", "realpath", "stat", "rmdir", "utimes"];
      const newFs = __spreadValues({}, fs2);
      methods.forEach((method) => {
        newFs[method] = (...args) => {
          const callback = args.pop();
          let ret;
          try {
            ret = fs2[`${method}Sync`](...args);
          } catch (err) {
            return callback(err);
          }
          callback(null, ret);
        };
      });
      return newFs;
    }
    function toPromise(method) {
      return (...args) => new Promise((resolve, reject) => {
        args.push((err, result) => {
          if (err) {
            reject(err);
          } else {
            resolve(result);
          }
        });
        method(...args);
      });
    }
    function toSync(method) {
      return (...args) => {
        let err;
        let result;
        args.push((_err, _result) => {
          err = _err;
          result = _result;
        });
        method(...args);
        if (err) {
          throw err;
        }
        return result;
      };
    }
    function toSyncOptions(options) {
      options = __spreadValues({}, options);
      options.fs = createSyncFs(options.fs || fs);
      if (typeof options.retries === "number" && options.retries > 0 || options.retries && typeof options.retries.retries === "number" && options.retries.retries > 0) {
        throw Object.assign(new Error("Cannot use retries with the sync api"), { code: "ESYNC" });
      }
      return options;
    }
    module2.exports = {
      toPromise,
      toSync,
      toSyncOptions
    };
  }
});

// node_modules/proper-lockfile/index.js
var require_proper_lockfile = __commonJS({
  "node_modules/proper-lockfile/index.js"(exports2, module2) {
    "use strict";
    var lockfile = require_lockfile();
    var { toPromise, toSync, toSyncOptions } = require_adapter();
    function lock(file, options) {
      return __async(this, null, function* () {
        const release = yield toPromise(lockfile.lock)(file, options);
        return toPromise(release);
      });
    }
    function lockSync(file, options) {
      const release = toSync(lockfile.lock)(file, toSyncOptions(options));
      return toSync(release);
    }
    function unlock(file, options) {
      return toPromise(lockfile.unlock)(file, options);
    }
    function unlockSync(file, options) {
      return toSync(lockfile.unlock)(file, toSyncOptions(options));
    }
    function check(file, options) {
      return toPromise(lockfile.check)(file, options);
    }
    function checkSync(file, options) {
      return toSync(lockfile.check)(file, toSyncOptions(options));
    }
    module2.exports = lock;
    module2.exports.lock = lock;
    module2.exports.unlock = unlock;
    module2.exports.lockSync = lockSync;
    module2.exports.unlockSync = unlockSync;
    module2.exports.check = check;
    module2.exports.checkSync = checkSync;
  }
});

// node_modules/playwright-core/lib/utils/ubuntuVersion.js
var require_ubuntuVersion = __commonJS({
  "node_modules/playwright-core/lib/utils/ubuntuVersion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getUbuntuVersion = getUbuntuVersion;
    exports2.getUbuntuVersionSync = getUbuntuVersionSync;
    exports2.parseOSReleaseText = parseOSReleaseText;
    var _fs = _interopRequireDefault(require("fs"));
    var os = _interopRequireWildcard(require("os"));
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ubuntuVersionCached;
    function getUbuntuVersion() {
      return __async(this, null, function* () {
        if (ubuntuVersionCached === void 0)
          ubuntuVersionCached = yield getUbuntuVersionAsyncInternal();
        return ubuntuVersionCached;
      });
    }
    function getUbuntuVersionSync() {
      if (ubuntuVersionCached === void 0)
        ubuntuVersionCached = getUbuntuVersionSyncInternal();
      return ubuntuVersionCached;
    }
    function getUbuntuVersionAsyncInternal() {
      return __async(this, null, function* () {
        if (os.platform() !== "linux")
          return "";
        let osReleaseText = yield _fs.default.promises.readFile("/etc/upstream-release/lsb-release", "utf8").catch((e) => "");
        if (!osReleaseText)
          osReleaseText = yield _fs.default.promises.readFile("/etc/os-release", "utf8").catch((e) => "");
        if (!osReleaseText)
          return "";
        return parseUbuntuVersion(osReleaseText);
      });
    }
    function getUbuntuVersionSyncInternal() {
      if (os.platform() !== "linux")
        return "";
      try {
        let osReleaseText;
        if (_fs.default.existsSync("/etc/upstream-release/lsb-release"))
          osReleaseText = _fs.default.readFileSync("/etc/upstream-release/lsb-release", "utf8");
        else
          osReleaseText = _fs.default.readFileSync("/etc/os-release", "utf8");
        if (!osReleaseText)
          return "";
        return parseUbuntuVersion(osReleaseText);
      } catch (e) {
        return "";
      }
    }
    function parseOSReleaseText(osReleaseText) {
      const fields = /* @__PURE__ */ new Map();
      for (const line of osReleaseText.split("\n")) {
        const tokens = line.split("=");
        const name = tokens.shift();
        let value = tokens.join("=").trim();
        if (value.startsWith('"') && value.endsWith('"'))
          value = value.substring(1, value.length - 1);
        if (!name)
          continue;
        fields.set(name.toLowerCase(), value);
      }
      return fields;
    }
    function parseUbuntuVersion(osReleaseText) {
      var _fields$get, _fields$get2;
      const fields = parseOSReleaseText(osReleaseText);
      if (fields.get("distrib_id") && ((_fields$get = fields.get("distrib_id")) === null || _fields$get === void 0 ? void 0 : _fields$get.toLowerCase()) === "ubuntu")
        return fields.get("distrib_release") || "";
      if (!fields.get("name") || ((_fields$get2 = fields.get("name")) === null || _fields$get2 === void 0 ? void 0 : _fields$get2.toLowerCase()) !== "ubuntu")
        return "";
      return fields.get("version_id") || "";
    }
  }
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "node_modules/proxy-from-env/index.js"(exports2) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl(url) {
      var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports2.getProxyForUrl = getProxyForUrl;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require("supports-color");
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/agent-base/dist/src/promisify.js
var require_promisify = __commonJS({
  "node_modules/agent-base/dist/src/promisify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function promisify(fn) {
      return function(req, opts) {
        return new Promise((resolve, reject) => {
          fn.call(this, req, opts, (err, rtn) => {
            if (err) {
              reject(err);
            } else {
              resolve(rtn);
            }
          });
        });
      };
    }
    exports2.default = promisify;
  }
});

// node_modules/agent-base/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/agent-base/dist/src/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var events_1 = require("events");
    var debug_1 = __importDefault(require_src());
    var promisify_1 = __importDefault(require_promisify());
    var debug = debug_1.default("agent-base");
    function isAgent(v) {
      return Boolean(v) && typeof v.addRequest === "function";
    }
    function isSecureEndpoint() {
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    function createAgent(callback, opts) {
      return new createAgent.Agent(callback, opts);
    }
    (function(createAgent2) {
      class Agent extends events_1.EventEmitter {
        constructor(callback, _opts) {
          super();
          let opts = _opts;
          if (typeof callback === "function") {
            this.callback = callback;
          } else if (callback) {
            opts = callback;
          }
          this.timeout = null;
          if (opts && typeof opts.timeout === "number") {
            this.timeout = opts.timeout;
          }
          this.maxFreeSockets = 1;
          this.maxSockets = 1;
          this.maxTotalSockets = Infinity;
          this.sockets = {};
          this.freeSockets = {};
          this.requests = {};
          this.options = {};
        }
        get defaultPort() {
          if (typeof this.explicitDefaultPort === "number") {
            return this.explicitDefaultPort;
          }
          return isSecureEndpoint() ? 443 : 80;
        }
        set defaultPort(v) {
          this.explicitDefaultPort = v;
        }
        get protocol() {
          if (typeof this.explicitProtocol === "string") {
            return this.explicitProtocol;
          }
          return isSecureEndpoint() ? "https:" : "http:";
        }
        set protocol(v) {
          this.explicitProtocol = v;
        }
        callback(req, opts, fn) {
          throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
        }
        addRequest(req, _opts) {
          const opts = Object.assign({}, _opts);
          if (typeof opts.secureEndpoint !== "boolean") {
            opts.secureEndpoint = isSecureEndpoint();
          }
          if (opts.host == null) {
            opts.host = "localhost";
          }
          if (opts.port == null) {
            opts.port = opts.secureEndpoint ? 443 : 80;
          }
          if (opts.protocol == null) {
            opts.protocol = opts.secureEndpoint ? "https:" : "http:";
          }
          if (opts.host && opts.path) {
            delete opts.path;
          }
          delete opts.agent;
          delete opts.hostname;
          delete opts._defaultAgent;
          delete opts.defaultPort;
          delete opts.createConnection;
          req._last = true;
          req.shouldKeepAlive = false;
          let timedOut = false;
          let timeoutId = null;
          const timeoutMs = opts.timeout || this.timeout;
          const onerror = (err) => {
            if (req._hadError)
              return;
            req.emit("error", err);
            req._hadError = true;
          };
          const ontimeout = () => {
            timeoutId = null;
            timedOut = true;
            const err = new Error(`A "socket" was not created for HTTP request before ${timeoutMs}ms`);
            err.code = "ETIMEOUT";
            onerror(err);
          };
          const callbackError = (err) => {
            if (timedOut)
              return;
            if (timeoutId !== null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            onerror(err);
          };
          const onsocket = (socket) => {
            if (timedOut)
              return;
            if (timeoutId != null) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
            if (isAgent(socket)) {
              debug("Callback returned another Agent instance %o", socket.constructor.name);
              socket.addRequest(req, opts);
              return;
            }
            if (socket) {
              socket.once("free", () => {
                this.freeSocket(socket, opts);
              });
              req.onSocket(socket);
              return;
            }
            const err = new Error(`no Duplex stream was returned to agent-base for \`${req.method} ${req.path}\``);
            onerror(err);
          };
          if (typeof this.callback !== "function") {
            onerror(new Error("`callback` is not defined"));
            return;
          }
          if (!this.promisifiedCallback) {
            if (this.callback.length >= 3) {
              debug("Converting legacy callback function to promise");
              this.promisifiedCallback = promisify_1.default(this.callback);
            } else {
              this.promisifiedCallback = this.callback;
            }
          }
          if (typeof timeoutMs === "number" && timeoutMs > 0) {
            timeoutId = setTimeout(ontimeout, timeoutMs);
          }
          if ("port" in opts && typeof opts.port !== "number") {
            opts.port = Number(opts.port);
          }
          try {
            debug("Resolving socket for %o request: %o", opts.protocol, `${req.method} ${req.path}`);
            Promise.resolve(this.promisifiedCallback(req, opts)).then(onsocket, callbackError);
          } catch (err) {
            Promise.reject(err).catch(callbackError);
          }
        }
        freeSocket(socket, opts) {
          debug("Freeing socket %o %o", socket.constructor.name, opts);
          socket.destroy();
        }
        destroy() {
          debug("Destroying agent %o", this.constructor.name);
        }
      }
      createAgent2.Agent = Agent;
      createAgent2.prototype = createAgent2.Agent.prototype;
    })(createAgent || (createAgent = {}));
    module2.exports = createAgent;
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug_1 = __importDefault(require_src());
    var debug = debug_1.default("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read() {
          const b = socket.read();
          if (b)
            ondata(b);
          else
            socket.once("readable", read);
        }
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("close", onclose);
          socket.removeListener("readable", read);
        }
        function onclose(err) {
          debug("onclose had error %o", err);
        }
        function onend() {
          debug("onend");
        }
        function onerror(err) {
          cleanup();
          debug("onerror %o", err);
          reject(err);
        }
        function ondata(b) {
          buffers.push(b);
          buffersLength += b.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug("have not received end of HTTP headers yet...");
            read();
            return;
          }
          const firstLine = buffered.toString("ascii", 0, buffered.indexOf("\r\n"));
          const statusCode = +firstLine.split(" ")[1];
          debug("got proxy server response: %o", firstLine);
          resolve({
            statusCode,
            buffered
          });
        }
        socket.on("error", onerror);
        socket.on("close", onclose);
        socket.on("end", onend);
        read();
      });
    }
    exports2.default = parseProxyResponse;
  }
});

// node_modules/https-proxy-agent/dist/agent.js
var require_agent = __commonJS({
  "node_modules/https-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var net_1 = __importDefault(require("net"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var assert_1 = __importDefault(require("assert"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_src2();
    var parse_proxy_response_1 = __importDefault(require_parse_proxy_response());
    var debug = debug_1.default("https-proxy-agent:agent");
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
        }
        debug("creating new HttpsProxyAgent instance: %o", opts);
        super(opts);
        const proxy = Object.assign({}, opts);
        this.secureProxy = opts.secureProxy || isHTTPS(proxy.protocol);
        proxy.host = proxy.hostname || proxy.host;
        if (typeof proxy.port === "string") {
          proxy.port = parseInt(proxy.port, 10);
        }
        if (!proxy.port && proxy.host) {
          proxy.port = this.secureProxy ? 443 : 80;
        }
        if (this.secureProxy && !("ALPNProtocols" in proxy)) {
          proxy.ALPNProtocols = ["http 1.1"];
        }
        if (proxy.host && proxy.path) {
          delete proxy.path;
          delete proxy.pathname;
        }
        this.proxy = proxy;
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { proxy, secureProxy } = this;
          let socket;
          if (secureProxy) {
            debug("Creating `tls.Socket`: %o", proxy);
            socket = tls_1.default.connect(proxy);
          } else {
            debug("Creating `net.Socket`: %o", proxy);
            socket = net_1.default.connect(proxy);
          }
          const headers = Object.assign({}, proxy.headers);
          const hostname = `${opts.host}:${opts.port}`;
          let payload = `CONNECT ${hostname} HTTP/1.1\r
`;
          if (proxy.auth) {
            headers["Proxy-Authorization"] = `Basic ${Buffer.from(proxy.auth).toString("base64")}`;
          }
          let { host, port, secureEndpoint } = opts;
          if (!isDefaultPort(port, secureEndpoint)) {
            host += `:${port}`;
          }
          headers.Host = host;
          headers.Connection = "close";
          for (const name of Object.keys(headers)) {
            payload += `${name}: ${headers[name]}\r
`;
          }
          const proxyResponsePromise = parse_proxy_response_1.default(socket);
          socket.write(`${payload}\r
`);
          const { statusCode, buffered } = yield proxyResponsePromise;
          if (statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              const servername = opts.servername || opts.host;
              if (!servername) {
                throw new Error('Could not determine "servername"');
              }
              debug("Upgrading socket connection to TLS");
              return tls_1.default.connect(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
                socket,
                servername
              }));
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net_1.default.Socket();
          fakeSocket.readable = true;
          req.once("socket", (s) => {
            debug("replaying proxy buffer for failed request");
            assert_1.default(s.listenerCount("data") > 0);
            s.push(buffered);
            s.push(null);
          });
          return fakeSocket;
        });
      }
    };
    exports2.default = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
    function isHTTPS(protocol) {
      return typeof protocol === "string" ? /^https:?$/i.test(protocol) : false;
    }
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist = __commonJS({
  "node_modules/https-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent());
    function createHttpsProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createHttpsProxyAgent2) {
      createHttpsProxyAgent2.HttpsProxyAgent = agent_1.default;
      createHttpsProxyAgent2.prototype = agent_1.default.prototype;
    })(createHttpsProxyAgent || (createHttpsProxyAgent = {}));
    module2.exports = createHttpsProxyAgent;
  }
});

// node_modules/playwright-core/lib/common/netUtils.js
var require_netUtils = __commonJS({
  "node_modules/playwright-core/lib/common/netUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createSocket = createSocket;
    exports2.fetchData = fetchData;
    exports2.httpRequest = httpRequest;
    var _http = _interopRequireDefault(require("http"));
    var _https = _interopRequireDefault(require("https"));
    var _net = _interopRequireDefault(require("net"));
    var _proxyFromEnv = require_proxy_from_env();
    var URL2 = _interopRequireWildcard(require("url"));
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createSocket(host, port) {
      return __async(this, null, function* () {
        return new Promise((resolve, reject) => {
          const socket = _net.default.createConnection({
            host,
            port
          });
          socket.on("connect", () => resolve(socket));
          socket.on("error", (error) => reject(error));
        });
      });
    }
    var ProxyAgent = require_dist();
    function httpRequest(params, onResponse, onError) {
      const parsedUrl = URL2.parse(params.url);
      let options = __spreadValues({}, parsedUrl);
      options.method = params.method || "GET";
      options.headers = params.headers;
      const proxyURL = (0, _proxyFromEnv.getProxyForUrl)(params.url);
      if (proxyURL) {
        if (params.url.startsWith("http:")) {
          const proxy = URL2.parse(proxyURL);
          options = {
            path: parsedUrl.href,
            host: proxy.hostname,
            port: proxy.port
          };
        } else {
          const parsedProxyURL = URL2.parse(proxyURL);
          parsedProxyURL.secureProxy = parsedProxyURL.protocol === "https:";
          options.agent = new ProxyAgent(parsedProxyURL);
          options.rejectUnauthorized = false;
        }
      }
      const requestCallback = (res) => {
        const statusCode = res.statusCode || 0;
        if (statusCode >= 300 && statusCode < 400 && res.headers.location)
          httpRequest(__spreadProps(__spreadValues({}, params), {
            url: res.headers.location
          }), onResponse, onError);
        else
          onResponse(res);
      };
      const request = options.protocol === "https:" ? _https.default.request(options, requestCallback) : _http.default.request(options, requestCallback);
      request.on("error", onError);
      if (params.timeout !== void 0) {
        const rejectOnTimeout = () => {
          onError(new Error(`Request to ${params.url} timed out after ${params.timeout}ms`));
          request.abort();
        };
        if (params.timeout <= 0) {
          rejectOnTimeout();
          return;
        }
        request.setTimeout(params.timeout, rejectOnTimeout);
      }
      request.end(params.data);
    }
    function fetchData(params, onError) {
      return new Promise((resolve, reject) => {
        httpRequest(params, (response) => __async(this, null, function* () {
          if (response.statusCode !== 200) {
            const error = onError ? yield onError(params, response) : new Error(`fetch failed: server returned code ${response.statusCode}. URL: ${params.url}`);
            reject(error);
            return;
          }
          let body = "";
          response.on("data", (chunk) => body += chunk);
          response.on("error", (error) => reject(error));
          response.on("end", () => resolve(body));
        }), reject);
      });
    }
  }
});

// node_modules/playwright-core/package.json
var require_package = __commonJS({
  "node_modules/playwright-core/package.json"(exports2, module2) {
    module2.exports = {
      name: "playwright-core",
      version: "1.21.0",
      description: "A high-level API to automate web browsers",
      repository: "github:Microsoft/playwright",
      homepage: "https://playwright.dev",
      engines: {
        node: ">=12"
      },
      author: {
        name: "Microsoft Corporation"
      },
      license: "Apache-2.0",
      exports: {
        ".": {
          import: "./index.mjs",
          require: "./index.js"
        },
        "./cli": "./cli.js",
        "./package.json": "./package.json",
        "./lib/grid/gridServer": "./lib/grid/gridServer.js",
        "./lib/grid/gridClient": "./lib/grid/gridClient.js",
        "./lib/grid/dockerGridFactory": "./lib/grid/dockerGridFactory.js",
        "./lib/outofprocess": "./lib/outofprocess.js",
        "./lib/utils": "./lib/utils/index.js",
        "./lib/utils/comparators": "./lib/utils/comparators.js",
        "./lib/utils/eventsHelper": "./lib/utils/eventsHelper.js",
        "./lib/utils/fileUtils": "./lib/utils/fileUtils.js",
        "./lib/utils/httpServer": "./lib/utils/httpServer.js",
        "./lib/utils/hostPlatform": "./lib/utils/hostPlatform.js",
        "./lib/utils/manualPromise": "./lib/utils/manualPromise.js",
        "./lib/utils/multimap": "./lib/utils/multimap.js",
        "./lib/utils/processLauncher": "./lib/utils/processLauncher.js",
        "./lib/utils/spawnAsync": "./lib/utils/spawnAsync.js",
        "./lib/utils/stackTrace": "./lib/utils/stackTrace.js",
        "./lib/utils/timeoutRunner": "./lib/utils/timeoutRunner.js",
        "./lib/remote/playwrightServer": "./lib/remote/playwrightServer.js",
        "./lib/remote/playwrightClient": "./lib/remote/playwrightClient.js",
        "./lib/server": "./lib/server/index.js"
      },
      types: "types/types.d.ts",
      bin: {
        playwright: "./cli.js"
      },
      dependencies: {
        commander: "8.3.0",
        colors: "1.4.0",
        debug: "4.3.3",
        "extract-zip": "2.0.1",
        "https-proxy-agent": "5.0.0",
        "jpeg-js": "0.4.3",
        mime: "3.0.0",
        pixelmatch: "5.2.1",
        pngjs: "6.0.0",
        progress: "2.0.3",
        "proper-lockfile": "4.1.2",
        "proxy-from-env": "1.1.0",
        rimraf: "3.0.2",
        "socks-proxy-agent": "6.1.1",
        "stack-utils": "2.0.5",
        ws: "8.4.2",
        yauzl: "2.10.0",
        yazl: "2.5.1"
      }
    };
  }
});

// node_modules/playwright-core/lib/common/userAgent.js
var require_userAgent = __commonJS({
  "node_modules/playwright-core/lib/common/userAgent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getClientLanguage = getClientLanguage;
    exports2.getPlaywrightVersion = getPlaywrightVersion;
    exports2.getUserAgent = getUserAgent;
    var _child_process = require("child_process");
    var _fs = _interopRequireDefault(require("fs"));
    var _os = _interopRequireDefault(require("os"));
    var _ubuntuVersion = require_ubuntuVersion();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var cachedUserAgent;
    function getUserAgent() {
      if (cachedUserAgent)
        return cachedUserAgent;
      try {
        cachedUserAgent = determineUserAgent();
      } catch (e) {
        cachedUserAgent = "Playwright/unknown";
      }
      return cachedUserAgent;
    }
    function determineUserAgent() {
      let osIdentifier = "unknown";
      let osVersion = "unknown";
      if (process.platform === "win32") {
        const version = _os.default.release().split(".");
        osIdentifier = "windows";
        osVersion = `${version[0]}.${version[1]}`;
      } else if (process.platform === "darwin") {
        const version = (0, _child_process.execSync)("sw_vers -productVersion", {
          stdio: ["ignore", "pipe", "ignore"]
        }).toString().trim().split(".");
        osIdentifier = "macOS";
        osVersion = `${version[0]}.${version[1]}`;
      } else if (process.platform === "linux") {
        try {
          const osReleaseText = _fs.default.readFileSync("/etc/os-release", "utf8");
          const fields = (0, _ubuntuVersion.parseOSReleaseText)(osReleaseText);
          osIdentifier = fields.get("id") || "unknown";
          osVersion = fields.get("version_id") || "unknown";
        } catch (e) {
          osIdentifier = "linux";
        }
      }
      const {
        langName,
        langVersion
      } = getClientLanguage();
      return `Playwright/${getPlaywrightVersion()} (${_os.default.arch()}; ${osIdentifier} ${osVersion}) ${langName}/${langVersion}`;
    }
    function getClientLanguage() {
      let langName = "unknown";
      let langVersion = "unknown";
      if (!process.env.PW_LANG_NAME) {
        langName = "node";
        langVersion = process.version.substring(1).split(".").slice(0, 2).join(".");
      } else if (["node", "python", "java", "csharp"].includes(process.env.PW_LANG_NAME)) {
        var _process$env$PW_LANG_;
        langName = process.env.PW_LANG_NAME;
        langVersion = (_process$env$PW_LANG_ = process.env.PW_LANG_NAME_VERSION) !== null && _process$env$PW_LANG_ !== void 0 ? _process$env$PW_LANG_ : "unknown";
      }
      return {
        langName,
        langVersion
      };
    }
    function getPlaywrightVersion(majorMinorOnly = false) {
      const packageJson = require_package();
      return majorMinorOnly ? packageJson.version.split(".").slice(0, 2).join(".") : packageJson.version;
    }
  }
});

// node_modules/playwright-core/lib/utils/index.js
var require_utils = __commonJS({
  "node_modules/playwright-core/lib/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.arrayToObject = arrayToObject;
    exports2.assert = assert;
    exports2.calculateSha1 = calculateSha1;
    exports2.constructURLBasedOnBaseURL = constructURLBasedOnBaseURL;
    exports2.createGuid = createGuid;
    exports2.debugAssert = debugAssert;
    exports2.debugMode = debugMode;
    exports2.experimentalFeaturesEnabled = experimentalFeaturesEnabled;
    exports2.getAsBooleanFromENV = getAsBooleanFromENV;
    exports2.getFromENV = getFromENV;
    exports2.headersArrayToObject = headersArrayToObject;
    exports2.headersObjectToArray = headersObjectToArray;
    exports2.isError = isError;
    exports2.isFilePayload = isFilePayload;
    exports2.isObject = isObject;
    exports2.isRegExp = isRegExp;
    exports2.isString = isString;
    exports2.isUnderTest = isUnderTest;
    exports2.makeWaitForNextTask = makeWaitForNextTask;
    exports2.monotonicTime = monotonicTime;
    exports2.objectToArray = objectToArray;
    exports2.setUnderTest = setUnderTest;
    exports2.streamToString = streamToString;
    exports2.wrapInASCIIBox = wrapInASCIIBox;
    var crypto = _interopRequireWildcard(require("crypto"));
    var URL2 = _interopRequireWildcard(require("url"));
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function makeWaitForNextTask() {
      if (process.versions.electron)
        return (callback) => setTimeout(callback, 0);
      if (parseInt(process.versions.node, 10) >= 11)
        return setImmediate;
      let spinning = false;
      const callbacks = [];
      const loop = () => {
        const callback = callbacks.shift();
        if (!callback) {
          spinning = false;
          return;
        }
        setImmediate(loop);
        callback();
      };
      return (callback) => {
        callbacks.push(callback);
        if (!spinning) {
          spinning = true;
          setImmediate(loop);
        }
      };
    }
    function assert(value, message) {
      if (!value)
        throw new Error(message || "Assertion error");
    }
    function debugAssert(value, message) {
      if (isUnderTest() && !value)
        throw new Error(message);
    }
    function isString(obj) {
      return typeof obj === "string" || obj instanceof String;
    }
    function isRegExp(obj) {
      return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function isObject(obj) {
      return typeof obj === "object" && obj !== null;
    }
    function isError(obj) {
      return obj instanceof Error || obj && obj.__proto__ && obj.__proto__.name === "Error";
    }
    var debugEnv = getFromENV("PWDEBUG") || "";
    function debugMode() {
      if (debugEnv === "console")
        return "console";
      if (debugEnv === "0" || debugEnv === "false")
        return "";
      return debugEnv ? "inspector" : "";
    }
    var _isUnderTest = false;
    function setUnderTest() {
      _isUnderTest = true;
    }
    function isUnderTest() {
      return _isUnderTest;
    }
    function experimentalFeaturesEnabled() {
      return isUnderTest() || !!process.env.PLAYWRIGHT_EXPERIMENTAL_FEATURES;
    }
    function getFromENV(name) {
      let value = process.env[name];
      value = value === void 0 ? process.env[`npm_config_${name.toLowerCase()}`] : value;
      value = value === void 0 ? process.env[`npm_package_config_${name.toLowerCase()}`] : value;
      return value;
    }
    function getAsBooleanFromENV(name) {
      const value = getFromENV(name);
      return !!value && value !== "false" && value !== "0";
    }
    function headersObjectToArray(headers, separator, setCookieSeparator) {
      if (!setCookieSeparator)
        setCookieSeparator = separator;
      const result = [];
      for (const name in headers) {
        const values = headers[name];
        if (separator) {
          const sep = name.toLowerCase() === "set-cookie" ? setCookieSeparator : separator;
          for (const value of values.split(sep))
            result.push({
              name,
              value: value.trim()
            });
        } else {
          result.push({
            name,
            value: values
          });
        }
      }
      return result;
    }
    function headersArrayToObject(headers, lowerCase) {
      const result = {};
      for (const {
        name,
        value
      } of headers)
        result[lowerCase ? name.toLowerCase() : name] = value;
      return result;
    }
    function monotonicTime() {
      const [seconds, nanoseconds] = process.hrtime();
      return seconds * 1e3 + (nanoseconds / 1e3 | 0) / 1e3;
    }
    function objectToArray(map) {
      if (!map)
        return void 0;
      const result = [];
      for (const [name, value] of Object.entries(map))
        result.push({
          name,
          value: String(value)
        });
      return result;
    }
    function arrayToObject(array) {
      if (!array)
        return void 0;
      const result = {};
      for (const {
        name,
        value
      } of array)
        result[name] = value;
      return result;
    }
    function calculateSha1(buffer) {
      const hash = crypto.createHash("sha1");
      hash.update(buffer);
      return hash.digest("hex");
    }
    function createGuid() {
      return crypto.randomBytes(16).toString("hex");
    }
    function constructURLBasedOnBaseURL(baseURL, givenURL) {
      try {
        return new URL2.URL(givenURL, baseURL).toString();
      } catch (e) {
        return givenURL;
      }
    }
    function wrapInASCIIBox(text, padding = 0) {
      const lines = text.split("\n");
      const maxLength = Math.max(...lines.map((line) => line.length));
      return ["\u2554" + "\u2550".repeat(maxLength + padding * 2) + "\u2557", ...lines.map((line) => "\u2551" + " ".repeat(padding) + line + " ".repeat(maxLength - line.length + padding) + "\u2551"), "\u255A" + "\u2550".repeat(maxLength + padding * 2) + "\u255D"].join("\n");
    }
    function isFilePayload(value) {
      return typeof value === "object" && value["name"] && value["mimeType"] && value["buffer"];
    }
    function streamToString(stream) {
      return new Promise((resolve, reject) => {
        const chunks = [];
        stream.on("data", (chunk) => chunks.push(Buffer.from(chunk)));
        stream.on("error", reject);
        stream.on("end", () => resolve(Buffer.concat(chunks).toString("utf8")));
      });
    }
  }
});

// node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "node_modules/fs.realpath/old.js"(exports2) {
    var pathModule = require("path");
    var isWindows = process.platform === "win32";
    var fs = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports2.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs.statSync(base);
            linkTarget = fs.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports2.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// node_modules/fs.realpath/index.js
var require_fs = __commonJS({
  "node_modules/fs.realpath/index.js"(exports2, module2) {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs = require("fs");
    var origRealpath = fs.realpath;
    var origRealpathSync = fs.realpathSync;
    var version = process.version;
    var ok = /^v[0-5]\./.test(version);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs.realpath = realpath;
      fs.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs.realpath = origRealpath;
      fs.realpathSync = origRealpathSync;
    }
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports2, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports2, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports2, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports2, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = function() {
      try {
        return require("path");
      } catch (e) {
      }
    }() || {
      sep: "/"
    };
    minimatch.sep = path.sep;
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      b = b || {};
      var t = {};
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch;
      }
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      m.Minimatch.defaults = function defaults(options) {
        return orig.defaults(ext(def, options)).Minimatch;
      };
      m.filter = function filter2(pattern, options) {
        return orig.filter(pattern, ext(def, options));
      };
      m.defaults = function defaults(options) {
        return orig.defaults(ext(def, options));
      };
      m.makeRe = function makeRe2(pattern, options) {
        return orig.makeRe(pattern, ext(def, options));
      };
      m.braceExpand = function braceExpand2(pattern, options) {
        return orig.braceExpand(pattern, ext(def, options));
      };
      m.match = function(list, pattern, options) {
        return orig.match(list, pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      assertValidPattern(pattern);
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      assertValidPattern(pattern);
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (!options.allowWindowsEscape && path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.partial = !!options.partial;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = function debug() {
          console.error.apply(console, arguments);
        };
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      assertValidPattern(pattern);
      if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        return [pattern];
      }
      return expand(pattern);
    }
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = function(pattern) {
      if (typeof pattern !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      assertValidPattern(pattern);
      var options = this.options;
      if (pattern === "**") {
        if (!options.noglobstar)
          return GLOBSTAR;
        else
          pattern = "*";
      }
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/": {
            return false;
          }
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case "[":
        case ".":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = function match(f, partial) {
      if (typeof partial === "undefined")
        partial = this.partial;
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    };
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug("matchOne", { "this": this, file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          hit = f === p;
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        return fi === fl - 1 && file[fi] === "";
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "node_modules/path-is-absolute/index.js"(exports2, module2) {
    "use strict";
    function posix(path) {
      return path.charAt(0) === "/";
    }
    function win32(path) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// node_modules/glob/common.js
var require_common2 = __commonJS({
  "node_modules/glob/common.js"(exports2) {
    exports2.setopts = setopts;
    exports2.ownProp = ownProp;
    exports2.makeAbs = makeAbs;
    exports2.finish = finish;
    exports2.mark = mark;
    exports2.isIgnored = isIgnored;
    exports2.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs = require("fs");
    var path = require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && pattern.indexOf("/") === -1) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.absolute = !!options.absolute;
      self2.fs = options.fs || fs;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || Object.create(null);
      self2.statCache = options.statCache || Object.create(null);
      self2.symlinks = options.symlinks || Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path.resolve(options.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options.root || path.resolve(self2.cwd, "/");
      self2.root = path.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      if (process.platform === "win32")
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      self2.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      options.allowWindowsEscape = false;
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : Object.create(null);
      for (var i = 0, l = self2.matches.length; i < l; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path.join(self2.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self2.changedCwd) {
        abs = path.resolve(self2.cwd, f);
      } else {
        abs = path.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
  }
});

// node_modules/glob/sync.js
var require_sync = __commonJS({
  "node_modules/glob/sync.js"(exports2, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = require("util");
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common2();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert.ok(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert.ok(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = this.fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, this.fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = this.fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports2, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports2, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "node_modules/inflight/inflight.js"(exports2, module2) {
    var wrappy = require_wrappy();
    var reqs = Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// node_modules/glob/glob.js
var require_glob = __commonJS({
  "node_modules/glob/glob.js"(exports2, module2) {
    module2.exports = glob;
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common2();
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.map(function(p) {
        return typeof p === "string" ? p : "[*]";
      }).join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        self2.fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      self2.fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        self2.fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return self2.fs.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f, abs, null, lstat, cb);
            else
              self2._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self2._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS({
  "node_modules/rimraf/rimraf.js"(exports2, module2) {
    var assert = require("assert");
    var path = require("path");
    var fs = require("fs");
    var glob = void 0;
    try {
      glob = require_glob();
    } catch (_err) {
    }
    var defaultGlobOpts = {
      nosort: true,
      silent: true
    };
    var timeout = 0;
    var isWindows = process.platform === "win32";
    var defaults = (options) => {
      const methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach((m) => {
        options[m] = options[m] || fs[m];
        m = m + "Sync";
        options[m] = options[m] || fs[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
      options.emfileWait = options.emfileWait || 1e3;
      if (options.glob === false) {
        options.disableGlob = true;
      }
      if (options.disableGlob !== true && glob === void 0) {
        throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
      }
      options.disableGlob = options.disableGlob || false;
      options.glob = options.glob || defaultGlobOpts;
    };
    var rimraf = (p, options, cb) => {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert.equal(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      let busyTries = 0;
      let errState = null;
      let n = 0;
      const next = (er) => {
        errState = errState || er;
        if (--n === 0)
          cb(errState);
      };
      const afterGlob = (er, results) => {
        if (er)
          return cb(er);
        n = results.length;
        if (n === 0)
          return cb();
        results.forEach((p2) => {
          const CB = (er2) => {
            if (er2) {
              if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
                busyTries++;
                return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);
              }
              if (er2.code === "EMFILE" && timeout < options.emfileWait) {
                return setTimeout(() => rimraf_(p2, options, CB), timeout++);
              }
              if (er2.code === "ENOENT")
                er2 = null;
            }
            timeout = 0;
            next(er2);
          };
          rimraf_(p2, options, CB);
        });
      };
      if (options.disableGlob || !glob.hasMagic(p))
        return afterGlob(null, [p]);
      options.lstat(p, (er, stat) => {
        if (!er)
          return afterGlob(null, [p]);
        glob(p, options.glob, afterGlob);
      });
    };
    var rimraf_ = (p, options, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, (er, st) => {
        if (er && er.code === "ENOENT")
          return cb(null);
        if (er && er.code === "EPERM" && isWindows)
          fixWinEPERM(p, options, er, cb);
        if (st && st.isDirectory())
          return rmdir(p, options, er, cb);
        options.unlink(p, (er2) => {
          if (er2) {
            if (er2.code === "ENOENT")
              return cb(null);
            if (er2.code === "EPERM")
              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            if (er2.code === "EISDIR")
              return rmdir(p, options, er2, cb);
          }
          return cb(er2);
        });
      });
    };
    var fixWinEPERM = (p, options, er, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.chmod(p, 438, (er2) => {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er);
        else
          options.stat(p, (er3, stats) => {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory())
              rmdir(p, options, er, cb);
            else
              options.unlink(p, cb);
          });
      });
    };
    var fixWinEPERMSync = (p, options, er) => {
      assert(p);
      assert(options);
      try {
        options.chmodSync(p, 438);
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else
          throw er;
      }
      let stats;
      try {
        stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT")
          return;
        else
          throw er;
      }
      if (stats.isDirectory())
        rmdirSync(p, options, er);
      else
        options.unlinkSync(p);
    };
    var rmdir = (p, options, originalEr, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.rmdir(p, (er) => {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options, cb);
        else if (er && er.code === "ENOTDIR")
          cb(originalEr);
        else
          cb(er);
      });
    };
    var rmkids = (p, options, cb) => {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, (er, files) => {
        if (er)
          return cb(er);
        let n = files.length;
        if (n === 0)
          return options.rmdir(p, cb);
        let errState;
        files.forEach((f) => {
          rimraf(path.join(p, f), options, (er2) => {
            if (errState)
              return;
            if (er2)
              return cb(errState = er2);
            if (--n === 0)
              options.rmdir(p, cb);
          });
        });
      });
    };
    var rimrafSync = (p, options) => {
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      let results;
      if (options.disableGlob || !glob.hasMagic(p)) {
        results = [p];
      } else {
        try {
          options.lstatSync(p);
          results = [p];
        } catch (er) {
          results = glob.sync(p, options.glob);
        }
      }
      if (!results.length)
        return;
      for (let i = 0; i < results.length; i++) {
        const p2 = results[i];
        let st;
        try {
          st = options.lstatSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM" && isWindows)
            fixWinEPERMSync(p2, options, er);
        }
        try {
          if (st && st.isDirectory())
            rmdirSync(p2, options, null);
          else
            options.unlinkSync(p2);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);
          if (er.code !== "EISDIR")
            throw er;
          rmdirSync(p2, options, er);
        }
      }
    };
    var rmdirSync = (p, options, originalEr) => {
      assert(p);
      assert(options);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "ENOTDIR")
          throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options);
      }
    };
    var rmkidsSync = (p, options) => {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach((f) => rimrafSync(path.join(p, f), options));
      const retries = isWindows ? 100 : 1;
      let i = 0;
      do {
        let threw = true;
        try {
          const ret = options.rmdirSync(p, options);
          threw = false;
          return ret;
        } finally {
          if (++i < retries && threw)
            continue;
        }
      } while (true);
    };
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
  }
});

// node_modules/playwright-core/lib/utils/fileUtils.js
var require_fileUtils = __commonJS({
  "node_modules/playwright-core/lib/utils/fileUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.canAccessFile = canAccessFile;
    exports2.existsAsync = void 0;
    exports2.mkdirIfNeeded = mkdirIfNeeded;
    exports2.removeFolders = removeFolders;
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var _rimraf = _interopRequireDefault(require_rimraf());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var existsAsync = (path) => new Promise((resolve) => _fs.default.stat(path, (err) => resolve(!err)));
    exports2.existsAsync = existsAsync;
    function mkdirIfNeeded(filePath) {
      return __async(this, null, function* () {
        yield _fs.default.promises.mkdir(_path.default.dirname(filePath), {
          recursive: true
        }).catch(() => {
        });
      });
    }
    function removeFolders(dirs) {
      return __async(this, null, function* () {
        return yield Promise.all(dirs.map((dir) => {
          return new Promise((fulfill) => {
            (0, _rimraf.default)(dir, {
              maxBusyTries: 10
            }, (error) => {
              fulfill(error !== null && error !== void 0 ? error : void 0);
            });
          });
        }));
      });
    }
    function canAccessFile(file) {
      if (!file)
        return false;
      try {
        _fs.default.accessSync(file);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// node_modules/playwright-core/lib/utils/hostPlatform.js
var require_hostPlatform = __commonJS({
  "node_modules/playwright-core/lib/utils/hostPlatform.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.hostPlatform = void 0;
    var _os = _interopRequireDefault(require("os"));
    var _ubuntuVersion = require_ubuntuVersion();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hostPlatform = (() => {
      const platform = _os.default.platform();
      if (platform === "darwin") {
        const ver = _os.default.release().split(".").map((a) => parseInt(a, 10));
        let macVersion = "";
        if (ver[0] < 18) {
          macVersion = "mac10.13";
        } else if (ver[0] === 18) {
          macVersion = "mac10.14";
        } else if (ver[0] === 19) {
          macVersion = "mac10.15";
        } else {
          const LAST_STABLE_MAC_MAJOR_VERSION = 12;
          macVersion = "mac" + Math.min(ver[0] - 9, LAST_STABLE_MAC_MAJOR_VERSION);
          if (_os.default.cpus().some((cpu) => cpu.model.includes("Apple")))
            macVersion += "-arm64";
        }
        return macVersion;
      }
      if (platform === "linux") {
        const archSuffix = _os.default.arch() === "arm64" ? "-arm64" : "";
        const ubuntuVersion = (0, _ubuntuVersion.getUbuntuVersionSync)();
        if (!ubuntuVersion)
          return "generic-linux" + archSuffix;
        if (parseInt(ubuntuVersion, 10) <= 19)
          return "ubuntu18.04" + archSuffix;
        return "ubuntu20.04" + archSuffix;
      }
      if (platform === "win32")
        return "win64";
      return "<unknown>";
    })();
    exports2.hostPlatform = hostPlatform;
  }
});

// node_modules/playwright-core/lib/utils/spawnAsync.js
var require_spawnAsync = __commonJS({
  "node_modules/playwright-core/lib/utils/spawnAsync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.spawnAsync = spawnAsync;
    var _child_process = require("child_process");
    function spawnAsync(cmd, args, options = {}) {
      const process2 = (0, _child_process.spawn)(cmd, args, Object.assign({
        windowsHide: true
      }, options));
      return new Promise((resolve) => {
        let stdout = "";
        let stderr = "";
        if (process2.stdout)
          process2.stdout.on("data", (data) => stdout += data);
        if (process2.stderr)
          process2.stderr.on("data", (data) => stderr += data);
        process2.on("close", (code) => resolve({
          stdout,
          stderr,
          code
        }));
        process2.on("error", (error) => resolve({
          stdout,
          stderr,
          code: 0,
          error
        }));
      });
    }
  }
});

// node_modules/playwright-core/lib/server/registry/nativeDeps.js
var require_nativeDeps = __commonJS({
  "node_modules/playwright-core/lib/server/registry/nativeDeps.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.deps = void 0;
    var deps = {
      "ubuntu18.04": {
        tools: ["xvfb", "fonts-noto-color-emoji", "ttf-unifont", "libfontconfig", "libfreetype6", "xfonts-cyrillic", "xfonts-scalable", "fonts-liberation", "fonts-ipafont-gothic", "fonts-wqy-zenhei", "fonts-tlwg-loma-otf", "ttf-ubuntu-font-family"],
        chromium: ["fonts-liberation", "libasound2", "libatk-bridge2.0-0", "libatk1.0-0", "libatspi2.0-0", "libcairo2", "libcups2", "libdbus-1-3", "libdrm2", "libegl1", "libgbm1", "libglib2.0-0", "libgtk-3-0", "libnspr4", "libnss3", "libpango-1.0-0", "libx11-6", "libx11-xcb1", "libxcb1", "libxcomposite1", "libxdamage1", "libxext6", "libxfixes3", "libxrandr2", "libxshmfence1"],
        firefox: ["ffmpeg", "libatk1.0-0", "libcairo-gobject2", "libcairo2", "libdbus-1-3", "libdbus-glib-1-2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf2.0-0", "libglib2.0-0", "libgtk-3-0", "libpango-1.0-0", "libpangocairo-1.0-0", "libpangoft2-1.0-0", "libx11-6", "libx11-xcb1", "libxcb-shm0", "libxcb1", "libxcomposite1", "libxcursor1", "libxdamage1", "libxext6", "libxfixes3", "libxi6", "libxrender1", "libxt6", "libxtst6"],
        webkit: ["gstreamer1.0-libav", "gstreamer1.0-plugins-bad", "gstreamer1.0-plugins-base", "gstreamer1.0-plugins-good", "libatk-bridge2.0-0", "libatk1.0-0", "libbrotli1", "libcairo2", "libegl1", "libenchant1c2a", "libepoxy0", "libevdev2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf2.0-0", "libgl1", "libgles2", "libglib2.0-0", "libgstreamer-gl1.0-0", "libgstreamer1.0-0", "libgtk-3-0", "libharfbuzz-icu0", "libharfbuzz0b", "libhyphen0", "libicu60", "libjpeg-turbo8", "libnotify4", "libopenjp2-7", "libopus0", "libpango-1.0-0", "libpng16-16", "libsecret-1-0", "libvpx5", "libwayland-client0", "libwayland-egl1", "libwayland-server0", "libwebp6", "libwebpdemux2", "libwoff1", "libx11-6", "libxcomposite1", "libxdamage1", "libxkbcommon0", "libxml2", "libxslt1.1"],
        lib2package: {
          "libasound.so.2": "libasound2",
          "libatk-1.0.so.0": "libatk1.0-0",
          "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
          "libatspi.so.0": "libatspi2.0-0",
          "libbrotlidec.so.1": "libbrotli1",
          "libcairo-gobject.so.2": "libcairo-gobject2",
          "libcairo.so.2": "libcairo2",
          "libcups.so.2": "libcups2",
          "libdbus-1.so.3": "libdbus-1-3",
          "libdbus-glib-1.so.2": "libdbus-glib-1-2",
          "libdrm.so.2": "libdrm2",
          "libEGL.so.1": "libegl1",
          "libenchant.so.1": "libenchant1c2a",
          "libepoxy.so.0": "libepoxy0",
          "libevent-2.1.so.6": "libevent-2.1-6",
          "libevdev.so.2": "libevdev2",
          "libfontconfig.so.1": "libfontconfig1",
          "libfreetype.so.6": "libfreetype6",
          "libgbm.so.1": "libgbm1",
          "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf2.0-0",
          "libgdk-3.so.0": "libgtk-3-0",
          "libgdk-x11-2.0.so.0": "libgtk2.0-0",
          "libgio-2.0.so.0": "libglib2.0-0",
          "libGL.so.1": "libgl1",
          "libGLESv2.so.2": "libgles2",
          "libglib-2.0.so.0": "libglib2.0-0",
          "libgmodule-2.0.so.0": "libglib2.0-0",
          "libgobject-2.0.so.0": "libglib2.0-0",
          "libgstapp-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstaudio-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstbase-1.0.so.0": "libgstreamer1.0-0",
          "libgstcodecparsers-1.0.so.0": "gstreamer1.0-plugins-bad",
          "libgstfft-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
          "libgstpbutils-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
          "libgsttag-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstvideo-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgthread-2.0.so.0": "libglib2.0-0",
          "libgtk-3.so.0": "libgtk-3-0",
          "libgtk-x11-2.0.so.0": "libgtk2.0-0",
          "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
          "libharfbuzz.so.0": "libharfbuzz0b",
          "libhyphen.so.0": "libhyphen0",
          "libicudata.so.60": "libicu60",
          "libicui18n.so.60": "libicu60",
          "libicuuc.so.60": "libicu60",
          "libjpeg.so.8": "libjpeg-turbo8",
          "libnotify.so.4": "libnotify4",
          "libnspr4.so": "libnspr4",
          "libnss3.so": "libnss3",
          "libnssutil3.so": "libnss3",
          "libopenjp2.so.7": "libopenjp2-7",
          "libopus.so.0": "libopus0",
          "libpango-1.0.so.0": "libpango-1.0-0",
          "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
          "libpangoft2-1.0.so.0": "libpangoft2-1.0-0",
          "libpng16.so.16": "libpng16-16",
          "libsecret-1.so.0": "libsecret-1-0",
          "libsmime3.so": "libnss3",
          "libvpx.so.5": "libvpx5",
          "libwayland-client.so.0": "libwayland-client0",
          "libwayland-egl.so.1": "libwayland-egl1",
          "libwayland-server.so.0": "libwayland-server0",
          "libwebp.so.6": "libwebp6",
          "libwebpdemux.so.2": "libwebpdemux2",
          "libwoff2dec.so.1.0.2": "libwoff1",
          "libX11-xcb.so.1": "libx11-xcb1",
          "libX11.so.6": "libx11-6",
          "libxcb-dri3.so.0": "libxcb-dri3-0",
          "libxcb-shm.so.0": "libxcb-shm0",
          "libxcb.so.1": "libxcb1",
          "libXcomposite.so.1": "libxcomposite1",
          "libXcursor.so.1": "libxcursor1",
          "libXdamage.so.1": "libxdamage1",
          "libXext.so.6": "libxext6",
          "libXfixes.so.3": "libxfixes3",
          "libXi.so.6": "libxi6",
          "libxkbcommon.so.0": "libxkbcommon0",
          "libxml2.so.2": "libxml2",
          "libXrandr.so.2": "libxrandr2",
          "libXrender.so.1": "libxrender1",
          "libxslt.so.1": "libxslt1.1",
          "libXt.so.6": "libxt6",
          "libXtst.so.6": "libxtst6"
        }
      },
      "ubuntu20.04": {
        tools: ["xvfb", "fonts-noto-color-emoji", "ttf-unifont", "libfontconfig", "libfreetype6", "xfonts-cyrillic", "xfonts-scalable", "fonts-liberation", "fonts-ipafont-gothic", "fonts-wqy-zenhei", "fonts-tlwg-loma-otf", "ttf-ubuntu-font-family"],
        chromium: ["fonts-liberation", "libasound2", "libatk-bridge2.0-0", "libatk1.0-0", "libatspi2.0-0", "libcairo2", "libcups2", "libdbus-1-3", "libdrm2", "libegl1", "libgbm1", "libglib2.0-0", "libgtk-3-0", "libnspr4", "libnss3", "libpango-1.0-0", "libx11-6", "libx11-xcb1", "libxcb1", "libxcomposite1", "libxdamage1", "libxext6", "libxfixes3", "libxrandr2", "libxshmfence1"],
        firefox: ["ffmpeg", "libatk1.0-0", "libcairo-gobject2", "libcairo2", "libdbus-1-3", "libdbus-glib-1-2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf2.0-0", "libglib2.0-0", "libgtk-3-0", "libpango-1.0-0", "libpangocairo-1.0-0", "libpangoft2-1.0-0", "libx11-6", "libx11-xcb1", "libxcb-shm0", "libxcb1", "libxcomposite1", "libxcursor1", "libxdamage1", "libxext6", "libxfixes3", "libxi6", "libxrender1", "libxt6", "libxtst6"],
        webkit: ["gstreamer1.0-libav", "gstreamer1.0-plugins-bad", "gstreamer1.0-plugins-base", "gstreamer1.0-plugins-good", "libatk-bridge2.0-0", "libatk1.0-0", "libcairo2", "libegl1", "libenchant1c2a", "libepoxy0", "libevdev2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf2.0-0", "libgl1", "libgles2", "libglib2.0-0", "libgstreamer-gl1.0-0", "libgstreamer1.0-0", "libgtk-3-0", "libharfbuzz-icu0", "libharfbuzz0b", "libhyphen0", "libicu66", "libjpeg-turbo8", "libnotify4", "libopengl0", "libopenjp2-7", "libopus0", "libpango-1.0-0", "libpng16-16", "libsecret-1-0", "libsoup2.4-1", "libvpx6", "libwayland-client0", "libwayland-egl1", "libwayland-server0", "libwebp6", "libwebpdemux2", "libwoff1", "libx11-6", "libxcomposite1", "libxdamage1", "libxkbcommon0", "libxml2", "libxslt1.1"],
        lib2package: {
          "libasound.so.2": "libasound2",
          "libatk-1.0.so.0": "libatk1.0-0",
          "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
          "libatspi.so.0": "libatspi2.0-0",
          "libcairo-gobject.so.2": "libcairo-gobject2",
          "libcairo.so.2": "libcairo2",
          "libcups.so.2": "libcups2",
          "libdbus-1.so.3": "libdbus-1-3",
          "libdbus-glib-1.so.2": "libdbus-glib-1-2",
          "libdrm.so.2": "libdrm2",
          "libEGL.so.1": "libegl1",
          "libenchant.so.1": "libenchant1c2a",
          "libevdev.so.2": "libevdev2",
          "libepoxy.so.0": "libepoxy0",
          "libfontconfig.so.1": "libfontconfig1",
          "libfreetype.so.6": "libfreetype6",
          "libgbm.so.1": "libgbm1",
          "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf2.0-0",
          "libgdk-3.so.0": "libgtk-3-0",
          "libgdk-x11-2.0.so.0": "libgtk2.0-0",
          "libgio-2.0.so.0": "libglib2.0-0",
          "libGL.so.1": "libgl1",
          "libGLESv2.so.2": "libgles2",
          "libglib-2.0.so.0": "libglib2.0-0",
          "libgmodule-2.0.so.0": "libglib2.0-0",
          "libgobject-2.0.so.0": "libglib2.0-0",
          "libgstapp-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstaudio-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstbase-1.0.so.0": "libgstreamer1.0-0",
          "libgstcodecparsers-1.0.so.0": "gstreamer1.0-plugins-bad",
          "libgstfft-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
          "libgstpbutils-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
          "libgsttag-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgstvideo-1.0.so.0": "gstreamer1.0-plugins-base",
          "libgthread-2.0.so.0": "libglib2.0-0",
          "libgtk-3.so.0": "libgtk-3-0",
          "libgtk-x11-2.0.so.0": "libgtk2.0-0",
          "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
          "libharfbuzz.so.0": "libharfbuzz0b",
          "libhyphen.so.0": "libhyphen0",
          "libicui18n.so.66": "libicu66",
          "libicuuc.so.66": "libicu66",
          "libjpeg.so.8": "libjpeg-turbo8",
          "libnotify.so.4": "libnotify4",
          "libnspr4.so": "libnspr4",
          "libnss3.so": "libnss3",
          "libnssutil3.so": "libnss3",
          "libOpenGL.so.0": "libopengl0",
          "libopenjp2.so.7": "libopenjp2-7",
          "libopus.so.0": "libopus0",
          "libpango-1.0.so.0": "libpango-1.0-0",
          "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
          "libpangoft2-1.0.so.0": "libpangoft2-1.0-0",
          "libpng16.so.16": "libpng16-16",
          "libsecret-1.so.0": "libsecret-1-0",
          "libsmime3.so": "libnss3",
          "libsoup-2.4.so.1": "libsoup2.4-1",
          "libvpx.so.6": "libvpx6",
          "libwayland-client.so.0": "libwayland-client0",
          "libwayland-egl.so.1": "libwayland-egl1",
          "libwayland-server.so.0": "libwayland-server0",
          "libwebp.so.6": "libwebp6",
          "libwebpdemux.so.2": "libwebpdemux2",
          "libwoff2dec.so.1.0.2": "libwoff1",
          "libX11-xcb.so.1": "libx11-xcb1",
          "libX11.so.6": "libx11-6",
          "libxcb-dri3.so.0": "libxcb-dri3-0",
          "libxcb-shm.so.0": "libxcb-shm0",
          "libxcb.so.1": "libxcb1",
          "libXcomposite.so.1": "libxcomposite1",
          "libXcursor.so.1": "libxcursor1",
          "libXdamage.so.1": "libxdamage1",
          "libXext.so.6": "libxext6",
          "libXfixes.so.3": "libxfixes3",
          "libXi.so.6": "libxi6",
          "libxkbcommon.so.0": "libxkbcommon0",
          "libxml2.so.2": "libxml2",
          "libXrandr.so.2": "libxrandr2",
          "libXrender.so.1": "libxrender1",
          "libxslt.so.1": "libxslt1.1",
          "libXt.so.6": "libxt6",
          "libXtst.so.6": "libxtst6",
          "libxshmfence.so.1": "libxshmfence1"
        }
      },
      "ubuntu21.04": {
        tools: ["xvfb", "fonts-noto-color-emoji", "ttf-unifont", "libfontconfig", "libfreetype6", "xfonts-cyrillic", "xfonts-scalable", "fonts-liberation", "fonts-ipafont-gothic", "fonts-wqy-zenhei", "fonts-tlwg-loma-otf", "ttf-ubuntu-font-family"],
        chromium: ["libasound2", "libatk-bridge2.0-0", "libatk1.0-0", "libatspi2.0-0", "libcairo2", "libcups2", "libdbus-1-3", "libdrm2", "libgbm1", "libglib2.0-0", "libnspr4", "libnss3", "libpango-1.0-0", "libx11-6", "libxcb1", "libxcomposite1", "libxdamage1", "libxext6", "libxfixes3", "libxkbcommon0", "libxrandr2", "libxshmfence1"],
        firefox: ["ffmpeg", "libatk1.0-0", "libcairo-gobject2", "libcairo2", "libdbus-1-3", "libdbus-glib-1-2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf-2.0-0", "libglib2.0-0", "libgtk-3-0", "libgtk2.0-0", "libharfbuzz0b", "libpango-1.0-0", "libpangocairo-1.0-0", "libpangoft2-1.0-0", "libx11-6", "libx11-xcb1", "libxcb-shm0", "libxcb1", "libxcomposite1", "libxcursor1", "libxdamage1", "libxext6", "libxfixes3", "libxi6", "libxrender1", "libxt6"],
        webkit: ["gstreamer1.0-libav", "gstreamer1.0-plugins-bad", "gstreamer1.0-plugins-base", "gstreamer1.0-plugins-good", "libatk-bridge2.0-0", "libatk1.0-0", "libcairo2", "libegl1", "libepoxy0", "libevdev2", "libfontconfig1", "libfreetype6", "libgdk-pixbuf-2.0-0", "libgl1", "libgles2", "libglib2.0-0", "libgstreamer-gl1.0-0", "libgstreamer-plugins-bad1.0-0", "libgstreamer-plugins-base1.0-0", "libgstreamer1.0-0", "libgtk-3-0", "libharfbuzz-icu0", "libharfbuzz0b", "libhyphen0", "libjavascriptcoregtk-4.0-18", "libjpeg-turbo8", "liblcms2-2", "libnotify4", "libopenjp2-7", "libopus0", "libpango-1.0-0", "libpng16-16", "libsecret-1-0", "libsoup2.4-1", "libvpx6", "libwayland-client0", "libwayland-egl1", "libwayland-server0", "libwebkit2gtk-4.0-37", "libwebp6", "libwebpdemux2", "libwoff1", "libwpe-1.0-1", "libwpebackend-fdo-1.0-1", "libwpewebkit-1.0-3", "libx11-6", "libxcomposite1", "libxdamage1", "libxkbcommon0", "libxml2", "libxslt1.1"],
        lib2package: {
          "libasound.so.2": "libasound2",
          "libatk-1.0.so.0": "libatk1.0-0",
          "libatk-bridge-2.0.so.0": "libatk-bridge2.0-0",
          "libatspi.so.0": "libatspi2.0-0",
          "libcairo-gobject.so.2": "libcairo-gobject2",
          "libcairo.so.2": "libcairo2",
          "libcups.so.2": "libcups2",
          "libdbus-1.so.3": "libdbus-1-3",
          "libdbus-glib-1.so.2": "libdbus-glib-1-2",
          "libdrm.so.2": "libdrm2",
          "libEGL.so.1": "libegl1",
          "libepoxy.so.0": "libepoxy0",
          "libfontconfig.so.1": "libfontconfig1",
          "libfreetype.so.6": "libfreetype6",
          "libgbm.so.1": "libgbm1",
          "libgdk_pixbuf-2.0.so.0": "libgdk-pixbuf-2.0-0",
          "libgdk-3.so.0": "libgtk-3-0",
          "libgdk-x11-2.0.so.0": "libgtk2.0-0",
          "libgio-2.0.so.0": "libglib2.0-0",
          "libGL.so.1": "libgl1",
          "libGLESv2.so.2": "libgles2",
          "libglib-2.0.so.0": "libglib2.0-0",
          "libgmodule-2.0.so.0": "libglib2.0-0",
          "libgobject-2.0.so.0": "libglib2.0-0",
          "libgstapp-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstaudio-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstbase-1.0.so.0": "libgstreamer1.0-0",
          "libgstcodecparsers-1.0.so.0": "libgstreamer-plugins-bad1.0-0",
          "libgstfft-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstgl-1.0.so.0": "libgstreamer-gl1.0-0",
          "libgstpbutils-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstreamer-1.0.so.0": "libgstreamer1.0-0",
          "libgsttag-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgstvideo-1.0.so.0": "libgstreamer-plugins-base1.0-0",
          "libgthread-2.0.so.0": "libglib2.0-0",
          "libgtk-3.so.0": "libgtk-3-0",
          "libgtk-x11-2.0.so.0": "libgtk2.0-0",
          "libharfbuzz-icu.so.0": "libharfbuzz-icu0",
          "libharfbuzz.so.0": "libharfbuzz0b",
          "libhyphen.so.0": "libhyphen0",
          "libjavascriptcoregtk-4.0.so.18": "libjavascriptcoregtk-4.0-18",
          "libjpeg.so.8": "libjpeg-turbo8",
          "liblcms2.so.2": "liblcms2-2",
          "libnotify.so.4": "libnotify4",
          "libnspr4.so": "libnspr4",
          "libnss3.so": "libnss3",
          "libnssutil3.so": "libnss3",
          "libopenjp2.so.7": "libopenjp2-7",
          "libopus.so.0": "libopus0",
          "libpango-1.0.so.0": "libpango-1.0-0",
          "libpangocairo-1.0.so.0": "libpangocairo-1.0-0",
          "libpangoft2-1.0.so.0": "libpangoft2-1.0-0",
          "libpng16.so.16": "libpng16-16",
          "libsecret-1.so.0": "libsecret-1-0",
          "libsmime3.so": "libnss3",
          "libsoup-2.4.so.1": "libsoup2.4-1",
          "libvpx.so.6": "libvpx6",
          "libwayland-client.so.0": "libwayland-client0",
          "libwayland-egl.so.1": "libwayland-egl1",
          "libwayland-server.so.0": "libwayland-server0",
          "libwebkit2gtk-4.0.so.37": "libwebkit2gtk-4.0-37",
          "libwebp.so.6": "libwebp6",
          "libwebpdemux.so.2": "libwebpdemux2",
          "libwoff2dec.so.1.0.2": "libwoff1",
          "libwpe-1.0.so.1": "libwpe-1.0-1",
          "libWPEBackend-fdo-1.0.so.1": "libwpebackend-fdo-1.0-1",
          "libWPEWebKit-1.0.so.3": "libwpewebkit-1.0-3",
          "libX11-xcb.so.1": "libx11-xcb1",
          "libX11.so.6": "libx11-6",
          "libxcb-shm.so.0": "libxcb-shm0",
          "libxcb.so.1": "libxcb1",
          "libXcomposite.so.1": "libxcomposite1",
          "libXcursor.so.1": "libxcursor1",
          "libXdamage.so.1": "libxdamage1",
          "libXext.so.6": "libxext6",
          "libXfixes.so.3": "libxfixes3",
          "libXi.so.6": "libxi6",
          "libxkbcommon.so.0": "libxkbcommon0",
          "libxml2.so.2": "libxml2",
          "libXrandr.so.2": "libxrandr2",
          "libXrender.so.1": "libxrender1",
          "libxshmfence.so.1": "libxshmfence1",
          "libxslt.so.1": "libxslt1.1",
          "libXt.so.6": "libxt6"
        }
      }
    };
    exports2.deps = deps;
    deps["ubuntu20.04-arm64"] = {
      tools: [...deps["ubuntu20.04"].tools],
      chromium: [...deps["ubuntu20.04"].chromium],
      firefox: [...deps["ubuntu20.04"].firefox],
      webkit: [...deps["ubuntu20.04"].webkit, "libevent-2.1-7"],
      lib2package: __spreadProps(__spreadValues({}, deps["ubuntu20.04"].lib2package), {
        "libevent-2.1.so.7": "libevent-2.1.so.7"
      })
    };
  }
});

// node_modules/playwright-core/lib/server/registry/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/playwright-core/lib/server/registry/dependencies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.installDependenciesLinux = installDependenciesLinux;
    exports2.installDependenciesWindows = installDependenciesWindows;
    exports2.transformCommandsForRoot = transformCommandsForRoot;
    exports2.validateDependenciesLinux = validateDependenciesLinux;
    exports2.validateDependenciesWindows = validateDependenciesWindows;
    exports2.writeDockerVersion = writeDockerVersion;
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var os = _interopRequireWildcard(require("os"));
    var _child_process = _interopRequireDefault(require("child_process"));
    var utils = _interopRequireWildcard(require_utils());
    var _spawnAsync = require_spawnAsync();
    var _hostPlatform = require_hostPlatform();
    var _ = require_registry();
    var _nativeDeps = require_nativeDeps();
    var _ubuntuVersion = require_ubuntuVersion();
    var _userAgent = require_userAgent();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var BIN_DIRECTORY = _path.default.join(__dirname, "..", "..", "..", "bin");
    var packageJSON = require_package();
    var dockerVersionFilePath = "/ms-playwright/.docker-info";
    function writeDockerVersion(dockerImageNameTemplate) {
      return __async(this, null, function* () {
        yield _fs.default.promises.mkdir(_path.default.dirname(dockerVersionFilePath), {
          recursive: true
        });
        yield _fs.default.promises.writeFile(dockerVersionFilePath, JSON.stringify({
          driverVersion: packageJSON.version,
          dockerImageName: dockerImageNameTemplate.replace("%version%", packageJSON.version)
        }, null, 2), "utf8");
        yield _fs.default.promises.chmod(dockerVersionFilePath, 511);
      });
    }
    function readDockerVersion() {
      return __async(this, null, function* () {
        return yield _fs.default.promises.readFile(dockerVersionFilePath, "utf8").then((text) => JSON.parse(text)).catch((e) => null);
      });
    }
    var checkExecutable = (filePath) => _fs.default.promises.access(filePath, _fs.default.constants.X_OK).then(() => true).catch((e) => false);
    function isSupportedWindowsVersion() {
      if (os.platform() !== "win32" || os.arch() !== "x64")
        return false;
      const [major, minor] = os.release().split(".").map((token) => parseInt(token, 10));
      return major > 6 || major === 6 && minor > 1;
    }
    function installDependenciesWindows(targets, dryRun) {
      return __async(this, null, function* () {
        if (targets.has("chromium")) {
          const command = "powershell.exe";
          const args = ["-ExecutionPolicy", "Bypass", "-File", _path.default.join(BIN_DIRECTORY, "install_media_pack.ps1")];
          if (dryRun) {
            console.log(`${command} ${quoteProcessArgs(args).join(" ")}`);
            return;
          }
          const {
            code
          } = yield (0, _spawnAsync.spawnAsync)(command, args, {
            cwd: BIN_DIRECTORY,
            stdio: "inherit"
          });
          if (code !== 0)
            throw new Error("Failed to install windows dependencies!");
        }
      });
    }
    function installDependenciesLinux(targets, dryRun) {
      return __async(this, null, function* () {
        if ((yield (0, _ubuntuVersion.getUbuntuVersion)()) === "")
          throw new Error(`Unsupported Linux distribution, only Ubuntu is supported!`);
        const libraries = [];
        for (const target of targets) {
          const info = _nativeDeps.deps[_hostPlatform.hostPlatform];
          if (!info) {
            console.warn("Cannot install dependencies for this linux distribution!");
            return;
          }
          libraries.push(...info[target]);
        }
        const uniqueLibraries = Array.from(new Set(libraries));
        if (!dryRun)
          console.log("Installing Ubuntu dependencies...");
        const commands = [];
        commands.push("apt-get update");
        commands.push(["apt-get", "install", "-y", "--no-install-recommends", ...uniqueLibraries].join(" "));
        const {
          command,
          args,
          elevatedPermissions
        } = yield transformCommandsForRoot(commands);
        if (dryRun) {
          console.log(`${command} ${quoteProcessArgs(args).join(" ")}`);
          return;
        }
        if (elevatedPermissions)
          console.log("Switching to root user to install dependencies...");
        const child = _child_process.default.spawn(command, args, {
          stdio: "inherit"
        });
        yield new Promise((resolve, reject) => {
          child.on("exit", (code) => code === 0 ? resolve() : reject(new Error(`Installation process exited with code: ${code}`)));
          child.on("error", reject);
        });
      });
    }
    function validateDependenciesWindows(windowsExeAndDllDirectories) {
      return __async(this, null, function* () {
        const directoryPaths = windowsExeAndDllDirectories;
        const lddPaths = [];
        for (const directoryPath of directoryPaths)
          lddPaths.push(...yield executablesOrSharedLibraries(directoryPath));
        const allMissingDeps = yield Promise.all(lddPaths.map((lddPath) => missingFileDependenciesWindows(lddPath)));
        const missingDeps = /* @__PURE__ */ new Set();
        for (const deps of allMissingDeps) {
          for (const dep of deps)
            missingDeps.add(dep);
        }
        if (!missingDeps.size)
          return;
        let isCrtMissing = false;
        let isMediaFoundationMissing = false;
        for (const dep of missingDeps) {
          if (dep.startsWith("api-ms-win-crt") || dep === "vcruntime140.dll" || dep === "vcruntime140_1.dll" || dep === "msvcp140.dll")
            isCrtMissing = true;
          else if (dep === "mf.dll" || dep === "mfplat.dll" || dep === "msmpeg2vdec.dll" || dep === "evr.dll" || dep === "avrt.dll")
            isMediaFoundationMissing = true;
        }
        const details = [];
        if (isCrtMissing) {
          details.push(`Some of the Universal C Runtime files cannot be found on the system. You can fix`, `that by installing Microsoft Visual C++ Redistributable for Visual Studio from:`, `https://support.microsoft.com/en-us/help/2977003/the-latest-supported-visual-c-downloads`, ``);
        }
        if (isMediaFoundationMissing) {
          details.push(`Some of the Media Foundation files cannot be found on the system. If you are`, `on Windows Server try fixing this by running the following command in PowerShell`, `as Administrator:`, ``, `    Install-WindowsFeature Server-Media-Foundation`, ``, `For Windows N editions visit:`, `https://support.microsoft.com/en-us/help/3145500/media-feature-pack-list-for-windows-n-editions`, ``);
        }
        details.push(`Full list of missing libraries:`, `    ${[...missingDeps].join("\n    ")}`, ``);
        const message = `Host system is missing dependencies!

${details.join("\n")}`;
        if (isSupportedWindowsVersion()) {
          throw new Error(message);
        } else {
          console.warn(`WARNING: running on unsupported windows version!`);
          console.warn(message);
        }
      });
    }
    function validateDependenciesLinux(sdkLanguage, linuxLddDirectories, dlOpenLibraries) {
      return __async(this, null, function* () {
        var _deps$hostPlatform;
        const directoryPaths = linuxLddDirectories;
        const lddPaths = [];
        for (const directoryPath of directoryPaths)
          lddPaths.push(...yield executablesOrSharedLibraries(directoryPath));
        const missingDepsPerFile = yield Promise.all(lddPaths.map((lddPath) => missingFileDependencies(lddPath, directoryPaths)));
        const missingDeps = /* @__PURE__ */ new Set();
        for (const deps of missingDepsPerFile) {
          for (const dep of deps)
            missingDeps.add(dep);
        }
        for (const dep of yield missingDLOPENLibraries(dlOpenLibraries))
          missingDeps.add(dep);
        if (!missingDeps.size)
          return;
        const allMissingDeps = new Set(missingDeps);
        const missingPackages = /* @__PURE__ */ new Set();
        const libraryToPackageNameMapping = __spreadValues(__spreadValues({}, ((_deps$hostPlatform = _nativeDeps.deps[_hostPlatform.hostPlatform]) === null || _deps$hostPlatform === void 0 ? void 0 : _deps$hostPlatform.lib2package) || {}), MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU);
        for (const missingDep of missingDeps) {
          const packageName = libraryToPackageNameMapping[missingDep];
          if (packageName) {
            missingPackages.add(packageName);
            missingDeps.delete(missingDep);
          }
        }
        const maybeSudo = process.getuid() !== 0 && os.platform() !== "win32" ? "sudo " : "";
        const dockerInfo = yield readDockerVersion();
        const errorLines = [`Host system is missing dependencies to run browsers.`];
        if (dockerInfo && !dockerInfo.driverVersion.startsWith((0, _userAgent.getPlaywrightVersion)(true) + ".")) {
          const pwVersion = (0, _userAgent.getPlaywrightVersion)();
          const requiredDockerImage = dockerInfo.dockerImageName.replace(dockerInfo.driverVersion, pwVersion);
          errorLines.push(...[`This is most likely due to docker image version not matching Playwright version:`, `- Playwright: ${pwVersion}`, `-     Docker: ${dockerInfo.driverVersion}`, ``, `Either:`, `- (recommended) use docker image "${requiredDockerImage}"`, `- (alternative 1) run the following command inside docker to install missing dependencies:`, ``, `    ${maybeSudo}${(0, _.buildPlaywrightCLICommand)(sdkLanguage, "install-deps")}`, ``, `- (alternative 2) use Aptitude inside docker:`, ``, `    ${maybeSudo}apt-get install ${[...missingPackages].join("\\\n        ")}`, ``, `<3 Playwright Team`]);
        } else if (missingPackages.size && !missingDeps.size) {
          errorLines.push(...[`Please install them with the following command:`, ``, `    ${maybeSudo}${(0, _.buildPlaywrightCLICommand)(sdkLanguage, "install-deps")}`, ``, `Alternatively, use Aptitude:`, `    ${maybeSudo}apt-get install ${[...missingPackages].join("\\\n        ")}`, ``, `<3 Playwright Team`]);
        } else {
          errorLines.push(...[`Missing libraries:`, ...[...allMissingDeps].map((dep) => "    " + dep)]);
        }
        throw new Error("\n" + utils.wrapInASCIIBox(errorLines.join("\n"), 1));
      });
    }
    function isSharedLib(basename) {
      switch (os.platform()) {
        case "linux":
          return basename.endsWith(".so") || basename.includes(".so.");
        case "win32":
          return basename.endsWith(".dll");
        default:
          return false;
      }
    }
    function executablesOrSharedLibraries(directoryPath) {
      return __async(this, null, function* () {
        if (!_fs.default.existsSync(directoryPath))
          return [];
        const allPaths = (yield _fs.default.promises.readdir(directoryPath)).map((file) => _path.default.resolve(directoryPath, file));
        const allStats = yield Promise.all(allPaths.map((aPath) => _fs.default.promises.stat(aPath)));
        const filePaths = allPaths.filter((aPath, index) => allStats[index].isFile());
        const executablersOrLibraries = (yield Promise.all(filePaths.map((filePath) => __async(this, null, function* () {
          const basename = _path.default.basename(filePath).toLowerCase();
          if (isSharedLib(basename))
            return filePath;
          if (yield checkExecutable(filePath))
            return filePath;
          return false;
        })))).filter(Boolean);
        return executablersOrLibraries;
      });
    }
    function missingFileDependenciesWindows(filePath) {
      return __async(this, null, function* () {
        const executable = _path.default.join(__dirname, "..", "..", "..", "bin", "PrintDeps.exe");
        const dirname = _path.default.dirname(filePath);
        const {
          stdout,
          code
        } = yield (0, _spawnAsync.spawnAsync)(executable, [filePath], {
          cwd: dirname,
          env: __spreadProps(__spreadValues({}, process.env), {
            LD_LIBRARY_PATH: process.env.LD_LIBRARY_PATH ? `${process.env.LD_LIBRARY_PATH}:${dirname}` : dirname
          })
        });
        if (code !== 0)
          return [];
        const missingDeps = stdout.split("\n").map((line) => line.trim()).filter((line) => line.endsWith("not found") && line.includes("=>")).map((line) => line.split("=>")[0].trim().toLowerCase());
        return missingDeps;
      });
    }
    function missingFileDependencies(filePath, extraLDPaths) {
      return __async(this, null, function* () {
        const dirname = _path.default.dirname(filePath);
        let LD_LIBRARY_PATH = extraLDPaths.join(":");
        if (process.env.LD_LIBRARY_PATH)
          LD_LIBRARY_PATH = `${process.env.LD_LIBRARY_PATH}:${LD_LIBRARY_PATH}`;
        const {
          stdout,
          code
        } = yield (0, _spawnAsync.spawnAsync)("ldd", [filePath], {
          cwd: dirname,
          env: __spreadProps(__spreadValues({}, process.env), {
            LD_LIBRARY_PATH
          })
        });
        if (code !== 0)
          return [];
        const missingDeps = stdout.split("\n").map((line) => line.trim()).filter((line) => line.endsWith("not found") && line.includes("=>")).map((line) => line.split("=>")[0].trim());
        return missingDeps;
      });
    }
    function missingDLOPENLibraries(libraries) {
      return __async(this, null, function* () {
        if (!libraries.length)
          return [];
        const {
          stdout,
          code,
          error
        } = yield (0, _spawnAsync.spawnAsync)("/sbin/ldconfig", ["-p"], {});
        if (code !== 0 || error)
          return [];
        const isLibraryAvailable = (library) => stdout.toLowerCase().includes(library.toLowerCase());
        return libraries.filter((library) => !isLibraryAvailable(library));
      });
    }
    var MANUAL_LIBRARY_TO_PACKAGE_NAME_UBUNTU = {
      "libx264.so": "gstreamer1.0-libav"
    };
    function quoteProcessArgs(args) {
      return args.map((arg) => {
        if (arg.includes(" "))
          return `"${arg}"`;
        return arg;
      });
    }
    function transformCommandsForRoot(commands) {
      return __async(this, null, function* () {
        const isRoot = process.getuid() === 0;
        if (isRoot)
          return {
            command: "sh",
            args: ["-c", `${commands.join("&& ")}`],
            elevatedPermissions: false
          };
        const sudoExists = yield (0, _spawnAsync.spawnAsync)("which", ["sudo"]);
        if (sudoExists.code === 0)
          return {
            command: "sudo",
            args: ["--", "sh", "-c", `${commands.join("&& ")}`],
            elevatedPermissions: true
          };
        return {
          command: "su",
          args: ["root", "-c", `${commands.join("&& ")}`],
          elevatedPermissions: true
        };
      });
    }
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream = __commonJS({
  "node_modules/end-of-stream/index.js"(exports2, module2) {
    var once = require_once();
    var noop = function() {
    };
    var isRequest = function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    };
    var isChildProcess = function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    };
    var eos = function(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var cancelled = false;
      var onlegacyfinish = function() {
        if (!stream.writable)
          onfinish();
      };
      var onfinish = function() {
        writable = false;
        if (!readable)
          callback.call(stream);
      };
      var onend = function() {
        readable = false;
        if (!writable)
          callback.call(stream);
      };
      var onexit = function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      };
      var onerror = function(err) {
        callback.call(stream, err);
      };
      var onclose = function() {
        process.nextTick(onclosenexttick);
      };
      var onclosenexttick = function() {
        if (cancelled)
          return;
        if (readable && !(rs && (rs.ended && !rs.destroyed)))
          return callback.call(stream, new Error("premature close"));
        if (writable && !(ws && (ws.ended && !ws.destroyed)))
          return callback.call(stream, new Error("premature close"));
      };
      var onrequest = function() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream))
        stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    };
    module2.exports = eos;
  }
});

// node_modules/pump/index.js
var require_pump = __commonJS({
  "node_modules/pump/index.js"(exports2, module2) {
    var once = require_once();
    var eos = require_end_of_stream();
    var fs = require("fs");
    var noop = function() {
    };
    var ancient = /^v?\.0/.test(process.version);
    var isFn = function(fn) {
      return typeof fn === "function";
    };
    var isFS = function(stream) {
      if (!ancient)
        return false;
      if (!fs)
        return false;
      return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);
    };
    var isRequest = function(stream) {
      return stream.setHeader && isFn(stream.abort);
    };
    var destroyer = function(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      eos(stream, { readable: reading, writable: writing }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isFS(stream))
          return stream.close(noop);
        if (isRequest(stream))
          return stream.abort();
        if (isFn(stream.destroy))
          return stream.destroy();
        callback(err || new Error("stream was destroyed"));
      };
    };
    var call = function(fn) {
      fn();
    };
    var pipe = function(from, to) {
      return from.pipe(to);
    };
    var pump = function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2)
        throw new Error("pump requires two streams per minimum");
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    };
    module2.exports = pump;
  }
});

// node_modules/get-stream/buffer-stream.js
var require_buffer_stream = __commonJS({
  "node_modules/get-stream/buffer-stream.js"(exports2, module2) {
    "use strict";
    var { PassThrough: PassThroughStream } = require("stream");
    module2.exports = (options) => {
      options = __spreadValues({}, options);
      const { array } = options;
      let { encoding } = options;
      const isBuffer = encoding === "buffer";
      let objectMode = false;
      if (array) {
        objectMode = !(encoding || isBuffer);
      } else {
        encoding = encoding || "utf8";
      }
      if (isBuffer) {
        encoding = null;
      }
      const stream = new PassThroughStream({ objectMode });
      if (encoding) {
        stream.setEncoding(encoding);
      }
      let length = 0;
      const chunks = [];
      stream.on("data", (chunk) => {
        chunks.push(chunk);
        if (objectMode) {
          length = chunks.length;
        } else {
          length += chunk.length;
        }
      });
      stream.getBufferedValue = () => {
        if (array) {
          return chunks;
        }
        return isBuffer ? Buffer.concat(chunks, length) : chunks.join("");
      };
      stream.getBufferedLength = () => length;
      return stream;
    };
  }
});

// node_modules/get-stream/index.js
var require_get_stream = __commonJS({
  "node_modules/get-stream/index.js"(exports2, module2) {
    "use strict";
    var { constants: BufferConstants } = require("buffer");
    var pump = require_pump();
    var bufferStream = require_buffer_stream();
    var MaxBufferError = class extends Error {
      constructor() {
        super("maxBuffer exceeded");
        this.name = "MaxBufferError";
      }
    };
    function getStream(inputStream, options) {
      return __async(this, null, function* () {
        if (!inputStream) {
          return Promise.reject(new Error("Expected a stream"));
        }
        options = __spreadValues({
          maxBuffer: Infinity
        }, options);
        const { maxBuffer } = options;
        let stream;
        yield new Promise((resolve, reject) => {
          const rejectPromise = (error) => {
            if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {
              error.bufferedData = stream.getBufferedValue();
            }
            reject(error);
          };
          stream = pump(inputStream, bufferStream(options), (error) => {
            if (error) {
              rejectPromise(error);
              return;
            }
            resolve();
          });
          stream.on("data", () => {
            if (stream.getBufferedLength() > maxBuffer) {
              rejectPromise(new MaxBufferError());
            }
          });
        });
        return stream.getBufferedValue();
      });
    }
    module2.exports = getStream;
    module2.exports.default = getStream;
    module2.exports.buffer = (stream, options) => getStream(stream, __spreadProps(__spreadValues({}, options), { encoding: "buffer" }));
    module2.exports.array = (stream, options) => getStream(stream, __spreadProps(__spreadValues({}, options), { array: true }));
    module2.exports.MaxBufferError = MaxBufferError;
  }
});

// node_modules/pend/index.js
var require_pend = __commonJS({
  "node_modules/pend/index.js"(exports2, module2) {
    module2.exports = Pend;
    function Pend() {
      this.pending = 0;
      this.max = Infinity;
      this.listeners = [];
      this.waiting = [];
      this.error = null;
    }
    Pend.prototype.go = function(fn) {
      if (this.pending < this.max) {
        pendGo(this, fn);
      } else {
        this.waiting.push(fn);
      }
    };
    Pend.prototype.wait = function(cb) {
      if (this.pending === 0) {
        cb(this.error);
      } else {
        this.listeners.push(cb);
      }
    };
    Pend.prototype.hold = function() {
      return pendHold(this);
    };
    function pendHold(self2) {
      self2.pending += 1;
      var called = false;
      return onCb;
      function onCb(err) {
        if (called)
          throw new Error("callback called twice");
        called = true;
        self2.error = self2.error || err;
        self2.pending -= 1;
        if (self2.waiting.length > 0 && self2.pending < self2.max) {
          pendGo(self2, self2.waiting.shift());
        } else if (self2.pending === 0) {
          var listeners = self2.listeners;
          self2.listeners = [];
          listeners.forEach(cbListener);
        }
      }
      function cbListener(listener) {
        listener(self2.error);
      }
    }
    function pendGo(self2, fn) {
      fn(pendHold(self2));
    }
  }
});

// node_modules/fd-slicer/index.js
var require_fd_slicer = __commonJS({
  "node_modules/fd-slicer/index.js"(exports2) {
    var fs = require("fs");
    var util = require("util");
    var stream = require("stream");
    var Readable = stream.Readable;
    var Writable = stream.Writable;
    var PassThrough = stream.PassThrough;
    var Pend = require_pend();
    var EventEmitter = require("events").EventEmitter;
    exports2.createFromBuffer = createFromBuffer;
    exports2.createFromFd = createFromFd;
    exports2.BufferSlicer = BufferSlicer;
    exports2.FdSlicer = FdSlicer;
    util.inherits(FdSlicer, EventEmitter);
    function FdSlicer(fd, options) {
      options = options || {};
      EventEmitter.call(this);
      this.fd = fd;
      this.pend = new Pend();
      this.pend.max = 1;
      this.refCount = 0;
      this.autoClose = !!options.autoClose;
    }
    FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs.read(self2.fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
          cb();
          callback(err, bytesRead, buffer2);
        });
      });
    };
    FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs.write(self2.fd, buffer, offset, length, position, function(err, written, buffer2) {
          cb();
          callback(err, written, buffer2);
        });
      });
    };
    FdSlicer.prototype.createReadStream = function(options) {
      return new ReadStream(this, options);
    };
    FdSlicer.prototype.createWriteStream = function(options) {
      return new WriteStream(this, options);
    };
    FdSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    FdSlicer.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      if (self2.autoClose) {
        fs.close(self2.fd, onCloseDone);
      }
      function onCloseDone(err) {
        if (err) {
          self2.emit("error", err);
        } else {
          self2.emit("close");
        }
      }
    };
    util.inherits(ReadStream, Readable);
    function ReadStream(context, options) {
      options = options || {};
      Readable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end;
      this.pos = this.start;
      this.destroyed = false;
    }
    ReadStream.prototype._read = function(n) {
      var self2 = this;
      if (self2.destroyed)
        return;
      var toRead = Math.min(self2._readableState.highWaterMark, n);
      if (self2.endOffset != null) {
        toRead = Math.min(toRead, self2.endOffset - self2.pos);
      }
      if (toRead <= 0) {
        self2.destroyed = true;
        self2.push(null);
        self2.context.unref();
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        var buffer = new Buffer(toRead);
        fs.read(self2.context.fd, buffer, 0, toRead, self2.pos, function(err, bytesRead) {
          if (err) {
            self2.destroy(err);
          } else if (bytesRead === 0) {
            self2.destroyed = true;
            self2.push(null);
            self2.context.unref();
          } else {
            self2.pos += bytesRead;
            self2.push(buffer.slice(0, bytesRead));
          }
          cb();
        });
      });
    };
    ReadStream.prototype.destroy = function(err) {
      if (this.destroyed)
        return;
      err = err || new Error("stream destroyed");
      this.destroyed = true;
      this.emit("error", err);
      this.context.unref();
    };
    util.inherits(WriteStream, Writable);
    function WriteStream(context, options) {
      options = options || {};
      Writable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end == null ? Infinity : +options.end;
      this.bytesWritten = 0;
      this.pos = this.start;
      this.destroyed = false;
      this.on("finish", this.destroy.bind(this));
    }
    WriteStream.prototype._write = function(buffer, encoding, callback) {
      var self2 = this;
      if (self2.destroyed)
        return;
      if (self2.pos + buffer.length > self2.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        self2.destroy();
        callback(err);
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        fs.write(self2.context.fd, buffer, 0, buffer.length, self2.pos, function(err2, bytes) {
          if (err2) {
            self2.destroy();
            cb();
            callback(err2);
          } else {
            self2.bytesWritten += bytes;
            self2.pos += bytes;
            self2.emit("progress");
            cb();
            callback();
          }
        });
      });
    };
    WriteStream.prototype.destroy = function() {
      if (this.destroyed)
        return;
      this.destroyed = true;
      this.context.unref();
    };
    util.inherits(BufferSlicer, EventEmitter);
    function BufferSlicer(buffer, options) {
      EventEmitter.call(this);
      options = options || {};
      this.refCount = 0;
      this.buffer = buffer;
      this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
    }
    BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var end = position + length;
      var delta = end - this.buffer.length;
      var written = delta > 0 ? delta : length;
      this.buffer.copy(buffer, offset, position, end);
      setImmediate(function() {
        callback(null, written);
      });
    };
    BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      buffer.copy(this.buffer, position, offset, offset + length);
      setImmediate(function() {
        callback(null, length, buffer);
      });
    };
    BufferSlicer.prototype.createReadStream = function(options) {
      options = options || {};
      var readStream = new PassThrough(options);
      readStream.destroyed = false;
      readStream.start = options.start || 0;
      readStream.endOffset = options.end;
      readStream.pos = readStream.endOffset || this.buffer.length;
      var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
      var offset = 0;
      while (true) {
        var nextOffset = offset + this.maxChunkSize;
        if (nextOffset >= entireSlice.length) {
          if (offset < entireSlice.length) {
            readStream.write(entireSlice.slice(offset, entireSlice.length));
          }
          break;
        }
        readStream.write(entireSlice.slice(offset, nextOffset));
        offset = nextOffset;
      }
      readStream.end();
      readStream.destroy = function() {
        readStream.destroyed = true;
      };
      return readStream;
    };
    BufferSlicer.prototype.createWriteStream = function(options) {
      var bufferSlicer = this;
      options = options || {};
      var writeStream = new Writable(options);
      writeStream.start = options.start || 0;
      writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;
      writeStream.bytesWritten = 0;
      writeStream.pos = writeStream.start;
      writeStream.destroyed = false;
      writeStream._write = function(buffer, encoding, callback) {
        if (writeStream.destroyed)
          return;
        var end = writeStream.pos + buffer.length;
        if (end > writeStream.endOffset) {
          var err = new Error("maximum file length exceeded");
          err.code = "ETOOBIG";
          writeStream.destroyed = true;
          callback(err);
          return;
        }
        buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
        writeStream.bytesWritten += buffer.length;
        writeStream.pos = end;
        writeStream.emit("progress");
        callback();
      };
      writeStream.destroy = function() {
        writeStream.destroyed = true;
      };
      return writeStream;
    };
    BufferSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    BufferSlicer.prototype.unref = function() {
      this.refCount -= 1;
      if (this.refCount < 0) {
        throw new Error("invalid unref");
      }
    };
    function createFromBuffer(buffer, options) {
      return new BufferSlicer(buffer, options);
    }
    function createFromFd(fd, options) {
      return new FdSlicer(fd, options);
    }
  }
});

// node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "node_modules/buffer-crc32/index.js"(exports2, module2) {
    var Buffer2 = require("buffer").Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer2.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer2.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module2.exports = crc32;
  }
});

// node_modules/yauzl/index.js
var require_yauzl = __commonJS({
  "node_modules/yauzl/index.js"(exports2) {
    var fs = require("fs");
    var zlib = require("zlib");
    var fd_slicer = require_fd_slicer();
    var crc32 = require_buffer_crc32();
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var Transform = require("stream").Transform;
    var PassThrough = require("stream").PassThrough;
    var Writable = require("stream").Writable;
    exports2.open = open;
    exports2.fromFd = fromFd;
    exports2.fromBuffer = fromBuffer;
    exports2.fromRandomAccessReader = fromRandomAccessReader;
    exports2.dosDateTimeToDate = dosDateTimeToDate;
    exports2.validateFileName = validateFileName;
    exports2.ZipFile = ZipFile;
    exports2.Entry = Entry;
    exports2.RandomAccessReader = RandomAccessReader;
    function open(path, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = true;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs.open(path, "r", function(err, fd) {
        if (err)
          return callback(err);
        fromFd(fd, options, function(err2, zipfile) {
          if (err2)
            fs.close(fd, defaultCallback);
          callback(err2, zipfile);
        });
      });
    }
    function fromFd(fd, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = false;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs.fstat(fd, function(err, stats) {
        if (err)
          return callback(err);
        var reader = fd_slicer.createFromFd(fd, { autoClose: true });
        fromRandomAccessReader(reader, stats.size, options, callback);
      });
    }
    function fromBuffer(buffer, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      options.autoClose = false;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
      fromRandomAccessReader(reader, buffer.length, options, callback);
    }
    function fromRandomAccessReader(reader, totalSize, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = true;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      var decodeStrings = !!options.decodeStrings;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      if (typeof totalSize !== "number")
        throw new Error("expected totalSize parameter to be a number");
      if (totalSize > Number.MAX_SAFE_INTEGER) {
        throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
      }
      reader.ref();
      var eocdrWithoutCommentSize = 22;
      var maxCommentSize = 65535;
      var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
      var buffer = newBuffer(bufferSize);
      var bufferReadStart = totalSize - buffer.length;
      readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
        if (err)
          return callback(err);
        for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
          if (buffer.readUInt32LE(i) !== 101010256)
            continue;
          var eocdrBuffer = buffer.slice(i);
          var diskNumber = eocdrBuffer.readUInt16LE(4);
          if (diskNumber !== 0) {
            return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
          }
          var entryCount = eocdrBuffer.readUInt16LE(10);
          var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
          var commentLength = eocdrBuffer.readUInt16LE(20);
          var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
          if (commentLength !== expectedCommentLength) {
            return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
          }
          var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
          if (!(entryCount === 65535 || centralDirectoryOffset === 4294967295)) {
            return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
          }
          var zip64EocdlBuffer = newBuffer(20);
          var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
          readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err2) {
            if (err2)
              return callback(err2);
            if (zip64EocdlBuffer.readUInt32LE(0) !== 117853008) {
              return callback(new Error("invalid zip64 end of central directory locator signature"));
            }
            var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
            var zip64EocdrBuffer = newBuffer(56);
            readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err3) {
              if (err3)
                return callback(err3);
              if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
                return callback(new Error("invalid zip64 end of central directory record signature"));
              }
              entryCount = readUInt64LE(zip64EocdrBuffer, 32);
              centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
              return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
            });
          });
          return;
        }
        callback(new Error("end of central directory record signature not found"));
      });
    }
    util.inherits(ZipFile, EventEmitter);
    function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
      var self2 = this;
      EventEmitter.call(self2);
      self2.reader = reader;
      self2.reader.on("error", function(err) {
        emitError(self2, err);
      });
      self2.reader.once("close", function() {
        self2.emit("close");
      });
      self2.readEntryCursor = centralDirectoryOffset;
      self2.fileSize = fileSize;
      self2.entryCount = entryCount;
      self2.comment = comment;
      self2.entriesRead = 0;
      self2.autoClose = !!autoClose;
      self2.lazyEntries = !!lazyEntries;
      self2.decodeStrings = !!decodeStrings;
      self2.validateEntrySizes = !!validateEntrySizes;
      self2.strictFileNames = !!strictFileNames;
      self2.isOpen = true;
      self2.emittedError = false;
      if (!self2.lazyEntries)
        self2._readEntry();
    }
    ZipFile.prototype.close = function() {
      if (!this.isOpen)
        return;
      this.isOpen = false;
      this.reader.unref();
    };
    function emitErrorAndAutoClose(self2, err) {
      if (self2.autoClose)
        self2.close();
      emitError(self2, err);
    }
    function emitError(self2, err) {
      if (self2.emittedError)
        return;
      self2.emittedError = true;
      self2.emit("error", err);
    }
    ZipFile.prototype.readEntry = function() {
      if (!this.lazyEntries)
        throw new Error("readEntry() called without lazyEntries:true");
      this._readEntry();
    };
    ZipFile.prototype._readEntry = function() {
      var self2 = this;
      if (self2.entryCount === self2.entriesRead) {
        setImmediate(function() {
          if (self2.autoClose)
            self2.close();
          if (self2.emittedError)
            return;
          self2.emit("end");
        });
        return;
      }
      if (self2.emittedError)
        return;
      var buffer = newBuffer(46);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err) {
        if (err)
          return emitErrorAndAutoClose(self2, err);
        if (self2.emittedError)
          return;
        var entry = new Entry();
        var signature = buffer.readUInt32LE(0);
        if (signature !== 33639248)
          return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
        entry.versionMadeBy = buffer.readUInt16LE(4);
        entry.versionNeededToExtract = buffer.readUInt16LE(6);
        entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
        entry.compressionMethod = buffer.readUInt16LE(10);
        entry.lastModFileTime = buffer.readUInt16LE(12);
        entry.lastModFileDate = buffer.readUInt16LE(14);
        entry.crc32 = buffer.readUInt32LE(16);
        entry.compressedSize = buffer.readUInt32LE(20);
        entry.uncompressedSize = buffer.readUInt32LE(24);
        entry.fileNameLength = buffer.readUInt16LE(28);
        entry.extraFieldLength = buffer.readUInt16LE(30);
        entry.fileCommentLength = buffer.readUInt16LE(32);
        entry.internalFileAttributes = buffer.readUInt16LE(36);
        entry.externalFileAttributes = buffer.readUInt32LE(38);
        entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
        if (entry.generalPurposeBitFlag & 64)
          return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
        self2.readEntryCursor += 46;
        buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
        readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err2) {
          if (err2)
            return emitErrorAndAutoClose(self2, err2);
          if (self2.emittedError)
            return;
          var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
          entry.fileName = self2.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
          var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
          var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
          entry.extraFields = [];
          var i = 0;
          while (i < extraFieldBuffer.length - 3) {
            var headerId = extraFieldBuffer.readUInt16LE(i + 0);
            var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
            var dataStart = i + 4;
            var dataEnd = dataStart + dataSize;
            if (dataEnd > extraFieldBuffer.length)
              return emitErrorAndAutoClose(self2, new Error("extra field length exceeds extra field buffer size"));
            var dataBuffer = newBuffer(dataSize);
            extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
            entry.extraFields.push({
              id: headerId,
              data: dataBuffer
            });
            i = dataEnd;
          }
          entry.fileComment = self2.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
          entry.comment = entry.fileComment;
          self2.readEntryCursor += buffer.length;
          self2.entriesRead += 1;
          if (entry.uncompressedSize === 4294967295 || entry.compressedSize === 4294967295 || entry.relativeOffsetOfLocalHeader === 4294967295) {
            var zip64EiefBuffer = null;
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 1) {
                zip64EiefBuffer = extraField.data;
                break;
              }
            }
            if (zip64EiefBuffer == null) {
              return emitErrorAndAutoClose(self2, new Error("expected zip64 extended information extra field"));
            }
            var index = 0;
            if (entry.uncompressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
              }
              entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.compressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
              }
              entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.relativeOffsetOfLocalHeader === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
              }
              entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
          }
          if (self2.decodeStrings) {
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 28789) {
                if (extraField.data.length < 6) {
                  continue;
                }
                if (extraField.data.readUInt8(0) !== 1) {
                  continue;
                }
                var oldNameCrc32 = extraField.data.readUInt32LE(1);
                if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
                  continue;
                }
                entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
                break;
              }
            }
          }
          if (self2.validateEntrySizes && entry.compressionMethod === 0) {
            var expectedCompressedSize = entry.uncompressedSize;
            if (entry.isEncrypted()) {
              expectedCompressedSize += 12;
            }
            if (entry.compressedSize !== expectedCompressedSize) {
              var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
              return emitErrorAndAutoClose(self2, new Error(msg));
            }
          }
          if (self2.decodeStrings) {
            if (!self2.strictFileNames) {
              entry.fileName = entry.fileName.replace(/\\/g, "/");
            }
            var errorMessage = validateFileName(entry.fileName, self2.validateFileNameOptions);
            if (errorMessage != null)
              return emitErrorAndAutoClose(self2, new Error(errorMessage));
          }
          self2.emit("entry", entry);
          if (!self2.lazyEntries)
            self2._readEntry();
        });
      });
    };
    ZipFile.prototype.openReadStream = function(entry, options, callback) {
      var self2 = this;
      var relativeStart = 0;
      var relativeEnd = entry.compressedSize;
      if (callback == null) {
        callback = options;
        options = {};
      } else {
        if (options.decrypt != null) {
          if (!entry.isEncrypted()) {
            throw new Error("options.decrypt can only be specified for encrypted entries");
          }
          if (options.decrypt !== false)
            throw new Error("invalid options.decrypt value: " + options.decrypt);
          if (entry.isCompressed()) {
            if (options.decompress !== false)
              throw new Error("entry is encrypted and compressed, and options.decompress !== false");
          }
        }
        if (options.decompress != null) {
          if (!entry.isCompressed()) {
            throw new Error("options.decompress can only be specified for compressed entries");
          }
          if (!(options.decompress === false || options.decompress === true)) {
            throw new Error("invalid options.decompress value: " + options.decompress);
          }
        }
        if (options.start != null || options.end != null) {
          if (entry.isCompressed() && options.decompress !== false) {
            throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
          }
          if (entry.isEncrypted() && options.decrypt !== false) {
            throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
          }
        }
        if (options.start != null) {
          relativeStart = options.start;
          if (relativeStart < 0)
            throw new Error("options.start < 0");
          if (relativeStart > entry.compressedSize)
            throw new Error("options.start > entry.compressedSize");
        }
        if (options.end != null) {
          relativeEnd = options.end;
          if (relativeEnd < 0)
            throw new Error("options.end < 0");
          if (relativeEnd > entry.compressedSize)
            throw new Error("options.end > entry.compressedSize");
          if (relativeEnd < relativeStart)
            throw new Error("options.end < options.start");
        }
      }
      if (!self2.isOpen)
        return callback(new Error("closed"));
      if (entry.isEncrypted()) {
        if (options.decrypt !== false)
          return callback(new Error("entry is encrypted, and options.decrypt !== false"));
      }
      self2.reader.ref();
      var buffer = newBuffer(30);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
        try {
          if (err)
            return callback(err);
          var signature = buffer.readUInt32LE(0);
          if (signature !== 67324752) {
            return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
          }
          var fileNameLength = buffer.readUInt16LE(26);
          var extraFieldLength = buffer.readUInt16LE(28);
          var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
          var decompress;
          if (entry.compressionMethod === 0) {
            decompress = false;
          } else if (entry.compressionMethod === 8) {
            decompress = options.decompress != null ? options.decompress : true;
          } else {
            return callback(new Error("unsupported compression method: " + entry.compressionMethod));
          }
          var fileDataStart = localFileHeaderEnd;
          var fileDataEnd = fileDataStart + entry.compressedSize;
          if (entry.compressedSize !== 0) {
            if (fileDataEnd > self2.fileSize) {
              return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
            }
          }
          var readStream = self2.reader.createReadStream({
            start: fileDataStart + relativeStart,
            end: fileDataStart + relativeEnd
          });
          var endpointStream = readStream;
          if (decompress) {
            var destroyed = false;
            var inflateFilter = zlib.createInflateRaw();
            readStream.on("error", function(err2) {
              setImmediate(function() {
                if (!destroyed)
                  inflateFilter.emit("error", err2);
              });
            });
            readStream.pipe(inflateFilter);
            if (self2.validateEntrySizes) {
              endpointStream = new AssertByteCountStream(entry.uncompressedSize);
              inflateFilter.on("error", function(err2) {
                setImmediate(function() {
                  if (!destroyed)
                    endpointStream.emit("error", err2);
                });
              });
              inflateFilter.pipe(endpointStream);
            } else {
              endpointStream = inflateFilter;
            }
            endpointStream.destroy = function() {
              destroyed = true;
              if (inflateFilter !== endpointStream)
                inflateFilter.unpipe(endpointStream);
              readStream.unpipe(inflateFilter);
              readStream.destroy();
            };
          }
          callback(null, endpointStream);
        } finally {
          self2.reader.unref();
        }
      });
    };
    function Entry() {
    }
    Entry.prototype.getLastModDate = function() {
      return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
    };
    Entry.prototype.isEncrypted = function() {
      return (this.generalPurposeBitFlag & 1) !== 0;
    };
    Entry.prototype.isCompressed = function() {
      return this.compressionMethod === 8;
    };
    function dosDateTimeToDate(date, time) {
      var day = date & 31;
      var month = (date >> 5 & 15) - 1;
      var year = (date >> 9 & 127) + 1980;
      var millisecond = 0;
      var second = (time & 31) * 2;
      var minute = time >> 5 & 63;
      var hour = time >> 11 & 31;
      return new Date(year, month, day, hour, minute, second, millisecond);
    }
    function validateFileName(fileName) {
      if (fileName.indexOf("\\") !== -1) {
        return "invalid characters in fileName: " + fileName;
      }
      if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
        return "absolute path: " + fileName;
      }
      if (fileName.split("/").indexOf("..") !== -1) {
        return "invalid relative path: " + fileName;
      }
      return null;
    }
    function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
      if (length === 0) {
        return setImmediate(function() {
          callback(null, newBuffer(0));
        });
      }
      reader.read(buffer, offset, length, position, function(err, bytesRead) {
        if (err)
          return callback(err);
        if (bytesRead < length) {
          return callback(new Error("unexpected EOF"));
        }
        callback();
      });
    }
    util.inherits(AssertByteCountStream, Transform);
    function AssertByteCountStream(byteCount) {
      Transform.call(this);
      this.actualByteCount = 0;
      this.expectedByteCount = byteCount;
    }
    AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
      this.actualByteCount += chunk.length;
      if (this.actualByteCount > this.expectedByteCount) {
        var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb(null, chunk);
    };
    AssertByteCountStream.prototype._flush = function(cb) {
      if (this.actualByteCount < this.expectedByteCount) {
        var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb();
    };
    util.inherits(RandomAccessReader, EventEmitter);
    function RandomAccessReader() {
      EventEmitter.call(this);
      this.refCount = 0;
    }
    RandomAccessReader.prototype.ref = function() {
      this.refCount += 1;
    };
    RandomAccessReader.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      self2.close(onCloseDone);
      function onCloseDone(err) {
        if (err)
          return self2.emit("error", err);
        self2.emit("close");
      }
    };
    RandomAccessReader.prototype.createReadStream = function(options) {
      var start = options.start;
      var end = options.end;
      if (start === end) {
        var emptyStream = new PassThrough();
        setImmediate(function() {
          emptyStream.end();
        });
        return emptyStream;
      }
      var stream = this._readStreamForRange(start, end);
      var destroyed = false;
      var refUnrefFilter = new RefUnrefFilter(this);
      stream.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            refUnrefFilter.emit("error", err);
        });
      });
      refUnrefFilter.destroy = function() {
        stream.unpipe(refUnrefFilter);
        refUnrefFilter.unref();
        stream.destroy();
      };
      var byteCounter = new AssertByteCountStream(end - start);
      refUnrefFilter.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            byteCounter.emit("error", err);
        });
      });
      byteCounter.destroy = function() {
        destroyed = true;
        refUnrefFilter.unpipe(byteCounter);
        refUnrefFilter.destroy();
      };
      return stream.pipe(refUnrefFilter).pipe(byteCounter);
    };
    RandomAccessReader.prototype._readStreamForRange = function(start, end) {
      throw new Error("not implemented");
    };
    RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
      var readStream = this.createReadStream({ start: position, end: position + length });
      var writeStream = new Writable();
      var written = 0;
      writeStream._write = function(chunk, encoding, cb) {
        chunk.copy(buffer, offset + written, 0, chunk.length);
        written += chunk.length;
        cb();
      };
      writeStream.on("finish", callback);
      readStream.on("error", function(error) {
        callback(error);
      });
      readStream.pipe(writeStream);
    };
    RandomAccessReader.prototype.close = function(callback) {
      setImmediate(callback);
    };
    util.inherits(RefUnrefFilter, PassThrough);
    function RefUnrefFilter(context) {
      PassThrough.call(this);
      this.context = context;
      this.context.ref();
      this.unreffedYet = false;
    }
    RefUnrefFilter.prototype._flush = function(cb) {
      this.unref();
      cb();
    };
    RefUnrefFilter.prototype.unref = function(cb) {
      if (this.unreffedYet)
        return;
      this.unreffedYet = true;
      this.context.unref();
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    function decodeBuffer(buffer, start, end, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8", start, end);
      } else {
        var result = "";
        for (var i = start; i < end; i++) {
          result += cp437[buffer[i]];
        }
        return result;
      }
    }
    function readUInt64LE(buffer, offset) {
      var lower32 = buffer.readUInt32LE(offset);
      var upper32 = buffer.readUInt32LE(offset + 4);
      return upper32 * 4294967296 + lower32;
    }
    var newBuffer;
    if (typeof Buffer.allocUnsafe === "function") {
      newBuffer = function(len) {
        return Buffer.allocUnsafe(len);
      };
    } else {
      newBuffer = function(len) {
        return new Buffer(len);
      };
    }
    function defaultCallback(err) {
      if (err)
        throw err;
    }
  }
});

// node_modules/extract-zip/index.js
var require_extract_zip = __commonJS({
  "node_modules/extract-zip/index.js"(exports2, module2) {
    var debug = require_src()("extract-zip");
    var { createWriteStream, promises: fs } = require("fs");
    var getStream = require_get_stream();
    var path = require("path");
    var { promisify } = require("util");
    var stream = require("stream");
    var yauzl = require_yauzl();
    var openZip = promisify(yauzl.open);
    var pipeline = promisify(stream.pipeline);
    var Extractor = class {
      constructor(zipPath, opts) {
        this.zipPath = zipPath;
        this.opts = opts;
      }
      extract() {
        return __async(this, null, function* () {
          debug("opening", this.zipPath, "with opts", this.opts);
          this.zipfile = yield openZip(this.zipPath, { lazyEntries: true });
          this.canceled = false;
          return new Promise((resolve, reject) => {
            this.zipfile.on("error", (err) => {
              this.canceled = true;
              reject(err);
            });
            this.zipfile.readEntry();
            this.zipfile.on("close", () => {
              if (!this.canceled) {
                debug("zip extraction complete");
                resolve();
              }
            });
            this.zipfile.on("entry", (entry) => __async(this, null, function* () {
              if (this.canceled) {
                debug("skipping entry", entry.fileName, { cancelled: this.canceled });
                return;
              }
              debug("zipfile entry", entry.fileName);
              if (entry.fileName.startsWith("__MACOSX/")) {
                this.zipfile.readEntry();
                return;
              }
              const destDir = path.dirname(path.join(this.opts.dir, entry.fileName));
              try {
                yield fs.mkdir(destDir, { recursive: true });
                const canonicalDestDir = yield fs.realpath(destDir);
                const relativeDestDir = path.relative(this.opts.dir, canonicalDestDir);
                if (relativeDestDir.split(path.sep).includes("..")) {
                  throw new Error(`Out of bound path "${canonicalDestDir}" found while processing file ${entry.fileName}`);
                }
                yield this.extractEntry(entry);
                debug("finished processing", entry.fileName);
                this.zipfile.readEntry();
              } catch (err) {
                this.canceled = true;
                this.zipfile.close();
                reject(err);
              }
            }));
          });
        });
      }
      extractEntry(entry) {
        return __async(this, null, function* () {
          if (this.canceled) {
            debug("skipping entry extraction", entry.fileName, { cancelled: this.canceled });
            return;
          }
          if (this.opts.onEntry) {
            this.opts.onEntry(entry, this.zipfile);
          }
          const dest = path.join(this.opts.dir, entry.fileName);
          const mode = entry.externalFileAttributes >> 16 & 65535;
          const IFMT = 61440;
          const IFDIR = 16384;
          const IFLNK = 40960;
          const symlink = (mode & IFMT) === IFLNK;
          let isDir = (mode & IFMT) === IFDIR;
          if (!isDir && entry.fileName.endsWith("/")) {
            isDir = true;
          }
          const madeBy = entry.versionMadeBy >> 8;
          if (!isDir)
            isDir = madeBy === 0 && entry.externalFileAttributes === 16;
          debug("extracting entry", { filename: entry.fileName, isDir, isSymlink: symlink });
          const procMode = this.getExtractedMode(mode, isDir) & 511;
          const destDir = isDir ? dest : path.dirname(dest);
          const mkdirOptions = { recursive: true };
          if (isDir) {
            mkdirOptions.mode = procMode;
          }
          debug("mkdir", __spreadValues({ dir: destDir }, mkdirOptions));
          yield fs.mkdir(destDir, mkdirOptions);
          if (isDir)
            return;
          debug("opening read stream", dest);
          const readStream = yield promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry);
          if (symlink) {
            const link = yield getStream(readStream);
            debug("creating symlink", link, dest);
            yield fs.symlink(link, dest);
          } else {
            yield pipeline(readStream, createWriteStream(dest, { mode: procMode }));
          }
        });
      }
      getExtractedMode(entryMode, isDir) {
        let mode = entryMode;
        if (mode === 0) {
          if (isDir) {
            if (this.opts.defaultDirMode) {
              mode = parseInt(this.opts.defaultDirMode, 10);
            }
            if (!mode) {
              mode = 493;
            }
          } else {
            if (this.opts.defaultFileMode) {
              mode = parseInt(this.opts.defaultFileMode, 10);
            }
            if (!mode) {
              mode = 420;
            }
          }
        }
        return mode;
      }
    };
    module2.exports = function(zipPath, opts) {
      return __async(this, null, function* () {
        debug("creating target directory", opts.dir);
        if (!path.isAbsolute(opts.dir)) {
          throw new Error("Target directory is expected to be absolute");
        }
        yield fs.mkdir(opts.dir, { recursive: true });
        opts.dir = yield fs.realpath(opts.dir);
        return new Extractor(zipPath, opts).extract();
      });
    };
  }
});

// node_modules/playwright-core/node_modules/debug/src/common.js
var require_common3 = __commonJS({
  "node_modules/playwright-core/node_modules/debug/src/common.js"(exports2, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/playwright-core/node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/playwright-core/node_modules/debug/src/browser.js"(exports2, module2) {
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common3()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/playwright-core/node_modules/debug/src/node.js
var require_node2 = __commonJS({
  "node_modules/playwright-core/node_modules/debug/src/node.js"(exports2, module2) {
    var tty = require("tty");
    var util = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require("supports-color");
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common3()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/playwright-core/node_modules/debug/src/index.js
var require_src3 = __commonJS({
  "node_modules/playwright-core/node_modules/debug/src/index.js"(exports2, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser2();
    } else {
      module2.exports = require_node2();
    }
  }
});

// node_modules/playwright-core/lib/common/debugLogger.js
var require_debugLogger = __commonJS({
  "node_modules/playwright-core/lib/common/debugLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.debugLogger = exports2.RecentLogsCollector = void 0;
    var _debug = _interopRequireDefault(require_src3());
    var _fs = _interopRequireDefault(require("fs"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var debugLoggerColorMap = {
      "api": 45,
      "protocol": 34,
      "install": 34,
      "download": 34,
      "browser": 0,
      "proxy": 92,
      "error": 160,
      "channel:command": 33,
      "channel:response": 202,
      "channel:event": 207
    };
    var DebugLogger = class {
      constructor() {
        this._debuggers = /* @__PURE__ */ new Map();
        if (process.env.DEBUG_FILE) {
          const ansiRegex = new RegExp(["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", "(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|"), "g");
          const stream = _fs.default.createWriteStream(process.env.DEBUG_FILE);
          _debug.default.log = (data) => {
            stream.write(data.replace(ansiRegex, ""));
            stream.write("\n");
          };
        }
      }
      log(name, message) {
        let cachedDebugger = this._debuggers.get(name);
        if (!cachedDebugger) {
          cachedDebugger = (0, _debug.default)(`pw:${name}`);
          this._debuggers.set(name, cachedDebugger);
          cachedDebugger.color = debugLoggerColorMap[name];
        }
        cachedDebugger(message);
      }
      isEnabled(name) {
        return _debug.default.enabled(`pw:${name}`);
      }
    };
    var debugLogger = new DebugLogger();
    exports2.debugLogger = debugLogger;
    var kLogCount = 150;
    var RecentLogsCollector = class {
      constructor() {
        this._logs = [];
      }
      log(message) {
        this._logs.push(message);
        if (this._logs.length === kLogCount * 2)
          this._logs.splice(0, kLogCount);
      }
      recentLogs() {
        if (this._logs.length > kLogCount)
          return this._logs.slice(-kLogCount);
        return this._logs;
      }
    };
    exports2.RecentLogsCollector = RecentLogsCollector;
  }
});

// node_modules/progress/lib/node-progress.js
var require_node_progress = __commonJS({
  "node_modules/progress/lib/node-progress.js"(exports2, module2) {
    exports2 = module2.exports = ProgressBar;
    function ProgressBar(fmt, options) {
      this.stream = options.stream || process.stderr;
      if (typeof options == "number") {
        var total = options;
        options = {};
        options.total = total;
      } else {
        options = options || {};
        if (typeof fmt != "string")
          throw new Error("format required");
        if (typeof options.total != "number")
          throw new Error("total required");
      }
      this.fmt = fmt;
      this.curr = options.curr || 0;
      this.total = options.total;
      this.width = options.width || this.total;
      this.clear = options.clear;
      this.chars = {
        complete: options.complete || "=",
        incomplete: options.incomplete || "-",
        head: options.head || (options.complete || "=")
      };
      this.renderThrottle = options.renderThrottle !== 0 ? options.renderThrottle || 16 : 0;
      this.lastRender = -Infinity;
      this.callback = options.callback || function() {
      };
      this.tokens = {};
      this.lastDraw = "";
    }
    ProgressBar.prototype.tick = function(len, tokens) {
      if (len !== 0)
        len = len || 1;
      if (typeof len == "object")
        tokens = len, len = 1;
      if (tokens)
        this.tokens = tokens;
      if (this.curr == 0)
        this.start = new Date();
      this.curr += len;
      this.render();
      if (this.curr >= this.total) {
        this.render(void 0, true);
        this.complete = true;
        this.terminate();
        this.callback(this);
        return;
      }
    };
    ProgressBar.prototype.render = function(tokens, force) {
      force = force !== void 0 ? force : false;
      if (tokens)
        this.tokens = tokens;
      if (!this.stream.isTTY)
        return;
      var now = Date.now();
      var delta = now - this.lastRender;
      if (!force && delta < this.renderThrottle) {
        return;
      } else {
        this.lastRender = now;
      }
      var ratio = this.curr / this.total;
      ratio = Math.min(Math.max(ratio, 0), 1);
      var percent = Math.floor(ratio * 100);
      var incomplete, complete, completeLength;
      var elapsed = new Date() - this.start;
      var eta = percent == 100 ? 0 : elapsed * (this.total / this.curr - 1);
      var rate = this.curr / (elapsed / 1e3);
      var str = this.fmt.replace(":current", this.curr).replace(":total", this.total).replace(":elapsed", isNaN(elapsed) ? "0.0" : (elapsed / 1e3).toFixed(1)).replace(":eta", isNaN(eta) || !isFinite(eta) ? "0.0" : (eta / 1e3).toFixed(1)).replace(":percent", percent.toFixed(0) + "%").replace(":rate", Math.round(rate));
      var availableSpace = Math.max(0, this.stream.columns - str.replace(":bar", "").length);
      if (availableSpace && process.platform === "win32") {
        availableSpace = availableSpace - 1;
      }
      var width = Math.min(this.width, availableSpace);
      completeLength = Math.round(width * ratio);
      complete = Array(Math.max(0, completeLength + 1)).join(this.chars.complete);
      incomplete = Array(Math.max(0, width - completeLength + 1)).join(this.chars.incomplete);
      if (completeLength > 0)
        complete = complete.slice(0, -1) + this.chars.head;
      str = str.replace(":bar", complete + incomplete);
      if (this.tokens)
        for (var key in this.tokens)
          str = str.replace(":" + key, this.tokens[key]);
      if (this.lastDraw !== str) {
        this.stream.cursorTo(0);
        this.stream.write(str);
        this.stream.clearLine(1);
        this.lastDraw = str;
      }
    };
    ProgressBar.prototype.update = function(ratio, tokens) {
      var goal = Math.floor(ratio * this.total);
      var delta = goal - this.curr;
      this.tick(delta, tokens);
    };
    ProgressBar.prototype.interrupt = function(message) {
      this.stream.clearLine();
      this.stream.cursorTo(0);
      this.stream.write(message);
      this.stream.write("\n");
      this.stream.write(this.lastDraw);
    };
    ProgressBar.prototype.terminate = function() {
      if (this.clear) {
        if (this.stream.clearLine) {
          this.stream.clearLine();
          this.stream.cursorTo(0);
        }
      } else {
        this.stream.write("\n");
      }
    };
  }
});

// node_modules/progress/index.js
var require_progress = __commonJS({
  "node_modules/progress/index.js"(exports2, module2) {
    module2.exports = require_node_progress();
  }
});

// node_modules/playwright-core/lib/server/registry/download.js
var require_download = __commonJS({
  "node_modules/playwright-core/lib/server/registry/download.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.download = download;
    var _fs = _interopRequireDefault(require("fs"));
    var _progress = _interopRequireDefault(require_progress());
    var _netUtils = require_netUtils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function downloadFile(url, destinationPath, options = {}) {
      const {
        progressCallback,
        log = () => {
        }
      } = options;
      log(`running download:`);
      log(`-- from url: ${url}`);
      log(`-- to location: ${destinationPath}`);
      let fulfill = ({
        error
      }) => {
      };
      let downloadedBytes = 0;
      let totalBytes = 0;
      const promise = new Promise((x) => {
        fulfill = x;
      });
      (0, _netUtils.httpRequest)({
        url,
        headers: options.userAgent ? {
          "User-Agent": options.userAgent
        } : void 0
      }, (response) => {
        log(`-- response status code: ${response.statusCode}`);
        if (response.statusCode !== 200) {
          const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`);
          response.resume();
          fulfill({
            error
          });
          return;
        }
        const file = _fs.default.createWriteStream(destinationPath);
        file.on("finish", () => fulfill({
          error: null
        }));
        file.on("error", (error) => fulfill({
          error
        }));
        response.pipe(file);
        totalBytes = parseInt(response.headers["content-length"] || "0", 10);
        log(`-- total bytes: ${totalBytes}`);
        if (progressCallback)
          response.on("data", onData);
      }, (error) => fulfill({
        error
      }));
      return promise;
      function onData(chunk) {
        downloadedBytes += chunk.length;
        progressCallback(downloadedBytes, totalBytes);
      }
    }
    function download(_0, _1) {
      return __async(this, arguments, function* (url, destination, options = {}) {
        const {
          progressBarName = "file",
          retryCount = 3,
          log = () => {
          },
          userAgent
        } = options;
        for (let attempt = 1; attempt <= retryCount; ++attempt) {
          log(`downloading ${progressBarName} - attempt #${attempt}`);
          const {
            error
          } = yield downloadFile(url, destination, {
            progressCallback: getDownloadProgress(progressBarName),
            log,
            userAgent
          });
          if (!error) {
            log(`SUCCESS downloading ${progressBarName}`);
            break;
          }
          const errorMessage = (error === null || error === void 0 ? void 0 : error.message) || "";
          log(`attempt #${attempt} - ERROR: ${errorMessage}`);
          if (attempt < retryCount && (errorMessage.includes("ECONNRESET") || errorMessage.includes("ETIMEDOUT"))) {
            const millis = Math.random() * 200 + 250 * Math.pow(1.5, attempt);
            log(`sleeping ${millis}ms before retry...`);
            yield new Promise((c) => setTimeout(c, millis));
          } else {
            throw error;
          }
        }
      });
    }
    function getDownloadProgress(progressBarName) {
      let progressBar;
      let lastDownloadedBytes = 0;
      return (downloadedBytes, totalBytes) => {
        if (!process.stderr.isTTY)
          return;
        if (!progressBar) {
          progressBar = new _progress.default(`Downloading ${progressBarName} - ${toMegabytes(totalBytes)} [:bar] :percent :etas `, {
            complete: "=",
            incomplete: " ",
            width: 20,
            total: totalBytes
          });
        }
        const delta = downloadedBytes - lastDownloadedBytes;
        lastDownloadedBytes = downloadedBytes;
        progressBar.tick(delta);
      };
    }
    function toMegabytes(bytes) {
      const mb = bytes / 1024 / 1024;
      return `${Math.round(mb * 10) / 10} Mb`;
    }
  }
});

// node_modules/playwright-core/lib/server/registry/browserFetcher.js
var require_browserFetcher = __commonJS({
  "node_modules/playwright-core/lib/server/registry/browserFetcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.downloadBrowserWithProgressBar = downloadBrowserWithProgressBar;
    exports2.logPolitely = logPolitely;
    var _extractZip = _interopRequireDefault(require_extract_zip());
    var _fs = _interopRequireDefault(require("fs"));
    var _os = _interopRequireDefault(require("os"));
    var _path = _interopRequireDefault(require("path"));
    var _userAgent = require_userAgent();
    var _fileUtils = require_fileUtils();
    var _debugLogger = require_debugLogger();
    var _download = require_download();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function downloadBrowserWithProgressBar(title, browserDirectory, executablePath, downloadURL, downloadFileName) {
      return __async(this, null, function* () {
        const progressBarName = `Playwright build of ${title}`;
        if (yield (0, _fileUtils.existsAsync)(browserDirectory)) {
          _debugLogger.debugLogger.log("install", `browser ${title} is already downloaded.`);
          return false;
        }
        const url = downloadURL;
        const zipPath = _path.default.join(_os.default.tmpdir(), downloadFileName);
        try {
          yield (0, _download.download)(url, zipPath, {
            progressBarName,
            log: _debugLogger.debugLogger.log.bind(_debugLogger.debugLogger, "install"),
            userAgent: (0, _userAgent.getUserAgent)()
          });
          _debugLogger.debugLogger.log("install", `extracting archive`);
          _debugLogger.debugLogger.log("install", `-- zip: ${zipPath}`);
          _debugLogger.debugLogger.log("install", `-- location: ${browserDirectory}`);
          yield (0, _extractZip.default)(zipPath, {
            dir: browserDirectory
          });
          _debugLogger.debugLogger.log("install", `fixing permissions at ${executablePath}`);
          yield _fs.default.promises.chmod(executablePath, 493);
        } catch (e) {
          _debugLogger.debugLogger.log("install", `FAILED installation ${progressBarName} with error: ${e}`);
          process.exitCode = 1;
          throw e;
        } finally {
          if (yield (0, _fileUtils.existsAsync)(zipPath))
            yield _fs.default.promises.unlink(zipPath);
        }
        logPolitely(`${progressBarName} downloaded to ${browserDirectory}`);
        return true;
      });
    }
    function logPolitely(toBeLogged) {
      const logLevel = process.env.npm_config_loglevel;
      const logLevelDisplay = ["silent", "error", "warn"].indexOf(logLevel || "") > -1;
      if (!logLevelDisplay)
        console.log(toBeLogged);
    }
  }
});

// node_modules/playwright-core/browsers.json
var require_browsers = __commonJS({
  "node_modules/playwright-core/browsers.json"(exports2, module2) {
    module2.exports = {
      comment: "Do not edit this file, use utils/roll_browser.js",
      browsers: [
        {
          name: "chromium",
          revision: "1000",
          installByDefault: true
        },
        {
          name: "chromium-with-symbols",
          revision: "1000",
          installByDefault: false
        },
        {
          name: "firefox",
          revision: "1322",
          installByDefault: true
        },
        {
          name: "firefox-beta",
          revision: "1321",
          installByDefault: false
        },
        {
          name: "webkit",
          revision: "1630",
          installByDefault: true,
          revisionOverrides: {
            "mac10.14": "1446",
            "mac10.15": "1616"
          }
        },
        {
          name: "ffmpeg",
          revision: "1007",
          installByDefault: true
        }
      ]
    };
  }
});

// node_modules/playwright-core/lib/server/registry/index.js
var require_registry = __commonJS({
  "node_modules/playwright-core/lib/server/registry/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Registry = void 0;
    exports2.buildPlaywrightCLICommand = buildPlaywrightCLICommand;
    exports2.findChromiumChannel = findChromiumChannel;
    exports2.installBrowsersForNpmInstall = installBrowsersForNpmInstall;
    exports2.installDefaultBrowsersForNpmInstall = installDefaultBrowsersForNpmInstall;
    exports2.registryDirectory = exports2.registry = void 0;
    Object.defineProperty(exports2, "writeDockerVersion", {
      enumerable: true,
      get: function() {
        return _dependencies.writeDockerVersion;
      }
    });
    var os = _interopRequireWildcard(require("os"));
    var _path = _interopRequireDefault(require("path"));
    var util = _interopRequireWildcard(require("util"));
    var fs = _interopRequireWildcard(require("fs"));
    var _properLockfile = _interopRequireDefault(require_proper_lockfile());
    var _ubuntuVersion = require_ubuntuVersion();
    var _netUtils = require_netUtils();
    var _userAgent = require_userAgent();
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _hostPlatform = require_hostPlatform();
    var _spawnAsync = require_spawnAsync();
    var _dependencies = require_dependencies();
    var _browserFetcher = require_browserFetcher();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var PACKAGE_PATH = _path.default.join(__dirname, "..", "..", "..");
    var BIN_PATH = _path.default.join(__dirname, "..", "..", "..", "bin");
    var EXECUTABLE_PATHS = {
      "chromium": {
        "linux": ["chrome-linux", "chrome"],
        "mac": ["chrome-mac", "Chromium.app", "Contents", "MacOS", "Chromium"],
        "win": ["chrome-win", "chrome.exe"]
      },
      "firefox": {
        "linux": ["firefox", "firefox"],
        "mac": ["firefox", "Nightly.app", "Contents", "MacOS", "firefox"],
        "win": ["firefox", "firefox.exe"]
      },
      "webkit": {
        "linux": ["pw_run.sh"],
        "mac": ["pw_run.sh"],
        "win": ["Playwright.exe"]
      },
      "ffmpeg": {
        "linux": ["ffmpeg-linux"],
        "mac": ["ffmpeg-mac"],
        "win": ["ffmpeg-win64.exe"]
      }
    };
    var DOWNLOAD_PATHS = {
      "chromium": {
        "<unknown>": void 0,
        "generic-linux": "builds/chromium/%s/chromium-linux.zip",
        "generic-linux-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
        "ubuntu18.04": "builds/chromium/%s/chromium-linux.zip",
        "ubuntu20.04": "builds/chromium/%s/chromium-linux.zip",
        "ubuntu18.04-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
        "ubuntu20.04-arm64": "builds/chromium/%s/chromium-linux-arm64.zip",
        "mac10.13": "builds/chromium/%s/chromium-mac.zip",
        "mac10.14": "builds/chromium/%s/chromium-mac.zip",
        "mac10.15": "builds/chromium/%s/chromium-mac.zip",
        "mac11": "builds/chromium/%s/chromium-mac.zip",
        "mac11-arm64": "builds/chromium/%s/chromium-mac-arm64.zip",
        "mac12": "builds/chromium/%s/chromium-mac.zip",
        "mac12-arm64": "builds/chromium/%s/chromium-mac-arm64.zip",
        "win64": "builds/chromium/%s/chromium-win64.zip"
      },
      "chromium-with-symbols": {
        "<unknown>": void 0,
        "generic-linux": "builds/chromium/%s/chromium-with-symbols-linux.zip",
        "generic-linux-arm64": "builds/chromium/%s/chromium-with-symbols-linux-arm64.zip",
        "ubuntu18.04": "builds/chromium/%s/chromium-with-symbols-linux.zip",
        "ubuntu20.04": "builds/chromium/%s/chromium-with-symbols-linux.zip",
        "ubuntu18.04-arm64": "builds/chromium/%s/chromium-with-symbols-linux-arm64.zip",
        "ubuntu20.04-arm64": "builds/chromium/%s/chromium-with-symbols-linux-arm64.zip",
        "mac10.13": "builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac10.14": "builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac10.15": "builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac11": "builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac11-arm64": "builds/chromium/%s/chromium-with-symbols-mac-arm64.zip",
        "mac12": "builds/chromium/%s/chromium-with-symbols-mac.zip",
        "mac12-arm64": "builds/chromium/%s/chromium-with-symbols-mac-arm64.zip",
        "win64": "builds/chromium/%s/chromium-with-symbols-win64.zip"
      },
      "firefox": {
        "<unknown>": void 0,
        "generic-linux": "builds/firefox/%s/firefox-ubuntu-20.04.zip",
        "generic-linux-arm64": "builds/firefox/%s/firefox-ubuntu-20.04-arm64.zip",
        "ubuntu18.04": "builds/firefox/%s/firefox-ubuntu-18.04.zip",
        "ubuntu20.04": "builds/firefox/%s/firefox-ubuntu-20.04.zip",
        "ubuntu18.04-arm64": void 0,
        "ubuntu20.04-arm64": "builds/firefox/%s/firefox-ubuntu-20.04-arm64.zip",
        "mac10.13": "builds/firefox/%s/firefox-mac-11.zip",
        "mac10.14": "builds/firefox/%s/firefox-mac-11.zip",
        "mac10.15": "builds/firefox/%s/firefox-mac-11.zip",
        "mac11": "builds/firefox/%s/firefox-mac-11.zip",
        "mac11-arm64": "builds/firefox/%s/firefox-mac-11-arm64.zip",
        "mac12": "builds/firefox/%s/firefox-mac-11.zip",
        "mac12-arm64": "builds/firefox/%s/firefox-mac-11-arm64.zip",
        "win64": "builds/firefox/%s/firefox-win64.zip"
      },
      "firefox-beta": {
        "<unknown>": void 0,
        "generic-linux": "builds/firefox-beta/%s/firefox-beta-ubuntu-20.04.zip",
        "generic-linux-arm64": void 0,
        "ubuntu18.04": "builds/firefox-beta/%s/firefox-beta-ubuntu-18.04.zip",
        "ubuntu20.04": "builds/firefox-beta/%s/firefox-beta-ubuntu-20.04.zip",
        "ubuntu18.04-arm64": void 0,
        "ubuntu20.04-arm64": void 0,
        "mac10.13": "builds/firefox-beta/%s/firefox-beta-mac-11.zip",
        "mac10.14": "builds/firefox-beta/%s/firefox-beta-mac-11.zip",
        "mac10.15": "builds/firefox-beta/%s/firefox-beta-mac-11.zip",
        "mac11": "builds/firefox-beta/%s/firefox-beta-mac-11.zip",
        "mac11-arm64": "builds/firefox-beta/%s/firefox-beta-mac-11-arm64.zip",
        "mac12": "builds/firefox-beta/%s/firefox-beta-mac-11.zip",
        "mac12-arm64": "builds/firefox-beta/%s/firefox-beta-mac-11-arm64.zip",
        "win64": "builds/firefox-beta/%s/firefox-beta-win64.zip"
      },
      "webkit": {
        "<unknown>": void 0,
        "generic-linux": "builds/webkit/%s/webkit-ubuntu-20.04.zip",
        "generic-linux-arm64": "builds/webkit/%s/webkit-ubuntu-20.04-arm64.zip",
        "ubuntu18.04": "builds/webkit/%s/webkit-ubuntu-18.04.zip",
        "ubuntu20.04": "builds/webkit/%s/webkit-ubuntu-20.04.zip",
        "ubuntu18.04-arm64": void 0,
        "ubuntu20.04-arm64": "builds/webkit/%s/webkit-ubuntu-20.04-arm64.zip",
        "mac10.13": void 0,
        "mac10.14": "builds/deprecated-webkit-mac-10.14/%s/deprecated-webkit-mac-10.14.zip",
        "mac10.15": "builds/webkit/%s/webkit-mac-10.15.zip",
        "mac11": "builds/webkit/%s/webkit-mac-11.zip",
        "mac11-arm64": "builds/webkit/%s/webkit-mac-11-arm64.zip",
        "mac12": "builds/webkit/%s/webkit-mac-12.zip",
        "mac12-arm64": "builds/webkit/%s/webkit-mac-12-arm64.zip",
        "win64": "builds/webkit/%s/webkit-win64.zip"
      },
      "ffmpeg": {
        "<unknown>": void 0,
        "generic-linux": "builds/ffmpeg/%s/ffmpeg-linux.zip",
        "generic-linux-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
        "ubuntu18.04": "builds/ffmpeg/%s/ffmpeg-linux.zip",
        "ubuntu20.04": "builds/ffmpeg/%s/ffmpeg-linux.zip",
        "ubuntu18.04-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
        "ubuntu20.04-arm64": "builds/ffmpeg/%s/ffmpeg-linux-arm64.zip",
        "mac10.13": "builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac10.14": "builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac10.15": "builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac11": "builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac11-arm64": "builds/ffmpeg/%s/ffmpeg-mac-arm64.zip",
        "mac12": "builds/ffmpeg/%s/ffmpeg-mac.zip",
        "mac12-arm64": "builds/ffmpeg/%s/ffmpeg-mac-arm64.zip",
        "win64": "builds/ffmpeg/%s/ffmpeg-win64.zip"
      }
    };
    var registryDirectory = (() => {
      let result;
      const envDefined = (0, _utils.getFromENV)("PLAYWRIGHT_BROWSERS_PATH");
      if (envDefined === "0") {
        result = _path.default.join(__dirname, "..", "..", "..", ".local-browsers");
      } else if (envDefined) {
        result = envDefined;
      } else {
        let cacheDirectory;
        if (process.platform === "linux")
          cacheDirectory = process.env.XDG_CACHE_HOME || _path.default.join(os.homedir(), ".cache");
        else if (process.platform === "darwin")
          cacheDirectory = _path.default.join(os.homedir(), "Library", "Caches");
        else if (process.platform === "win32")
          cacheDirectory = process.env.LOCALAPPDATA || _path.default.join(os.homedir(), "AppData", "Local");
        else
          throw new Error("Unsupported platform: " + process.platform);
        result = _path.default.join(cacheDirectory, "ms-playwright");
      }
      if (!_path.default.isAbsolute(result)) {
        result = _path.default.resolve((0, _utils.getFromENV)("INIT_CWD") || process.cwd(), result);
      }
      return result;
    })();
    exports2.registryDirectory = registryDirectory;
    function isBrowserDirectory(browserDirectory) {
      const baseName = _path.default.basename(browserDirectory);
      for (const browserName of allDownloadable) {
        if (baseName.startsWith(browserName + "-"))
          return true;
      }
      return false;
    }
    function readDescriptors(browsersJSON) {
      return browsersJSON["browsers"].map((obj) => {
        const name = obj.name;
        const revisionOverride = (obj.revisionOverrides || {})[_hostPlatform.hostPlatform];
        const revision = revisionOverride || obj.revision;
        const browserDirectoryPrefix = revisionOverride ? `${name}_${_hostPlatform.hostPlatform}_special` : `${name}`;
        const descriptor = {
          name,
          revision,
          installByDefault: !!obj.installByDefault,
          dir: _path.default.join(registryDirectory, browserDirectoryPrefix.replace(/-/g, "_") + "-" + revision)
        };
        return descriptor;
      });
    }
    var allDownloadable = ["chromium", "firefox", "webkit", "ffmpeg", "firefox-beta", "chromium-with-symbols"];
    var Registry = class {
      constructor(browsersJSON) {
        this._executables = void 0;
        const descriptors = readDescriptors(browsersJSON);
        const findExecutablePath = (dir, name) => {
          let tokens = void 0;
          if (_hostPlatform.hostPlatform.startsWith("ubuntu") || _hostPlatform.hostPlatform.startsWith("generic-linux"))
            tokens = EXECUTABLE_PATHS[name]["linux"];
          else if (_hostPlatform.hostPlatform.startsWith("mac"))
            tokens = EXECUTABLE_PATHS[name]["mac"];
          else if (_hostPlatform.hostPlatform.startsWith("win"))
            tokens = EXECUTABLE_PATHS[name]["win"];
          return tokens ? _path.default.join(dir, ...tokens) : void 0;
        };
        const executablePathOrDie = (name, e, installByDefault, sdkLanguage) => {
          if (!e)
            throw new Error(`${name} is not supported on ${_hostPlatform.hostPlatform}`);
          const installCommand = buildPlaywrightCLICommand(sdkLanguage, `install${installByDefault ? "" : " " + name}`);
          if (!(0, _fileUtils.canAccessFile)(e)) {
            const prettyMessage = [`Looks like Playwright Test or Playwright was just installed or updated.`, `Please run the following command to download new browser${installByDefault ? "s" : ""}:`, ``, `    ${installCommand}`, ``, `<3 Playwright Team`].join("\n");
            throw new Error(`Executable doesn't exist at ${e}
${(0, _utils.wrapInASCIIBox)(prettyMessage, 1)}`);
          }
          return e;
        };
        this._executables = [];
        const chromium = descriptors.find((d) => d.name === "chromium");
        const chromiumExecutable = findExecutablePath(chromium.dir, "chromium");
        this._executables.push({
          type: "browser",
          name: "chromium",
          browserName: "chromium",
          directory: chromium.dir,
          executablePath: () => chromiumExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("chromium", chromiumExecutable, chromium.installByDefault, sdkLanguage),
          installType: chromium.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "chromium", chromium.dir, ["chrome-linux"], [], ["chrome-win"]),
          _install: () => this._downloadExecutable(chromium, chromiumExecutable, DOWNLOAD_PATHS["chromium"][_hostPlatform.hostPlatform], "PLAYWRIGHT_CHROMIUM_DOWNLOAD_HOST"),
          _dependencyGroup: "chromium",
          _isHermeticInstallation: true
        });
        const chromiumWithSymbols = descriptors.find((d) => d.name === "chromium-with-symbols");
        const chromiumWithSymbolsExecutable = findExecutablePath(chromiumWithSymbols.dir, "chromium");
        this._executables.push({
          type: "tool",
          name: "chromium-with-symbols",
          browserName: "chromium",
          directory: chromiumWithSymbols.dir,
          executablePath: () => chromiumWithSymbolsExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("chromium-with-symbols", chromiumWithSymbolsExecutable, chromiumWithSymbols.installByDefault, sdkLanguage),
          installType: chromiumWithSymbols.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "chromium", chromiumWithSymbols.dir, ["chrome-linux"], [], ["chrome-win"]),
          _install: () => this._downloadExecutable(chromiumWithSymbols, chromiumWithSymbolsExecutable, DOWNLOAD_PATHS["chromium-with-symbols"][_hostPlatform.hostPlatform], "PLAYWRIGHT_CHROMIUM_DOWNLOAD_HOST"),
          _dependencyGroup: "chromium",
          _isHermeticInstallation: true
        });
        this._executables.push(this._createChromiumChannel("chrome", {
          "linux": "/opt/google/chrome/chrome",
          "darwin": "/Applications/Google Chrome.app/Contents/MacOS/Google Chrome",
          "win32": `\\Google\\Chrome\\Application\\chrome.exe`
        }, () => this._installChromiumChannel("chrome", {
          "linux": "reinstall_chrome_stable_linux.sh",
          "darwin": "reinstall_chrome_stable_mac.sh",
          "win32": "reinstall_chrome_stable_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("chrome-beta", {
          "linux": "/opt/google/chrome-beta/chrome",
          "darwin": "/Applications/Google Chrome Beta.app/Contents/MacOS/Google Chrome Beta",
          "win32": `\\Google\\Chrome Beta\\Application\\chrome.exe`
        }, () => this._installChromiumChannel("chrome-beta", {
          "linux": "reinstall_chrome_beta_linux.sh",
          "darwin": "reinstall_chrome_beta_mac.sh",
          "win32": "reinstall_chrome_beta_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("chrome-dev", {
          "linux": "/opt/google/chrome-unstable/chrome",
          "darwin": "/Applications/Google Chrome Dev.app/Contents/MacOS/Google Chrome Dev",
          "win32": `\\Google\\Chrome Dev\\Application\\chrome.exe`
        }));
        this._executables.push(this._createChromiumChannel("chrome-canary", {
          "linux": "",
          "darwin": "/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary",
          "win32": `\\Google\\Chrome SxS\\Application\\chrome.exe`
        }));
        this._executables.push(this._createChromiumChannel("msedge", {
          "linux": "/opt/microsoft/msedge/msedge",
          "darwin": "/Applications/Microsoft Edge.app/Contents/MacOS/Microsoft Edge",
          "win32": `\\Microsoft\\Edge\\Application\\msedge.exe`
        }, () => this._installMSEdgeChannel("msedge", {
          "linux": "reinstall_msedge_stable_linux.sh",
          "darwin": "reinstall_msedge_stable_mac.sh",
          "win32": "reinstall_msedge_stable_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("msedge-beta", {
          "linux": "/opt/microsoft/msedge-beta/msedge",
          "darwin": "/Applications/Microsoft Edge Beta.app/Contents/MacOS/Microsoft Edge Beta",
          "win32": `\\Microsoft\\Edge Beta\\Application\\msedge.exe`
        }, () => this._installMSEdgeChannel("msedge-beta", {
          "darwin": "reinstall_msedge_beta_mac.sh",
          "linux": "reinstall_msedge_beta_linux.sh",
          "win32": "reinstall_msedge_beta_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("msedge-dev", {
          "linux": "/opt/microsoft/msedge-dev/msedge",
          "darwin": "/Applications/Microsoft Edge Dev.app/Contents/MacOS/Microsoft Edge Dev",
          "win32": `\\Microsoft\\Edge Dev\\Application\\msedge.exe`
        }, () => this._installMSEdgeChannel("msedge-dev", {
          "darwin": "reinstall_msedge_dev_mac.sh",
          "linux": "reinstall_msedge_dev_linux.sh",
          "win32": "reinstall_msedge_dev_win.ps1"
        })));
        this._executables.push(this._createChromiumChannel("msedge-canary", {
          "linux": "",
          "darwin": "/Applications/Microsoft Edge Canary.app/Contents/MacOS/Microsoft Edge Canary",
          "win32": `\\Microsoft\\Edge SxS\\Application\\msedge.exe`
        }));
        const firefox = descriptors.find((d) => d.name === "firefox");
        const firefoxExecutable = findExecutablePath(firefox.dir, "firefox");
        this._executables.push({
          type: "browser",
          name: "firefox",
          browserName: "firefox",
          directory: firefox.dir,
          executablePath: () => firefoxExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("firefox", firefoxExecutable, firefox.installByDefault, sdkLanguage),
          installType: firefox.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "firefox", firefox.dir, ["firefox"], [], ["firefox"]),
          _install: () => this._downloadExecutable(firefox, firefoxExecutable, DOWNLOAD_PATHS["firefox"][_hostPlatform.hostPlatform], "PLAYWRIGHT_FIREFOX_DOWNLOAD_HOST"),
          _dependencyGroup: "firefox",
          _isHermeticInstallation: true
        });
        const firefoxBeta = descriptors.find((d) => d.name === "firefox-beta");
        const firefoxBetaExecutable = findExecutablePath(firefoxBeta.dir, "firefox");
        this._executables.push({
          type: "tool",
          name: "firefox-beta",
          browserName: "firefox",
          directory: firefoxBeta.dir,
          executablePath: () => firefoxBetaExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("firefox-beta", firefoxBetaExecutable, firefoxBeta.installByDefault, sdkLanguage),
          installType: firefoxBeta.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "firefox", firefoxBeta.dir, ["firefox"], [], ["firefox"]),
          _install: () => this._downloadExecutable(firefoxBeta, firefoxBetaExecutable, DOWNLOAD_PATHS["firefox-beta"][_hostPlatform.hostPlatform], "PLAYWRIGHT_FIREFOX_DOWNLOAD_HOST"),
          _dependencyGroup: "firefox",
          _isHermeticInstallation: true
        });
        const webkit = descriptors.find((d) => d.name === "webkit");
        const webkitExecutable = findExecutablePath(webkit.dir, "webkit");
        const webkitLinuxLddDirectories = [_path.default.join("minibrowser-gtk"), _path.default.join("minibrowser-gtk", "bin"), _path.default.join("minibrowser-gtk", "lib"), _path.default.join("minibrowser-gtk", "sys", "lib"), _path.default.join("minibrowser-wpe"), _path.default.join("minibrowser-wpe", "bin"), _path.default.join("minibrowser-wpe", "lib"), _path.default.join("minibrowser-wpe", "sys", "lib")];
        this._executables.push({
          type: "browser",
          name: "webkit",
          browserName: "webkit",
          directory: webkit.dir,
          executablePath: () => webkitExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("webkit", webkitExecutable, webkit.installByDefault, sdkLanguage),
          installType: webkit.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: (sdkLanguage) => this._validateHostRequirements(sdkLanguage, "webkit", webkit.dir, webkitLinuxLddDirectories, ["libGLESv2.so.2", "libx264.so"], [""]),
          _install: () => this._downloadExecutable(webkit, webkitExecutable, DOWNLOAD_PATHS["webkit"][_hostPlatform.hostPlatform], "PLAYWRIGHT_WEBKIT_DOWNLOAD_HOST"),
          _dependencyGroup: "webkit",
          _isHermeticInstallation: true
        });
        const ffmpeg = descriptors.find((d) => d.name === "ffmpeg");
        const ffmpegExecutable = findExecutablePath(ffmpeg.dir, "ffmpeg");
        this._executables.push({
          type: "tool",
          name: "ffmpeg",
          browserName: void 0,
          directory: ffmpeg.dir,
          executablePath: () => ffmpegExecutable,
          executablePathOrDie: (sdkLanguage) => executablePathOrDie("ffmpeg", ffmpegExecutable, ffmpeg.installByDefault, sdkLanguage),
          installType: ffmpeg.installByDefault ? "download-by-default" : "download-on-demand",
          validateHostRequirements: () => Promise.resolve(),
          _install: () => this._downloadExecutable(ffmpeg, ffmpegExecutable, DOWNLOAD_PATHS["ffmpeg"][_hostPlatform.hostPlatform], "PLAYWRIGHT_FFMPEG_DOWNLOAD_HOST"),
          _dependencyGroup: "tools",
          _isHermeticInstallation: true
        });
      }
      _createChromiumChannel(name, lookAt, install) {
        const executablePath = (sdkLanguage, shouldThrow) => {
          const suffix = lookAt[process.platform];
          if (!suffix) {
            if (shouldThrow)
              throw new Error(`Chromium distribution '${name}' is not supported on ${process.platform}`);
            return void 0;
          }
          const prefixes = process.platform === "win32" ? [process.env.LOCALAPPDATA, process.env.PROGRAMFILES, process.env["PROGRAMFILES(X86)"]].filter(Boolean) : [""];
          for (const prefix of prefixes) {
            const executablePath2 = _path.default.join(prefix, suffix);
            if ((0, _fileUtils.canAccessFile)(executablePath2))
              return executablePath2;
          }
          if (!shouldThrow)
            return void 0;
          const location2 = prefixes.length ? ` at ${_path.default.join(prefixes[0], suffix)}` : ``;
          const installation = install ? `
Run "${buildPlaywrightCLICommand(sdkLanguage, "install " + name)}"` : "";
          throw new Error(`Chromium distribution '${name}' is not found${location2}${installation}`);
        };
        return {
          type: "channel",
          name,
          browserName: "chromium",
          directory: void 0,
          executablePath: (sdkLanguage) => executablePath(sdkLanguage, false),
          executablePathOrDie: (sdkLanguage) => executablePath(sdkLanguage, true),
          installType: install ? "install-script" : "none",
          validateHostRequirements: () => Promise.resolve(),
          _isHermeticInstallation: false,
          _install: install
        };
      }
      executables() {
        return this._executables;
      }
      findExecutable(name) {
        return this._executables.find((b) => b.name === name);
      }
      defaultExecutables() {
        return this._executables.filter((e) => e.installType === "download-by-default");
      }
      _addRequirementsAndDedupe(executables) {
        const set = /* @__PURE__ */ new Set();
        for (const executable of executables) {
          set.add(executable);
          if (executable.browserName === "chromium")
            set.add(this.findExecutable("ffmpeg"));
        }
        return Array.from(set);
      }
      _validateHostRequirements(sdkLanguage, browserName, browserDirectory, linuxLddDirectories, dlOpenLibraries, windowsExeAndDllDirectories) {
        return __async(this, null, function* () {
          if ((0, _utils.getAsBooleanFromENV)("PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS")) {
            process.stdout.write("Skipping host requirements validation logic because `PLAYWRIGHT_SKIP_VALIDATE_HOST_REQUIREMENTS` env variable is set.\n");
            return;
          }
          const ubuntuVersion = yield (0, _ubuntuVersion.getUbuntuVersion)();
          if (browserName === "firefox" && ubuntuVersion === "16.04")
            throw new Error(`Cannot launch Firefox on Ubuntu 16.04! Minimum required Ubuntu version for Firefox browser is 18.04`);
          if (os.platform() === "linux")
            return yield (0, _dependencies.validateDependenciesLinux)(sdkLanguage, linuxLddDirectories.map((d) => _path.default.join(browserDirectory, d)), dlOpenLibraries);
          if (os.platform() === "win32" && os.arch() === "x64")
            return yield (0, _dependencies.validateDependenciesWindows)(windowsExeAndDllDirectories.map((d) => _path.default.join(browserDirectory, d)));
        });
      }
      installDeps(executablesToInstallDeps, dryRun) {
        return __async(this, null, function* () {
          const executables = this._addRequirementsAndDedupe(executablesToInstallDeps);
          const targets = /* @__PURE__ */ new Set();
          for (const executable of executables) {
            if (executable._dependencyGroup)
              targets.add(executable._dependencyGroup);
          }
          targets.add("tools");
          if (os.platform() === "win32")
            return yield (0, _dependencies.installDependenciesWindows)(targets, dryRun);
          if (os.platform() === "linux")
            return yield (0, _dependencies.installDependenciesLinux)(targets, dryRun);
        });
      }
      install(executablesToInstall, forceReinstall) {
        return __async(this, null, function* () {
          const executables = this._addRequirementsAndDedupe(executablesToInstall);
          yield fs.promises.mkdir(registryDirectory, {
            recursive: true
          });
          const lockfilePath = _path.default.join(registryDirectory, "__dirlock");
          const linksDir = _path.default.join(registryDirectory, ".links");
          let releaseLock;
          try {
            releaseLock = yield _properLockfile.default.lock(registryDirectory, {
              retries: {
                retries: 20,
                factor: 1.27579
              },
              onCompromised: (err) => {
                throw new Error(`${err.message} Path: ${lockfilePath}`);
              },
              lockfilePath
            });
            yield fs.promises.mkdir(linksDir, {
              recursive: true
            });
            yield fs.promises.writeFile(_path.default.join(linksDir, (0, _utils.calculateSha1)(PACKAGE_PATH)), PACKAGE_PATH);
            yield this._validateInstallationCache(linksDir);
            for (const executable of executables) {
              if (!executable._install)
                throw new Error(`ERROR: Playwright does not support installing ${executable.name}`);
              const {
                langName
              } = (0, _userAgent.getClientLanguage)();
              if (!(0, _utils.getAsBooleanFromENV)("CI") && !executable._isHermeticInstallation && !forceReinstall && executable.executablePath(langName)) {
                const command = buildPlaywrightCLICommand(langName, "install --force " + executable.name);
                throw new Error("\n" + (0, _utils.wrapInASCIIBox)([`ATTENTION: "${executable.name}" is already installed on the system!`, ``, `"${executable.name}" installation is not hermetic; installing newer version`, `requires *removal* of a current installation first.`, ``, `To *uninstall* current version and re-install latest "${executable.name}":`, ``, `- Close all running instances of "${executable.name}", if any`, `- Use "--force" to install browser:`, ``, `    ${command}`, ``, `<3 Playwright Team`].join("\n"), 1));
              }
              yield executable._install();
            }
          } catch (e) {
            if (e.code === "ELOCKED") {
              const rmCommand = process.platform === "win32" ? "rm -R" : "rm -rf";
              throw new Error("\n" + (0, _utils.wrapInASCIIBox)([`An active lockfile is found at:`, ``, `  ${lockfilePath}`, ``, `Either:`, `- wait a few minutes if other Playwright is installing browsers in parallel`, `- remove lock manually with:`, ``, `    ${rmCommand} ${lockfilePath}`, ``, `<3 Playwright Team`].join("\n"), 1));
            } else {
              throw e;
            }
          } finally {
            if (releaseLock)
              yield releaseLock();
          }
        });
      }
      _downloadExecutable(descriptor, executablePath, downloadPathTemplate, downloadHostEnv) {
        return __async(this, null, function* () {
          if (!downloadPathTemplate || !executablePath)
            throw new Error(`ERROR: Playwright does not support ${descriptor.name} on ${_hostPlatform.hostPlatform}`);
          if (_hostPlatform.hostPlatform === "generic-linux" || _hostPlatform.hostPlatform === "generic-linux-arm64")
            (0, _browserFetcher.logPolitely)("BEWARE: your OS is not officially supported by Playwright; downloading Ubuntu build as a fallback.");
          const downloadHost = downloadHostEnv && (0, _utils.getFromENV)(downloadHostEnv) || (0, _utils.getFromENV)("PLAYWRIGHT_DOWNLOAD_HOST") || "https://playwright.azureedge.net";
          const downloadPath = util.format(downloadPathTemplate, descriptor.revision);
          const downloadURL = `${downloadHost}/${downloadPath}`;
          const title = `${descriptor.name} v${descriptor.revision}`;
          const downloadFileName = `playwright-download-${descriptor.name}-${_hostPlatform.hostPlatform}-${descriptor.revision}.zip`;
          yield (0, _browserFetcher.downloadBrowserWithProgressBar)(title, descriptor.dir, executablePath, downloadURL, downloadFileName).catch((e) => {
            throw new Error(`Failed to download ${title}, caused by
${e.stack}`);
          });
          yield fs.promises.writeFile(markerFilePath(descriptor.dir), "");
        });
      }
      _installMSEdgeChannel(channel, scripts) {
        return __async(this, null, function* () {
          const scriptArgs = [];
          if (process.platform !== "linux") {
            const products = JSON.parse(yield (0, _netUtils.fetchData)({
              url: "https://edgeupdates.microsoft.com/api/products"
            }));
            const productName = {
              "msedge": "Stable",
              "msedge-beta": "Beta",
              "msedge-dev": "Dev"
            }[channel];
            const product = products.find((product2) => product2.Product === productName);
            const searchConfig = {
              darwin: {
                platform: "MacOS",
                arch: "universal",
                artifact: "pkg"
              },
              win32: {
                platform: "Windows",
                arch: "x64",
                artifact: "msi"
              }
            }[process.platform];
            const release = searchConfig ? product.Releases.find((release2) => release2.Platform === searchConfig.platform && release2.Architecture === searchConfig.arch) : null;
            const artifact = release ? release.Artifacts.find((artifact2) => artifact2.ArtifactName === searchConfig.artifact) : null;
            if (artifact)
              scriptArgs.push(artifact.Location);
            else
              throw new Error(`Cannot install ${channel} on ${process.platform}`);
          }
          yield this._installChromiumChannel(channel, scripts, scriptArgs);
        });
      }
      _installChromiumChannel(_0, _1) {
        return __async(this, arguments, function* (channel, scripts, scriptArgs = []) {
          const scriptName = scripts[process.platform];
          if (!scriptName)
            throw new Error(`Cannot install ${channel} on ${process.platform}`);
          const cwd = BIN_PATH;
          const isPowerShell = scriptName.endsWith(".ps1");
          if (isPowerShell) {
            const args = ["-ExecutionPolicy", "Bypass", "-File", _path.default.join(BIN_PATH, scriptName), ...scriptArgs];
            const {
              code
            } = yield (0, _spawnAsync.spawnAsync)("powershell.exe", args, {
              cwd,
              stdio: "inherit"
            });
            if (code !== 0)
              throw new Error(`Failed to install ${channel}`);
          } else {
            const {
              command,
              args,
              elevatedPermissions
            } = yield (0, _dependencies.transformCommandsForRoot)([`bash "${_path.default.join(BIN_PATH, scriptName)}" ${scriptArgs.join("")}`]);
            if (elevatedPermissions)
              console.log("Switching to root user to install dependencies...");
            const {
              code
            } = yield (0, _spawnAsync.spawnAsync)(command, args, {
              cwd,
              stdio: "inherit"
            });
            if (code !== 0)
              throw new Error(`Failed to install ${channel}`);
          }
        });
      }
      _validateInstallationCache(linksDir) {
        return __async(this, null, function* () {
          const usedBrowserPaths = /* @__PURE__ */ new Set();
          for (const fileName of yield fs.promises.readdir(linksDir)) {
            const linkPath = _path.default.join(linksDir, fileName);
            let linkTarget = "";
            try {
              linkTarget = (yield fs.promises.readFile(linkPath)).toString();
              const browsersJSON = require(_path.default.join(linkTarget, "browsers.json"));
              const descriptors = readDescriptors(browsersJSON);
              for (const browserName of allDownloadable) {
                const descriptor = descriptors.find((d) => d.name === browserName);
                if (!descriptor)
                  continue;
                const usedBrowserPath = descriptor.dir;
                const browserRevision = parseInt(descriptor.revision, 10);
                const shouldHaveMarkerFile = browserName === "chromium" && browserRevision >= 786218 || browserName === "firefox" && browserRevision >= 1128 || browserName === "webkit" && browserRevision >= 1307 || browserName !== "firefox" && browserName !== "chromium" && browserName !== "webkit";
                if (!shouldHaveMarkerFile || (yield (0, _fileUtils.existsAsync)(markerFilePath(usedBrowserPath))))
                  usedBrowserPaths.add(usedBrowserPath);
              }
            } catch (e) {
              yield fs.promises.unlink(linkPath).catch((e2) => {
              });
            }
          }
          if (!(0, _utils.getAsBooleanFromENV)("PLAYWRIGHT_SKIP_BROWSER_GC")) {
            let downloadedBrowsers = (yield fs.promises.readdir(registryDirectory)).map((file) => _path.default.join(registryDirectory, file));
            downloadedBrowsers = downloadedBrowsers.filter((file) => isBrowserDirectory(file));
            const directories = new Set(downloadedBrowsers);
            for (const browserDirectory of usedBrowserPaths)
              directories.delete(browserDirectory);
            for (const directory of directories)
              (0, _browserFetcher.logPolitely)("Removing unused browser at " + directory);
            yield (0, _fileUtils.removeFolders)([...directories]);
          }
        });
      }
    };
    exports2.Registry = Registry;
    function markerFilePath(browserDirectory) {
      return _path.default.join(browserDirectory, "INSTALLATION_COMPLETE");
    }
    function buildPlaywrightCLICommand(sdkLanguage, parameters) {
      switch (sdkLanguage) {
        case "python":
          return `playwright ${parameters}`;
        case "java":
          return `mvn exec:java -e -Dexec.mainClass=com.microsoft.playwright.CLI -Dexec.args="${parameters}"`;
        case "csharp":
          return `pwsh bin\\Debug\\netX\\playwright.ps1 ${parameters}`;
        default:
          return `npx playwright ${parameters}`;
      }
    }
    function installDefaultBrowsersForNpmInstall() {
      return __async(this, null, function* () {
        const defaultBrowserNames = registry.defaultExecutables().map((e) => e.name);
        return installBrowsersForNpmInstall(defaultBrowserNames);
      });
    }
    function installBrowsersForNpmInstall(browsers) {
      return __async(this, null, function* () {
        if ((0, _utils.getAsBooleanFromENV)("PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD")) {
          (0, _browserFetcher.logPolitely)("Skipping browsers download because `PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD` env variable is set");
          return false;
        }
        const executables = [];
        for (const browserName of browsers) {
          const executable = registry.findExecutable(browserName);
          if (!executable || executable.installType === "none")
            throw new Error(`Cannot install ${browserName}`);
          executables.push(executable);
        }
        yield registry.install(executables, false);
      });
    }
    function findChromiumChannel(sdkLanguage) {
      let channel = null;
      for (const name of ["chromium", "chrome", "msedge"]) {
        try {
          registry.findExecutable(name).executablePathOrDie(sdkLanguage);
          channel = name === "chromium" ? void 0 : name;
          break;
        } catch (e) {
        }
      }
      if (channel === null) {
        const installCommand = buildPlaywrightCLICommand(sdkLanguage, `install chromium`);
        const prettyMessage = [`No chromium-based browser found on the system.`, `Please run the following command to download one:`, ``, `    ${installCommand}`, ``, `<3 Playwright Team`].join("\n");
        throw new Error("\n" + (0, _utils.wrapInASCIIBox)(prettyMessage, 1));
      }
      return channel;
    }
    var registry = new Registry(require_browsers());
    exports2.registry = registry;
  }
});

// node_modules/playwright-core/lib/common/errors.js
var require_errors = __commonJS({
  "node_modules/playwright-core/lib/common/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TimeoutError = void 0;
    exports2.isSafeCloseError = isSafeCloseError;
    exports2.kBrowserOrContextClosedError = exports2.kBrowserClosedError = void 0;
    var CustomError = class extends Error {
      constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
      }
    };
    var TimeoutError = class extends CustomError {
    };
    exports2.TimeoutError = TimeoutError;
    var kBrowserClosedError = "Browser has been closed";
    exports2.kBrowserClosedError = kBrowserClosedError;
    var kBrowserOrContextClosedError = "Target page, context or browser has been closed";
    exports2.kBrowserOrContextClosedError = kBrowserOrContextClosedError;
    function isSafeCloseError(error) {
      return error.message.endsWith(kBrowserClosedError) || error.message.endsWith(kBrowserOrContextClosedError);
    }
  }
});

// node_modules/playwright-core/lib/protocol/serializers.js
var require_serializers = __commonJS({
  "node_modules/playwright-core/lib/protocol/serializers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.parseError = parseError;
    exports2.parseSerializedValue = parseSerializedValue;
    exports2.serializeError = serializeError;
    exports2.serializeValue = serializeValue;
    var _errors = require_errors();
    function serializeError(e) {
      if (isError(e))
        return {
          error: {
            message: e.message,
            stack: e.stack,
            name: e.name
          }
        };
      return {
        value: serializeValue(e, (value) => ({
          fallThrough: value
        }), /* @__PURE__ */ new Set())
      };
    }
    function parseError(error) {
      if (!error.error) {
        if (error.value === void 0)
          throw new Error("Serialized error must have either an error or a value");
        return parseSerializedValue(error.value, void 0);
      }
      if (error.error.name === "TimeoutError") {
        const e2 = new _errors.TimeoutError(error.error.message);
        e2.stack = error.error.stack || "";
        return e2;
      }
      const e = new Error(error.error.message);
      e.stack = error.error.stack || "";
      e.name = error.error.name;
      return e;
    }
    function parseSerializedValue(value, handles) {
      if (value.n !== void 0)
        return value.n;
      if (value.s !== void 0)
        return value.s;
      if (value.b !== void 0)
        return value.b;
      if (value.v !== void 0) {
        if (value.v === "undefined")
          return void 0;
        if (value.v === "null")
          return null;
        if (value.v === "NaN")
          return NaN;
        if (value.v === "Infinity")
          return Infinity;
        if (value.v === "-Infinity")
          return -Infinity;
        if (value.v === "-0")
          return -0;
      }
      if (value.d !== void 0)
        return new Date(value.d);
      if (value.r !== void 0)
        return new RegExp(value.r.p, value.r.f);
      if (value.a !== void 0)
        return value.a.map((a) => parseSerializedValue(a, handles));
      if (value.o !== void 0) {
        const result = {};
        for (const {
          k,
          v
        } of value.o)
          result[k] = parseSerializedValue(v, handles);
        return result;
      }
      if (value.h !== void 0) {
        if (handles === void 0)
          throw new Error("Unexpected handle");
        return handles[value.h];
      }
      throw new Error("Unexpected value");
    }
    function serializeValue(value, handleSerializer, visited) {
      const handle = handleSerializer(value);
      if ("fallThrough" in handle)
        value = handle.fallThrough;
      else
        return handle;
      if (visited.has(value))
        throw new Error("Argument is a circular structure");
      if (typeof value === "symbol")
        return {
          v: "undefined"
        };
      if (Object.is(value, void 0))
        return {
          v: "undefined"
        };
      if (Object.is(value, null))
        return {
          v: "null"
        };
      if (Object.is(value, NaN))
        return {
          v: "NaN"
        };
      if (Object.is(value, Infinity))
        return {
          v: "Infinity"
        };
      if (Object.is(value, -Infinity))
        return {
          v: "-Infinity"
        };
      if (Object.is(value, -0))
        return {
          v: "-0"
        };
      if (typeof value === "boolean")
        return {
          b: value
        };
      if (typeof value === "number")
        return {
          n: value
        };
      if (typeof value === "string")
        return {
          s: value
        };
      if (isError(value)) {
        const error = value;
        if ("captureStackTrace" in globalThis.Error) {
          return {
            s: error.stack || ""
          };
        }
        return {
          s: `${error.name}: ${error.message}
${error.stack}`
        };
      }
      if (isDate(value))
        return {
          d: value.toJSON()
        };
      if (isRegExp(value))
        return {
          r: {
            p: value.source,
            f: value.flags
          }
        };
      if (Array.isArray(value)) {
        const a = [];
        visited.add(value);
        for (let i = 0; i < value.length; ++i)
          a.push(serializeValue(value[i], handleSerializer, visited));
        visited.delete(value);
        return {
          a
        };
      }
      if (typeof value === "object") {
        const o = [];
        visited.add(value);
        for (const name of Object.keys(value))
          o.push({
            k: name,
            v: serializeValue(value[name], handleSerializer, visited)
          });
        visited.delete(value);
        return {
          o
        };
      }
      throw new Error("Unexpected value");
    }
    function isRegExp(obj) {
      return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function isDate(obj) {
      return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";
    }
    function isError(obj) {
      var _obj$__proto__;
      return obj instanceof Error || (obj === null || obj === void 0 ? void 0 : (_obj$__proto__ = obj.__proto__) === null || _obj$__proto__ === void 0 ? void 0 : _obj$__proto__.name) === "Error" || (obj === null || obj === void 0 ? void 0 : obj.__proto__) && isError(obj.__proto__);
    }
  }
});

// node_modules/playwright-core/lib/protocol/validatorPrimitives.js
var require_validatorPrimitives = __commonJS({
  "node_modules/playwright-core/lib/protocol/validatorPrimitives.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.tUndefined = exports2.tString = exports2.tOptional = exports2.tObject = exports2.tNumber = exports2.tEnum = exports2.tBoolean = exports2.tBinary = exports2.tArray = exports2.tAny = exports2.ValidationError = void 0;
    var _utils = require_utils();
    var ValidationError = class extends Error {
    };
    exports2.ValidationError = ValidationError;
    var tNumber = (arg, path) => {
      if (arg instanceof Number)
        return arg.valueOf();
      if (typeof arg === "number")
        return arg;
      throw new ValidationError(`${path}: expected number, got ${typeof arg}`);
    };
    exports2.tNumber = tNumber;
    var tBoolean = (arg, path) => {
      if (arg instanceof Boolean)
        return arg.valueOf();
      if (typeof arg === "boolean")
        return arg;
      throw new ValidationError(`${path}: expected boolean, got ${typeof arg}`);
    };
    exports2.tBoolean = tBoolean;
    var tString = (arg, path) => {
      if (arg instanceof String)
        return arg.valueOf();
      if (typeof arg === "string")
        return arg;
      throw new ValidationError(`${path}: expected string, got ${typeof arg}`);
    };
    exports2.tString = tString;
    var tBinary = (arg, path) => {
      if (arg instanceof String)
        return arg.valueOf();
      if (typeof arg === "string")
        return arg;
      throw new ValidationError(`${path}: expected base64-encoded buffer, got ${typeof arg}`);
    };
    exports2.tBinary = tBinary;
    var tUndefined = (arg, path) => {
      if (Object.is(arg, void 0))
        return arg;
      throw new ValidationError(`${path}: expected undefined, got ${typeof arg}`);
    };
    exports2.tUndefined = tUndefined;
    var tAny = (arg, path) => {
      return arg;
    };
    exports2.tAny = tAny;
    var tOptional = (v) => {
      return (arg, path) => {
        if (Object.is(arg, void 0))
          return arg;
        return v(arg, path);
      };
    };
    exports2.tOptional = tOptional;
    var tArray = (v) => {
      return (arg, path) => {
        if (!Array.isArray(arg))
          throw new ValidationError(`${path}: expected array, got ${typeof arg}`);
        return arg.map((x, index) => v(x, path + "[" + index + "]"));
      };
    };
    exports2.tArray = tArray;
    var tObject = (s) => {
      return (arg, path) => {
        if (Object.is(arg, null))
          throw new ValidationError(`${path}: expected object, got null`);
        if (typeof arg !== "object")
          throw new ValidationError(`${path}: expected object, got ${typeof arg}`);
        const result = {};
        for (const [key, v] of Object.entries(s)) {
          const value = v(arg[key], path ? path + "." + key : key);
          if (!Object.is(value, void 0))
            result[key] = value;
        }
        if ((0, _utils.isUnderTest)()) {
          for (const [key, value] of Object.entries(arg)) {
            if (key.startsWith("__testHook"))
              result[key] = value;
          }
        }
        return result;
      };
    };
    exports2.tObject = tObject;
    var tEnum = (e) => {
      return (arg, path) => {
        if (!e.includes(arg))
          throw new ValidationError(`${path}: expected one of (${e.join("|")})`);
        return arg;
      };
    };
    exports2.tEnum = tEnum;
  }
});

// node_modules/playwright-core/lib/protocol/validator.js
var require_validator = __commonJS({
  "node_modules/playwright-core/lib/protocol/validator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "ValidationError", {
      enumerable: true,
      get: function() {
        return _validatorPrimitives.ValidationError;
      }
    });
    exports2.createScheme = createScheme;
    var _validatorPrimitives = require_validatorPrimitives();
    function createScheme(tChannel) {
      const scheme = {};
      const tType = (name) => {
        return (arg, path) => {
          const v = scheme[name];
          if (!v)
            throw new _validatorPrimitives.ValidationError(path + ': unknown type "' + name + '"');
          return v(arg, path);
        };
      };
      scheme.StackFrame = (0, _validatorPrimitives.tObject)({
        file: _validatorPrimitives.tString,
        line: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        column: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        function: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.Metadata = (0, _validatorPrimitives.tObject)({
        stack: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("StackFrame"))),
        apiName: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        internal: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.Point = (0, _validatorPrimitives.tObject)({
        x: _validatorPrimitives.tNumber,
        y: _validatorPrimitives.tNumber
      });
      scheme.Rect = (0, _validatorPrimitives.tObject)({
        x: _validatorPrimitives.tNumber,
        y: _validatorPrimitives.tNumber,
        width: _validatorPrimitives.tNumber,
        height: _validatorPrimitives.tNumber
      });
      scheme.SerializedValue = (0, _validatorPrimitives.tObject)({
        n: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        b: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        s: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        v: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["null", "undefined", "NaN", "Infinity", "-Infinity", "-0"])),
        d: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        r: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          p: _validatorPrimitives.tString,
          f: _validatorPrimitives.tString
        })),
        a: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("SerializedValue"))),
        o: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          k: _validatorPrimitives.tString,
          v: tType("SerializedValue")
        }))),
        h: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.SerializedArgument = (0, _validatorPrimitives.tObject)({
        value: tType("SerializedValue"),
        handles: (0, _validatorPrimitives.tArray)(tChannel("*"))
      });
      scheme.ExpectedTextValue = (0, _validatorPrimitives.tObject)({
        string: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        regexSource: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        regexFlags: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        matchSubstring: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        normalizeWhiteSpace: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.AXNode = (0, _validatorPrimitives.tObject)({
        role: _validatorPrimitives.tString,
        name: _validatorPrimitives.tString,
        valueString: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        valueNumber: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        description: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        keyshortcuts: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        roledescription: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        valuetext: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        disabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        expanded: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        focused: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modal: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        multiline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        multiselectable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        readonly: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        required: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        selected: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        checked: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["checked", "unchecked", "mixed"])),
        pressed: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["pressed", "released", "mixed"])),
        level: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        valuemin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        valuemax: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        autocomplete: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        haspopup: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        invalid: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        orientation: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        children: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("AXNode")))
      });
      scheme.SetNetworkCookie = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        value: _validatorPrimitives.tString,
        url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        domain: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        path: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        expires: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        httpOnly: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        secure: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        sameSite: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["Strict", "Lax", "None"]))
      });
      scheme.NetworkCookie = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        value: _validatorPrimitives.tString,
        domain: _validatorPrimitives.tString,
        path: _validatorPrimitives.tString,
        expires: _validatorPrimitives.tNumber,
        httpOnly: _validatorPrimitives.tBoolean,
        secure: _validatorPrimitives.tBoolean,
        sameSite: (0, _validatorPrimitives.tEnum)(["Strict", "Lax", "None"])
      });
      scheme.NameValue = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        value: _validatorPrimitives.tString
      });
      scheme.OriginStorage = (0, _validatorPrimitives.tObject)({
        origin: _validatorPrimitives.tString,
        localStorage: (0, _validatorPrimitives.tArray)(tType("NameValue"))
      });
      scheme.SerializedError = (0, _validatorPrimitives.tObject)({
        error: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          message: _validatorPrimitives.tString,
          name: _validatorPrimitives.tString,
          stack: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        })),
        value: (0, _validatorPrimitives.tOptional)(tType("SerializedValue"))
      });
      scheme.FormField = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        file: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          name: _validatorPrimitives.tString,
          mimeType: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          buffer: _validatorPrimitives.tBinary
        }))
      });
      scheme.APIRequestContextFetchParams = (0, _validatorPrimitives.tObject)({
        url: _validatorPrimitives.tString,
        params: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        method: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        postData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
        jsonData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
        formData: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        multipartData: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("FormField"))),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        failOnStatusCode: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.APIRequestContextFetchResponseBodyParams = (0, _validatorPrimitives.tObject)({
        fetchUid: _validatorPrimitives.tString
      });
      scheme.APIRequestContextFetchLogParams = (0, _validatorPrimitives.tObject)({
        fetchUid: _validatorPrimitives.tString
      });
      scheme.APIRequestContextStorageStateParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.APIRequestContextDisposeAPIResponseParams = (0, _validatorPrimitives.tObject)({
        fetchUid: _validatorPrimitives.tString
      });
      scheme.APIRequestContextDisposeParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.APIResponse = (0, _validatorPrimitives.tObject)({
        fetchUid: _validatorPrimitives.tString,
        url: _validatorPrimitives.tString,
        status: _validatorPrimitives.tNumber,
        statusText: _validatorPrimitives.tString,
        headers: (0, _validatorPrimitives.tArray)(tType("NameValue"))
      });
      scheme.LifecycleEvent = (0, _validatorPrimitives.tEnum)(["load", "domcontentloaded", "networkidle", "commit"]);
      scheme.LocalUtilsZipParams = (0, _validatorPrimitives.tObject)({
        zipFile: _validatorPrimitives.tString,
        entries: (0, _validatorPrimitives.tArray)(tType("NameValue"))
      });
      scheme.RootInitializeParams = (0, _validatorPrimitives.tObject)({
        sdkLanguage: _validatorPrimitives.tString
      });
      scheme.PlaywrightNewRequestParams = (0, _validatorPrimitives.tObject)({
        baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          username: _validatorPrimitives.tString,
          password: _validatorPrimitives.tString
        })),
        proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          server: _validatorPrimitives.tString,
          bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        })),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        storageState: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          cookies: (0, _validatorPrimitives.tArray)(tType("NetworkCookie")),
          origins: (0, _validatorPrimitives.tArray)(tType("OriginStorage"))
        })),
        tracesDir: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.PlaywrightHideHighlightParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.SocksSupportSocksConnectedParams = (0, _validatorPrimitives.tObject)({
        uid: _validatorPrimitives.tString,
        host: _validatorPrimitives.tString,
        port: _validatorPrimitives.tNumber
      });
      scheme.SocksSupportSocksFailedParams = (0, _validatorPrimitives.tObject)({
        uid: _validatorPrimitives.tString,
        errorCode: _validatorPrimitives.tString
      });
      scheme.SocksSupportSocksDataParams = (0, _validatorPrimitives.tObject)({
        uid: _validatorPrimitives.tString,
        data: _validatorPrimitives.tBinary
      });
      scheme.SocksSupportSocksErrorParams = (0, _validatorPrimitives.tObject)({
        uid: _validatorPrimitives.tString,
        error: _validatorPrimitives.tString
      });
      scheme.SocksSupportSocksEndParams = (0, _validatorPrimitives.tObject)({
        uid: _validatorPrimitives.tString
      });
      scheme.SelectorsRegisterParams = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        source: _validatorPrimitives.tString,
        contentScript: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.BrowserTypeConnectParams = (0, _validatorPrimitives.tObject)({
        wsEndpoint: _validatorPrimitives.tString,
        headers: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
        slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        socksProxyRedirectPortForTest: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.BrowserTypeLaunchParams = (0, _validatorPrimitives.tObject)({
        channel: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        executablePath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        ignoreAllDefaultArgs: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        ignoreDefaultArgs: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        handleSIGINT: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        handleSIGTERM: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        handleSIGHUP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        env: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        headless: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        devtools: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          server: _validatorPrimitives.tString,
          bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        })),
        downloadsPath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        tracesDir: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        chromiumSandbox: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        firefoxUserPrefs: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
        slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.BrowserTypeLaunchPersistentContextParams = (0, _validatorPrimitives.tObject)({
        channel: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        executablePath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        ignoreAllDefaultArgs: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        ignoreDefaultArgs: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        handleSIGINT: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        handleSIGTERM: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        handleSIGHUP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        env: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        headless: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        devtools: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          server: _validatorPrimitives.tString,
          bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        })),
        downloadsPath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        tracesDir: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        chromiumSandbox: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        })),
        screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        })),
        ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          longitude: _validatorPrimitives.tNumber,
          latitude: _validatorPrimitives.tNumber,
          accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        })),
        permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          username: _validatorPrimitives.tString,
          password: _validatorPrimitives.tString
        })),
        deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference"])),
        reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["reduce", "no-preference"])),
        forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["active", "none"])),
        acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          dir: _validatorPrimitives.tString,
          size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
            width: _validatorPrimitives.tNumber,
            height: _validatorPrimitives.tNumber
          }))
        })),
        recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          omitContent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
          path: _validatorPrimitives.tString
        })),
        strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        userDataDir: _validatorPrimitives.tString,
        slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.BrowserTypeConnectOverCDPParams = (0, _validatorPrimitives.tObject)({
        endpointURL: _validatorPrimitives.tString,
        headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        slowMo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.BrowserCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserKillForTestsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserNewContextParams = (0, _validatorPrimitives.tObject)({
        noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        })),
        screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        })),
        ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          longitude: _validatorPrimitives.tNumber,
          latitude: _validatorPrimitives.tNumber,
          accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        })),
        permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          username: _validatorPrimitives.tString,
          password: _validatorPrimitives.tString
        })),
        deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference"])),
        reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["reduce", "no-preference"])),
        forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["active", "none"])),
        acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          dir: _validatorPrimitives.tString,
          size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
            width: _validatorPrimitives.tNumber,
            height: _validatorPrimitives.tNumber
          }))
        })),
        recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          omitContent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
          path: _validatorPrimitives.tString
        })),
        strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          server: _validatorPrimitives.tString,
          bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        })),
        storageState: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          cookies: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("SetNetworkCookie"))),
          origins: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("OriginStorage")))
        }))
      });
      scheme.BrowserNewBrowserCDPSessionParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserStartTracingParams = (0, _validatorPrimitives.tObject)({
        page: (0, _validatorPrimitives.tOptional)(tChannel("Page")),
        path: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        screenshots: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        categories: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))
      });
      scheme.BrowserStopTracingParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.EventTargetWaitForEventInfoParams = (0, _validatorPrimitives.tObject)({
        info: (0, _validatorPrimitives.tObject)({
          waitId: _validatorPrimitives.tString,
          phase: (0, _validatorPrimitives.tEnum)(["before", "after", "log"]),
          event: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          message: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          error: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        })
      });
      scheme.BrowserContextWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
      scheme.PageWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
      scheme.WebSocketWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
      scheme.ElectronApplicationWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
      scheme.AndroidDeviceWaitForEventInfoParams = tType("EventTargetWaitForEventInfoParams");
      scheme.BrowserContextAddCookiesParams = (0, _validatorPrimitives.tObject)({
        cookies: (0, _validatorPrimitives.tArray)(tType("SetNetworkCookie"))
      });
      scheme.BrowserContextAddInitScriptParams = (0, _validatorPrimitives.tObject)({
        source: _validatorPrimitives.tString
      });
      scheme.BrowserContextRemoveInitScriptsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserContextClearCookiesParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserContextClearPermissionsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserContextCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserContextCookiesParams = (0, _validatorPrimitives.tObject)({
        urls: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)
      });
      scheme.BrowserContextExposeBindingParams = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        needsHandle: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.BrowserContextRemoveExposedBindingsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserContextGrantPermissionsParams = (0, _validatorPrimitives.tObject)({
        permissions: (0, _validatorPrimitives.tArray)(_validatorPrimitives.tString),
        origin: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.BrowserContextNewPageParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserContextSetDefaultNavigationTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.BrowserContextSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.BrowserContextSetExtraHTTPHeadersParams = (0, _validatorPrimitives.tObject)({
        headers: (0, _validatorPrimitives.tArray)(tType("NameValue"))
      });
      scheme.BrowserContextSetGeolocationParams = (0, _validatorPrimitives.tObject)({
        geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          longitude: _validatorPrimitives.tNumber,
          latitude: _validatorPrimitives.tNumber,
          accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        }))
      });
      scheme.BrowserContextSetHTTPCredentialsParams = (0, _validatorPrimitives.tObject)({
        httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          username: _validatorPrimitives.tString,
          password: _validatorPrimitives.tString
        }))
      });
      scheme.BrowserContextSetNetworkInterceptionEnabledParams = (0, _validatorPrimitives.tObject)({
        enabled: _validatorPrimitives.tBoolean
      });
      scheme.BrowserContextSetOfflineParams = (0, _validatorPrimitives.tObject)({
        offline: _validatorPrimitives.tBoolean
      });
      scheme.BrowserContextStorageStateParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserContextPauseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserContextRecorderSupplementEnableParams = (0, _validatorPrimitives.tObject)({
        language: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        startRecording: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        pauseOnNextStatement: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        launchOptions: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
        contextOptions: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
        device: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        saveStorage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        outputFile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.BrowserContextNewCDPSessionParams = (0, _validatorPrimitives.tObject)({
        page: (0, _validatorPrimitives.tOptional)(tChannel("Page")),
        frame: (0, _validatorPrimitives.tOptional)(tChannel("Frame"))
      });
      scheme.BrowserContextHarExportParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.BrowserContextCreateTempFileParams = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString
      });
      scheme.PageSetDefaultNavigationTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.PageSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.PageSetFileChooserInterceptedNoReplyParams = (0, _validatorPrimitives.tObject)({
        intercepted: _validatorPrimitives.tBoolean
      });
      scheme.PageAddInitScriptParams = (0, _validatorPrimitives.tObject)({
        source: _validatorPrimitives.tString
      });
      scheme.PageRemoveInitScriptsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.PageCloseParams = (0, _validatorPrimitives.tObject)({
        runBeforeUnload: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.PageEmulateMediaParams = (0, _validatorPrimitives.tObject)({
        media: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["screen", "print", "null"])),
        colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference", "null"])),
        reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["reduce", "no-preference", "null"])),
        forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["active", "none", "null"]))
      });
      scheme.PageExposeBindingParams = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString,
        needsHandle: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.PageRemoveExposedBindingsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.PageGoBackParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        waitUntil: (0, _validatorPrimitives.tOptional)(tType("LifecycleEvent"))
      });
      scheme.PageGoForwardParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        waitUntil: (0, _validatorPrimitives.tOptional)(tType("LifecycleEvent"))
      });
      scheme.PageReloadParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        waitUntil: (0, _validatorPrimitives.tOptional)(tType("LifecycleEvent"))
      });
      scheme.PageExpectScreenshotParams = (0, _validatorPrimitives.tObject)({
        expected: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        isNot: _validatorPrimitives.tBoolean,
        locator: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          frame: tChannel("Frame"),
          selector: _validatorPrimitives.tString
        })),
        comparatorOptions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          maxDiffPixels: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
          maxDiffPixelRatio: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
          threshold: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        })),
        screenshotOptions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          fullPage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
          clip: (0, _validatorPrimitives.tOptional)(tType("Rect")),
          omitBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
          caret: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["hide", "initial"])),
          animations: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["disabled", "allow"])),
          scale: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["css", "device"])),
          fonts: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["ready", "nowait"])),
          mask: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
            frame: tChannel("Frame"),
            selector: _validatorPrimitives.tString
          })))
        }))
      });
      scheme.PageScreenshotParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        type: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["png", "jpeg"])),
        quality: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        fullPage: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        clip: (0, _validatorPrimitives.tOptional)(tType("Rect")),
        omitBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        caret: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["hide", "initial"])),
        animations: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["disabled", "allow"])),
        scale: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["css", "device"])),
        fonts: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["ready", "nowait"])),
        mask: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          frame: tChannel("Frame"),
          selector: _validatorPrimitives.tString
        })))
      });
      scheme.PageSetExtraHTTPHeadersParams = (0, _validatorPrimitives.tObject)({
        headers: (0, _validatorPrimitives.tArray)(tType("NameValue"))
      });
      scheme.PageSetNetworkInterceptionEnabledParams = (0, _validatorPrimitives.tObject)({
        enabled: _validatorPrimitives.tBoolean
      });
      scheme.PageSetViewportSizeParams = (0, _validatorPrimitives.tObject)({
        viewportSize: (0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        })
      });
      scheme.PageKeyboardDownParams = (0, _validatorPrimitives.tObject)({
        key: _validatorPrimitives.tString
      });
      scheme.PageKeyboardUpParams = (0, _validatorPrimitives.tObject)({
        key: _validatorPrimitives.tString
      });
      scheme.PageKeyboardInsertTextParams = (0, _validatorPrimitives.tObject)({
        text: _validatorPrimitives.tString
      });
      scheme.PageKeyboardTypeParams = (0, _validatorPrimitives.tObject)({
        text: _validatorPrimitives.tString,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.PageKeyboardPressParams = (0, _validatorPrimitives.tObject)({
        key: _validatorPrimitives.tString,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.PageMouseMoveParams = (0, _validatorPrimitives.tObject)({
        x: _validatorPrimitives.tNumber,
        y: _validatorPrimitives.tNumber,
        steps: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.PageMouseDownParams = (0, _validatorPrimitives.tObject)({
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.PageMouseUpParams = (0, _validatorPrimitives.tObject)({
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.PageMouseClickParams = (0, _validatorPrimitives.tObject)({
        x: _validatorPrimitives.tNumber,
        y: _validatorPrimitives.tNumber,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.PageMouseWheelParams = (0, _validatorPrimitives.tObject)({
        deltaX: _validatorPrimitives.tNumber,
        deltaY: _validatorPrimitives.tNumber
      });
      scheme.PageTouchscreenTapParams = (0, _validatorPrimitives.tObject)({
        x: _validatorPrimitives.tNumber,
        y: _validatorPrimitives.tNumber
      });
      scheme.PageAccessibilitySnapshotParams = (0, _validatorPrimitives.tObject)({
        interestingOnly: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        root: (0, _validatorPrimitives.tOptional)(tChannel("ElementHandle"))
      });
      scheme.PagePdfParams = (0, _validatorPrimitives.tObject)({
        scale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        displayHeaderFooter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        headerTemplate: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        footerTemplate: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        printBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        landscape: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        pageRanges: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        format: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        width: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        height: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        preferCSSPageSize: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        margin: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          top: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          bottom: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          left: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          right: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        }))
      });
      scheme.PageStartJSCoverageParams = (0, _validatorPrimitives.tObject)({
        resetOnNavigation: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        reportAnonymousScripts: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.PageStopJSCoverageParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.PageStartCSSCoverageParams = (0, _validatorPrimitives.tObject)({
        resetOnNavigation: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.PageStopCSSCoverageParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.PageBringToFrontParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.FrameEvalOnSelectorParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.FrameEvalOnSelectorAllParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.FrameAddScriptTagParams = (0, _validatorPrimitives.tObject)({
        url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        content: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        type: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.FrameAddStyleTagParams = (0, _validatorPrimitives.tObject)({
        url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        content: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.FrameCheckParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameClickParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameContentParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.FrameDragAndDropParams = (0, _validatorPrimitives.tObject)({
        source: _validatorPrimitives.tString,
        target: _validatorPrimitives.tString,
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        sourcePosition: (0, _validatorPrimitives.tOptional)(tType("Point")),
        targetPosition: (0, _validatorPrimitives.tOptional)(tType("Point")),
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameDblclickParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameDispatchEventParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        type: _validatorPrimitives.tString,
        eventInit: tType("SerializedArgument"),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.FrameEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.FrameFillParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        value: _validatorPrimitives.tString,
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameFocusParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameFrameElementParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.FrameHighlightParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString
      });
      scheme.FrameGetAttributeParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        name: _validatorPrimitives.tString,
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameGotoParams = (0, _validatorPrimitives.tObject)({
        url: _validatorPrimitives.tString,
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        waitUntil: (0, _validatorPrimitives.tOptional)(tType("LifecycleEvent")),
        referer: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.FrameHoverParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameInnerHTMLParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameInnerTextParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameInputValueParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameIsCheckedParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameIsDisabledParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameIsEnabledParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameIsHiddenParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameIsVisibleParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameIsEditableParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FramePressParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        key: _validatorPrimitives.tString,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameQuerySelectorParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameQuerySelectorAllParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString
      });
      scheme.FrameQueryCountParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString
      });
      scheme.FrameSelectOptionParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        elements: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tChannel("ElementHandle"))),
        options: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          label: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          index: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        }))),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameSetContentParams = (0, _validatorPrimitives.tObject)({
        html: _validatorPrimitives.tString,
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        waitUntil: (0, _validatorPrimitives.tOptional)(tType("LifecycleEvent"))
      });
      scheme.FrameSetInputFilesParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        files: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          name: _validatorPrimitives.tString,
          mimeType: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          buffer: _validatorPrimitives.tBinary
        })),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameSetInputFilePathsParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        localPaths: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        streams: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tChannel("WritableStream"))),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameTapParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameTextContentParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameTitleParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.FrameTypeParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        text: _validatorPrimitives.tString,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameUncheckParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameWaitForTimeoutParams = (0, _validatorPrimitives.tObject)({
        timeout: _validatorPrimitives.tNumber
      });
      scheme.FrameWaitForFunctionParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument"),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        pollingInterval: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.FrameWaitForSelectorParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        state: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["attached", "detached", "visible", "hidden"])),
        omitReturnValue: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.FrameExpectParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        expression: _validatorPrimitives.tString,
        expressionArg: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny),
        expectedText: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("ExpectedTextValue"))),
        expectedNumber: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        expectedValue: (0, _validatorPrimitives.tOptional)(tType("SerializedArgument")),
        useInnerText: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        isNot: _validatorPrimitives.tBoolean,
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.WorkerEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.WorkerEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.JSHandleDisposeParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleDisposeParams = tType("JSHandleDisposeParams");
      scheme.JSHandleEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.ElementHandleEvaluateExpressionParams = tType("JSHandleEvaluateExpressionParams");
      scheme.JSHandleEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.ElementHandleEvaluateExpressionHandleParams = tType("JSHandleEvaluateExpressionHandleParams");
      scheme.JSHandleGetPropertyListParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleGetPropertyListParams = tType("JSHandleGetPropertyListParams");
      scheme.JSHandleGetPropertyParams = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString
      });
      scheme.ElementHandleGetPropertyParams = tType("JSHandleGetPropertyParams");
      scheme.JSHandleJsonValueParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleJsonValueParams = tType("JSHandleJsonValueParams");
      scheme.ElementHandleEvalOnSelectorParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.ElementHandleEvalOnSelectorAllParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.ElementHandleBoundingBoxParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleCheckParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleClickParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        clickCount: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleContentFrameParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleDblclickParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        button: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["left", "right", "middle"])),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleDispatchEventParams = (0, _validatorPrimitives.tObject)({
        type: _validatorPrimitives.tString,
        eventInit: tType("SerializedArgument")
      });
      scheme.ElementHandleFillParams = (0, _validatorPrimitives.tObject)({
        value: _validatorPrimitives.tString,
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleFocusParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleGetAttributeParams = (0, _validatorPrimitives.tObject)({
        name: _validatorPrimitives.tString
      });
      scheme.ElementHandleHoverParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleInnerHTMLParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleInnerTextParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleInputValueParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleIsCheckedParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleIsDisabledParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleIsEditableParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleIsEnabledParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleIsHiddenParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleIsVisibleParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleOwnerFrameParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandlePressParams = (0, _validatorPrimitives.tObject)({
        key: _validatorPrimitives.tString,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleQuerySelectorParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleQuerySelectorAllParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString
      });
      scheme.ElementHandleScreenshotParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        type: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["png", "jpeg"])),
        quality: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        omitBackground: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        caret: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["hide", "initial"])),
        animations: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["disabled", "allow"])),
        scale: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["css", "device"])),
        fonts: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["ready", "nowait"])),
        mask: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          frame: tChannel("Frame"),
          selector: _validatorPrimitives.tString
        })))
      });
      scheme.ElementHandleScrollIntoViewIfNeededParams = (0, _validatorPrimitives.tObject)({
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.ElementHandleSelectOptionParams = (0, _validatorPrimitives.tObject)({
        elements: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tChannel("ElementHandle"))),
        options: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          value: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          label: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          index: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        }))),
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleSelectTextParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.ElementHandleSetInputFilesParams = (0, _validatorPrimitives.tObject)({
        files: (0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tObject)({
          name: _validatorPrimitives.tString,
          mimeType: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          buffer: _validatorPrimitives.tBinary
        })),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleSetInputFilePathsParams = (0, _validatorPrimitives.tObject)({
        localPaths: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        streams: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tChannel("WritableStream"))),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleTapParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        modifiers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)((0, _validatorPrimitives.tEnum)(["Alt", "Control", "Meta", "Shift"]))),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleTextContentParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElementHandleTypeParams = (0, _validatorPrimitives.tObject)({
        text: _validatorPrimitives.tString,
        delay: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.ElementHandleUncheckParams = (0, _validatorPrimitives.tObject)({
        force: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        noWaitAfter: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        position: (0, _validatorPrimitives.tOptional)(tType("Point")),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        trial: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.ElementHandleWaitForElementStateParams = (0, _validatorPrimitives.tObject)({
        state: (0, _validatorPrimitives.tEnum)(["visible", "hidden", "stable", "enabled", "disabled", "editable"]),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.ElementHandleWaitForSelectorParams = (0, _validatorPrimitives.tObject)({
        selector: _validatorPrimitives.tString,
        strict: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        state: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["attached", "detached", "visible", "hidden"]))
      });
      scheme.RequestResponseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.RequestRawRequestHeadersParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.RouteAbortParams = (0, _validatorPrimitives.tObject)({
        errorCode: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.RouteContinueParams = (0, _validatorPrimitives.tObject)({
        url: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        method: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        postData: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBinary)
      });
      scheme.RouteFulfillParams = (0, _validatorPrimitives.tObject)({
        status: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        headers: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        body: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        isBase64: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        fetchResponseUid: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.ResourceTiming = (0, _validatorPrimitives.tObject)({
        startTime: _validatorPrimitives.tNumber,
        domainLookupStart: _validatorPrimitives.tNumber,
        domainLookupEnd: _validatorPrimitives.tNumber,
        connectStart: _validatorPrimitives.tNumber,
        secureConnectionStart: _validatorPrimitives.tNumber,
        connectEnd: _validatorPrimitives.tNumber,
        requestStart: _validatorPrimitives.tNumber,
        responseStart: _validatorPrimitives.tNumber
      });
      scheme.ResponseBodyParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ResponseSecurityDetailsParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ResponseServerAddrParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ResponseRawResponseHeadersParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ResponseSizesParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.SecurityDetails = (0, _validatorPrimitives.tObject)({
        issuer: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        protocol: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        subjectName: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        validFrom: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        validTo: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.RequestSizes = (0, _validatorPrimitives.tObject)({
        requestBodySize: _validatorPrimitives.tNumber,
        requestHeadersSize: _validatorPrimitives.tNumber,
        responseBodySize: _validatorPrimitives.tNumber,
        responseHeadersSize: _validatorPrimitives.tNumber
      });
      scheme.RemoteAddr = (0, _validatorPrimitives.tObject)({
        ipAddress: _validatorPrimitives.tString,
        port: _validatorPrimitives.tNumber
      });
      scheme.BindingCallRejectParams = (0, _validatorPrimitives.tObject)({
        error: tType("SerializedError")
      });
      scheme.BindingCallResolveParams = (0, _validatorPrimitives.tObject)({
        result: tType("SerializedArgument")
      });
      scheme.DialogAcceptParams = (0, _validatorPrimitives.tObject)({
        promptText: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.DialogDismissParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.TracingTracingStartParams = (0, _validatorPrimitives.tObject)({
        name: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        snapshots: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        screenshots: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        sources: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.TracingTracingStartChunkParams = (0, _validatorPrimitives.tObject)({
        title: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.TracingTracingStopChunkParams = (0, _validatorPrimitives.tObject)({
        mode: (0, _validatorPrimitives.tEnum)(["doNotSave", "compressTrace", "compressTraceAndSources"])
      });
      scheme.TracingTracingStopParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ArtifactPathAfterFinishedParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ArtifactSaveAsParams = (0, _validatorPrimitives.tObject)({
        path: _validatorPrimitives.tString
      });
      scheme.ArtifactSaveAsStreamParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ArtifactFailureParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ArtifactStreamParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ArtifactCancelParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ArtifactDeleteParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.StreamReadParams = (0, _validatorPrimitives.tObject)({
        size: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.StreamCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.WritableStreamWriteParams = (0, _validatorPrimitives.tObject)({
        binary: _validatorPrimitives.tBinary
      });
      scheme.WritableStreamCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.CDPSessionSendParams = (0, _validatorPrimitives.tObject)({
        method: _validatorPrimitives.tString,
        params: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tAny)
      });
      scheme.CDPSessionDetachParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.ElectronLaunchParams = (0, _validatorPrimitives.tObject)({
        executablePath: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        cwd: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        env: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference"])),
        extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          longitude: _validatorPrimitives.tNumber,
          latitude: _validatorPrimitives.tNumber,
          accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        })),
        httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          username: _validatorPrimitives.tString,
          password: _validatorPrimitives.tString
        })),
        ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          omitContent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
          path: _validatorPrimitives.tString
        })),
        recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          dir: _validatorPrimitives.tString,
          size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
            width: _validatorPrimitives.tNumber,
            height: _validatorPrimitives.tNumber
          }))
        })),
        strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.ElectronApplicationBrowserWindowParams = (0, _validatorPrimitives.tObject)({
        page: tChannel("Page")
      });
      scheme.ElectronApplicationEvaluateExpressionParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.ElectronApplicationEvaluateExpressionHandleParams = (0, _validatorPrimitives.tObject)({
        expression: _validatorPrimitives.tString,
        isFunction: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        arg: tType("SerializedArgument")
      });
      scheme.ElectronApplicationCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.AndroidDevicesParams = (0, _validatorPrimitives.tObject)({
        port: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        omitDriverInstall: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean)
      });
      scheme.AndroidSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
        timeout: _validatorPrimitives.tNumber
      });
      scheme.AndroidSocketWriteParams = (0, _validatorPrimitives.tObject)({
        data: _validatorPrimitives.tBinary
      });
      scheme.AndroidSocketCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.AndroidDeviceWaitParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        state: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["gone"])),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDeviceFillParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        text: _validatorPrimitives.tString,
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDeviceTapParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        duration: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDeviceDragParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        dest: tType("Point"),
        speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDeviceFlingParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        direction: (0, _validatorPrimitives.tEnum)(["up", "down", "left", "right"]),
        speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDeviceLongTapParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDevicePinchCloseParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        percent: _validatorPrimitives.tNumber,
        speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDevicePinchOpenParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        percent: _validatorPrimitives.tNumber,
        speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDeviceScrollParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        direction: (0, _validatorPrimitives.tEnum)(["up", "down", "left", "right"]),
        percent: _validatorPrimitives.tNumber,
        speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDeviceSwipeParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector"),
        direction: (0, _validatorPrimitives.tEnum)(["up", "down", "left", "right"]),
        percent: _validatorPrimitives.tNumber,
        speed: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        timeout: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDeviceInfoParams = (0, _validatorPrimitives.tObject)({
        selector: tType("AndroidSelector")
      });
      scheme.AndroidDeviceScreenshotParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.AndroidDeviceInputTypeParams = (0, _validatorPrimitives.tObject)({
        text: _validatorPrimitives.tString
      });
      scheme.AndroidDeviceInputPressParams = (0, _validatorPrimitives.tObject)({
        key: _validatorPrimitives.tString
      });
      scheme.AndroidDeviceInputTapParams = (0, _validatorPrimitives.tObject)({
        point: tType("Point")
      });
      scheme.AndroidDeviceInputSwipeParams = (0, _validatorPrimitives.tObject)({
        segments: (0, _validatorPrimitives.tArray)(tType("Point")),
        steps: _validatorPrimitives.tNumber
      });
      scheme.AndroidDeviceInputDragParams = (0, _validatorPrimitives.tObject)({
        from: tType("Point"),
        to: tType("Point"),
        steps: _validatorPrimitives.tNumber
      });
      scheme.AndroidDeviceLaunchBrowserParams = (0, _validatorPrimitives.tObject)({
        noDefaultViewport: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        viewport: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        })),
        screen: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          width: _validatorPrimitives.tNumber,
          height: _validatorPrimitives.tNumber
        })),
        ignoreHTTPSErrors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        javaScriptEnabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        bypassCSP: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        userAgent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        locale: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        timezoneId: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        geolocation: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          longitude: _validatorPrimitives.tNumber,
          latitude: _validatorPrimitives.tNumber,
          accuracy: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        })),
        permissions: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString)),
        extraHTTPHeaders: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("NameValue"))),
        offline: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        httpCredentials: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          username: _validatorPrimitives.tString,
          password: _validatorPrimitives.tString
        })),
        deviceScaleFactor: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        isMobile: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        hasTouch: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        colorScheme: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["dark", "light", "no-preference"])),
        reducedMotion: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["reduce", "no-preference"])),
        forcedColors: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tEnum)(["active", "none"])),
        acceptDownloads: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        baseURL: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        recordVideo: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          dir: _validatorPrimitives.tString,
          size: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
            width: _validatorPrimitives.tNumber,
            height: _validatorPrimitives.tNumber
          }))
        })),
        recordHar: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          omitContent: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
          path: _validatorPrimitives.tString
        })),
        strictSelectors: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        pkg: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        proxy: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          server: _validatorPrimitives.tString,
          bypass: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          username: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
          password: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
        }))
      });
      scheme.AndroidDeviceOpenParams = (0, _validatorPrimitives.tObject)({
        command: _validatorPrimitives.tString
      });
      scheme.AndroidDeviceShellParams = (0, _validatorPrimitives.tObject)({
        command: _validatorPrimitives.tString
      });
      scheme.AndroidDeviceInstallApkParams = (0, _validatorPrimitives.tObject)({
        file: _validatorPrimitives.tBinary,
        args: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(_validatorPrimitives.tString))
      });
      scheme.AndroidDevicePushParams = (0, _validatorPrimitives.tObject)({
        file: _validatorPrimitives.tBinary,
        path: _validatorPrimitives.tString,
        mode: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
      });
      scheme.AndroidDeviceSetDefaultTimeoutNoReplyParams = (0, _validatorPrimitives.tObject)({
        timeout: _validatorPrimitives.tNumber
      });
      scheme.AndroidDeviceConnectToWebViewParams = (0, _validatorPrimitives.tObject)({
        pid: _validatorPrimitives.tNumber
      });
      scheme.AndroidDeviceCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      scheme.AndroidWebView = (0, _validatorPrimitives.tObject)({
        pid: _validatorPrimitives.tNumber,
        pkg: _validatorPrimitives.tString
      });
      scheme.AndroidSelector = (0, _validatorPrimitives.tObject)({
        checkable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        checked: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        clazz: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        clickable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        depth: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber),
        desc: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        enabled: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        focusable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        focused: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        hasChild: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          selector: tType("AndroidSelector")
        })),
        hasDescendant: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({
          selector: tType("AndroidSelector"),
          maxDepth: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tNumber)
        })),
        longClickable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        pkg: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        res: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString),
        scrollable: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        selected: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tBoolean),
        text: (0, _validatorPrimitives.tOptional)(_validatorPrimitives.tString)
      });
      scheme.AndroidElementInfo = (0, _validatorPrimitives.tObject)({
        children: (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tArray)(tType("AndroidElementInfo"))),
        clazz: _validatorPrimitives.tString,
        desc: _validatorPrimitives.tString,
        res: _validatorPrimitives.tString,
        pkg: _validatorPrimitives.tString,
        text: _validatorPrimitives.tString,
        bounds: tType("Rect"),
        checkable: _validatorPrimitives.tBoolean,
        checked: _validatorPrimitives.tBoolean,
        clickable: _validatorPrimitives.tBoolean,
        enabled: _validatorPrimitives.tBoolean,
        focusable: _validatorPrimitives.tBoolean,
        focused: _validatorPrimitives.tBoolean,
        longClickable: _validatorPrimitives.tBoolean,
        scrollable: _validatorPrimitives.tBoolean,
        selected: _validatorPrimitives.tBoolean
      });
      scheme.JsonPipeSendParams = (0, _validatorPrimitives.tObject)({
        message: _validatorPrimitives.tAny
      });
      scheme.JsonPipeCloseParams = (0, _validatorPrimitives.tOptional)((0, _validatorPrimitives.tObject)({}));
      return scheme;
    }
  }
});

// node_modules/playwright-core/lib/server/instrumentation.js
var require_instrumentation = __commonJS({
  "node_modules/playwright-core/lib/server/instrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SdkObject = void 0;
    exports2.createInstrumentation = createInstrumentation;
    exports2.serverSideCallMetadata = serverSideCallMetadata;
    var _events = require("events");
    var _utils = require_utils();
    var SdkObject = class extends _events.EventEmitter {
      constructor(parent, guidPrefix, guid) {
        super();
        this.guid = void 0;
        this.attribution = void 0;
        this.instrumentation = void 0;
        this.guid = guid || `${guidPrefix || ""}@${(0, _utils.createGuid)()}`;
        this.setMaxListeners(0);
        this.attribution = __spreadValues({}, parent.attribution);
        this.instrumentation = parent.instrumentation;
      }
    };
    exports2.SdkObject = SdkObject;
    function createInstrumentation() {
      const listeners = /* @__PURE__ */ new Map();
      return new Proxy({}, {
        get: (obj, prop) => {
          if (prop === "addListener")
            return (listener, context) => listeners.set(listener, context);
          if (prop === "removeListener")
            return (listener) => listeners.delete(listener);
          if (!prop.startsWith("on"))
            return obj[prop];
          return (sdkObject, ...params) => __async(this, null, function* () {
            for (const [listener, context] of listeners) {
              var _prop, _ref;
              if (!context || sdkObject.attribution.context === context)
                yield (_prop = (_ref = listener)[prop]) === null || _prop === void 0 ? void 0 : _prop.call(_ref, sdkObject, ...params);
            }
          });
        }
      });
    }
    function serverSideCallMetadata() {
      return {
        id: "",
        wallTime: 0,
        startTime: 0,
        endTime: 0,
        type: "Internal",
        method: "",
        params: {},
        log: [],
        snapshots: [],
        isServerSide: true
      };
    }
  }
});

// node_modules/stack-utils/node_modules/escape-string-regexp/index.js
var require_escape_string_regexp = __commonJS({
  "node_modules/stack-utils/node_modules/escape-string-regexp/index.js"(exports2, module2) {
    "use strict";
    var matchOperatorsRegex = /[|\\{}()[\]^$+*?.-]/g;
    module2.exports = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      return string.replace(matchOperatorsRegex, "\\$&");
    };
  }
});

// node_modules/stack-utils/index.js
var require_stack_utils = __commonJS({
  "node_modules/stack-utils/index.js"(exports2, module2) {
    "use strict";
    var escapeStringRegexp = require_escape_string_regexp();
    var cwd = typeof process === "object" && process && typeof process.cwd === "function" ? process.cwd() : ".";
    var natives = [].concat(require("module").builtinModules, "bootstrap_node", "node").map((n) => new RegExp(`(?:\\((?:node:)?${n}(?:\\.js)?:\\d+:\\d+\\)$|^\\s*at (?:node:)?${n}(?:\\.js)?:\\d+:\\d+$)`));
    natives.push(/\((?:node:)?internal\/[^:]+:\d+:\d+\)$/, /\s*at (?:node:)?internal\/[^:]+:\d+:\d+$/, /\/\.node-spawn-wrap-\w+-\w+\/node:\d+:\d+\)?$/);
    var StackUtils = class {
      constructor(opts) {
        opts = __spreadValues({
          ignoredPackages: []
        }, opts);
        if ("internals" in opts === false) {
          opts.internals = StackUtils.nodeInternals();
        }
        if ("cwd" in opts === false) {
          opts.cwd = cwd;
        }
        this._cwd = opts.cwd.replace(/\\/g, "/");
        this._internals = [].concat(opts.internals, ignoredPackagesRegExp(opts.ignoredPackages));
        this._wrapCallSite = opts.wrapCallSite || false;
      }
      static nodeInternals() {
        return [...natives];
      }
      clean(stack, indent = 0) {
        indent = " ".repeat(indent);
        if (!Array.isArray(stack)) {
          stack = stack.split("\n");
        }
        if (!/^\s*at /.test(stack[0]) && /^\s*at /.test(stack[1])) {
          stack = stack.slice(1);
        }
        let outdent = false;
        let lastNonAtLine = null;
        const result = [];
        stack.forEach((st) => {
          st = st.replace(/\\/g, "/");
          if (this._internals.some((internal) => internal.test(st))) {
            return;
          }
          const isAtLine = /^\s*at /.test(st);
          if (outdent) {
            st = st.trimEnd().replace(/^(\s+)at /, "$1");
          } else {
            st = st.trim();
            if (isAtLine) {
              st = st.slice(3);
            }
          }
          st = st.replace(`${this._cwd}/`, "");
          if (st) {
            if (isAtLine) {
              if (lastNonAtLine) {
                result.push(lastNonAtLine);
                lastNonAtLine = null;
              }
              result.push(st);
            } else {
              outdent = true;
              lastNonAtLine = st;
            }
          }
        });
        return result.map((line) => `${indent}${line}
`).join("");
      }
      captureString(limit, fn = this.captureString) {
        if (typeof limit === "function") {
          fn = limit;
          limit = Infinity;
        }
        const { stackTraceLimit } = Error;
        if (limit) {
          Error.stackTraceLimit = limit;
        }
        const obj = {};
        Error.captureStackTrace(obj, fn);
        const { stack } = obj;
        Error.stackTraceLimit = stackTraceLimit;
        return this.clean(stack);
      }
      capture(limit, fn = this.capture) {
        if (typeof limit === "function") {
          fn = limit;
          limit = Infinity;
        }
        const { prepareStackTrace, stackTraceLimit } = Error;
        Error.prepareStackTrace = (obj2, site) => {
          if (this._wrapCallSite) {
            return site.map(this._wrapCallSite);
          }
          return site;
        };
        if (limit) {
          Error.stackTraceLimit = limit;
        }
        const obj = {};
        Error.captureStackTrace(obj, fn);
        const { stack } = obj;
        Object.assign(Error, { prepareStackTrace, stackTraceLimit });
        return stack;
      }
      at(fn = this.at) {
        const [site] = this.capture(1, fn);
        if (!site) {
          return {};
        }
        const res = {
          line: site.getLineNumber(),
          column: site.getColumnNumber()
        };
        setFile(res, site.getFileName(), this._cwd);
        if (site.isConstructor()) {
          res.constructor = true;
        }
        if (site.isEval()) {
          res.evalOrigin = site.getEvalOrigin();
        }
        if (site.isNative()) {
          res.native = true;
        }
        let typename;
        try {
          typename = site.getTypeName();
        } catch (_) {
        }
        if (typename && typename !== "Object" && typename !== "[object Object]") {
          res.type = typename;
        }
        const fname = site.getFunctionName();
        if (fname) {
          res.function = fname;
        }
        const meth = site.getMethodName();
        if (meth && fname !== meth) {
          res.method = meth;
        }
        return res;
      }
      parseLine(line) {
        const match = line && line.match(re);
        if (!match) {
          return null;
        }
        const ctor = match[1] === "new";
        let fname = match[2];
        const evalOrigin = match[3];
        const evalFile = match[4];
        const evalLine = Number(match[5]);
        const evalCol = Number(match[6]);
        let file = match[7];
        const lnum = match[8];
        const col = match[9];
        const native = match[10] === "native";
        const closeParen = match[11] === ")";
        let method;
        const res = {};
        if (lnum) {
          res.line = Number(lnum);
        }
        if (col) {
          res.column = Number(col);
        }
        if (closeParen && file) {
          let closes = 0;
          for (let i = file.length - 1; i > 0; i--) {
            if (file.charAt(i) === ")") {
              closes++;
            } else if (file.charAt(i) === "(" && file.charAt(i - 1) === " ") {
              closes--;
              if (closes === -1 && file.charAt(i - 1) === " ") {
                const before = file.slice(0, i - 1);
                const after = file.slice(i + 1);
                file = after;
                fname += ` (${before}`;
                break;
              }
            }
          }
        }
        if (fname) {
          const methodMatch = fname.match(methodRe);
          if (methodMatch) {
            fname = methodMatch[1];
            method = methodMatch[2];
          }
        }
        setFile(res, file, this._cwd);
        if (ctor) {
          res.constructor = true;
        }
        if (evalOrigin) {
          res.evalOrigin = evalOrigin;
          res.evalLine = evalLine;
          res.evalColumn = evalCol;
          res.evalFile = evalFile && evalFile.replace(/\\/g, "/");
        }
        if (native) {
          res.native = true;
        }
        if (fname) {
          res.function = fname;
        }
        if (method && fname !== method) {
          res.method = method;
        }
        return res;
      }
    };
    function setFile(result, filename, cwd2) {
      if (filename) {
        filename = filename.replace(/\\/g, "/");
        if (filename.startsWith(`${cwd2}/`)) {
          filename = filename.slice(cwd2.length + 1);
        }
        result.file = filename;
      }
    }
    function ignoredPackagesRegExp(ignoredPackages) {
      if (ignoredPackages.length === 0) {
        return [];
      }
      const packages = ignoredPackages.map((mod) => escapeStringRegexp(mod));
      return new RegExp(`[/\\\\]node_modules[/\\\\](?:${packages.join("|")})[/\\\\][^:]+:\\d+:\\d+`);
    }
    var re = new RegExp("^(?:\\s*at )?(?:(new) )?(?:(.*?) \\()?(?:eval at ([^ ]+) \\((.+?):(\\d+):(\\d+)\\), )?(?:(.+?):(\\d+):(\\d+)|(native))(\\)?)$");
    var methodRe = /^(.*?) \[as (.*?)\]$/;
    module2.exports = StackUtils;
  }
});

// node_modules/playwright-core/lib/utils/stackTrace.js
var require_stackTrace = __commonJS({
  "node_modules/playwright-core/lib/utils/stackTrace.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.captureRawStack = captureRawStack;
    exports2.captureStackTrace = captureStackTrace;
    exports2.isInternalFileName = isInternalFileName;
    exports2.rewriteErrorMessage = rewriteErrorMessage;
    exports2.splitErrorMessage = splitErrorMessage;
    var _path = _interopRequireDefault(require("path"));
    var _stackUtils = _interopRequireDefault(require_stack_utils());
    var _ = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var stackUtils = new _stackUtils.default();
    function rewriteErrorMessage(e, newMessage) {
      var _e$stack;
      const lines = (((_e$stack = e.stack) === null || _e$stack === void 0 ? void 0 : _e$stack.split("\n")) || []).filter((l) => l.startsWith("    at "));
      e.message = newMessage;
      const errorTitle = `${e.name}: ${e.message}`;
      if (lines.length)
        e.stack = `${errorTitle}
${lines.join("\n")}`;
      return e;
    }
    var CORE_DIR = _path.default.resolve(__dirname, "..", "..");
    var CORE_LIB = _path.default.join(CORE_DIR, "lib");
    var CORE_SRC = _path.default.join(CORE_DIR, "src");
    var TEST_DIR_SRC = _path.default.resolve(CORE_DIR, "..", "playwright-test");
    var TEST_DIR_LIB = _path.default.resolve(CORE_DIR, "..", "@playwright", "test");
    var COVERAGE_PATH = _path.default.join(CORE_DIR, "..", "..", "tests", "config", "coverage.js");
    var WS_LIB = _path.default.relative(process.cwd(), _path.default.dirname(require.resolve("ws")));
    function captureRawStack() {
      const stackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 30;
      const error = new Error();
      const stack = error.stack;
      Error.stackTraceLimit = stackTraceLimit;
      return stack;
    }
    function isInternalFileName(file, functionName) {
      if (file.startsWith("internal") || file.startsWith("node:"))
        return true;
      if (file === "events.js" && functionName !== null && functionName !== void 0 && functionName.endsWith("emit"))
        return true;
      if (file === "_stream_readable.js" || file === "_stream_writable.js")
        return true;
      if (file.startsWith(WS_LIB))
        return true;
      return false;
    }
    function captureStackTrace(rawStack) {
      const stack = rawStack || captureRawStack();
      const isTesting = (0, _.isUnderTest)();
      let parsedFrames = stack.split("\n").map((line) => {
        const frame = stackUtils.parseLine(line);
        if (!frame || !frame.file)
          return null;
        if (isInternalFileName(frame.file, frame.function))
          return null;
        let fileName;
        if (frame.file.startsWith("file://"))
          fileName = new URL(frame.file).pathname;
        else
          fileName = _path.default.resolve(process.cwd(), frame.file);
        if (isTesting && fileName.includes(COVERAGE_PATH))
          return null;
        const inCore = fileName.startsWith(CORE_LIB) || fileName.startsWith(CORE_SRC);
        const parsed = {
          frame: {
            file: fileName,
            line: frame.line,
            column: frame.column,
            function: frame.function
          },
          frameText: line,
          inCore
        };
        return parsed;
      }).filter(Boolean);
      let apiName = "";
      const allFrames = parsedFrames;
      for (let i = 0; i < parsedFrames.length - 1; i++) {
        if (parsedFrames[i].inCore && !parsedFrames[i + 1].inCore) {
          const frame = parsedFrames[i].frame;
          apiName = normalizeAPIName(frame.function);
          parsedFrames = parsedFrames.slice(i + 1);
          break;
        }
      }
      function normalizeAPIName(name) {
        if (!name)
          return "";
        const match = name.match(/(API|JS|CDP|[A-Z])(.*)/);
        if (!match)
          return name;
        return match[1].toLowerCase() + match[2];
      }
      parsedFrames = parsedFrames.filter((f, i) => {
        if (f.frame.file.startsWith(TEST_DIR_SRC) || f.frame.file.startsWith(TEST_DIR_LIB))
          return false;
        if (i && f.frame.file.startsWith(CORE_DIR))
          return false;
        return true;
      });
      return {
        allFrames: allFrames.map((p) => p.frame),
        frames: parsedFrames.map((p) => p.frame),
        frameTexts: parsedFrames.map((p) => p.frameText),
        apiName
      };
    }
    function splitErrorMessage(message) {
      const separationIdx = message.indexOf(":");
      return {
        name: separationIdx !== -1 ? message.slice(0, separationIdx) : "",
        message: separationIdx !== -1 && separationIdx + 2 <= message.length ? message.substring(separationIdx + 2) : message
      };
    }
  }
});

// node_modules/playwright-core/lib/server/dispatchers/dispatcher.js
var require_dispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/dispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.dispatcherSymbol = exports2.Root = exports2.DispatcherConnection = exports2.Dispatcher = void 0;
    exports2.existingDispatcher = existingDispatcher;
    exports2.lookupDispatcher = lookupDispatcher;
    exports2.lookupNullableDispatcher = lookupNullableDispatcher;
    var _events = require("events");
    var _serializers = require_serializers();
    var _validator = require_validator();
    var _utils = require_utils();
    var _validatorPrimitives = require_validatorPrimitives();
    var _errors = require_errors();
    var _instrumentation = require_instrumentation();
    var _stackTrace = require_stackTrace();
    var dispatcherSymbol = Symbol("dispatcher");
    exports2.dispatcherSymbol = dispatcherSymbol;
    function lookupDispatcher(object) {
      const result = object[dispatcherSymbol];
      (0, _utils.debugAssert)(result);
      return result;
    }
    function existingDispatcher(object) {
      return object[dispatcherSymbol];
    }
    function lookupNullableDispatcher(object) {
      return object ? lookupDispatcher(object) : void 0;
    }
    var Dispatcher = class extends _events.EventEmitter {
      constructor(parent, object, type, initializer, isScope) {
        super();
        this._connection = void 0;
        this._isScope = void 0;
        this._parent = void 0;
        this._dispatchers = /* @__PURE__ */ new Map();
        this._disposed = false;
        this._guid = void 0;
        this._type = void 0;
        this._scope = void 0;
        this._object = void 0;
        this._connection = parent instanceof DispatcherConnection ? parent : parent._connection;
        this._isScope = !!isScope;
        this._parent = parent instanceof DispatcherConnection ? void 0 : parent;
        this._scope = isScope ? this : this._parent;
        const guid = object.guid;
        (0, _utils.assert)(!this._connection._dispatchers.has(guid));
        this._connection._dispatchers.set(guid, this);
        if (this._parent) {
          (0, _utils.assert)(!this._parent._dispatchers.has(guid));
          this._parent._dispatchers.set(guid, this);
        }
        this._type = type;
        this._guid = guid;
        this._object = object;
        object[dispatcherSymbol] = this;
        if (this._parent)
          this._connection.sendMessageToClient(this._parent._guid, type, "__create__", {
            type,
            initializer,
            guid
          }, this._parent._object);
      }
      _dispatchEvent(method, params) {
        if (this._disposed) {
          if ((0, _utils.isUnderTest)())
            throw new Error(`${this._guid} is sending "${method}" event after being disposed`);
          return;
        }
        const sdkObject = this._object instanceof _instrumentation.SdkObject ? this._object : void 0;
        this._connection.sendMessageToClient(this._guid, this._type, method, params, sdkObject);
      }
      _dispose() {
        (0, _utils.assert)(!this._disposed);
        this._disposed = true;
        if (this._parent)
          this._parent._dispatchers.delete(this._guid);
        this._connection._dispatchers.delete(this._guid);
        for (const dispatcher of [...this._dispatchers.values()])
          dispatcher._dispose();
        this._dispatchers.clear();
        if (this._isScope)
          this._connection.sendMessageToClient(this._guid, this._type, "__dispose__", {});
      }
      _debugScopeState() {
        return {
          _guid: this._guid,
          objects: Array.from(this._dispatchers.values()).map((o) => o._debugScopeState())
        };
      }
      waitForEventInfo() {
        return __async(this, null, function* () {
        });
      }
    };
    exports2.Dispatcher = Dispatcher;
    var Root = class extends Dispatcher {
      constructor(connection, createPlaywright) {
        super(connection, {
          guid: ""
        }, "Root", {}, true);
        this._initialized = false;
        this.createPlaywright = createPlaywright;
      }
      initialize(params) {
        return __async(this, null, function* () {
          (0, _utils.assert)(this.createPlaywright);
          (0, _utils.assert)(!this._initialized);
          this._initialized = true;
          return {
            playwright: yield this.createPlaywright(this, params)
          };
        });
      }
    };
    exports2.Root = Root;
    var DispatcherConnection = class {
      sendMessageToClient(guid, type, method, params, sdkObject) {
        params = this._replaceDispatchersWithGuids(params);
        if (sdkObject) {
          var _sdkObject$attributio, _sdkObject$attributio2, _sdkObject$attributio3, _sdkObject$attributio4, _sdkObject$instrument;
          const eventMetadata = {
            id: `event@${++lastEventId}`,
            objectId: sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.guid,
            pageId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio = sdkObject.attribution) === null || _sdkObject$attributio === void 0 ? void 0 : (_sdkObject$attributio2 = _sdkObject$attributio.page) === null || _sdkObject$attributio2 === void 0 ? void 0 : _sdkObject$attributio2.guid,
            frameId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio3 = sdkObject.attribution) === null || _sdkObject$attributio3 === void 0 ? void 0 : (_sdkObject$attributio4 = _sdkObject$attributio3.frame) === null || _sdkObject$attributio4 === void 0 ? void 0 : _sdkObject$attributio4.guid,
            wallTime: Date.now(),
            startTime: (0, _utils.monotonicTime)(),
            endTime: 0,
            type,
            method,
            params: params || {},
            log: [],
            snapshots: []
          };
          (_sdkObject$instrument = sdkObject.instrumentation) === null || _sdkObject$instrument === void 0 ? void 0 : _sdkObject$instrument.onEvent(sdkObject, eventMetadata);
        }
        this.onmessage({
          guid,
          method,
          params
        });
      }
      constructor() {
        this._dispatchers = /* @__PURE__ */ new Map();
        this.onmessage = (message) => {
        };
        this._validateParams = void 0;
        this._validateMetadata = void 0;
        this._waitOperations = /* @__PURE__ */ new Map();
        const tChannel = (name) => {
          return (arg, path) => {
            if (arg && typeof arg === "object" && typeof arg.guid === "string") {
              const guid = arg.guid;
              const dispatcher = this._dispatchers.get(guid);
              if (!dispatcher)
                throw new _validator.ValidationError(`${path}: no object with guid ${guid}`);
              if (name !== "*" && dispatcher._type !== name)
                throw new _validator.ValidationError(`${path}: object with guid ${guid} has type ${dispatcher._type}, expected ${name}`);
              return dispatcher;
            }
            throw new _validator.ValidationError(`${path}: expected ${name}`);
          };
        };
        const scheme = (0, _validator.createScheme)(tChannel);
        this._validateParams = (type, method, params) => {
          const name = type + method[0].toUpperCase() + method.substring(1) + "Params";
          if (!scheme[name])
            throw new _validator.ValidationError(`Unknown scheme for ${type}.${method}`);
          return scheme[name](params, "");
        };
        this._validateMetadata = (metadata) => {
          return (0, _validatorPrimitives.tOptional)(scheme["Metadata"])(metadata, "");
        };
      }
      dispatch(message) {
        return __async(this, null, function* () {
          var _sdkObject$attributio5, _sdkObject$attributio6, _sdkObject$attributio7, _sdkObject$attributio8, _params$info;
          const {
            id,
            guid,
            method,
            params,
            metadata
          } = message;
          const dispatcher = this._dispatchers.get(guid);
          if (!dispatcher) {
            this.onmessage({
              id,
              error: (0, _serializers.serializeError)(new Error(_errors.kBrowserOrContextClosedError))
            });
            return;
          }
          if (method === "debugScopeState") {
            const rootDispatcher = this._dispatchers.get("");
            this.onmessage({
              id,
              result: rootDispatcher._debugScopeState()
            });
            return;
          }
          let validParams;
          let validMetadata;
          try {
            validParams = this._validateParams(dispatcher._type, method, params);
            validMetadata = this._validateMetadata(metadata);
            if (typeof dispatcher[method] !== "function")
              throw new Error(`Mismatching dispatcher: "${dispatcher._type}" does not implement "${method}"`);
          } catch (e) {
            this.onmessage({
              id,
              error: (0, _serializers.serializeError)(e)
            });
            return;
          }
          const sdkObject = dispatcher._object instanceof _instrumentation.SdkObject ? dispatcher._object : void 0;
          const callMetadata = {
            id: `call@${id}`,
            stack: validMetadata.stack,
            apiName: validMetadata.apiName,
            internal: validMetadata.internal,
            objectId: sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.guid,
            pageId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio5 = sdkObject.attribution) === null || _sdkObject$attributio5 === void 0 ? void 0 : (_sdkObject$attributio6 = _sdkObject$attributio5.page) === null || _sdkObject$attributio6 === void 0 ? void 0 : _sdkObject$attributio6.guid,
            frameId: sdkObject === null || sdkObject === void 0 ? void 0 : (_sdkObject$attributio7 = sdkObject.attribution) === null || _sdkObject$attributio7 === void 0 ? void 0 : (_sdkObject$attributio8 = _sdkObject$attributio7.frame) === null || _sdkObject$attributio8 === void 0 ? void 0 : _sdkObject$attributio8.guid,
            wallTime: Date.now(),
            startTime: (0, _utils.monotonicTime)(),
            endTime: 0,
            type: dispatcher._type,
            method,
            params: params || {},
            log: [],
            snapshots: []
          };
          if (sdkObject && params !== null && params !== void 0 && (_params$info = params.info) !== null && _params$info !== void 0 && _params$info.waitId) {
            const info = params.info;
            switch (info.phase) {
              case "before": {
                this._waitOperations.set(info.waitId, callMetadata);
                yield sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata);
                this.onmessage({
                  id
                });
                return;
              }
              case "log": {
                const originalMetadata = this._waitOperations.get(info.waitId);
                originalMetadata.log.push(info.message);
                sdkObject.instrumentation.onCallLog(sdkObject, originalMetadata, "api", info.message);
                this.onmessage({
                  id
                });
                return;
              }
              case "after": {
                const originalMetadata = this._waitOperations.get(info.waitId);
                originalMetadata.endTime = (0, _utils.monotonicTime)();
                originalMetadata.error = info.error ? {
                  error: {
                    name: "Error",
                    message: info.error
                  }
                } : void 0;
                this._waitOperations.delete(info.waitId);
                yield sdkObject.instrumentation.onAfterCall(sdkObject, originalMetadata);
                this.onmessage({
                  id
                });
                return;
              }
            }
          }
          let error;
          yield sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.instrumentation.onBeforeCall(sdkObject, callMetadata);
          try {
            const result = yield dispatcher[method](validParams, callMetadata);
            callMetadata.result = this._replaceDispatchersWithGuids(result);
          } catch (e) {
            callMetadata.error = (0, _serializers.serializeError)(e);
            if (callMetadata.log.length)
              (0, _stackTrace.rewriteErrorMessage)(e, e.message + formatLogRecording(callMetadata.log));
            error = (0, _serializers.serializeError)(e);
          } finally {
            callMetadata.endTime = (0, _utils.monotonicTime)();
            yield sdkObject === null || sdkObject === void 0 ? void 0 : sdkObject.instrumentation.onAfterCall(sdkObject, callMetadata);
          }
          const response = {
            id
          };
          if (callMetadata.result)
            response.result = callMetadata.result;
          if (error)
            response.error = error;
          this.onmessage(response);
        });
      }
      _replaceDispatchersWithGuids(payload) {
        if (!payload)
          return payload;
        if (payload instanceof Dispatcher)
          return {
            guid: payload._guid
          };
        if (Array.isArray(payload))
          return payload.map((p) => this._replaceDispatchersWithGuids(p));
        if (typeof payload === "object") {
          const result = {};
          for (const key of Object.keys(payload))
            result[key] = this._replaceDispatchersWithGuids(payload[key]);
          return result;
        }
        return payload;
      }
    };
    exports2.DispatcherConnection = DispatcherConnection;
    function formatLogRecording(log) {
      if (!log.length)
        return "";
      const header = ` logs `;
      const headerLength = 60;
      const leftLength = (headerLength - header.length) / 2;
      const rightLength = headerLength - header.length - leftLength;
      return `
${"=".repeat(leftLength)}${header}${"=".repeat(rightLength)}
${log.join("\n")}
${"=".repeat(headerLength)}`;
    }
    var lastEventId = 0;
  }
});

// node_modules/smart-buffer/build/utils.js
var require_utils2 = __commonJS({
  "node_modules/smart-buffer/build/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var buffer_1 = require("buffer");
    var ERRORS = {
      INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
      INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.",
      INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.",
      INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
      INVALID_OFFSET: "An invalid offset value was provided.",
      INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.",
      INVALID_LENGTH: "An invalid length value was provided.",
      INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.",
      INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.",
      INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
      INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.",
      INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data."
    };
    exports2.ERRORS = ERRORS;
    function checkEncoding(encoding) {
      if (!buffer_1.Buffer.isEncoding(encoding)) {
        throw new Error(ERRORS.INVALID_ENCODING);
      }
    }
    exports2.checkEncoding = checkEncoding;
    function isFiniteInteger(value) {
      return typeof value === "number" && isFinite(value) && isInteger(value);
    }
    exports2.isFiniteInteger = isFiniteInteger;
    function checkOffsetOrLengthValue(value, offset) {
      if (typeof value === "number") {
        if (!isFiniteInteger(value) || value < 0) {
          throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);
        }
      } else {
        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);
      }
    }
    function checkLengthValue(length) {
      checkOffsetOrLengthValue(length, false);
    }
    exports2.checkLengthValue = checkLengthValue;
    function checkOffsetValue(offset) {
      checkOffsetOrLengthValue(offset, true);
    }
    exports2.checkOffsetValue = checkOffsetValue;
    function checkTargetOffset(offset, buff) {
      if (offset < 0 || offset > buff.length) {
        throw new Error(ERRORS.INVALID_TARGET_OFFSET);
      }
    }
    exports2.checkTargetOffset = checkTargetOffset;
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    }
    function bigIntAndBufferInt64Check(bufferMethod) {
      if (typeof BigInt === "undefined") {
        throw new Error("Platform does not support JS BigInt type.");
      }
      if (typeof buffer_1.Buffer.prototype[bufferMethod] === "undefined") {
        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
      }
    }
    exports2.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
  }
});

// node_modules/smart-buffer/build/smartbuffer.js
var require_smartbuffer = __commonJS({
  "node_modules/smart-buffer/build/smartbuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils_1 = require_utils2();
    var DEFAULT_SMARTBUFFER_SIZE = 4096;
    var DEFAULT_SMARTBUFFER_ENCODING = "utf8";
    var SmartBuffer = class {
      constructor(options) {
        this.length = 0;
        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
        this._writeOffset = 0;
        this._readOffset = 0;
        if (SmartBuffer.isSmartBufferOptions(options)) {
          if (options.encoding) {
            utils_1.checkEncoding(options.encoding);
            this._encoding = options.encoding;
          }
          if (options.size) {
            if (utils_1.isFiniteInteger(options.size) && options.size > 0) {
              this._buff = Buffer.allocUnsafe(options.size);
            } else {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
            }
          } else if (options.buff) {
            if (Buffer.isBuffer(options.buff)) {
              this._buff = options.buff;
              this.length = options.buff.length;
            } else {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
            }
          } else {
            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
          }
        } else {
          if (typeof options !== "undefined") {
            throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
          }
          this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
        }
      }
      static fromSize(size, encoding) {
        return new this({
          size,
          encoding
        });
      }
      static fromBuffer(buff, encoding) {
        return new this({
          buff,
          encoding
        });
      }
      static fromOptions(options) {
        return new this(options);
      }
      static isSmartBufferOptions(options) {
        const castOptions = options;
        return castOptions && (castOptions.encoding !== void 0 || castOptions.size !== void 0 || castOptions.buff !== void 0);
      }
      readInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
      }
      readInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
      }
      readInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
      }
      readInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
      }
      readInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
      }
      readBigInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigInt64BE");
        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);
      }
      readBigInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigInt64LE");
        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);
      }
      writeInt8(value, offset) {
        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
        return this;
      }
      insertInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
      }
      writeInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
      }
      insertInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);
      }
      writeInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
      }
      insertInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);
      }
      writeInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
      }
      insertInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);
      }
      writeInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
      }
      insertInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);
      }
      writeBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
      }
      insertBigInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);
      }
      writeBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
      }
      insertBigInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);
      }
      readUInt8(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
      }
      readUInt16BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);
      }
      readUInt16LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);
      }
      readUInt32BE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);
      }
      readUInt32LE(offset) {
        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);
      }
      readBigUInt64BE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigUInt64BE");
        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);
      }
      readBigUInt64LE(offset) {
        utils_1.bigIntAndBufferInt64Check("readBigUInt64LE");
        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);
      }
      writeUInt8(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
      }
      insertUInt8(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);
      }
      writeUInt16BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
      }
      insertUInt16BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);
      }
      writeUInt16LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
      }
      insertUInt16LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);
      }
      writeUInt32BE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
      }
      insertUInt32BE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);
      }
      writeUInt32LE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
      }
      insertUInt32LE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);
      }
      writeBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
      }
      insertBigUInt64BE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);
      }
      writeBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
      }
      insertBigUInt64LE(value, offset) {
        utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);
      }
      readFloatBE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
      }
      readFloatLE(offset) {
        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
      }
      writeFloatBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
      }
      insertFloatBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);
      }
      writeFloatLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
      }
      insertFloatLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);
      }
      readDoubleBE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);
      }
      readDoubleLE(offset) {
        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);
      }
      writeDoubleBE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
      }
      insertDoubleBE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);
      }
      writeDoubleLE(value, offset) {
        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
      }
      insertDoubleLE(value, offset) {
        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);
      }
      readString(arg1, encoding) {
        let lengthVal;
        if (typeof arg1 === "number") {
          utils_1.checkLengthValue(arg1);
          lengthVal = Math.min(arg1, this.length - this._readOffset);
        } else {
          encoding = arg1;
          lengthVal = this.length - this._readOffset;
        }
        if (typeof encoding !== "undefined") {
          utils_1.checkEncoding(encoding);
        }
        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);
        this._readOffset += lengthVal;
        return value;
      }
      insertString(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        return this._handleString(value, true, offset, encoding);
      }
      writeString(value, arg2, encoding) {
        return this._handleString(value, false, arg2, encoding);
      }
      readStringNT(encoding) {
        if (typeof encoding !== "undefined") {
          utils_1.checkEncoding(encoding);
        }
        let nullPos = this.length;
        for (let i = this._readOffset; i < this.length; i++) {
          if (this._buff[i] === 0) {
            nullPos = i;
            break;
          }
        }
        const value = this._buff.slice(this._readOffset, nullPos);
        this._readOffset = nullPos + 1;
        return value.toString(encoding || this._encoding);
      }
      insertStringNT(value, offset, encoding) {
        utils_1.checkOffsetValue(offset);
        this.insertString(value, offset, encoding);
        this.insertUInt8(0, offset + value.length);
        return this;
      }
      writeStringNT(value, arg2, encoding) {
        this.writeString(value, arg2, encoding);
        this.writeUInt8(0, typeof arg2 === "number" ? arg2 + value.length : this.writeOffset);
        return this;
      }
      readBuffer(length) {
        if (typeof length !== "undefined") {
          utils_1.checkLengthValue(length);
        }
        const lengthVal = typeof length === "number" ? length : this.length;
        const endPoint = Math.min(this.length, this._readOffset + lengthVal);
        const value = this._buff.slice(this._readOffset, endPoint);
        this._readOffset = endPoint;
        return value;
      }
      insertBuffer(value, offset) {
        utils_1.checkOffsetValue(offset);
        return this._handleBuffer(value, true, offset);
      }
      writeBuffer(value, offset) {
        return this._handleBuffer(value, false, offset);
      }
      readBufferNT() {
        let nullPos = this.length;
        for (let i = this._readOffset; i < this.length; i++) {
          if (this._buff[i] === 0) {
            nullPos = i;
            break;
          }
        }
        const value = this._buff.slice(this._readOffset, nullPos);
        this._readOffset = nullPos + 1;
        return value;
      }
      insertBufferNT(value, offset) {
        utils_1.checkOffsetValue(offset);
        this.insertBuffer(value, offset);
        this.insertUInt8(0, offset + value.length);
        return this;
      }
      writeBufferNT(value, offset) {
        if (typeof offset !== "undefined") {
          utils_1.checkOffsetValue(offset);
        }
        this.writeBuffer(value, offset);
        this.writeUInt8(0, typeof offset === "number" ? offset + value.length : this._writeOffset);
        return this;
      }
      clear() {
        this._writeOffset = 0;
        this._readOffset = 0;
        this.length = 0;
        return this;
      }
      remaining() {
        return this.length - this._readOffset;
      }
      get readOffset() {
        return this._readOffset;
      }
      set readOffset(offset) {
        utils_1.checkOffsetValue(offset);
        utils_1.checkTargetOffset(offset, this);
        this._readOffset = offset;
      }
      get writeOffset() {
        return this._writeOffset;
      }
      set writeOffset(offset) {
        utils_1.checkOffsetValue(offset);
        utils_1.checkTargetOffset(offset, this);
        this._writeOffset = offset;
      }
      get encoding() {
        return this._encoding;
      }
      set encoding(encoding) {
        utils_1.checkEncoding(encoding);
        this._encoding = encoding;
      }
      get internalBuffer() {
        return this._buff;
      }
      toBuffer() {
        return this._buff.slice(0, this.length);
      }
      toString(encoding) {
        const encodingVal = typeof encoding === "string" ? encoding : this._encoding;
        utils_1.checkEncoding(encodingVal);
        return this._buff.toString(encodingVal, 0, this.length);
      }
      destroy() {
        this.clear();
        return this;
      }
      _handleString(value, isInsert, arg3, encoding) {
        let offsetVal = this._writeOffset;
        let encodingVal = this._encoding;
        if (typeof arg3 === "number") {
          offsetVal = arg3;
        } else if (typeof arg3 === "string") {
          utils_1.checkEncoding(arg3);
          encodingVal = arg3;
        }
        if (typeof encoding === "string") {
          utils_1.checkEncoding(encoding);
          encodingVal = encoding;
        }
        const byteLength = Buffer.byteLength(value, encodingVal);
        if (isInsert) {
          this.ensureInsertable(byteLength, offsetVal);
        } else {
          this._ensureWriteable(byteLength, offsetVal);
        }
        this._buff.write(value, offsetVal, byteLength, encodingVal);
        if (isInsert) {
          this._writeOffset += byteLength;
        } else {
          if (typeof arg3 === "number") {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);
          } else {
            this._writeOffset += byteLength;
          }
        }
        return this;
      }
      _handleBuffer(value, isInsert, offset) {
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        if (isInsert) {
          this.ensureInsertable(value.length, offsetVal);
        } else {
          this._ensureWriteable(value.length, offsetVal);
        }
        value.copy(this._buff, offsetVal);
        if (isInsert) {
          this._writeOffset += value.length;
        } else {
          if (typeof offset === "number") {
            this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);
          } else {
            this._writeOffset += value.length;
          }
        }
        return this;
      }
      ensureReadable(length, offset) {
        let offsetVal = this._readOffset;
        if (typeof offset !== "undefined") {
          utils_1.checkOffsetValue(offset);
          offsetVal = offset;
        }
        if (offsetVal < 0 || offsetVal + length > this.length) {
          throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
        }
      }
      ensureInsertable(dataLength, offset) {
        utils_1.checkOffsetValue(offset);
        this._ensureCapacity(this.length + dataLength);
        if (offset < this.length) {
          this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);
        }
        if (offset + dataLength > this.length) {
          this.length = offset + dataLength;
        } else {
          this.length += dataLength;
        }
      }
      _ensureWriteable(dataLength, offset) {
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        this._ensureCapacity(offsetVal + dataLength);
        if (offsetVal + dataLength > this.length) {
          this.length = offsetVal + dataLength;
        }
      }
      _ensureCapacity(minLength) {
        const oldLength = this._buff.length;
        if (minLength > oldLength) {
          let data = this._buff;
          let newLength = oldLength * 3 / 2 + 1;
          if (newLength < minLength) {
            newLength = minLength;
          }
          this._buff = Buffer.allocUnsafe(newLength);
          data.copy(this._buff, 0, 0, oldLength);
        }
      }
      _readNumberValue(func, byteSize, offset) {
        this.ensureReadable(byteSize, offset);
        const value = func.call(this._buff, typeof offset === "number" ? offset : this._readOffset);
        if (typeof offset === "undefined") {
          this._readOffset += byteSize;
        }
        return value;
      }
      _insertNumberValue(func, byteSize, value, offset) {
        utils_1.checkOffsetValue(offset);
        this.ensureInsertable(byteSize, offset);
        func.call(this._buff, value, offset);
        this._writeOffset += byteSize;
        return this;
      }
      _writeNumberValue(func, byteSize, value, offset) {
        if (typeof offset === "number") {
          if (offset < 0) {
            throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
          }
          utils_1.checkOffsetValue(offset);
        }
        const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
        this._ensureWriteable(byteSize, offsetVal);
        func.call(this._buff, value, offsetVal);
        if (typeof offset === "number") {
          this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);
        } else {
          this._writeOffset += byteSize;
        }
        return this;
      }
    };
    exports2.SmartBuffer = SmartBuffer;
  }
});

// node_modules/socks/build/common/constants.js
var require_constants = __commonJS({
  "node_modules/socks/build/common/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SOCKS5_NO_ACCEPTABLE_AUTH = exports2.SOCKS5_CUSTOM_AUTH_END = exports2.SOCKS5_CUSTOM_AUTH_START = exports2.SOCKS_INCOMING_PACKET_SIZES = exports2.SocksClientState = exports2.Socks5Response = exports2.Socks5HostType = exports2.Socks5Auth = exports2.Socks4Response = exports2.SocksCommand = exports2.ERRORS = exports2.DEFAULT_TIMEOUT = void 0;
    var DEFAULT_TIMEOUT = 3e4;
    exports2.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
    var ERRORS = {
      InvalidSocksCommand: "An invalid SOCKS command was provided. Valid options are connect, bind, and associate.",
      InvalidSocksCommandForOperation: "An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.",
      InvalidSocksCommandChain: "An invalid SOCKS command was provided. Chaining currently only supports the connect command.",
      InvalidSocksClientOptionsDestination: "An invalid destination host was provided.",
      InvalidSocksClientOptionsExistingSocket: "An invalid existing socket was provided. This should be an instance of stream.Duplex.",
      InvalidSocksClientOptionsProxy: "Invalid SOCKS proxy details were provided.",
      InvalidSocksClientOptionsTimeout: "An invalid timeout value was provided. Please enter a value above 0 (in ms).",
      InvalidSocksClientOptionsProxiesLength: "At least two socks proxies must be provided for chaining.",
      InvalidSocksClientOptionsCustomAuthRange: "Custom auth must be a value between 0x80 and 0xFE.",
      InvalidSocksClientOptionsCustomAuthOptions: "When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.",
      NegotiationError: "Negotiation error",
      SocketClosed: "Socket closed",
      ProxyConnectionTimedOut: "Proxy connection timed out",
      InternalError: "SocksClient internal error (this should not happen)",
      InvalidSocks4HandshakeResponse: "Received invalid Socks4 handshake response",
      Socks4ProxyRejectedConnection: "Socks4 Proxy rejected connection",
      InvalidSocks4IncomingConnectionResponse: "Socks4 invalid incoming connection response",
      Socks4ProxyRejectedIncomingBoundConnection: "Socks4 Proxy rejected incoming bound connection",
      InvalidSocks5InitialHandshakeResponse: "Received invalid Socks5 initial handshake response",
      InvalidSocks5IntiailHandshakeSocksVersion: "Received invalid Socks5 initial handshake (invalid socks version)",
      InvalidSocks5InitialHandshakeNoAcceptedAuthType: "Received invalid Socks5 initial handshake (no accepted authentication type)",
      InvalidSocks5InitialHandshakeUnknownAuthType: "Received invalid Socks5 initial handshake (unknown authentication type)",
      Socks5AuthenticationFailed: "Socks5 Authentication failed",
      InvalidSocks5FinalHandshake: "Received invalid Socks5 final handshake response",
      InvalidSocks5FinalHandshakeRejected: "Socks5 proxy rejected connection",
      InvalidSocks5IncomingConnectionResponse: "Received invalid Socks5 incoming connection response",
      Socks5ProxyRejectedIncomingBoundConnection: "Socks5 Proxy rejected incoming bound connection"
    };
    exports2.ERRORS = ERRORS;
    var SOCKS_INCOMING_PACKET_SIZES = {
      Socks5InitialHandshakeResponse: 2,
      Socks5UserPassAuthenticationResponse: 2,
      Socks5ResponseHeader: 5,
      Socks5ResponseIPv4: 10,
      Socks5ResponseIPv6: 22,
      Socks5ResponseHostname: (hostNameLength) => hostNameLength + 7,
      Socks4Response: 8
    };
    exports2.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;
    var SocksCommand;
    (function(SocksCommand2) {
      SocksCommand2[SocksCommand2["connect"] = 1] = "connect";
      SocksCommand2[SocksCommand2["bind"] = 2] = "bind";
      SocksCommand2[SocksCommand2["associate"] = 3] = "associate";
    })(SocksCommand || (exports2.SocksCommand = SocksCommand = {}));
    var Socks4Response;
    (function(Socks4Response2) {
      Socks4Response2[Socks4Response2["Granted"] = 90] = "Granted";
      Socks4Response2[Socks4Response2["Failed"] = 91] = "Failed";
      Socks4Response2[Socks4Response2["Rejected"] = 92] = "Rejected";
      Socks4Response2[Socks4Response2["RejectedIdent"] = 93] = "RejectedIdent";
    })(Socks4Response || (exports2.Socks4Response = Socks4Response = {}));
    var Socks5Auth;
    (function(Socks5Auth2) {
      Socks5Auth2[Socks5Auth2["NoAuth"] = 0] = "NoAuth";
      Socks5Auth2[Socks5Auth2["GSSApi"] = 1] = "GSSApi";
      Socks5Auth2[Socks5Auth2["UserPass"] = 2] = "UserPass";
    })(Socks5Auth || (exports2.Socks5Auth = Socks5Auth = {}));
    var SOCKS5_CUSTOM_AUTH_START = 128;
    exports2.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;
    var SOCKS5_CUSTOM_AUTH_END = 254;
    exports2.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;
    var SOCKS5_NO_ACCEPTABLE_AUTH = 255;
    exports2.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;
    var Socks5Response;
    (function(Socks5Response2) {
      Socks5Response2[Socks5Response2["Granted"] = 0] = "Granted";
      Socks5Response2[Socks5Response2["Failure"] = 1] = "Failure";
      Socks5Response2[Socks5Response2["NotAllowed"] = 2] = "NotAllowed";
      Socks5Response2[Socks5Response2["NetworkUnreachable"] = 3] = "NetworkUnreachable";
      Socks5Response2[Socks5Response2["HostUnreachable"] = 4] = "HostUnreachable";
      Socks5Response2[Socks5Response2["ConnectionRefused"] = 5] = "ConnectionRefused";
      Socks5Response2[Socks5Response2["TTLExpired"] = 6] = "TTLExpired";
      Socks5Response2[Socks5Response2["CommandNotSupported"] = 7] = "CommandNotSupported";
      Socks5Response2[Socks5Response2["AddressNotSupported"] = 8] = "AddressNotSupported";
    })(Socks5Response || (exports2.Socks5Response = Socks5Response = {}));
    var Socks5HostType;
    (function(Socks5HostType2) {
      Socks5HostType2[Socks5HostType2["IPv4"] = 1] = "IPv4";
      Socks5HostType2[Socks5HostType2["Hostname"] = 3] = "Hostname";
      Socks5HostType2[Socks5HostType2["IPv6"] = 4] = "IPv6";
    })(Socks5HostType || (exports2.Socks5HostType = Socks5HostType = {}));
    var SocksClientState;
    (function(SocksClientState2) {
      SocksClientState2[SocksClientState2["Created"] = 0] = "Created";
      SocksClientState2[SocksClientState2["Connecting"] = 1] = "Connecting";
      SocksClientState2[SocksClientState2["Connected"] = 2] = "Connected";
      SocksClientState2[SocksClientState2["SentInitialHandshake"] = 3] = "SentInitialHandshake";
      SocksClientState2[SocksClientState2["ReceivedInitialHandshakeResponse"] = 4] = "ReceivedInitialHandshakeResponse";
      SocksClientState2[SocksClientState2["SentAuthentication"] = 5] = "SentAuthentication";
      SocksClientState2[SocksClientState2["ReceivedAuthenticationResponse"] = 6] = "ReceivedAuthenticationResponse";
      SocksClientState2[SocksClientState2["SentFinalHandshake"] = 7] = "SentFinalHandshake";
      SocksClientState2[SocksClientState2["ReceivedFinalResponse"] = 8] = "ReceivedFinalResponse";
      SocksClientState2[SocksClientState2["BoundWaitingForConnection"] = 9] = "BoundWaitingForConnection";
      SocksClientState2[SocksClientState2["Established"] = 10] = "Established";
      SocksClientState2[SocksClientState2["Disconnected"] = 11] = "Disconnected";
      SocksClientState2[SocksClientState2["Error"] = 99] = "Error";
    })(SocksClientState || (exports2.SocksClientState = SocksClientState = {}));
  }
});

// node_modules/socks/build/common/util.js
var require_util = __commonJS({
  "node_modules/socks/build/common/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shuffleArray = exports2.SocksClientError = void 0;
    var SocksClientError = class extends Error {
      constructor(message, options) {
        super(message);
        this.options = options;
      }
    };
    exports2.SocksClientError = SocksClientError;
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }
    exports2.shuffleArray = shuffleArray;
  }
});

// node_modules/ip-address/dist/common.js
var require_common4 = __commonJS({
  "node_modules/ip-address/dist/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isCorrect = exports2.isInSubnet = void 0;
    function isInSubnet(address) {
      if (this.subnetMask < address.subnetMask) {
        return false;
      }
      if (this.mask(address.subnetMask) === address.mask()) {
        return true;
      }
      return false;
    }
    exports2.isInSubnet = isInSubnet;
    function isCorrect(defaultBits) {
      return function() {
        if (this.addressMinusSuffix !== this.correctForm()) {
          return false;
        }
        if (this.subnetMask === defaultBits && !this.parsedSubnet) {
          return true;
        }
        return this.parsedSubnet === String(this.subnetMask);
      };
    }
    exports2.isCorrect = isCorrect;
  }
});

// node_modules/ip-address/dist/v4/constants.js
var require_constants2 = __commonJS({
  "node_modules/ip-address/dist/v4/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RE_SUBNET_STRING = exports2.RE_ADDRESS = exports2.GROUPS = exports2.BITS = void 0;
    exports2.BITS = 32;
    exports2.GROUPS = 4;
    exports2.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
    exports2.RE_SUBNET_STRING = /\/\d{1,2}$/;
  }
});

// node_modules/ip-address/dist/address-error.js
var require_address_error = __commonJS({
  "node_modules/ip-address/dist/address-error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AddressError = void 0;
    var AddressError = class extends Error {
      constructor(message, parseMessage) {
        super(message);
        this.name = "AddressError";
        if (parseMessage !== null) {
          this.parseMessage = parseMessage;
        }
      }
    };
    exports2.AddressError = AddressError;
  }
});

// node_modules/jsbn/index.js
var require_jsbn = __commonJS({
  "node_modules/jsbn/index.js"(exports2, module2) {
    (function() {
      var dbits;
      var canary = 244837814094590;
      var j_lm = (canary & 16777215) == 15715070;
      function BigInteger(a, b, c) {
        if (a != null)
          if (typeof a == "number")
            this.fromNumber(a, b, c);
          else if (b == null && typeof a != "string")
            this.fromString(a, 256);
          else
            this.fromString(a, b);
      }
      function nbi() {
        return new BigInteger(null);
      }
      function am1(i, x, w, j, c, n) {
        while (--n >= 0) {
          var v = x * this[i++] + w[j] + c;
          c = Math.floor(v / 67108864);
          w[j++] = v & 67108863;
        }
        return c;
      }
      function am2(i, x, w, j, c, n) {
        var xl = x & 32767, xh = x >> 15;
        while (--n >= 0) {
          var l = this[i] & 32767;
          var h = this[i++] >> 15;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
          c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
          w[j++] = l & 1073741823;
        }
        return c;
      }
      function am3(i, x, w, j, c, n) {
        var xl = x & 16383, xh = x >> 14;
        while (--n >= 0) {
          var l = this[i] & 16383;
          var h = this[i++] >> 14;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 16383) << 14) + w[j] + c;
          c = (l >> 28) + (m >> 14) + xh * h;
          w[j++] = l & 268435455;
        }
        return c;
      }
      var inBrowser = typeof navigator !== "undefined";
      if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
        BigInteger.prototype.am = am2;
        dbits = 30;
      } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
        BigInteger.prototype.am = am1;
        dbits = 26;
      } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = (1 << dbits) - 1;
      BigInteger.prototype.DV = 1 << dbits;
      var BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2, BI_FP);
      BigInteger.prototype.F1 = BI_FP - dbits;
      BigInteger.prototype.F2 = 2 * dbits - BI_FP;
      var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      var BI_RC = new Array();
      var rr, vv;
      rr = "0".charCodeAt(0);
      for (vv = 0; vv <= 9; ++vv)
        BI_RC[rr++] = vv;
      rr = "a".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      rr = "A".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      function int2char(n) {
        return BI_RM.charAt(n);
      }
      function intAt(s, i) {
        var c = BI_RC[s.charCodeAt(i)];
        return c == null ? -1 : c;
      }
      function bnpCopyTo(r) {
        for (var i = this.t - 1; i >= 0; --i)
          r[i] = this[i];
        r.t = this.t;
        r.s = this.s;
      }
      function bnpFromInt(x) {
        this.t = 1;
        this.s = x < 0 ? -1 : 0;
        if (x > 0)
          this[0] = x;
        else if (x < -1)
          this[0] = x + this.DV;
        else
          this.t = 0;
      }
      function nbv(i) {
        var r = nbi();
        r.fromInt(i);
        return r;
      }
      function bnpFromString(s, b) {
        var k;
        if (b == 16)
          k = 4;
        else if (b == 8)
          k = 3;
        else if (b == 256)
          k = 8;
        else if (b == 2)
          k = 1;
        else if (b == 32)
          k = 5;
        else if (b == 4)
          k = 2;
        else {
          this.fromRadix(s, b);
          return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length, mi = false, sh = 0;
        while (--i >= 0) {
          var x = k == 8 ? s[i] & 255 : intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-")
              mi = true;
            continue;
          }
          mi = false;
          if (sh == 0)
            this[this.t++] = x;
          else if (sh + k > this.DB) {
            this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
            this[this.t++] = x >> this.DB - sh;
          } else
            this[this.t - 1] |= x << sh;
          sh += k;
          if (sh >= this.DB)
            sh -= this.DB;
        }
        if (k == 8 && (s[0] & 128) != 0) {
          this.s = -1;
          if (sh > 0)
            this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
        }
        this.clamp();
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpClamp() {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c)
          --this.t;
      }
      function bnToString(b) {
        if (this.s < 0)
          return "-" + this.negate().toString(b);
        var k;
        if (b == 16)
          k = 4;
        else if (b == 8)
          k = 3;
        else if (b == 2)
          k = 1;
        else if (b == 32)
          k = 5;
        else if (b == 4)
          k = 2;
        else
          return this.toRadix(b);
        var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
        var p = this.DB - i * this.DB % k;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) > 0) {
            m = true;
            r = int2char(d);
          }
          while (i >= 0) {
            if (p < k) {
              d = (this[i] & (1 << p) - 1) << k - p;
              d |= this[--i] >> (p += this.DB - k);
            } else {
              d = this[i] >> (p -= k) & km;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if (d > 0)
              m = true;
            if (m)
              r += int2char(d);
          }
        }
        return m ? r : "0";
      }
      function bnNegate() {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
      }
      function bnAbs() {
        return this.s < 0 ? this.negate() : this;
      }
      function bnCompareTo(a) {
        var r = this.s - a.s;
        if (r != 0)
          return r;
        var i = this.t;
        r = i - a.t;
        if (r != 0)
          return this.s < 0 ? -r : r;
        while (--i >= 0)
          if ((r = this[i] - a[i]) != 0)
            return r;
        return 0;
      }
      function nbits(x) {
        var r = 1, t2;
        if ((t2 = x >>> 16) != 0) {
          x = t2;
          r += 16;
        }
        if ((t2 = x >> 8) != 0) {
          x = t2;
          r += 8;
        }
        if ((t2 = x >> 4) != 0) {
          x = t2;
          r += 4;
        }
        if ((t2 = x >> 2) != 0) {
          x = t2;
          r += 2;
        }
        if ((t2 = x >> 1) != 0) {
          x = t2;
          r += 1;
        }
        return r;
      }
      function bnBitLength() {
        if (this.t <= 0)
          return 0;
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
      }
      function bnpDLShiftTo(n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i)
          r[i + n] = this[i];
        for (i = n - 1; i >= 0; --i)
          r[i] = 0;
        r.t = this.t + n;
        r.s = this.s;
      }
      function bnpDRShiftTo(n, r) {
        for (var i = n; i < this.t; ++i)
          r[i - n] = this[i];
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
      }
      function bnpLShiftTo(n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
        for (i = this.t - 1; i >= 0; --i) {
          r[i + ds + 1] = this[i] >> cbs | c;
          c = (this[i] & bm) << bs;
        }
        for (i = ds - 1; i >= 0; --i)
          r[i] = 0;
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
      }
      function bnpRShiftTo(n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
          r.t = 0;
          return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
          r[i - ds - 1] |= (this[i] & bm) << cbs;
          r[i - ds] = this[i] >> bs;
        }
        if (bs > 0)
          r[this.t - ds - 1] |= (this.s & bm) << cbs;
        r.t = this.t - ds;
        r.clamp();
      }
      function bnpSubTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] - a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c -= a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c -= a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c -= a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c < -1)
          r[i++] = this.DV + c;
        else if (c > 0)
          r[i++] = c;
        r.t = i;
        r.clamp();
      }
      function bnpMultiplyTo(a, r) {
        var x = this.abs(), y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0)
          r[i] = 0;
        for (i = 0; i < y.t; ++i)
          r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        r.s = 0;
        r.clamp();
        if (this.s != a.s)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnpSquareTo(r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0)
          r[i] = 0;
        for (i = 0; i < x.t - 1; ++i) {
          var c = x.am(i, x[i], r, 2 * i, 0, 1);
          if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
            r[i + x.t] -= x.DV;
            r[i + x.t + 1] = 1;
          }
        }
        if (r.t > 0)
          r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        r.s = 0;
        r.clamp();
      }
      function bnpDivRemTo(m, q, r) {
        var pm = m.abs();
        if (pm.t <= 0)
          return;
        var pt = this.abs();
        if (pt.t < pm.t) {
          if (q != null)
            q.fromInt(0);
          if (r != null)
            this.copyTo(r);
          return;
        }
        if (r == null)
          r = nbi();
        var y = nbi(), ts = this.s, ms = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]);
        if (nsh > 0) {
          pm.lShiftTo(nsh, y);
          pt.lShiftTo(nsh, r);
        } else {
          pm.copyTo(y);
          pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0)
          return;
        var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
        var i = r.t, j = i - ys, t2 = q == null ? nbi() : q;
        y.dlShiftTo(j, t2);
        if (r.compareTo(t2) >= 0) {
          r[r.t++] = 1;
          r.subTo(t2, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t2);
        t2.subTo(y, y);
        while (y.t < ys)
          y[y.t++] = 0;
        while (--j >= 0) {
          var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
          if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
            y.dlShiftTo(j, t2);
            r.subTo(t2, r);
            while (r[i] < --qd)
              r.subTo(t2, r);
          }
        }
        if (q != null) {
          r.drShiftTo(ys, q);
          if (ts != ms)
            BigInteger.ZERO.subTo(q, q);
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0)
          r.rShiftTo(nsh, r);
        if (ts < 0)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnMod(a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          a.subTo(r, r);
        return r;
      }
      function Classic(m) {
        this.m = m;
      }
      function cConvert(x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0)
          return x.mod(this.m);
        else
          return x;
      }
      function cRevert(x) {
        return x;
      }
      function cReduce(x) {
        x.divRemTo(this.m, null, x);
      }
      function cMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      function cSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      Classic.prototype.convert = cConvert;
      Classic.prototype.revert = cRevert;
      Classic.prototype.reduce = cReduce;
      Classic.prototype.mulTo = cMulTo;
      Classic.prototype.sqrTo = cSqrTo;
      function bnpInvDigit() {
        if (this.t < 1)
          return 0;
        var x = this[0];
        if ((x & 1) == 0)
          return 0;
        var y = x & 3;
        y = y * (2 - (x & 15) * y) & 15;
        y = y * (2 - (x & 255) * y) & 255;
        y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
        y = y * (2 - x * y % this.DV) % this.DV;
        return y > 0 ? this.DV - y : -y;
      }
      function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 32767;
        this.mph = this.mp >> 15;
        this.um = (1 << m.DB - 15) - 1;
        this.mt2 = 2 * m.t;
      }
      function montConvert(x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          this.m.subTo(r, r);
        return r;
      }
      function montRevert(x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
      function montReduce(x) {
        while (x.t <= this.mt2)
          x[x.t++] = 0;
        for (var i = 0; i < this.m.t; ++i) {
          var j = x[i] & 32767;
          var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
          j = i + this.m.t;
          x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
          while (x[j] >= x.DV) {
            x[j] -= x.DV;
            x[++j]++;
          }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function montSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function montMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Montgomery.prototype.convert = montConvert;
      Montgomery.prototype.revert = montRevert;
      Montgomery.prototype.reduce = montReduce;
      Montgomery.prototype.mulTo = montMulTo;
      Montgomery.prototype.sqrTo = montSqrTo;
      function bnpIsEven() {
        return (this.t > 0 ? this[0] & 1 : this.s) == 0;
      }
      function bnpExp(e, z2) {
        if (e > 4294967295 || e < 1)
          return BigInteger.ONE;
        var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
          z2.sqrTo(r, r2);
          if ((e & 1 << i) > 0)
            z2.mulTo(r2, g, r);
          else {
            var t2 = r;
            r = r2;
            r2 = t2;
          }
        }
        return z2.revert(r);
      }
      function bnModPowInt(e, m) {
        var z2;
        if (e < 256 || m.isEven())
          z2 = new Classic(m);
        else
          z2 = new Montgomery(m);
        return this.exp(e, z2);
      }
      BigInteger.prototype.copyTo = bnpCopyTo;
      BigInteger.prototype.fromInt = bnpFromInt;
      BigInteger.prototype.fromString = bnpFromString;
      BigInteger.prototype.clamp = bnpClamp;
      BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
      BigInteger.prototype.drShiftTo = bnpDRShiftTo;
      BigInteger.prototype.lShiftTo = bnpLShiftTo;
      BigInteger.prototype.rShiftTo = bnpRShiftTo;
      BigInteger.prototype.subTo = bnpSubTo;
      BigInteger.prototype.multiplyTo = bnpMultiplyTo;
      BigInteger.prototype.squareTo = bnpSquareTo;
      BigInteger.prototype.divRemTo = bnpDivRemTo;
      BigInteger.prototype.invDigit = bnpInvDigit;
      BigInteger.prototype.isEven = bnpIsEven;
      BigInteger.prototype.exp = bnpExp;
      BigInteger.prototype.toString = bnToString;
      BigInteger.prototype.negate = bnNegate;
      BigInteger.prototype.abs = bnAbs;
      BigInteger.prototype.compareTo = bnCompareTo;
      BigInteger.prototype.bitLength = bnBitLength;
      BigInteger.prototype.mod = bnMod;
      BigInteger.prototype.modPowInt = bnModPowInt;
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      function bnClone() {
        var r = nbi();
        this.copyTo(r);
        return r;
      }
      function bnIntValue() {
        if (this.s < 0) {
          if (this.t == 1)
            return this[0] - this.DV;
          else if (this.t == 0)
            return -1;
        } else if (this.t == 1)
          return this[0];
        else if (this.t == 0)
          return 0;
        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
      }
      function bnByteValue() {
        return this.t == 0 ? this.s : this[0] << 24 >> 24;
      }
      function bnShortValue() {
        return this.t == 0 ? this.s : this[0] << 16 >> 16;
      }
      function bnpChunkSize(r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
      }
      function bnSigNum() {
        if (this.s < 0)
          return -1;
        else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
          return 0;
        else
          return 1;
      }
      function bnpToRadix(b) {
        if (b == null)
          b = 10;
        if (this.signum() == 0 || b < 2 || b > 36)
          return "0";
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a), y = nbi(), z2 = nbi(), r = "";
        this.divRemTo(d, y, z2);
        while (y.signum() > 0) {
          r = (a + z2.intValue()).toString(b).substr(1) + r;
          y.divRemTo(d, y, z2);
        }
        return z2.intValue().toString(b) + r;
      }
      function bnpFromRadix(s, b) {
        this.fromInt(0);
        if (b == null)
          b = 10;
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
        for (var i = 0; i < s.length; ++i) {
          var x = intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-" && this.signum() == 0)
              mi = true;
            continue;
          }
          w = b * w + x;
          if (++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
          }
        }
        if (j > 0) {
          this.dMultiply(Math.pow(b, j));
          this.dAddOffset(w, 0);
        }
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpFromNumber(a, b, c) {
        if (typeof b == "number") {
          if (a < 2)
            this.fromInt(1);
          else {
            this.fromNumber(a, c);
            if (!this.testBit(a - 1))
              this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            if (this.isEven())
              this.dAddOffset(1, 0);
            while (!this.isProbablePrime(b)) {
              this.dAddOffset(2, 0);
              if (this.bitLength() > a)
                this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
            }
          }
        } else {
          var x = new Array(), t2 = a & 7;
          x.length = (a >> 3) + 1;
          b.nextBytes(x);
          if (t2 > 0)
            x[0] &= (1 << t2) - 1;
          else
            x[0] = 0;
          this.fromString(x, 256);
        }
      }
      function bnToByteArray() {
        var i = this.t, r = new Array();
        r[0] = this.s;
        var p = this.DB - i * this.DB % 8, d, k = 0;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
            r[k++] = d | this.s << this.DB - p;
          while (i >= 0) {
            if (p < 8) {
              d = (this[i] & (1 << p) - 1) << 8 - p;
              d |= this[--i] >> (p += this.DB - 8);
            } else {
              d = this[i] >> (p -= 8) & 255;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if ((d & 128) != 0)
              d |= -256;
            if (k == 0 && (this.s & 128) != (d & 128))
              ++k;
            if (k > 0 || d != this.s)
              r[k++] = d;
          }
        }
        return r;
      }
      function bnEquals(a) {
        return this.compareTo(a) == 0;
      }
      function bnMin(a) {
        return this.compareTo(a) < 0 ? this : a;
      }
      function bnMax(a) {
        return this.compareTo(a) > 0 ? this : a;
      }
      function bnpBitwiseTo(a, op, r) {
        var i, f, m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i)
          r[i] = op(this[i], a[i]);
        if (a.t < this.t) {
          f = a.s & this.DM;
          for (i = m; i < this.t; ++i)
            r[i] = op(this[i], f);
          r.t = this.t;
        } else {
          f = this.s & this.DM;
          for (i = m; i < a.t; ++i)
            r[i] = op(f, a[i]);
          r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
      }
      function op_and(x, y) {
        return x & y;
      }
      function bnAnd(a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
      }
      function op_or(x, y) {
        return x | y;
      }
      function bnOr(a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
      }
      function op_xor(x, y) {
        return x ^ y;
      }
      function bnXor(a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
      }
      function op_andnot(x, y) {
        return x & ~y;
      }
      function bnAndNot(a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
      }
      function bnNot() {
        var r = nbi();
        for (var i = 0; i < this.t; ++i)
          r[i] = this.DM & ~this[i];
        r.t = this.t;
        r.s = ~this.s;
        return r;
      }
      function bnShiftLeft(n) {
        var r = nbi();
        if (n < 0)
          this.rShiftTo(-n, r);
        else
          this.lShiftTo(n, r);
        return r;
      }
      function bnShiftRight(n) {
        var r = nbi();
        if (n < 0)
          this.lShiftTo(-n, r);
        else
          this.rShiftTo(n, r);
        return r;
      }
      function lbit(x) {
        if (x == 0)
          return -1;
        var r = 0;
        if ((x & 65535) == 0) {
          x >>= 16;
          r += 16;
        }
        if ((x & 255) == 0) {
          x >>= 8;
          r += 8;
        }
        if ((x & 15) == 0) {
          x >>= 4;
          r += 4;
        }
        if ((x & 3) == 0) {
          x >>= 2;
          r += 2;
        }
        if ((x & 1) == 0)
          ++r;
        return r;
      }
      function bnGetLowestSetBit() {
        for (var i = 0; i < this.t; ++i)
          if (this[i] != 0)
            return i * this.DB + lbit(this[i]);
        if (this.s < 0)
          return this.t * this.DB;
        return -1;
      }
      function cbit(x) {
        var r = 0;
        while (x != 0) {
          x &= x - 1;
          ++r;
        }
        return r;
      }
      function bnBitCount() {
        var r = 0, x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i)
          r += cbit(this[i] ^ x);
        return r;
      }
      function bnTestBit(n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t)
          return this.s != 0;
        return (this[j] & 1 << n % this.DB) != 0;
      }
      function bnpChangeBit(n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
      }
      function bnSetBit(n) {
        return this.changeBit(n, op_or);
      }
      function bnClearBit(n) {
        return this.changeBit(n, op_andnot);
      }
      function bnFlipBit(n) {
        return this.changeBit(n, op_xor);
      }
      function bnpAddTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] + a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c += a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c += a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c > 0)
          r[i++] = c;
        else if (c < -1)
          r[i++] = this.DV + c;
        r.t = i;
        r.clamp();
      }
      function bnAdd(a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
      }
      function bnSubtract(a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
      }
      function bnMultiply(a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
      }
      function bnSquare() {
        var r = nbi();
        this.squareTo(r);
        return r;
      }
      function bnDivide(a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
      }
      function bnRemainder(a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
      }
      function bnDivideAndRemainder(a) {
        var q = nbi(), r = nbi();
        this.divRemTo(a, q, r);
        return new Array(q, r);
      }
      function bnpDMultiply(n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
      }
      function bnpDAddOffset(n, w) {
        if (n == 0)
          return;
        while (this.t <= w)
          this[this.t++] = 0;
        this[w] += n;
        while (this[w] >= this.DV) {
          this[w] -= this.DV;
          if (++w >= this.t)
            this[this.t++] = 0;
          ++this[w];
        }
      }
      function NullExp() {
      }
      function nNop(x) {
        return x;
      }
      function nMulTo(x, y, r) {
        x.multiplyTo(y, r);
      }
      function nSqrTo(x, r) {
        x.squareTo(r);
      }
      NullExp.prototype.convert = nNop;
      NullExp.prototype.revert = nNop;
      NullExp.prototype.mulTo = nMulTo;
      NullExp.prototype.sqrTo = nSqrTo;
      function bnPow(e) {
        return this.exp(e, new NullExp());
      }
      function bnpMultiplyLowerTo(a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0;
        r.t = i;
        while (i > 0)
          r[--i] = 0;
        var j;
        for (j = r.t - this.t; i < j; ++i)
          r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        for (j = Math.min(a.t, n); i < j; ++i)
          this.am(0, a[i], r, i, 0, n - i);
        r.clamp();
      }
      function bnpMultiplyUpperTo(a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0;
        while (--i >= 0)
          r[i] = 0;
        for (i = Math.max(n - this.t, 0); i < a.t; ++i)
          r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        r.clamp();
        r.drShiftTo(1, r);
      }
      function Barrett(m) {
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
        this.m = m;
      }
      function barrettConvert(x) {
        if (x.s < 0 || x.t > 2 * this.m.t)
          return x.mod(this.m);
        else if (x.compareTo(this.m) < 0)
          return x;
        else {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
      }
      function barrettRevert(x) {
        return x;
      }
      function barrettReduce(x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
          x.t = this.m.t + 1;
          x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0)
          x.dAddOffset(1, this.m.t + 1);
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function barrettSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function barrettMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Barrett.prototype.convert = barrettConvert;
      Barrett.prototype.revert = barrettRevert;
      Barrett.prototype.reduce = barrettReduce;
      Barrett.prototype.mulTo = barrettMulTo;
      Barrett.prototype.sqrTo = barrettSqrTo;
      function bnModPow(e, m) {
        var i = e.bitLength(), k, r = nbv(1), z2;
        if (i <= 0)
          return r;
        else if (i < 18)
          k = 1;
        else if (i < 48)
          k = 3;
        else if (i < 144)
          k = 4;
        else if (i < 768)
          k = 5;
        else
          k = 6;
        if (i < 8)
          z2 = new Classic(m);
        else if (m.isEven())
          z2 = new Barrett(m);
        else
          z2 = new Montgomery(m);
        var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
        g[1] = z2.convert(this);
        if (k > 1) {
          var g2 = nbi();
          z2.sqrTo(g[1], g2);
          while (n <= km) {
            g[n] = nbi();
            z2.mulTo(g2, g[n - 2], g[n]);
            n += 2;
          }
        }
        var j = e.t - 1, w, is1 = true, r2 = nbi(), t2;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
          if (i >= k1)
            w = e[j] >> i - k1 & km;
          else {
            w = (e[j] & (1 << i + 1) - 1) << k1 - i;
            if (j > 0)
              w |= e[j - 1] >> this.DB + i - k1;
          }
          n = k;
          while ((w & 1) == 0) {
            w >>= 1;
            --n;
          }
          if ((i -= n) < 0) {
            i += this.DB;
            --j;
          }
          if (is1) {
            g[w].copyTo(r);
            is1 = false;
          } else {
            while (n > 1) {
              z2.sqrTo(r, r2);
              z2.sqrTo(r2, r);
              n -= 2;
            }
            if (n > 0)
              z2.sqrTo(r, r2);
            else {
              t2 = r;
              r = r2;
              r2 = t2;
            }
            z2.mulTo(r2, g[w], r);
          }
          while (j >= 0 && (e[j] & 1 << i) == 0) {
            z2.sqrTo(r, r2);
            t2 = r;
            r = r2;
            r2 = t2;
            if (--i < 0) {
              i = this.DB - 1;
              --j;
            }
          }
        }
        return z2.revert(r);
      }
      function bnGCD(a) {
        var x = this.s < 0 ? this.negate() : this.clone();
        var y = a.s < 0 ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
          var t2 = x;
          x = y;
          y = t2;
        }
        var i = x.getLowestSetBit(), g = y.getLowestSetBit();
        if (g < 0)
          return x;
        if (i < g)
          g = i;
        if (g > 0) {
          x.rShiftTo(g, x);
          y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
          if ((i = x.getLowestSetBit()) > 0)
            x.rShiftTo(i, x);
          if ((i = y.getLowestSetBit()) > 0)
            y.rShiftTo(i, y);
          if (x.compareTo(y) >= 0) {
            x.subTo(y, x);
            x.rShiftTo(1, x);
          } else {
            y.subTo(x, y);
            y.rShiftTo(1, y);
          }
        }
        if (g > 0)
          y.lShiftTo(g, y);
        return y;
      }
      function bnpModInt(n) {
        if (n <= 0)
          return 0;
        var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
        if (this.t > 0)
          if (d == 0)
            r = this[0] % n;
          else
            for (var i = this.t - 1; i >= 0; --i)
              r = (d * r + this[i]) % n;
        return r;
      }
      function bnModInverse(m) {
        var ac = m.isEven();
        if (this.isEven() && ac || m.signum() == 0)
          return BigInteger.ZERO;
        var u = m.clone(), v = this.clone();
        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
        while (u.signum() != 0) {
          while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
              if (!a.isEven() || !b.isEven()) {
                a.addTo(this, a);
                b.subTo(m, b);
              }
              a.rShiftTo(1, a);
            } else if (!b.isEven())
              b.subTo(m, b);
            b.rShiftTo(1, b);
          }
          while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
              if (!c.isEven() || !d.isEven()) {
                c.addTo(this, c);
                d.subTo(m, d);
              }
              c.rShiftTo(1, c);
            } else if (!d.isEven())
              d.subTo(m, d);
            d.rShiftTo(1, d);
          }
          if (u.compareTo(v) >= 0) {
            u.subTo(v, u);
            if (ac)
              a.subTo(c, a);
            b.subTo(d, b);
          } else {
            v.subTo(u, v);
            if (ac)
              c.subTo(a, c);
            d.subTo(b, d);
          }
        }
        if (v.compareTo(BigInteger.ONE) != 0)
          return BigInteger.ZERO;
        if (d.compareTo(m) >= 0)
          return d.subtract(m);
        if (d.signum() < 0)
          d.addTo(m, d);
        else
          return d;
        if (d.signum() < 0)
          return d.add(m);
        else
          return d;
      }
      var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
      var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
      function bnIsProbablePrime(t2) {
        var i, x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
          for (i = 0; i < lowprimes.length; ++i)
            if (x[0] == lowprimes[i])
              return true;
          return false;
        }
        if (x.isEven())
          return false;
        i = 1;
        while (i < lowprimes.length) {
          var m = lowprimes[i], j = i + 1;
          while (j < lowprimes.length && m < lplim)
            m *= lowprimes[j++];
          m = x.modInt(m);
          while (i < j)
            if (m % lowprimes[i++] == 0)
              return false;
        }
        return x.millerRabin(t2);
      }
      function bnpMillerRabin(t2) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0)
          return false;
        var r = n1.shiftRight(k);
        t2 = t2 + 1 >> 1;
        if (t2 > lowprimes.length)
          t2 = lowprimes.length;
        var a = nbi();
        for (var i = 0; i < t2; ++i) {
          a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
          var y = a.modPow(r, this);
          if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ < k && y.compareTo(n1) != 0) {
              y = y.modPowInt(2, this);
              if (y.compareTo(BigInteger.ONE) == 0)
                return false;
            }
            if (y.compareTo(n1) != 0)
              return false;
          }
        }
        return true;
      }
      BigInteger.prototype.chunkSize = bnpChunkSize;
      BigInteger.prototype.toRadix = bnpToRadix;
      BigInteger.prototype.fromRadix = bnpFromRadix;
      BigInteger.prototype.fromNumber = bnpFromNumber;
      BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
      BigInteger.prototype.changeBit = bnpChangeBit;
      BigInteger.prototype.addTo = bnpAddTo;
      BigInteger.prototype.dMultiply = bnpDMultiply;
      BigInteger.prototype.dAddOffset = bnpDAddOffset;
      BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
      BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
      BigInteger.prototype.modInt = bnpModInt;
      BigInteger.prototype.millerRabin = bnpMillerRabin;
      BigInteger.prototype.clone = bnClone;
      BigInteger.prototype.intValue = bnIntValue;
      BigInteger.prototype.byteValue = bnByteValue;
      BigInteger.prototype.shortValue = bnShortValue;
      BigInteger.prototype.signum = bnSigNum;
      BigInteger.prototype.toByteArray = bnToByteArray;
      BigInteger.prototype.equals = bnEquals;
      BigInteger.prototype.min = bnMin;
      BigInteger.prototype.max = bnMax;
      BigInteger.prototype.and = bnAnd;
      BigInteger.prototype.or = bnOr;
      BigInteger.prototype.xor = bnXor;
      BigInteger.prototype.andNot = bnAndNot;
      BigInteger.prototype.not = bnNot;
      BigInteger.prototype.shiftLeft = bnShiftLeft;
      BigInteger.prototype.shiftRight = bnShiftRight;
      BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
      BigInteger.prototype.bitCount = bnBitCount;
      BigInteger.prototype.testBit = bnTestBit;
      BigInteger.prototype.setBit = bnSetBit;
      BigInteger.prototype.clearBit = bnClearBit;
      BigInteger.prototype.flipBit = bnFlipBit;
      BigInteger.prototype.add = bnAdd;
      BigInteger.prototype.subtract = bnSubtract;
      BigInteger.prototype.multiply = bnMultiply;
      BigInteger.prototype.divide = bnDivide;
      BigInteger.prototype.remainder = bnRemainder;
      BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
      BigInteger.prototype.modPow = bnModPow;
      BigInteger.prototype.modInverse = bnModInverse;
      BigInteger.prototype.pow = bnPow;
      BigInteger.prototype.gcd = bnGCD;
      BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
      BigInteger.prototype.square = bnSquare;
      BigInteger.prototype.Barrett = Barrett;
      var rng_state;
      var rng_pool;
      var rng_pptr;
      function rng_seed_int(x) {
        rng_pool[rng_pptr++] ^= x & 255;
        rng_pool[rng_pptr++] ^= x >> 8 & 255;
        rng_pool[rng_pptr++] ^= x >> 16 & 255;
        rng_pool[rng_pptr++] ^= x >> 24 & 255;
        if (rng_pptr >= rng_psize)
          rng_pptr -= rng_psize;
      }
      function rng_seed_time() {
        rng_seed_int(new Date().getTime());
      }
      if (rng_pool == null) {
        rng_pool = new Array();
        rng_pptr = 0;
        var t;
        if (typeof window !== "undefined" && window.crypto) {
          if (window.crypto.getRandomValues) {
            var ua = new Uint8Array(32);
            window.crypto.getRandomValues(ua);
            for (t = 0; t < 32; ++t)
              rng_pool[rng_pptr++] = ua[t];
          } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
            var z = window.crypto.random(32);
            for (t = 0; t < z.length; ++t)
              rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
          }
        }
        while (rng_pptr < rng_psize) {
          t = Math.floor(65536 * Math.random());
          rng_pool[rng_pptr++] = t >>> 8;
          rng_pool[rng_pptr++] = t & 255;
        }
        rng_pptr = 0;
        rng_seed_time();
      }
      function rng_get_byte() {
        if (rng_state == null) {
          rng_seed_time();
          rng_state = prng_newstate();
          rng_state.init(rng_pool);
          for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
            rng_pool[rng_pptr] = 0;
          rng_pptr = 0;
        }
        return rng_state.next();
      }
      function rng_get_bytes(ba) {
        var i;
        for (i = 0; i < ba.length; ++i)
          ba[i] = rng_get_byte();
      }
      function SecureRandom() {
      }
      SecureRandom.prototype.nextBytes = rng_get_bytes;
      function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = new Array();
      }
      function ARC4init(key) {
        var i, j, t2;
        for (i = 0; i < 256; ++i)
          this.S[i] = i;
        j = 0;
        for (i = 0; i < 256; ++i) {
          j = j + this.S[i] + key[i % key.length] & 255;
          t2 = this.S[i];
          this.S[i] = this.S[j];
          this.S[j] = t2;
        }
        this.i = 0;
        this.j = 0;
      }
      function ARC4next() {
        var t2;
        this.i = this.i + 1 & 255;
        this.j = this.j + this.S[this.i] & 255;
        t2 = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t2;
        return this.S[t2 + this.S[this.i] & 255];
      }
      Arcfour.prototype.init = ARC4init;
      Arcfour.prototype.next = ARC4next;
      function prng_newstate() {
        return new Arcfour();
      }
      var rng_psize = 256;
      if (typeof exports2 !== "undefined") {
        exports2 = module2.exports = {
          default: BigInteger,
          BigInteger,
          SecureRandom
        };
      } else {
        this.jsbn = {
          BigInteger,
          SecureRandom
        };
      }
    }).call(exports2);
  }
});

// node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/sprintf-js/src/sprintf.js"(exports2) {
    !function() {
      "use strict";
      var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []));
      }
      function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign;
        for (i = 0; i < tree_length; i++) {
          if (typeof parse_tree[i] === "string") {
            output += parse_tree[i];
          } else if (typeof parse_tree[i] === "object") {
            ph = parse_tree[i];
            if (ph.keys) {
              arg = argv[cursor];
              for (k = 0; k < ph.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                }
                arg = arg[ph.keys[k]];
              }
            } else if (ph.param_no) {
              arg = argv[ph.param_no];
            } else {
              arg = argv[cursor++];
            }
            if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
            }
            if (re.number.test(ph.type)) {
              is_positive = arg >= 0;
            }
            switch (ph.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                break;
              case "e":
                arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re.json.test(ph.type)) {
              output += arg;
            } else {
              if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                sign = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign = "";
              }
              pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
              pad_length = ph.width - (sign + arg).length;
              pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output += ph.align ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
            }
          }
        }
        return output;
      }
      var sprintf_cache = Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = re.text.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = re.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match = re.placeholder.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push({
              placeholder: match[0],
              param_no: match[1],
              keys: match[2],
              sign: match[3],
              pad_char: match[4],
              align: match[5],
              width: match[6],
              precision: match[7],
              type: match[8]
            });
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      if (typeof exports2 !== "undefined") {
        exports2["sprintf"] = sprintf;
        exports2["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf;
        window["vsprintf"] = vsprintf;
        if (typeof define === "function" && define["amd"]) {
          define(function() {
            return {
              "sprintf": sprintf,
              "vsprintf": vsprintf
            };
          });
        }
      }
    }();
  }
});

// node_modules/ip-address/dist/ipv4.js
var require_ipv4 = __commonJS({
  "node_modules/ip-address/dist/ipv4.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Address4 = void 0;
    var common = __importStar(require_common4());
    var constants = __importStar(require_constants2());
    var address_error_1 = require_address_error();
    var jsbn_1 = require_jsbn();
    var sprintf_js_1 = require_sprintf();
    var Address4 = class {
      constructor(address) {
        this.groups = constants.GROUPS;
        this.parsedAddress = [];
        this.parsedSubnet = "";
        this.subnet = "/32";
        this.subnetMask = 32;
        this.v4 = true;
        this.isCorrect = common.isCorrect(constants.BITS);
        this.isInSubnet = common.isInSubnet;
        this.address = address;
        const subnet = constants.RE_SUBNET_STRING.exec(address);
        if (subnet) {
          this.parsedSubnet = subnet[0].replace("/", "");
          this.subnetMask = parseInt(this.parsedSubnet, 10);
          this.subnet = `/${this.subnetMask}`;
          if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
            throw new address_error_1.AddressError("Invalid subnet mask.");
          }
          address = address.replace(constants.RE_SUBNET_STRING, "");
        }
        this.addressMinusSuffix = address;
        this.parsedAddress = this.parse(address);
      }
      static isValid(address) {
        try {
          new Address4(address);
          return true;
        } catch (e) {
          return false;
        }
      }
      parse(address) {
        const groups = address.split(".");
        if (!address.match(constants.RE_ADDRESS)) {
          throw new address_error_1.AddressError("Invalid IPv4 address.");
        }
        return groups;
      }
      correctForm() {
        return this.parsedAddress.map((part) => parseInt(part, 10)).join(".");
      }
      static fromHex(hex) {
        const padded = hex.replace(/:/g, "").padStart(8, "0");
        const groups = [];
        let i;
        for (i = 0; i < 8; i += 2) {
          const h = padded.slice(i, i + 2);
          groups.push(parseInt(h, 16));
        }
        return new Address4(groups.join("."));
      }
      static fromInteger(integer) {
        return Address4.fromHex(integer.toString(16));
      }
      static fromArpa(arpaFormAddress) {
        const leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, "");
        const address = leader.split(".").reverse().join(".");
        return new Address4(address);
      }
      toHex() {
        return this.parsedAddress.map((part) => (0, sprintf_js_1.sprintf)("%02x", parseInt(part, 10))).join(":");
      }
      toArray() {
        return this.parsedAddress.map((part) => parseInt(part, 10));
      }
      toGroup6() {
        const output = [];
        let i;
        for (i = 0; i < constants.GROUPS; i += 2) {
          const hex = (0, sprintf_js_1.sprintf)("%02x%02x", parseInt(this.parsedAddress[i], 10), parseInt(this.parsedAddress[i + 1], 10));
          output.push((0, sprintf_js_1.sprintf)("%x", parseInt(hex, 16)));
        }
        return output.join(":");
      }
      bigInteger() {
        return new jsbn_1.BigInteger(this.parsedAddress.map((n) => (0, sprintf_js_1.sprintf)("%02x", parseInt(n, 10))).join(""), 16);
      }
      _startAddress() {
        return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants.BITS - this.subnetMask), 2);
      }
      startAddress() {
        return Address4.fromBigInteger(this._startAddress());
      }
      startAddressExclusive() {
        const adjust = new jsbn_1.BigInteger("1");
        return Address4.fromBigInteger(this._startAddress().add(adjust));
      }
      _endAddress() {
        return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants.BITS - this.subnetMask), 2);
      }
      endAddress() {
        return Address4.fromBigInteger(this._endAddress());
      }
      endAddressExclusive() {
        const adjust = new jsbn_1.BigInteger("1");
        return Address4.fromBigInteger(this._endAddress().subtract(adjust));
      }
      static fromBigInteger(bigInteger) {
        return Address4.fromInteger(parseInt(bigInteger.toString(), 10));
      }
      mask(mask) {
        if (mask === void 0) {
          mask = this.subnetMask;
        }
        return this.getBitsBase2(0, mask);
      }
      getBitsBase2(start, end) {
        return this.binaryZeroPad().slice(start, end);
      }
      reverseForm(options) {
        if (!options) {
          options = {};
        }
        const reversed = this.correctForm().split(".").reverse().join(".");
        if (options.omitSuffix) {
          return reversed;
        }
        return (0, sprintf_js_1.sprintf)("%s.in-addr.arpa.", reversed);
      }
      isMulticast() {
        return this.isInSubnet(new Address4("224.0.0.0/4"));
      }
      binaryZeroPad() {
        return this.bigInteger().toString(2).padStart(constants.BITS, "0");
      }
      groupForV6() {
        const segments = this.parsedAddress;
        return this.address.replace(constants.RE_ADDRESS, (0, sprintf_js_1.sprintf)('<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>', segments.slice(0, 2).join("."), segments.slice(2, 4).join(".")));
      }
    };
    exports2.Address4 = Address4;
  }
});

// node_modules/ip-address/dist/v6/constants.js
var require_constants3 = __commonJS({
  "node_modules/ip-address/dist/v6/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RE_URL_WITH_PORT = exports2.RE_URL = exports2.RE_ZONE_STRING = exports2.RE_SUBNET_STRING = exports2.RE_BAD_ADDRESS = exports2.RE_BAD_CHARACTERS = exports2.TYPES = exports2.SCOPES = exports2.GROUPS = exports2.BITS = void 0;
    exports2.BITS = 128;
    exports2.GROUPS = 8;
    exports2.SCOPES = {
      0: "Reserved",
      1: "Interface local",
      2: "Link local",
      4: "Admin local",
      5: "Site local",
      8: "Organization local",
      14: "Global",
      15: "Reserved"
    };
    exports2.TYPES = {
      "ff01::1/128": "Multicast (All nodes on this interface)",
      "ff01::2/128": "Multicast (All routers on this interface)",
      "ff02::1/128": "Multicast (All nodes on this link)",
      "ff02::2/128": "Multicast (All routers on this link)",
      "ff05::2/128": "Multicast (All routers in this site)",
      "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
      "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
      "ff02::9/128": "Multicast (RIP routers)",
      "ff02::a/128": "Multicast (EIGRP routers)",
      "ff02::d/128": "Multicast (PIM routers)",
      "ff02::16/128": "Multicast (MLDv2 reports)",
      "ff01::fb/128": "Multicast (mDNSv6)",
      "ff02::fb/128": "Multicast (mDNSv6)",
      "ff05::fb/128": "Multicast (mDNSv6)",
      "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)",
      "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)",
      "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
      "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
      "::/128": "Unspecified",
      "::1/128": "Loopback",
      "ff00::/8": "Multicast",
      "fe80::/10": "Link-local unicast"
    };
    exports2.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
    exports2.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
    exports2.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
    exports2.RE_ZONE_STRING = /%.*$/;
    exports2.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/);
    exports2.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
  }
});

// node_modules/ip-address/dist/v6/helpers.js
var require_helpers = __commonJS({
  "node_modules/ip-address/dist/v6/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.simpleGroup = exports2.spanLeadingZeroes = exports2.spanAll = exports2.spanAllZeroes = void 0;
    var sprintf_js_1 = require_sprintf();
    function spanAllZeroes(s) {
      return s.replace(/(0+)/g, '<span class="zero">$1</span>');
    }
    exports2.spanAllZeroes = spanAllZeroes;
    function spanAll(s, offset = 0) {
      const letters = s.split("");
      return letters.map((n, i) => (0, sprintf_js_1.sprintf)('<span class="digit value-%s position-%d">%s</span>', n, i + offset, spanAllZeroes(n))).join("");
    }
    exports2.spanAll = spanAll;
    function spanLeadingZeroesSimple(group) {
      return group.replace(/^(0+)/, '<span class="zero">$1</span>');
    }
    function spanLeadingZeroes(address) {
      const groups = address.split(":");
      return groups.map((g) => spanLeadingZeroesSimple(g)).join(":");
    }
    exports2.spanLeadingZeroes = spanLeadingZeroes;
    function simpleGroup(addressString, offset = 0) {
      const groups = addressString.split(":");
      return groups.map((g, i) => {
        if (/group-v4/.test(g)) {
          return g;
        }
        return (0, sprintf_js_1.sprintf)('<span class="hover-group group-%d">%s</span>', i + offset, spanLeadingZeroesSimple(g));
      });
    }
    exports2.simpleGroup = simpleGroup;
  }
});

// node_modules/ip-address/dist/v6/regular-expressions.js
var require_regular_expressions = __commonJS({
  "node_modules/ip-address/dist/v6/regular-expressions.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.possibleElisions = exports2.simpleRegularExpression = exports2.ADDRESS_BOUNDARY = exports2.padGroup = exports2.groupPossibilities = void 0;
    var v6 = __importStar(require_constants3());
    var sprintf_js_1 = require_sprintf();
    function groupPossibilities(possibilities) {
      return (0, sprintf_js_1.sprintf)("(%s)", possibilities.join("|"));
    }
    exports2.groupPossibilities = groupPossibilities;
    function padGroup(group) {
      if (group.length < 4) {
        return (0, sprintf_js_1.sprintf)("0{0,%d}%s", 4 - group.length, group);
      }
      return group;
    }
    exports2.padGroup = padGroup;
    exports2.ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";
    function simpleRegularExpression(groups) {
      const zeroIndexes = [];
      groups.forEach((group, i) => {
        const groupInteger = parseInt(group, 16);
        if (groupInteger === 0) {
          zeroIndexes.push(i);
        }
      });
      const possibilities = zeroIndexes.map((zeroIndex) => groups.map((group, i) => {
        if (i === zeroIndex) {
          const elision = i === 0 || i === v6.GROUPS - 1 ? ":" : "";
          return groupPossibilities([padGroup(group), elision]);
        }
        return padGroup(group);
      }).join(":"));
      possibilities.push(groups.map(padGroup).join(":"));
      return groupPossibilities(possibilities);
    }
    exports2.simpleRegularExpression = simpleRegularExpression;
    function possibleElisions(elidedGroups, moreLeft, moreRight) {
      const left = moreLeft ? "" : ":";
      const right = moreRight ? "" : ":";
      const possibilities = [];
      if (!moreLeft && !moreRight) {
        possibilities.push("::");
      }
      if (moreLeft && moreRight) {
        possibilities.push("");
      }
      if (moreRight && !moreLeft || !moreRight && moreLeft) {
        possibilities.push(":");
      }
      possibilities.push((0, sprintf_js_1.sprintf)("%s(:0{1,4}){1,%d}", left, elidedGroups - 1));
      possibilities.push((0, sprintf_js_1.sprintf)("(0{1,4}:){1,%d}%s", elidedGroups - 1, right));
      possibilities.push((0, sprintf_js_1.sprintf)("(0{1,4}:){%d}0{1,4}", elidedGroups - 1));
      for (let groups = 1; groups < elidedGroups - 1; groups++) {
        for (let position = 1; position < elidedGroups - groups; position++) {
          possibilities.push((0, sprintf_js_1.sprintf)("(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}", position, elidedGroups - position - groups - 1));
        }
      }
      return groupPossibilities(possibilities);
    }
    exports2.possibleElisions = possibleElisions;
  }
});

// node_modules/ip-address/dist/ipv6.js
var require_ipv6 = __commonJS({
  "node_modules/ip-address/dist/ipv6.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Address6 = void 0;
    var common = __importStar(require_common4());
    var constants4 = __importStar(require_constants2());
    var constants6 = __importStar(require_constants3());
    var helpers = __importStar(require_helpers());
    var ipv4_1 = require_ipv4();
    var regular_expressions_1 = require_regular_expressions();
    var address_error_1 = require_address_error();
    var jsbn_1 = require_jsbn();
    var sprintf_js_1 = require_sprintf();
    function assert(condition) {
      if (!condition) {
        throw new Error("Assertion failed.");
      }
    }
    function addCommas(number) {
      const r = /(\d+)(\d{3})/;
      while (r.test(number)) {
        number = number.replace(r, "$1,$2");
      }
      return number;
    }
    function spanLeadingZeroes4(n) {
      n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
      n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
      return n;
    }
    function compact(address, slice) {
      const s1 = [];
      const s2 = [];
      let i;
      for (i = 0; i < address.length; i++) {
        if (i < slice[0]) {
          s1.push(address[i]);
        } else if (i > slice[1]) {
          s2.push(address[i]);
        }
      }
      return s1.concat(["compact"]).concat(s2);
    }
    function paddedHex(octet) {
      return (0, sprintf_js_1.sprintf)("%04x", parseInt(octet, 16));
    }
    function unsignByte(b) {
      return b & 255;
    }
    var Address6 = class {
      constructor(address, optionalGroups) {
        this.addressMinusSuffix = "";
        this.parsedSubnet = "";
        this.subnet = "/128";
        this.subnetMask = 128;
        this.v4 = false;
        this.zone = "";
        this.isInSubnet = common.isInSubnet;
        this.isCorrect = common.isCorrect(constants6.BITS);
        if (optionalGroups === void 0) {
          this.groups = constants6.GROUPS;
        } else {
          this.groups = optionalGroups;
        }
        this.address = address;
        const subnet = constants6.RE_SUBNET_STRING.exec(address);
        if (subnet) {
          this.parsedSubnet = subnet[0].replace("/", "");
          this.subnetMask = parseInt(this.parsedSubnet, 10);
          this.subnet = `/${this.subnetMask}`;
          if (Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > constants6.BITS) {
            throw new address_error_1.AddressError("Invalid subnet mask.");
          }
          address = address.replace(constants6.RE_SUBNET_STRING, "");
        } else if (/\//.test(address)) {
          throw new address_error_1.AddressError("Invalid subnet mask.");
        }
        const zone = constants6.RE_ZONE_STRING.exec(address);
        if (zone) {
          this.zone = zone[0];
          address = address.replace(constants6.RE_ZONE_STRING, "");
        }
        this.addressMinusSuffix = address;
        this.parsedAddress = this.parse(this.addressMinusSuffix);
      }
      static isValid(address) {
        try {
          new Address6(address);
          return true;
        } catch (e) {
          return false;
        }
      }
      static fromBigInteger(bigInteger) {
        const hex = bigInteger.toString(16).padStart(32, "0");
        const groups = [];
        let i;
        for (i = 0; i < constants6.GROUPS; i++) {
          groups.push(hex.slice(i * 4, (i + 1) * 4));
        }
        return new Address6(groups.join(":"));
      }
      static fromURL(url) {
        let host;
        let port = null;
        let result;
        if (url.indexOf("[") !== -1 && url.indexOf("]:") !== -1) {
          result = constants6.RE_URL_WITH_PORT.exec(url);
          if (result === null) {
            return {
              error: "failed to parse address with port",
              address: null,
              port: null
            };
          }
          host = result[1];
          port = result[2];
        } else if (url.indexOf("/") !== -1) {
          url = url.replace(/^[a-z0-9]+:\/\//, "");
          result = constants6.RE_URL.exec(url);
          if (result === null) {
            return {
              error: "failed to parse address from URL",
              address: null,
              port: null
            };
          }
          host = result[1];
        } else {
          host = url;
        }
        if (port) {
          port = parseInt(port, 10);
          if (port < 0 || port > 65536) {
            port = null;
          }
        } else {
          port = null;
        }
        return {
          address: new Address6(host),
          port
        };
      }
      static fromAddress4(address) {
        const address4 = new ipv4_1.Address4(address);
        const mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);
        return new Address6(`::ffff:${address4.correctForm()}/${mask6}`);
      }
      static fromArpa(arpaFormAddress) {
        let address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, "");
        const semicolonAmount = 7;
        if (address.length !== 63) {
          throw new address_error_1.AddressError("Invalid 'ip6.arpa' form.");
        }
        const parts = address.split(".").reverse();
        for (let i = semicolonAmount; i > 0; i--) {
          const insertIndex = i * 4;
          parts.splice(insertIndex, 0, ":");
        }
        address = parts.join("");
        return new Address6(address);
      }
      microsoftTranscription() {
        return (0, sprintf_js_1.sprintf)("%s.ipv6-literal.net", this.correctForm().replace(/:/g, "-"));
      }
      mask(mask = this.subnetMask) {
        return this.getBitsBase2(0, mask);
      }
      possibleSubnets(subnetSize = 128) {
        const availableBits = constants6.BITS - this.subnetMask;
        const subnetBits = Math.abs(subnetSize - constants6.BITS);
        const subnetPowers = availableBits - subnetBits;
        if (subnetPowers < 0) {
          return "0";
        }
        return addCommas(new jsbn_1.BigInteger("2", 10).pow(subnetPowers).toString(10));
      }
      _startAddress() {
        return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants6.BITS - this.subnetMask), 2);
      }
      startAddress() {
        return Address6.fromBigInteger(this._startAddress());
      }
      startAddressExclusive() {
        const adjust = new jsbn_1.BigInteger("1");
        return Address6.fromBigInteger(this._startAddress().add(adjust));
      }
      _endAddress() {
        return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants6.BITS - this.subnetMask), 2);
      }
      endAddress() {
        return Address6.fromBigInteger(this._endAddress());
      }
      endAddressExclusive() {
        const adjust = new jsbn_1.BigInteger("1");
        return Address6.fromBigInteger(this._endAddress().subtract(adjust));
      }
      getScope() {
        let scope = constants6.SCOPES[this.getBits(12, 16).intValue()];
        if (this.getType() === "Global unicast" && scope !== "Link local") {
          scope = "Global";
        }
        return scope || "Unknown";
      }
      getType() {
        for (const subnet of Object.keys(constants6.TYPES)) {
          if (this.isInSubnet(new Address6(subnet))) {
            return constants6.TYPES[subnet];
          }
        }
        return "Global unicast";
      }
      getBits(start, end) {
        return new jsbn_1.BigInteger(this.getBitsBase2(start, end), 2);
      }
      getBitsBase2(start, end) {
        return this.binaryZeroPad().slice(start, end);
      }
      getBitsBase16(start, end) {
        const length = end - start;
        if (length % 4 !== 0) {
          throw new Error("Length of bits to retrieve must be divisible by four");
        }
        return this.getBits(start, end).toString(16).padStart(length / 4, "0");
      }
      getBitsPastSubnet() {
        return this.getBitsBase2(this.subnetMask, constants6.BITS);
      }
      reverseForm(options) {
        if (!options) {
          options = {};
        }
        const characters = Math.floor(this.subnetMask / 4);
        const reversed = this.canonicalForm().replace(/:/g, "").split("").slice(0, characters).reverse().join(".");
        if (characters > 0) {
          if (options.omitSuffix) {
            return reversed;
          }
          return (0, sprintf_js_1.sprintf)("%s.ip6.arpa.", reversed);
        }
        if (options.omitSuffix) {
          return "";
        }
        return "ip6.arpa.";
      }
      correctForm() {
        let i;
        let groups = [];
        let zeroCounter = 0;
        const zeroes = [];
        for (i = 0; i < this.parsedAddress.length; i++) {
          const value = parseInt(this.parsedAddress[i], 16);
          if (value === 0) {
            zeroCounter++;
          }
          if (value !== 0 && zeroCounter > 0) {
            if (zeroCounter > 1) {
              zeroes.push([i - zeroCounter, i - 1]);
            }
            zeroCounter = 0;
          }
        }
        if (zeroCounter > 1) {
          zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);
        }
        const zeroLengths = zeroes.map((n) => n[1] - n[0] + 1);
        if (zeroes.length > 0) {
          const index = zeroLengths.indexOf(Math.max(...zeroLengths));
          groups = compact(this.parsedAddress, zeroes[index]);
        } else {
          groups = this.parsedAddress;
        }
        for (i = 0; i < groups.length; i++) {
          if (groups[i] !== "compact") {
            groups[i] = parseInt(groups[i], 16).toString(16);
          }
        }
        let correct = groups.join(":");
        correct = correct.replace(/^compact$/, "::");
        correct = correct.replace(/^compact|compact$/, ":");
        correct = correct.replace(/compact/, "");
        return correct;
      }
      binaryZeroPad() {
        return this.bigInteger().toString(2).padStart(constants6.BITS, "0");
      }
      parse4in6(address) {
        const groups = address.split(":");
        const lastGroup = groups.slice(-1)[0];
        const address4 = lastGroup.match(constants4.RE_ADDRESS);
        if (address4) {
          this.parsedAddress4 = address4[0];
          this.address4 = new ipv4_1.Address4(this.parsedAddress4);
          for (let i = 0; i < this.address4.groups; i++) {
            if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {
              throw new address_error_1.AddressError("IPv4 addresses can't have leading zeroes.", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join(".")));
            }
          }
          this.v4 = true;
          groups[groups.length - 1] = this.address4.toGroup6();
          address = groups.join(":");
        }
        return address;
      }
      parse(address) {
        address = this.parse4in6(address);
        const badCharacters = address.match(constants6.RE_BAD_CHARACTERS);
        if (badCharacters) {
          throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)("Bad character%s detected in address: %s", badCharacters.length > 1 ? "s" : "", badCharacters.join("")), address.replace(constants6.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'));
        }
        const badAddress = address.match(constants6.RE_BAD_ADDRESS);
        if (badAddress) {
          throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)("Address failed regex: %s", badAddress.join("")), address.replace(constants6.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'));
        }
        let groups = [];
        const halves = address.split("::");
        if (halves.length === 2) {
          let first = halves[0].split(":");
          let last = halves[1].split(":");
          if (first.length === 1 && first[0] === "") {
            first = [];
          }
          if (last.length === 1 && last[0] === "") {
            last = [];
          }
          const remaining = this.groups - (first.length + last.length);
          if (!remaining) {
            throw new address_error_1.AddressError("Error parsing groups");
          }
          this.elidedGroups = remaining;
          this.elisionBegin = first.length;
          this.elisionEnd = first.length + this.elidedGroups;
          groups = groups.concat(first);
          for (let i = 0; i < remaining; i++) {
            groups.push("0");
          }
          groups = groups.concat(last);
        } else if (halves.length === 1) {
          groups = address.split(":");
          this.elidedGroups = 0;
        } else {
          throw new address_error_1.AddressError("Too many :: groups found");
        }
        groups = groups.map((group) => (0, sprintf_js_1.sprintf)("%x", parseInt(group, 16)));
        if (groups.length !== this.groups) {
          throw new address_error_1.AddressError("Incorrect number of groups found");
        }
        return groups;
      }
      canonicalForm() {
        return this.parsedAddress.map(paddedHex).join(":");
      }
      decimal() {
        return this.parsedAddress.map((n) => (0, sprintf_js_1.sprintf)("%05d", parseInt(n, 16))).join(":");
      }
      bigInteger() {
        return new jsbn_1.BigInteger(this.parsedAddress.map(paddedHex).join(""), 16);
      }
      to4() {
        const binary = this.binaryZeroPad().split("");
        return ipv4_1.Address4.fromHex(new jsbn_1.BigInteger(binary.slice(96, 128).join(""), 2).toString(16));
      }
      to4in6() {
        const address4 = this.to4();
        const address6 = new Address6(this.parsedAddress.slice(0, 6).join(":"), 6);
        const correct = address6.correctForm();
        let infix = "";
        if (!/:$/.test(correct)) {
          infix = ":";
        }
        return correct + infix + address4.address;
      }
      inspectTeredo() {
        const prefix = this.getBitsBase16(0, 32);
        const udpPort = this.getBits(80, 96).xor(new jsbn_1.BigInteger("ffff", 16)).toString();
        const server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));
        const client4 = ipv4_1.Address4.fromHex(this.getBits(96, 128).xor(new jsbn_1.BigInteger("ffffffff", 16)).toString(16));
        const flags = this.getBits(64, 80);
        const flagsBase2 = this.getBitsBase2(64, 80);
        const coneNat = flags.testBit(15);
        const reserved = flags.testBit(14);
        const groupIndividual = flags.testBit(8);
        const universalLocal = flags.testBit(9);
        const nonce = new jsbn_1.BigInteger(flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16), 2).toString(10);
        return {
          prefix: (0, sprintf_js_1.sprintf)("%s:%s", prefix.slice(0, 4), prefix.slice(4, 8)),
          server4: server4.address,
          client4: client4.address,
          flags: flagsBase2,
          coneNat,
          microsoft: {
            reserved,
            universalLocal,
            groupIndividual,
            nonce
          },
          udpPort
        };
      }
      inspect6to4() {
        const prefix = this.getBitsBase16(0, 16);
        const gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));
        return {
          prefix: (0, sprintf_js_1.sprintf)("%s", prefix.slice(0, 4)),
          gateway: gateway.address
        };
      }
      to6to4() {
        if (!this.is4()) {
          return null;
        }
        const addr6to4 = [
          "2002",
          this.getBitsBase16(96, 112),
          this.getBitsBase16(112, 128),
          "",
          "/16"
        ].join(":");
        return new Address6(addr6to4);
      }
      toByteArray() {
        const byteArray = this.bigInteger().toByteArray();
        if (byteArray.length === 17 && byteArray[0] === 0) {
          return byteArray.slice(1);
        }
        return byteArray;
      }
      toUnsignedByteArray() {
        return this.toByteArray().map(unsignByte);
      }
      static fromByteArray(bytes) {
        return this.fromUnsignedByteArray(bytes.map(unsignByte));
      }
      static fromUnsignedByteArray(bytes) {
        const BYTE_MAX = new jsbn_1.BigInteger("256", 10);
        let result = new jsbn_1.BigInteger("0", 10);
        let multiplier = new jsbn_1.BigInteger("1", 10);
        for (let i = bytes.length - 1; i >= 0; i--) {
          result = result.add(multiplier.multiply(new jsbn_1.BigInteger(bytes[i].toString(10), 10)));
          multiplier = multiplier.multiply(BYTE_MAX);
        }
        return Address6.fromBigInteger(result);
      }
      isCanonical() {
        return this.addressMinusSuffix === this.canonicalForm();
      }
      isLinkLocal() {
        if (this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000") {
          return true;
        }
        return false;
      }
      isMulticast() {
        return this.getType() === "Multicast";
      }
      is4() {
        return this.v4;
      }
      isTeredo() {
        return this.isInSubnet(new Address6("2001::/32"));
      }
      is6to4() {
        return this.isInSubnet(new Address6("2002::/16"));
      }
      isLoopback() {
        return this.getType() === "Loopback";
      }
      href(optionalPort) {
        if (optionalPort === void 0) {
          optionalPort = "";
        } else {
          optionalPort = (0, sprintf_js_1.sprintf)(":%s", optionalPort);
        }
        return (0, sprintf_js_1.sprintf)("http://[%s]%s/", this.correctForm(), optionalPort);
      }
      link(options) {
        if (!options) {
          options = {};
        }
        if (options.className === void 0) {
          options.className = "";
        }
        if (options.prefix === void 0) {
          options.prefix = "/#address=";
        }
        if (options.v4 === void 0) {
          options.v4 = false;
        }
        let formFunction = this.correctForm;
        if (options.v4) {
          formFunction = this.to4in6;
        }
        if (options.className) {
          return (0, sprintf_js_1.sprintf)('<a href="%1$s%2$s" class="%3$s">%2$s</a>', options.prefix, formFunction.call(this), options.className);
        }
        return (0, sprintf_js_1.sprintf)('<a href="%1$s%2$s">%2$s</a>', options.prefix, formFunction.call(this));
      }
      group() {
        if (this.elidedGroups === 0) {
          return helpers.simpleGroup(this.address).join(":");
        }
        assert(typeof this.elidedGroups === "number");
        assert(typeof this.elisionBegin === "number");
        const output = [];
        const [left, right] = this.address.split("::");
        if (left.length) {
          output.push(...helpers.simpleGroup(left));
        } else {
          output.push("");
        }
        const classes = ["hover-group"];
        for (let i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {
          classes.push((0, sprintf_js_1.sprintf)("group-%d", i));
        }
        output.push((0, sprintf_js_1.sprintf)('<span class="%s"></span>', classes.join(" ")));
        if (right.length) {
          output.push(...helpers.simpleGroup(right, this.elisionEnd));
        } else {
          output.push("");
        }
        if (this.is4()) {
          assert(this.address4 instanceof ipv4_1.Address4);
          output.pop();
          output.push(this.address4.groupForV6());
        }
        return output.join(":");
      }
      regularExpressionString(substringSearch = false) {
        let output = [];
        const address6 = new Address6(this.correctForm());
        if (address6.elidedGroups === 0) {
          output.push((0, regular_expressions_1.simpleRegularExpression)(address6.parsedAddress));
        } else if (address6.elidedGroups === constants6.GROUPS) {
          output.push((0, regular_expressions_1.possibleElisions)(constants6.GROUPS));
        } else {
          const halves = address6.address.split("::");
          if (halves[0].length) {
            output.push((0, regular_expressions_1.simpleRegularExpression)(halves[0].split(":")));
          }
          assert(typeof address6.elidedGroups === "number");
          output.push((0, regular_expressions_1.possibleElisions)(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));
          if (halves[1].length) {
            output.push((0, regular_expressions_1.simpleRegularExpression)(halves[1].split(":")));
          }
          output = [output.join(":")];
        }
        if (!substringSearch) {
          output = [
            "(?=^|",
            regular_expressions_1.ADDRESS_BOUNDARY,
            "|[^\\w\\:])(",
            ...output,
            ")(?=[^\\w\\:]|",
            regular_expressions_1.ADDRESS_BOUNDARY,
            "|$)"
          ];
        }
        return output.join("");
      }
      regularExpression(substringSearch = false) {
        return new RegExp(this.regularExpressionString(substringSearch), "i");
      }
    };
    exports2.Address6 = Address6;
  }
});

// node_modules/ip-address/dist/ip-address.js
var require_ip_address = __commonJS({
  "node_modules/ip-address/dist/ip-address.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.v6 = exports2.AddressError = exports2.Address6 = exports2.Address4 = void 0;
    var ipv4_1 = require_ipv4();
    Object.defineProperty(exports2, "Address4", { enumerable: true, get: function() {
      return ipv4_1.Address4;
    } });
    var ipv6_1 = require_ipv6();
    Object.defineProperty(exports2, "Address6", { enumerable: true, get: function() {
      return ipv6_1.Address6;
    } });
    var address_error_1 = require_address_error();
    Object.defineProperty(exports2, "AddressError", { enumerable: true, get: function() {
      return address_error_1.AddressError;
    } });
    var helpers = __importStar(require_helpers());
    exports2.v6 = { helpers };
  }
});

// node_modules/socks/build/common/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/socks/build/common/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ipToBuffer = exports2.int32ToIpv4 = exports2.ipv4ToInt32 = exports2.validateSocksClientChainOptions = exports2.validateSocksClientOptions = void 0;
    var util_1 = require_util();
    var constants_1 = require_constants();
    var stream = require("stream");
    var ip_address_1 = require_ip_address();
    var net = require("net");
    function validateSocksClientOptions(options, acceptedCommands = ["connect", "bind", "associate"]) {
      if (!constants_1.SocksCommand[options.command]) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommand, options);
      }
      if (acceptedCommands.indexOf(options.command) === -1) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandForOperation, options);
      }
      if (!isValidSocksRemoteHost(options.destination)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
      }
      if (!isValidSocksProxy(options.proxy)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
      }
      validateCustomProxyAuth(options.proxy, options);
      if (options.timeout && !isValidTimeoutValue(options.timeout)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
      }
      if (options.existing_socket && !(options.existing_socket instanceof stream.Duplex)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket, options);
      }
    }
    exports2.validateSocksClientOptions = validateSocksClientOptions;
    function validateSocksClientChainOptions(options) {
      if (options.command !== "connect") {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksCommandChain, options);
      }
      if (!isValidSocksRemoteHost(options.destination)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
      }
      if (!(options.proxies && Array.isArray(options.proxies) && options.proxies.length >= 2)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength, options);
      }
      options.proxies.forEach((proxy) => {
        if (!isValidSocksProxy(proxy)) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
        }
        validateCustomProxyAuth(proxy, options);
      });
      if (options.timeout && !isValidTimeoutValue(options.timeout)) {
        throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
      }
    }
    exports2.validateSocksClientChainOptions = validateSocksClientChainOptions;
    function validateCustomProxyAuth(proxy, options) {
      if (proxy.custom_auth_method !== void 0) {
        if (proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START || proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange, options);
        }
        if (proxy.custom_auth_request_handler === void 0 || typeof proxy.custom_auth_request_handler !== "function") {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
        if (proxy.custom_auth_response_size === void 0) {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
        if (proxy.custom_auth_response_handler === void 0 || typeof proxy.custom_auth_response_handler !== "function") {
          throw new util_1.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
        }
      }
    }
    function isValidSocksRemoteHost(remoteHost) {
      return remoteHost && typeof remoteHost.host === "string" && typeof remoteHost.port === "number" && remoteHost.port >= 0 && remoteHost.port <= 65535;
    }
    function isValidSocksProxy(proxy) {
      return proxy && (typeof proxy.host === "string" || typeof proxy.ipaddress === "string") && typeof proxy.port === "number" && proxy.port >= 0 && proxy.port <= 65535 && (proxy.type === 4 || proxy.type === 5);
    }
    function isValidTimeoutValue(value) {
      return typeof value === "number" && value > 0;
    }
    function ipv4ToInt32(ip) {
      const address = new ip_address_1.Address4(ip);
      return address.toArray().reduce((acc, part) => (acc << 8) + part, 0);
    }
    exports2.ipv4ToInt32 = ipv4ToInt32;
    function int32ToIpv4(int32) {
      const octet1 = int32 >>> 24 & 255;
      const octet2 = int32 >>> 16 & 255;
      const octet3 = int32 >>> 8 & 255;
      const octet4 = int32 & 255;
      return [octet1, octet2, octet3, octet4].join(".");
    }
    exports2.int32ToIpv4 = int32ToIpv4;
    function ipToBuffer(ip) {
      if (net.isIPv4(ip)) {
        const address = new ip_address_1.Address4(ip);
        return Buffer.from(address.toArray());
      } else if (net.isIPv6(ip)) {
        const address = new ip_address_1.Address6(ip);
        return Buffer.from(address.canonicalForm().split(":").map((segment) => segment.padStart(4, "0")).join(""), "hex");
      } else {
        throw new Error("Invalid IP address format");
      }
    }
    exports2.ipToBuffer = ipToBuffer;
  }
});

// node_modules/socks/build/common/receivebuffer.js
var require_receivebuffer = __commonJS({
  "node_modules/socks/build/common/receivebuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReceiveBuffer = void 0;
    var ReceiveBuffer = class {
      constructor(size = 4096) {
        this.buffer = Buffer.allocUnsafe(size);
        this.offset = 0;
        this.originalSize = size;
      }
      get length() {
        return this.offset;
      }
      append(data) {
        if (!Buffer.isBuffer(data)) {
          throw new Error("Attempted to append a non-buffer instance to ReceiveBuffer.");
        }
        if (this.offset + data.length >= this.buffer.length) {
          const tmp = this.buffer;
          this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + data.length));
          tmp.copy(this.buffer);
        }
        data.copy(this.buffer, this.offset);
        return this.offset += data.length;
      }
      peek(length) {
        if (length > this.offset) {
          throw new Error("Attempted to read beyond the bounds of the managed internal data.");
        }
        return this.buffer.slice(0, length);
      }
      get(length) {
        if (length > this.offset) {
          throw new Error("Attempted to read beyond the bounds of the managed internal data.");
        }
        const value = Buffer.allocUnsafe(length);
        this.buffer.slice(0, length).copy(value);
        this.buffer.copyWithin(0, length, length + this.offset - length);
        this.offset -= length;
        return value;
      }
    };
    exports2.ReceiveBuffer = ReceiveBuffer;
  }
});

// node_modules/socks/build/client/socksclient.js
var require_socksclient = __commonJS({
  "node_modules/socks/build/client/socksclient.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SocksClientError = exports2.SocksClient = void 0;
    var events_1 = require("events");
    var net = require("net");
    var smart_buffer_1 = require_smartbuffer();
    var constants_1 = require_constants();
    var helpers_1 = require_helpers2();
    var receivebuffer_1 = require_receivebuffer();
    var util_1 = require_util();
    Object.defineProperty(exports2, "SocksClientError", { enumerable: true, get: function() {
      return util_1.SocksClientError;
    } });
    var ip_address_1 = require_ip_address();
    var SocksClient = class extends events_1.EventEmitter {
      constructor(options) {
        super();
        this.options = Object.assign({}, options);
        (0, helpers_1.validateSocksClientOptions)(options);
        this.setState(constants_1.SocksClientState.Created);
      }
      static createConnection(options, callback) {
        return new Promise((resolve, reject) => {
          try {
            (0, helpers_1.validateSocksClientOptions)(options, ["connect"]);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              return resolve(err);
            } else {
              return reject(err);
            }
          }
          const client = new SocksClient(options);
          client.connect(options.existing_socket);
          client.once("established", (info) => {
            client.removeAllListeners();
            if (typeof callback === "function") {
              callback(null, info);
              resolve(info);
            } else {
              resolve(info);
            }
          });
          client.once("error", (err) => {
            client.removeAllListeners();
            if (typeof callback === "function") {
              callback(err);
              resolve(err);
            } else {
              reject(err);
            }
          });
        });
      }
      static createConnectionChain(options, callback) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
          try {
            (0, helpers_1.validateSocksClientChainOptions)(options);
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              return resolve(err);
            } else {
              return reject(err);
            }
          }
          if (options.randomizeChain) {
            (0, util_1.shuffleArray)(options.proxies);
          }
          try {
            let sock;
            for (let i = 0; i < options.proxies.length; i++) {
              const nextProxy = options.proxies[i];
              const nextDestination = i === options.proxies.length - 1 ? options.destination : {
                host: options.proxies[i + 1].host || options.proxies[i + 1].ipaddress,
                port: options.proxies[i + 1].port
              };
              const result = yield SocksClient.createConnection({
                command: "connect",
                proxy: nextProxy,
                destination: nextDestination,
                existing_socket: sock
              });
              sock = sock || result.socket;
            }
            if (typeof callback === "function") {
              callback(null, { socket: sock });
              resolve({ socket: sock });
            } else {
              resolve({ socket: sock });
            }
          } catch (err) {
            if (typeof callback === "function") {
              callback(err);
              resolve(err);
            } else {
              reject(err);
            }
          }
        }));
      }
      static createUDPFrame(options) {
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt16BE(0);
        buff.writeUInt8(options.frameNumber || 0);
        if (net.isIPv4(options.remoteHost.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv4);
          buff.writeUInt32BE((0, helpers_1.ipv4ToInt32)(options.remoteHost.host));
        } else if (net.isIPv6(options.remoteHost.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv6);
          buff.writeBuffer((0, helpers_1.ipToBuffer)(options.remoteHost.host));
        } else {
          buff.writeUInt8(constants_1.Socks5HostType.Hostname);
          buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));
          buff.writeString(options.remoteHost.host);
        }
        buff.writeUInt16BE(options.remoteHost.port);
        buff.writeBuffer(options.data);
        return buff.toBuffer();
      }
      static parseUDPFrame(data) {
        const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
        buff.readOffset = 2;
        const frameNumber = buff.readUInt8();
        const hostType = buff.readUInt8();
        let remoteHost;
        if (hostType === constants_1.Socks5HostType.IPv4) {
          remoteHost = (0, helpers_1.int32ToIpv4)(buff.readUInt32BE());
        } else if (hostType === constants_1.Socks5HostType.IPv6) {
          remoteHost = ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm();
        } else {
          remoteHost = buff.readString(buff.readUInt8());
        }
        const remotePort = buff.readUInt16BE();
        return {
          frameNumber,
          remoteHost: {
            host: remoteHost,
            port: remotePort
          },
          data: buff.readBuffer()
        };
      }
      setState(newState) {
        if (this.state !== constants_1.SocksClientState.Error) {
          this.state = newState;
        }
      }
      connect(existingSocket) {
        this.onDataReceived = (data) => this.onDataReceivedHandler(data);
        this.onClose = () => this.onCloseHandler();
        this.onError = (err) => this.onErrorHandler(err);
        this.onConnect = () => this.onConnectHandler();
        const timer = setTimeout(() => this.onEstablishedTimeout(), this.options.timeout || constants_1.DEFAULT_TIMEOUT);
        if (timer.unref && typeof timer.unref === "function") {
          timer.unref();
        }
        if (existingSocket) {
          this.socket = existingSocket;
        } else {
          this.socket = new net.Socket();
        }
        this.socket.once("close", this.onClose);
        this.socket.once("error", this.onError);
        this.socket.once("connect", this.onConnect);
        this.socket.on("data", this.onDataReceived);
        this.setState(constants_1.SocksClientState.Connecting);
        this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();
        if (existingSocket) {
          this.socket.emit("connect");
        } else {
          this.socket.connect(this.getSocketOptions());
          if (this.options.set_tcp_nodelay !== void 0 && this.options.set_tcp_nodelay !== null) {
            this.socket.setNoDelay(!!this.options.set_tcp_nodelay);
          }
        }
        this.prependOnceListener("established", (info) => {
          setImmediate(() => {
            if (this.receiveBuffer.length > 0) {
              const excessData = this.receiveBuffer.get(this.receiveBuffer.length);
              info.socket.emit("data", excessData);
            }
            info.socket.resume();
          });
        });
      }
      getSocketOptions() {
        return Object.assign(Object.assign({}, this.options.socket_options), { host: this.options.proxy.host || this.options.proxy.ipaddress, port: this.options.proxy.port });
      }
      onEstablishedTimeout() {
        if (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.BoundWaitingForConnection) {
          this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);
        }
      }
      onConnectHandler() {
        this.setState(constants_1.SocksClientState.Connected);
        if (this.options.proxy.type === 4) {
          this.sendSocks4InitialHandshake();
        } else {
          this.sendSocks5InitialHandshake();
        }
        this.setState(constants_1.SocksClientState.SentInitialHandshake);
      }
      onDataReceivedHandler(data) {
        this.receiveBuffer.append(data);
        this.processData();
      }
      processData() {
        while (this.state !== constants_1.SocksClientState.Established && this.state !== constants_1.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize) {
          if (this.state === constants_1.SocksClientState.SentInitialHandshake) {
            if (this.options.proxy.type === 4) {
              this.handleSocks4FinalHandshakeResponse();
            } else {
              this.handleInitialSocks5HandshakeResponse();
            }
          } else if (this.state === constants_1.SocksClientState.SentAuthentication) {
            this.handleInitialSocks5AuthenticationHandshakeResponse();
          } else if (this.state === constants_1.SocksClientState.SentFinalHandshake) {
            this.handleSocks5FinalHandshakeResponse();
          } else if (this.state === constants_1.SocksClientState.BoundWaitingForConnection) {
            if (this.options.proxy.type === 4) {
              this.handleSocks4IncomingConnectionResponse();
            } else {
              this.handleSocks5IncomingConnectionResponse();
            }
          } else {
            this.closeSocket(constants_1.ERRORS.InternalError);
            break;
          }
        }
      }
      onCloseHandler() {
        this.closeSocket(constants_1.ERRORS.SocketClosed);
      }
      onErrorHandler(err) {
        this.closeSocket(err.message);
      }
      removeInternalSocketHandlers() {
        this.socket.pause();
        this.socket.removeListener("data", this.onDataReceived);
        this.socket.removeListener("close", this.onClose);
        this.socket.removeListener("error", this.onError);
        this.socket.removeListener("connect", this.onConnect);
      }
      closeSocket(err) {
        if (this.state !== constants_1.SocksClientState.Error) {
          this.setState(constants_1.SocksClientState.Error);
          this.socket.destroy();
          this.removeInternalSocketHandlers();
          this.emit("error", new util_1.SocksClientError(err, this.options));
        }
      }
      sendSocks4InitialHandshake() {
        const userId = this.options.proxy.userId || "";
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(4);
        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
        buff.writeUInt16BE(this.options.destination.port);
        if (net.isIPv4(this.options.destination.host)) {
          buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
          buff.writeStringNT(userId);
        } else {
          buff.writeUInt8(0);
          buff.writeUInt8(0);
          buff.writeUInt8(0);
          buff.writeUInt8(1);
          buff.writeStringNT(userId);
          buff.writeStringNT(this.options.destination.host);
        }
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;
        this.socket.write(buff.toBuffer());
      }
      handleSocks4FinalHandshakeResponse() {
        const data = this.receiveBuffer.get(8);
        if (data[1] !== constants_1.Socks4Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedConnection} - (${constants_1.Socks4Response[data[1]]})`);
        } else {
          if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
            const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
            buff.readOffset = 2;
            const remoteHost = {
              port: buff.readUInt16BE(),
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
            this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
            this.emit("bound", { remoteHost, socket: this.socket });
          } else {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { socket: this.socket });
          }
        }
      }
      handleSocks4IncomingConnectionResponse() {
        const data = this.receiveBuffer.get(8);
        if (data[1] !== constants_1.Socks4Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_1.Socks4Response[data[1]]})`);
        } else {
          const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
          buff.readOffset = 2;
          const remoteHost = {
            port: buff.readUInt16BE(),
            host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
          };
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        }
      }
      sendSocks5InitialHandshake() {
        const buff = new smart_buffer_1.SmartBuffer();
        const supportedAuthMethods = [constants_1.Socks5Auth.NoAuth];
        if (this.options.proxy.userId || this.options.proxy.password) {
          supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);
        }
        if (this.options.proxy.custom_auth_method !== void 0) {
          supportedAuthMethods.push(this.options.proxy.custom_auth_method);
        }
        buff.writeUInt8(5);
        buff.writeUInt8(supportedAuthMethods.length);
        for (const authMethod of supportedAuthMethods) {
          buff.writeUInt8(authMethod);
        }
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentInitialHandshake);
      }
      handleInitialSocks5HandshakeResponse() {
        const data = this.receiveBuffer.get(2);
        if (data[0] !== 5) {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);
        } else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {
          this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);
        } else {
          if (data[1] === constants_1.Socks5Auth.NoAuth) {
            this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;
            this.sendSocks5CommandRequest();
          } else if (data[1] === constants_1.Socks5Auth.UserPass) {
            this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;
            this.sendSocks5UserPassAuthentication();
          } else if (data[1] === this.options.proxy.custom_auth_method) {
            this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;
            this.sendSocks5CustomAuthentication();
          } else {
            this.closeSocket(constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);
          }
        }
      }
      sendSocks5UserPassAuthentication() {
        const userId = this.options.proxy.userId || "";
        const password = this.options.proxy.password || "";
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(1);
        buff.writeUInt8(Buffer.byteLength(userId));
        buff.writeString(userId);
        buff.writeUInt8(Buffer.byteLength(password));
        buff.writeString(password);
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentAuthentication);
      }
      sendSocks5CustomAuthentication() {
        return __awaiter(this, void 0, void 0, function* () {
          this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size;
          this.socket.write(yield this.options.proxy.custom_auth_request_handler());
          this.setState(constants_1.SocksClientState.SentAuthentication);
        });
      }
      handleSocks5CustomAuthHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return yield this.options.proxy.custom_auth_response_handler(data);
        });
      }
      handleSocks5AuthenticationNoAuthHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return data[1] === 0;
        });
      }
      handleSocks5AuthenticationUserPassHandshakeResponse(data) {
        return __awaiter(this, void 0, void 0, function* () {
          return data[1] === 0;
        });
      }
      handleInitialSocks5AuthenticationHandshakeResponse() {
        return __awaiter(this, void 0, void 0, function* () {
          this.setState(constants_1.SocksClientState.ReceivedAuthenticationResponse);
          let authResult = false;
          if (this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth) {
            authResult = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));
          } else if (this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass) {
            authResult = yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));
          } else if (this.socks5ChosenAuthType === this.options.proxy.custom_auth_method) {
            authResult = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));
          }
          if (!authResult) {
            this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);
          } else {
            this.sendSocks5CommandRequest();
          }
        });
      }
      sendSocks5CommandRequest() {
        const buff = new smart_buffer_1.SmartBuffer();
        buff.writeUInt8(5);
        buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
        buff.writeUInt8(0);
        if (net.isIPv4(this.options.destination.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv4);
          buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
        } else if (net.isIPv6(this.options.destination.host)) {
          buff.writeUInt8(constants_1.Socks5HostType.IPv6);
          buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
        } else {
          buff.writeUInt8(constants_1.Socks5HostType.Hostname);
          buff.writeUInt8(this.options.destination.host.length);
          buff.writeString(this.options.destination.host);
        }
        buff.writeUInt16BE(this.options.destination.port);
        this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
        this.socket.write(buff.toBuffer());
        this.setState(constants_1.SocksClientState.SentFinalHandshake);
      }
      handleSocks5FinalHandshakeResponse() {
        const header = this.receiveBuffer.peek(5);
        if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_1.Socks5Response[header[1]]}`);
        } else {
          const addressType = header[3];
          let remoteHost;
          let buff;
          if (addressType === constants_1.Socks5HostType.IPv4) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
              port: buff.readUInt16BE()
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
          } else if (addressType === constants_1.Socks5HostType.Hostname) {
            const hostLength = header[4];
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
            remoteHost = {
              host: buff.readString(hostLength),
              port: buff.readUInt16BE()
            };
          } else if (addressType === constants_1.Socks5HostType.IPv6) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
              port: buff.readUInt16BE()
            };
          }
          this.setState(constants_1.SocksClientState.ReceivedFinalResponse);
          if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.connect) {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { remoteHost, socket: this.socket });
          } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.bind) {
            this.setState(constants_1.SocksClientState.BoundWaitingForConnection);
            this.nextRequiredPacketBufferSize = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
            this.emit("bound", { remoteHost, socket: this.socket });
          } else if (constants_1.SocksCommand[this.options.command] === constants_1.SocksCommand.associate) {
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", {
              remoteHost,
              socket: this.socket
            });
          }
        }
      }
      handleSocks5IncomingConnectionResponse() {
        const header = this.receiveBuffer.peek(5);
        if (header[0] !== 5 || header[1] !== constants_1.Socks5Response.Granted) {
          this.closeSocket(`${constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_1.Socks5Response[header[1]]}`);
        } else {
          const addressType = header[3];
          let remoteHost;
          let buff;
          if (addressType === constants_1.Socks5HostType.IPv4) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
              port: buff.readUInt16BE()
            };
            if (remoteHost.host === "0.0.0.0") {
              remoteHost.host = this.options.proxy.ipaddress;
            }
          } else if (addressType === constants_1.Socks5HostType.Hostname) {
            const hostLength = header[4];
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
            remoteHost = {
              host: buff.readString(hostLength),
              port: buff.readUInt16BE()
            };
          } else if (addressType === constants_1.Socks5HostType.IPv6) {
            const dataNeeded = constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
            if (this.receiveBuffer.length < dataNeeded) {
              this.nextRequiredPacketBufferSize = dataNeeded;
              return;
            }
            buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
            remoteHost = {
              host: ip_address_1.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
              port: buff.readUInt16BE()
            };
          }
          this.setState(constants_1.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        }
      }
      get socksClientOptions() {
        return Object.assign({}, this.options);
      }
    };
    exports2.SocksClient = SocksClient;
  }
});

// node_modules/socks/build/index.js
var require_build = __commonJS({
  "node_modules/socks/build/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_socksclient(), exports2);
  }
});

// node_modules/socks-proxy-agent/dist/agent.js
var require_agent2 = __commonJS({
  "node_modules/socks-proxy-agent/dist/agent.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dns_1 = __importDefault(require("dns"));
    var tls_1 = __importDefault(require("tls"));
    var url_1 = __importDefault(require("url"));
    var debug_1 = __importDefault(require_src());
    var agent_base_1 = require_src2();
    var socks_1 = require_build();
    var debug = debug_1.default("socks-proxy-agent");
    function dnsLookup(host) {
      return new Promise((resolve, reject) => {
        dns_1.default.lookup(host, (err, res) => {
          if (err) {
            reject(err);
          } else {
            resolve(res);
          }
        });
      });
    }
    function parseSocksProxy(opts) {
      let port = 0;
      let lookup = false;
      let type = 5;
      const host = opts.hostname || opts.host;
      if (!host) {
        throw new TypeError('No "host"');
      }
      if (typeof opts.port === "number") {
        port = opts.port;
      } else if (typeof opts.port === "string") {
        port = parseInt(opts.port, 10);
      }
      if (!port) {
        port = 1080;
      }
      if (opts.protocol) {
        switch (opts.protocol.replace(":", "")) {
          case "socks4":
            lookup = true;
          case "socks4a":
            type = 4;
            break;
          case "socks5":
            lookup = true;
          case "socks":
          case "socks5h":
            type = 5;
            break;
          default:
            throw new TypeError(`A "socks" protocol must be specified! Got: ${opts.protocol}`);
        }
      }
      if (typeof opts.type !== "undefined") {
        if (opts.type === 4 || opts.type === 5) {
          type = opts.type;
        } else {
          throw new TypeError(`"type" must be 4 or 5, got: ${opts.type}`);
        }
      }
      const proxy = {
        host,
        port,
        type
      };
      let userId = opts.userId || opts.username;
      let password = opts.password;
      if (opts.auth) {
        const auth = opts.auth.split(":");
        userId = auth[0];
        password = auth[1];
      }
      if (userId) {
        Object.defineProperty(proxy, "userId", {
          value: userId,
          enumerable: false
        });
      }
      if (password) {
        Object.defineProperty(proxy, "password", {
          value: password,
          enumerable: false
        });
      }
      return { lookup, proxy };
    }
    var SocksProxyAgent = class extends agent_base_1.Agent {
      constructor(_opts) {
        let opts;
        if (typeof _opts === "string") {
          opts = url_1.default.parse(_opts);
        } else {
          opts = _opts;
        }
        if (!opts) {
          throw new TypeError("a SOCKS proxy server `host` and `port` must be specified!");
        }
        super(opts);
        const parsedProxy = parseSocksProxy(opts);
        this.lookup = parsedProxy.lookup;
        this.proxy = parsedProxy.proxy;
        this.tlsConnectionOptions = opts.tls || {};
      }
      callback(req, opts) {
        return __awaiter(this, void 0, void 0, function* () {
          const { lookup, proxy } = this;
          let { host, port, timeout } = opts;
          if (!host) {
            throw new Error("No `host` defined!");
          }
          if (lookup) {
            host = yield dnsLookup(host);
          }
          const socksOpts = {
            proxy,
            destination: { host, port },
            command: "connect",
            timeout
          };
          debug("Creating socks proxy connection: %o", socksOpts);
          const { socket } = yield socks_1.SocksClient.createConnection(socksOpts);
          debug("Successfully created socks proxy connection");
          if (opts.secureEndpoint) {
            debug("Upgrading socket connection to TLS");
            const servername = opts.servername || opts.host;
            return tls_1.default.connect(Object.assign(Object.assign(Object.assign({}, omit(opts, "host", "hostname", "path", "port")), {
              socket,
              servername
            }), this.tlsConnectionOptions));
          }
          return socket;
        });
      }
    };
    exports2.default = SocksProxyAgent;
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
  }
});

// node_modules/socks-proxy-agent/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/socks-proxy-agent/dist/index.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    var agent_1 = __importDefault(require_agent2());
    function createSocksProxyAgent(opts) {
      return new agent_1.default(opts);
    }
    (function(createSocksProxyAgent2) {
      createSocksProxyAgent2.SocksProxyAgent = agent_1.default;
      createSocksProxyAgent2.prototype = agent_1.default.prototype;
    })(createSocksProxyAgent || (createSocksProxyAgent = {}));
    module2.exports = createSocksProxyAgent;
  }
});

// node_modules/playwright-core/lib/common/timeoutSettings.js
var require_timeoutSettings = __commonJS({
  "node_modules/playwright-core/lib/common/timeoutSettings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TimeoutSettings = exports2.DEFAULT_TIMEOUT = void 0;
    var _utils = require_utils();
    var DEFAULT_TIMEOUT = 3e4;
    exports2.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
    var TimeoutSettings = class {
      constructor(parent) {
        this._parent = void 0;
        this._defaultTimeout = void 0;
        this._defaultNavigationTimeout = void 0;
        this._parent = parent;
      }
      setDefaultTimeout(timeout) {
        this._defaultTimeout = timeout;
      }
      setDefaultNavigationTimeout(timeout) {
        this._defaultNavigationTimeout = timeout;
      }
      navigationTimeout(options) {
        if (typeof options.timeout === "number")
          return options.timeout;
        if (this._defaultNavigationTimeout !== void 0)
          return this._defaultNavigationTimeout;
        if ((0, _utils.debugMode)())
          return 0;
        if (this._defaultTimeout !== void 0)
          return this._defaultTimeout;
        if (this._parent)
          return this._parent.navigationTimeout(options);
        return DEFAULT_TIMEOUT;
      }
      timeout(options) {
        if (typeof options.timeout === "number")
          return options.timeout;
        if ((0, _utils.debugMode)())
          return 0;
        if (this._defaultTimeout !== void 0)
          return this._defaultTimeout;
        if (this._parent)
          return this._parent.timeout(options);
        return DEFAULT_TIMEOUT;
      }
      static timeout(options) {
        if (typeof options.timeout === "number")
          return options.timeout;
        if ((0, _utils.debugMode)())
          return 0;
        return DEFAULT_TIMEOUT;
      }
    };
    exports2.TimeoutSettings = TimeoutSettings;
  }
});

// node_modules/playwright-core/lib/utils/eventsHelper.js
var require_eventsHelper = __commonJS({
  "node_modules/playwright-core/lib/utils/eventsHelper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.eventsHelper = void 0;
    var EventsHelper = class {
      static addEventListener(emitter, eventName, handler) {
        emitter.on(eventName, handler);
        return {
          emitter,
          eventName,
          handler
        };
      }
      static removeEventListeners(listeners) {
        for (const listener of listeners)
          listener.emitter.removeListener(listener.eventName, listener.handler);
        listeners.splice(0, listeners.length);
      }
    };
    var eventsHelper = EventsHelper;
    exports2.eventsHelper = eventsHelper;
  }
});

// node_modules/playwright-core/lib/server/helper.js
var require_helper = __commonJS({
  "node_modules/playwright-core/lib/server/helper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.helper = void 0;
    var _debugLogger = require_debugLogger();
    var _eventsHelper = require_eventsHelper();
    var Helper = class {
      static completeUserURL(urlString) {
        if (urlString.startsWith("localhost") || urlString.startsWith("127.0.0.1"))
          urlString = "http://" + urlString;
        return urlString;
      }
      static enclosingIntRect(rect) {
        const x = Math.floor(rect.x + 1e-3);
        const y = Math.floor(rect.y + 1e-3);
        const x2 = Math.ceil(rect.x + rect.width - 1e-3);
        const y2 = Math.ceil(rect.y + rect.height - 1e-3);
        return {
          x,
          y,
          width: x2 - x,
          height: y2 - y
        };
      }
      static enclosingIntSize(size) {
        return {
          width: Math.floor(size.width + 1e-3),
          height: Math.floor(size.height + 1e-3)
        };
      }
      static getViewportSizeFromWindowFeatures(features) {
        const widthString = features.find((f) => f.startsWith("width="));
        const heightString = features.find((f) => f.startsWith("height="));
        const width = widthString ? parseInt(widthString.substring(6), 10) : NaN;
        const height = heightString ? parseInt(heightString.substring(7), 10) : NaN;
        if (!Number.isNaN(width) && !Number.isNaN(height))
          return {
            width,
            height
          };
        return null;
      }
      static waitForEvent(progress, emitter, event, predicate) {
        const listeners = [];
        const promise = new Promise((resolve, reject) => {
          listeners.push(_eventsHelper.eventsHelper.addEventListener(emitter, event, (eventArg) => {
            try {
              if (predicate && !predicate(eventArg))
                return;
              _eventsHelper.eventsHelper.removeEventListeners(listeners);
              resolve(eventArg);
            } catch (e) {
              _eventsHelper.eventsHelper.removeEventListeners(listeners);
              reject(e);
            }
          }));
        });
        const dispose = () => _eventsHelper.eventsHelper.removeEventListeners(listeners);
        if (progress)
          progress.cleanupWhenAborted(dispose);
        return {
          promise,
          dispose
        };
      }
      static secondsToRoundishMillis(value) {
        return (value * 1e6 | 0) / 1e3;
      }
      static millisToRoundishMillis(value) {
        return (value * 1e3 | 0) / 1e3;
      }
      static debugProtocolLogger(protocolLogger) {
        return (direction, message) => {
          if (protocolLogger)
            protocolLogger(direction, message);
          if (_debugLogger.debugLogger.isEnabled("protocol"))
            _debugLogger.debugLogger.log("protocol", (direction === "send" ? "SEND \u25BA " : "\u25C0 RECV ") + JSON.stringify(message));
        };
      }
      static formatBrowserLogs(logs) {
        if (!logs.length)
          return "";
        return "\n" + "=".repeat(20) + " Browser output: " + "=".repeat(20) + "\n" + logs.join("\n");
      }
    };
    var helper = Helper;
    exports2.helper = helper;
  }
});

// node_modules/playwright-core/lib/utils/manualPromise.js
var require_manualPromise = __commonJS({
  "node_modules/playwright-core/lib/utils/manualPromise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ManualPromise = void 0;
    var _Symbol$species;
    var _Symbol$toStringTag;
    _Symbol$species = Symbol.species;
    _Symbol$toStringTag = Symbol.toStringTag;
    var ManualPromise = class extends Promise {
      constructor() {
        let resolve;
        let reject;
        super((f, r) => {
          resolve = f;
          reject = r;
        });
        this._resolve = void 0;
        this._reject = void 0;
        this._isDone = void 0;
        this._isDone = false;
        this._resolve = resolve;
        this._reject = reject;
      }
      isDone() {
        return this._isDone;
      }
      resolve(t) {
        this._isDone = true;
        this._resolve(t);
      }
      reject(e) {
        this._isDone = true;
        this._reject(e);
      }
      static get [_Symbol$species]() {
        return Promise;
      }
      get [_Symbol$toStringTag]() {
        return "ManualPromise";
      }
    };
    exports2.ManualPromise = ManualPromise;
  }
});

// node_modules/playwright-core/lib/server/network.js
var require_network = __commonJS({
  "node_modules/playwright-core/lib/server/network.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WebSocket = exports2.STATUS_TEXTS = exports2.Route = exports2.Response = exports2.Request = void 0;
    exports2.filterCookies = filterCookies;
    exports2.mergeHeaders = mergeHeaders;
    exports2.parsedURL = parsedURL;
    exports2.rewriteCookies = rewriteCookies;
    exports2.singleHeader = singleHeader;
    exports2.stripFragmentFromUrl = stripFragmentFromUrl;
    var _utils = require_utils();
    var _manualPromise = require_manualPromise();
    var _instrumentation = require_instrumentation();
    var _fetch = require_fetch();
    function filterCookies(cookies, urls) {
      const parsedURLs = urls.map((s) => new URL(s));
      return cookies.filter((c) => {
        if (!parsedURLs.length)
          return true;
        for (const parsedURL2 of parsedURLs) {
          let domain = c.domain;
          if (!domain.startsWith("."))
            domain = "." + domain;
          if (!("." + parsedURL2.hostname).endsWith(domain))
            continue;
          if (!parsedURL2.pathname.startsWith(c.path))
            continue;
          if (parsedURL2.protocol !== "https:" && parsedURL2.hostname !== "localhost" && c.secure)
            continue;
          return true;
        }
        return false;
      });
    }
    var kMaxCookieExpiresDateInSeconds = 253402300799;
    function rewriteCookies(cookies) {
      return cookies.map((c) => {
        (0, _utils.assert)(c.url || c.domain && c.path, "Cookie should have a url or a domain/path pair");
        (0, _utils.assert)(!(c.url && c.domain), "Cookie should have either url or domain");
        (0, _utils.assert)(!(c.url && c.path), "Cookie should have either url or path");
        (0, _utils.assert)(!(c.expires && c.expires < 0 && c.expires !== -1), "Cookie should have a valid expires, only -1 or a positive number for the unix timestamp in seconds is allowed");
        (0, _utils.assert)(!(c.expires && c.expires > 0 && c.expires > kMaxCookieExpiresDateInSeconds), "Cookie should have a valid expires, only -1 or a positive number for the unix timestamp in seconds is allowed");
        const copy = __spreadValues({}, c);
        if (copy.url) {
          (0, _utils.assert)(copy.url !== "about:blank", `Blank page can not have cookie "${c.name}"`);
          (0, _utils.assert)(!copy.url.startsWith("data:"), `Data URL page can not have cookie "${c.name}"`);
          const url = new URL(copy.url);
          copy.domain = url.hostname;
          copy.path = url.pathname.substring(0, url.pathname.lastIndexOf("/") + 1);
          copy.secure = url.protocol === "https:";
        }
        return copy;
      });
    }
    function parsedURL(url) {
      try {
        return new URL(url);
      } catch (e) {
        return null;
      }
    }
    function stripFragmentFromUrl(url) {
      if (!url.includes("#"))
        return url;
      return url.substring(0, url.indexOf("#"));
    }
    var Request = class extends _instrumentation.SdkObject {
      constructor(frame, redirectedFrom, documentId, url, resourceType, method, postData, headers) {
        super(frame, "request");
        this._response = null;
        this._redirectedFrom = void 0;
        this._redirectedTo = null;
        this._documentId = void 0;
        this._isFavicon = void 0;
        this._failureText = null;
        this._url = void 0;
        this._resourceType = void 0;
        this._method = void 0;
        this._postData = void 0;
        this._headers = void 0;
        this._headersMap = /* @__PURE__ */ new Map();
        this._rawRequestHeadersPromise = void 0;
        this._frame = void 0;
        this._waitForResponsePromise = new _manualPromise.ManualPromise();
        this._responseEndTiming = -1;
        this.responseSize = {
          encodedBodySize: 0,
          transferSize: 0,
          responseHeadersSize: 0
        };
        (0, _utils.assert)(!url.startsWith("data:"), "Data urls should not fire requests");
        this._frame = frame;
        this._redirectedFrom = redirectedFrom;
        if (redirectedFrom)
          redirectedFrom._redirectedTo = this;
        this._documentId = documentId;
        this._url = stripFragmentFromUrl(url);
        this._resourceType = resourceType;
        this._method = method;
        this._postData = postData;
        this._headers = headers;
        for (const {
          name,
          value
        } of this._headers)
          this._headersMap.set(name.toLowerCase(), value);
        this._isFavicon = url.endsWith("/favicon.ico") || !!(redirectedFrom !== null && redirectedFrom !== void 0 && redirectedFrom._isFavicon);
      }
      _setFailureText(failureText) {
        this._failureText = failureText;
        this._waitForResponsePromise.resolve(null);
      }
      url() {
        return this._url;
      }
      resourceType() {
        return this._resourceType;
      }
      method() {
        return this._method;
      }
      postDataBuffer() {
        return this._postData;
      }
      headers() {
        return this._headers;
      }
      headerValue(name) {
        return this._headersMap.get(name);
      }
      setWillReceiveExtraHeaders() {
        if (!this._rawRequestHeadersPromise)
          this._rawRequestHeadersPromise = new _manualPromise.ManualPromise();
      }
      setRawRequestHeaders(headers) {
        if (!this._rawRequestHeadersPromise)
          this._rawRequestHeadersPromise = new _manualPromise.ManualPromise();
        this._rawRequestHeadersPromise.resolve(headers);
      }
      rawRequestHeaders() {
        return __async(this, null, function* () {
          return this._rawRequestHeadersPromise || Promise.resolve(this._headers);
        });
      }
      rawRequestHeadersPromise() {
        return this._rawRequestHeadersPromise;
      }
      response() {
        return this._waitForResponsePromise;
      }
      _existingResponse() {
        return this._response;
      }
      _setResponse(response) {
        this._response = response;
        this._waitForResponsePromise.resolve(response);
      }
      _finalRequest() {
        return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
      }
      frame() {
        return this._frame;
      }
      isNavigationRequest() {
        return !!this._documentId;
      }
      redirectedFrom() {
        return this._redirectedFrom;
      }
      failure() {
        if (this._failureText === null)
          return null;
        return {
          errorText: this._failureText
        };
      }
      bodySize() {
        var _this$postDataBuffer;
        return ((_this$postDataBuffer = this.postDataBuffer()) === null || _this$postDataBuffer === void 0 ? void 0 : _this$postDataBuffer.length) || 0;
      }
      requestHeadersSize() {
        return __async(this, null, function* () {
          let headersSize = 4;
          headersSize += this.method().length;
          headersSize += new URL(this.url()).pathname.length;
          headersSize += 8;
          const headers = this.rawRequestHeadersPromise() ? yield this.rawRequestHeadersPromise() : this._headers;
          for (const header of headers)
            headersSize += header.name.length + header.value.length + 4;
          return headersSize;
        });
      }
    };
    exports2.Request = Request;
    var Route = class extends _instrumentation.SdkObject {
      constructor(request, delegate) {
        super(request.frame(), "route");
        this._request = void 0;
        this._delegate = void 0;
        this._handled = false;
        this._request = request;
        this._delegate = delegate;
      }
      request() {
        return this._request;
      }
      abort(errorCode = "failed") {
        return __async(this, null, function* () {
          this._startHandling();
          yield this._delegate.abort(errorCode);
        });
      }
      fulfill(overrides) {
        return __async(this, null, function* () {
          this._startHandling();
          let body = overrides.body;
          let isBase64 = overrides.isBase64 || false;
          if (body === void 0) {
            if (overrides.fetchResponseUid) {
              const context = this._request.frame()._page._browserContext;
              const buffer = context.fetchRequest.fetchResponses.get(overrides.fetchResponseUid) || _fetch.APIRequestContext.findResponseBody(overrides.fetchResponseUid);
              (0, _utils.assert)(buffer, "Fetch response has been disposed");
              body = buffer.toString("base64");
              isBase64 = true;
            } else {
              body = "";
              isBase64 = false;
            }
          }
          const headers = [...overrides.headers || []];
          this._maybeAddCorsHeaders(headers);
          yield this._delegate.fulfill({
            status: overrides.status || 200,
            headers,
            body,
            isBase64
          });
        });
      }
      _maybeAddCorsHeaders(headers) {
        const origin = this._request.headerValue("origin");
        if (!origin)
          return;
        const requestUrl = new URL(this._request.url());
        if (!requestUrl.protocol.startsWith("http"))
          return;
        if (requestUrl.origin === origin.trim())
          return;
        const corsHeader = headers.find(({
          name
        }) => name === "access-control-allow-origin");
        if (corsHeader)
          return;
        headers.push({
          name: "access-control-allow-origin",
          value: origin
        });
        headers.push({
          name: "access-control-allow-credentials",
          value: "true"
        });
        headers.push({
          name: "vary",
          value: "Origin"
        });
      }
      continue() {
        return __async(this, arguments, function* (overrides = {}) {
          this._startHandling();
          if (overrides.url) {
            const newUrl = new URL(overrides.url);
            const oldUrl = new URL(this._request.url());
            if (oldUrl.protocol !== newUrl.protocol)
              throw new Error("New URL must have same protocol as overridden URL");
          }
          yield this._delegate.continue(this._request, overrides);
        });
      }
      _startHandling() {
        (0, _utils.assert)(!this._handled, "Route is already handled!");
        this._handled = true;
      }
    };
    exports2.Route = Route;
    var Response = class extends _instrumentation.SdkObject {
      constructor(request, status, statusText, headers, timing, getResponseBodyCallback, httpVersion) {
        super(request.frame(), "response");
        this._request = void 0;
        this._contentPromise = null;
        this._finishedPromise = new _manualPromise.ManualPromise();
        this._status = void 0;
        this._statusText = void 0;
        this._url = void 0;
        this._headers = void 0;
        this._headersMap = /* @__PURE__ */ new Map();
        this._getResponseBodyCallback = void 0;
        this._timing = void 0;
        this._serverAddrPromise = new _manualPromise.ManualPromise();
        this._securityDetailsPromise = new _manualPromise.ManualPromise();
        this._rawResponseHeadersPromise = void 0;
        this._httpVersion = void 0;
        this._request = request;
        this._timing = timing;
        this._status = status;
        this._statusText = statusText;
        this._url = request.url();
        this._headers = headers;
        for (const {
          name,
          value
        } of this._headers)
          this._headersMap.set(name.toLowerCase(), value);
        this._getResponseBodyCallback = getResponseBodyCallback;
        this._request._setResponse(this);
        this._httpVersion = httpVersion;
      }
      _serverAddrFinished(addr) {
        this._serverAddrPromise.resolve(addr);
      }
      _securityDetailsFinished(securityDetails) {
        this._securityDetailsPromise.resolve(securityDetails);
      }
      _requestFinished(responseEndTiming) {
        this._request._responseEndTiming = Math.max(responseEndTiming, this._timing.responseStart);
        this._finishedPromise.resolve();
      }
      _setHttpVersion(httpVersion) {
        this._httpVersion = httpVersion;
      }
      url() {
        return this._url;
      }
      status() {
        return this._status;
      }
      statusText() {
        return this._statusText;
      }
      headers() {
        return this._headers;
      }
      headerValue(name) {
        return this._headersMap.get(name);
      }
      rawResponseHeaders() {
        return __async(this, null, function* () {
          return this._rawResponseHeadersPromise || Promise.resolve(this._headers);
        });
      }
      setWillReceiveExtraHeaders() {
        this._request.setWillReceiveExtraHeaders();
        this._rawResponseHeadersPromise = new _manualPromise.ManualPromise();
      }
      setRawResponseHeaders(headers) {
        if (!this._rawResponseHeadersPromise)
          this._rawResponseHeadersPromise = new _manualPromise.ManualPromise();
        this._rawResponseHeadersPromise.resolve(headers);
      }
      timing() {
        return this._timing;
      }
      serverAddr() {
        return __async(this, null, function* () {
          return (yield this._serverAddrPromise) || null;
        });
      }
      securityDetails() {
        return __async(this, null, function* () {
          return (yield this._securityDetailsPromise) || null;
        });
      }
      body() {
        if (!this._contentPromise) {
          this._contentPromise = this._finishedPromise.then(() => __async(this, null, function* () {
            if (this._status >= 300 && this._status <= 399)
              throw new Error("Response body is unavailable for redirect responses");
            return this._getResponseBodyCallback();
          }));
        }
        return this._contentPromise;
      }
      request() {
        return this._request;
      }
      frame() {
        return this._request.frame();
      }
      httpVersion() {
        if (!this._httpVersion)
          return "HTTP/1.1";
        if (this._httpVersion === "http/1.1")
          return "HTTP/1.1";
        if (this._httpVersion === "h2")
          return "HTTP/2.0";
        return this._httpVersion;
      }
      _responseHeadersSize() {
        return __async(this, null, function* () {
          if (this._request.responseSize.responseHeadersSize)
            return this._request.responseSize.responseHeadersSize;
          let headersSize = 4;
          headersSize += 8;
          headersSize += 3;
          headersSize += this.statusText().length;
          const headers = yield this._bestEffortResponseHeaders();
          for (const header of headers)
            headersSize += header.name.length + header.value.length + 4;
          headersSize += 2;
          return headersSize;
        });
      }
      _bestEffortResponseHeaders() {
        return __async(this, null, function* () {
          return this._rawResponseHeadersPromise ? yield this._rawResponseHeadersPromise : this._headers;
        });
      }
      sizes() {
        return __async(this, null, function* () {
          yield this._finishedPromise;
          const requestHeadersSize = yield this._request.requestHeadersSize();
          const responseHeadersSize = yield this._responseHeadersSize();
          let {
            encodedBodySize
          } = this._request.responseSize;
          if (!encodedBodySize) {
            var _headers$find;
            const headers = yield this._bestEffortResponseHeaders();
            const contentLength = (_headers$find = headers.find((h) => h.name.toLowerCase() === "content-length")) === null || _headers$find === void 0 ? void 0 : _headers$find.value;
            encodedBodySize = contentLength ? +contentLength : 0;
          }
          return {
            requestBodySize: this._request.bodySize(),
            requestHeadersSize,
            responseBodySize: encodedBodySize,
            responseHeadersSize
          };
        });
      }
    };
    exports2.Response = Response;
    var WebSocket = class extends _instrumentation.SdkObject {
      constructor(parent, url) {
        super(parent, "ws");
        this._url = void 0;
        this._notified = false;
        this._url = url;
      }
      markAsNotified() {
        if (this._notified)
          return false;
        this._notified = true;
        return true;
      }
      url() {
        return this._url;
      }
      frameSent(opcode, data) {
        this.emit(WebSocket.Events.FrameSent, {
          opcode,
          data
        });
      }
      frameReceived(opcode, data) {
        this.emit(WebSocket.Events.FrameReceived, {
          opcode,
          data
        });
      }
      error(errorMessage) {
        this.emit(WebSocket.Events.SocketError, errorMessage);
      }
      closed() {
        this.emit(WebSocket.Events.Close);
      }
    };
    exports2.WebSocket = WebSocket;
    WebSocket.Events = {
      Close: "close",
      SocketError: "socketerror",
      FrameReceived: "framereceived",
      FrameSent: "framesent"
    };
    var STATUS_TEXTS = {
      "100": "Continue",
      "101": "Switching Protocols",
      "102": "Processing",
      "103": "Early Hints",
      "200": "OK",
      "201": "Created",
      "202": "Accepted",
      "203": "Non-Authoritative Information",
      "204": "No Content",
      "205": "Reset Content",
      "206": "Partial Content",
      "207": "Multi-Status",
      "208": "Already Reported",
      "226": "IM Used",
      "300": "Multiple Choices",
      "301": "Moved Permanently",
      "302": "Found",
      "303": "See Other",
      "304": "Not Modified",
      "305": "Use Proxy",
      "306": "Switch Proxy",
      "307": "Temporary Redirect",
      "308": "Permanent Redirect",
      "400": "Bad Request",
      "401": "Unauthorized",
      "402": "Payment Required",
      "403": "Forbidden",
      "404": "Not Found",
      "405": "Method Not Allowed",
      "406": "Not Acceptable",
      "407": "Proxy Authentication Required",
      "408": "Request Timeout",
      "409": "Conflict",
      "410": "Gone",
      "411": "Length Required",
      "412": "Precondition Failed",
      "413": "Payload Too Large",
      "414": "URI Too Long",
      "415": "Unsupported Media Type",
      "416": "Range Not Satisfiable",
      "417": "Expectation Failed",
      "418": "I'm a teapot",
      "421": "Misdirected Request",
      "422": "Unprocessable Entity",
      "423": "Locked",
      "424": "Failed Dependency",
      "425": "Too Early",
      "426": "Upgrade Required",
      "428": "Precondition Required",
      "429": "Too Many Requests",
      "431": "Request Header Fields Too Large",
      "451": "Unavailable For Legal Reasons",
      "500": "Internal Server Error",
      "501": "Not Implemented",
      "502": "Bad Gateway",
      "503": "Service Unavailable",
      "504": "Gateway Timeout",
      "505": "HTTP Version Not Supported",
      "506": "Variant Also Negotiates",
      "507": "Insufficient Storage",
      "508": "Loop Detected",
      "510": "Not Extended",
      "511": "Network Authentication Required"
    };
    exports2.STATUS_TEXTS = STATUS_TEXTS;
    function singleHeader(name, value) {
      return [{
        name,
        value
      }];
    }
    function mergeHeaders(headers) {
      const lowerCaseToValue = /* @__PURE__ */ new Map();
      const lowerCaseToOriginalCase = /* @__PURE__ */ new Map();
      for (const h of headers) {
        if (!h)
          continue;
        for (const {
          name,
          value
        } of h) {
          const lower = name.toLowerCase();
          lowerCaseToOriginalCase.set(lower, name);
          lowerCaseToValue.set(lower, value);
        }
      }
      const result = [];
      for (const [lower, value] of lowerCaseToValue)
        result.push({
          name: lowerCaseToOriginalCase.get(lower),
          value
        });
      return result;
    }
  }
});

// node_modules/mime/Mime.js
var require_Mime = __commonJS({
  "node_modules/mime/Mime.js"(exports2, module2) {
    "use strict";
    function Mime() {
      this._types = Object.create(null);
      this._extensions = Object.create(null);
      for (let i = 0; i < arguments.length; i++) {
        this.define(arguments[i]);
      }
      this.define = this.define.bind(this);
      this.getType = this.getType.bind(this);
      this.getExtension = this.getExtension.bind(this);
    }
    Mime.prototype.define = function(typeMap, force) {
      for (let type in typeMap) {
        let extensions = typeMap[type].map(function(t) {
          return t.toLowerCase();
        });
        type = type.toLowerCase();
        for (let i = 0; i < extensions.length; i++) {
          const ext = extensions[i];
          if (ext[0] === "*") {
            continue;
          }
          if (!force && ext in this._types) {
            throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
          }
          this._types[ext] = type;
        }
        if (force || !this._extensions[type]) {
          const ext = extensions[0];
          this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
        }
      }
    };
    Mime.prototype.getType = function(path) {
      path = String(path);
      let last = path.replace(/^.*[/\\]/, "").toLowerCase();
      let ext = last.replace(/^.*\./, "").toLowerCase();
      let hasPath = last.length < path.length;
      let hasDot = ext.length < last.length - 1;
      return (hasDot || !hasPath) && this._types[ext] || null;
    };
    Mime.prototype.getExtension = function(type) {
      type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
      return type && this._extensions[type.toLowerCase()] || null;
    };
    module2.exports = Mime;
  }
});

// node_modules/mime/types/standard.js
var require_standard = __commonJS({
  "node_modules/mime/types/standard.js"(exports2, module2) {
    module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
  }
});

// node_modules/mime/types/other.js
var require_other = __commonJS({
  "node_modules/mime/types/other.js"(exports2, module2) {
    module2.exports = { "application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.sap.vds": ["vds"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
  }
});

// node_modules/mime/index.js
var require_mime = __commonJS({
  "node_modules/mime/index.js"(exports2, module2) {
    "use strict";
    var Mime = require_Mime();
    module2.exports = new Mime(require_standard(), require_other());
  }
});

// node_modules/playwright-core/lib/generated/injectedScriptSource.js
var require_injectedScriptSource = __commonJS({
  "node_modules/playwright-core/lib/generated/injectedScriptSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.source = void 0;
    var source = 'var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === "object" || typeof from === "function") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);\n\n// packages/playwright-core/src/server/isomorphic/cssTokenizer.js\nvar require_cssTokenizer = __commonJS({\n  "packages/playwright-core/src/server/isomorphic/cssTokenizer.js"(exports) {\n    (function(root, factory) {\n      if (typeof define === "function" && define.amd) {\n        define(["exports"], factory);\n      } else if (typeof exports !== "undefined") {\n        factory(exports);\n      } else {\n        factory(root);\n      }\n    })(exports, function(exports2) {\n      var between = function(num, first, last) {\n        return num >= first && num <= last;\n      };\n      function digit(code) {\n        return between(code, 48, 57);\n      }\n      function hexdigit(code) {\n        return digit(code) || between(code, 65, 70) || between(code, 97, 102);\n      }\n      function uppercaseletter(code) {\n        return between(code, 65, 90);\n      }\n      function lowercaseletter(code) {\n        return between(code, 97, 122);\n      }\n      function letter(code) {\n        return uppercaseletter(code) || lowercaseletter(code);\n      }\n      function nonascii(code) {\n        return code >= 128;\n      }\n      function namestartchar(code) {\n        return letter(code) || nonascii(code) || code == 95;\n      }\n      function namechar(code) {\n        return namestartchar(code) || digit(code) || code == 45;\n      }\n      function nonprintable(code) {\n        return between(code, 0, 8) || code == 11 || between(code, 14, 31) || code == 127;\n      }\n      function newline(code) {\n        return code == 10;\n      }\n      function whitespace(code) {\n        return newline(code) || code == 9 || code == 32;\n      }\n      function badescape(code) {\n        return newline(code) || isNaN(code);\n      }\n      var maximumallowedcodepoint = 1114111;\n      var InvalidCharacterError = function(message) {\n        this.message = message;\n      };\n      InvalidCharacterError.prototype = new Error();\n      InvalidCharacterError.prototype.name = "InvalidCharacterError";\n      function preprocess(str) {\n        var codepoints = [];\n        for (var i = 0; i < str.length; i++) {\n          var code = str.charCodeAt(i);\n          if (code == 13 && str.charCodeAt(i + 1) == 10) {\n            code = 10;\n            i++;\n          }\n          if (code == 13 || code == 12)\n            code = 10;\n          if (code == 0)\n            code = 65533;\n          if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {\n            var lead = code - 55296;\n            var trail = str.charCodeAt(i + 1) - 56320;\n            code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n            i++;\n          }\n          codepoints.push(code);\n        }\n        return codepoints;\n      }\n      function stringFromCode(code) {\n        if (code <= 65535)\n          return String.fromCharCode(code);\n        code -= Math.pow(2, 16);\n        var lead = Math.floor(code / Math.pow(2, 10)) + 55296;\n        var trail = code % Math.pow(2, 10) + 56320;\n        return String.fromCharCode(lead) + String.fromCharCode(trail);\n      }\n      function tokenize2(str) {\n        str = preprocess(str);\n        var i = -1;\n        var tokens = [];\n        var code;\n        var line = 0;\n        var column = 0;\n        var lastLineLength = 0;\n        var incrLineno = function() {\n          line += 1;\n          lastLineLength = column;\n          column = 0;\n        };\n        var locStart = { line, column };\n        var codepoint = function(i2) {\n          if (i2 >= str.length) {\n            return -1;\n          }\n          return str[i2];\n        };\n        var next = function(num) {\n          if (num === void 0)\n            num = 1;\n          if (num > 3)\n            throw "Spec Error: no more than three codepoints of lookahead.";\n          return codepoint(i + num);\n        };\n        var consume = function(num) {\n          if (num === void 0)\n            num = 1;\n          i += num;\n          code = codepoint(i);\n          if (newline(code))\n            incrLineno();\n          else\n            column += num;\n          return true;\n        };\n        var reconsume = function() {\n          i -= 1;\n          if (newline(code)) {\n            line -= 1;\n            column = lastLineLength;\n          } else {\n            column -= 1;\n          }\n          locStart.line = line;\n          locStart.column = column;\n          return true;\n        };\n        var eof = function(codepoint2) {\n          if (codepoint2 === void 0)\n            codepoint2 = code;\n          return codepoint2 == -1;\n        };\n        var donothing = function() {\n        };\n        var parseerror = function() {\n          console.log("Parse error at index " + i + ", processing codepoint 0x" + code.toString(16) + ".");\n          return true;\n        };\n        var consumeAToken = function() {\n          consumeComments();\n          consume();\n          if (whitespace(code)) {\n            while (whitespace(next()))\n              consume();\n            return new WhitespaceToken2();\n          } else if (code == 34)\n            return consumeAStringToken();\n          else if (code == 35) {\n            if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n              var token = new HashToken2();\n              if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n                token.type = "id";\n              token.value = consumeAName();\n              return token;\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 36) {\n            if (next() == 61) {\n              consume();\n              return new SuffixMatchToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 39)\n            return consumeAStringToken();\n          else if (code == 40)\n            return new OpenParenToken();\n          else if (code == 41)\n            return new CloseParenToken2();\n          else if (code == 42) {\n            if (next() == 61) {\n              consume();\n              return new SubstringMatchToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 43) {\n            if (startsWithANumber()) {\n              reconsume();\n              return consumeANumericToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 44)\n            return new CommaToken2();\n          else if (code == 45) {\n            if (startsWithANumber()) {\n              reconsume();\n              return consumeANumericToken();\n            } else if (next(1) == 45 && next(2) == 62) {\n              consume(2);\n              return new CDCToken2();\n            } else if (startsWithAnIdentifier()) {\n              reconsume();\n              return consumeAnIdentlikeToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 46) {\n            if (startsWithANumber()) {\n              reconsume();\n              return consumeANumericToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 58)\n            return new ColonToken2();\n          else if (code == 59)\n            return new SemicolonToken2();\n          else if (code == 60) {\n            if (next(1) == 33 && next(2) == 45 && next(3) == 45) {\n              consume(3);\n              return new CDOToken2();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 64) {\n            if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n              return new AtKeywordToken2(consumeAName());\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 91)\n            return new OpenSquareToken2();\n          else if (code == 92) {\n            if (startsWithAValidEscape()) {\n              reconsume();\n              return consumeAnIdentlikeToken();\n            } else {\n              parseerror();\n              return new DelimToken2(code);\n            }\n          } else if (code == 93)\n            return new CloseSquareToken2();\n          else if (code == 94) {\n            if (next() == 61) {\n              consume();\n              return new PrefixMatchToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 123)\n            return new OpenCurlyToken2();\n          else if (code == 124) {\n            if (next() == 61) {\n              consume();\n              return new DashMatchToken();\n            } else if (next() == 124) {\n              consume();\n              return new ColumnToken2();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 125)\n            return new CloseCurlyToken2();\n          else if (code == 126) {\n            if (next() == 61) {\n              consume();\n              return new IncludeMatchToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (digit(code)) {\n            reconsume();\n            return consumeANumericToken();\n          } else if (namestartchar(code)) {\n            reconsume();\n            return consumeAnIdentlikeToken();\n          } else if (eof())\n            return new EOFToken2();\n          else\n            return new DelimToken2(code);\n        };\n        var consumeComments = function() {\n          while (next(1) == 47 && next(2) == 42) {\n            consume(2);\n            while (true) {\n              consume();\n              if (code == 42 && next() == 47) {\n                consume();\n                break;\n              } else if (eof()) {\n                parseerror();\n                return;\n              }\n            }\n          }\n        };\n        var consumeANumericToken = function() {\n          var num = consumeANumber();\n          if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n            var token = new DimensionToken();\n            token.value = num.value;\n            token.repr = num.repr;\n            token.type = num.type;\n            token.unit = consumeAName();\n            return token;\n          } else if (next() == 37) {\n            consume();\n            var token = new PercentageToken2();\n            token.value = num.value;\n            token.repr = num.repr;\n            return token;\n          } else {\n            var token = new NumberToken2();\n            token.value = num.value;\n            token.repr = num.repr;\n            token.type = num.type;\n            return token;\n          }\n        };\n        var consumeAnIdentlikeToken = function() {\n          var str2 = consumeAName();\n          if (str2.toLowerCase() == "url" && next() == 40) {\n            consume();\n            while (whitespace(next(1)) && whitespace(next(2)))\n              consume();\n            if (next() == 34 || next() == 39) {\n              return new FunctionToken2(str2);\n            } else if (whitespace(next()) && (next(2) == 34 || next(2) == 39)) {\n              return new FunctionToken2(str2);\n            } else {\n              return consumeAURLToken();\n            }\n          } else if (next() == 40) {\n            consume();\n            return new FunctionToken2(str2);\n          } else {\n            return new IdentToken2(str2);\n          }\n        };\n        var consumeAStringToken = function(endingCodePoint) {\n          if (endingCodePoint === void 0)\n            endingCodePoint = code;\n          var string = "";\n          while (consume()) {\n            if (code == endingCodePoint || eof()) {\n              return new StringToken2(string);\n            } else if (newline(code)) {\n              parseerror();\n              reconsume();\n              return new BadStringToken2();\n            } else if (code == 92) {\n              if (eof(next())) {\n                donothing();\n              } else if (newline(next())) {\n                consume();\n              } else {\n                string += stringFromCode(consumeEscape());\n              }\n            } else {\n              string += stringFromCode(code);\n            }\n          }\n        };\n        var consumeAURLToken = function() {\n          var token = new URLToken2("");\n          while (whitespace(next()))\n            consume();\n          if (eof(next()))\n            return token;\n          while (consume()) {\n            if (code == 41 || eof()) {\n              return token;\n            } else if (whitespace(code)) {\n              while (whitespace(next()))\n                consume();\n              if (next() == 41 || eof(next())) {\n                consume();\n                return token;\n              } else {\n                consumeTheRemnantsOfABadURL();\n                return new BadURLToken2();\n              }\n            } else if (code == 34 || code == 39 || code == 40 || nonprintable(code)) {\n              parseerror();\n              consumeTheRemnantsOfABadURL();\n              return new BadURLToken2();\n            } else if (code == 92) {\n              if (startsWithAValidEscape()) {\n                token.value += stringFromCode(consumeEscape());\n              } else {\n                parseerror();\n                consumeTheRemnantsOfABadURL();\n                return new BadURLToken2();\n              }\n            } else {\n              token.value += stringFromCode(code);\n            }\n          }\n        };\n        var consumeEscape = function() {\n          consume();\n          if (hexdigit(code)) {\n            var digits = [code];\n            for (var total = 0; total < 5; total++) {\n              if (hexdigit(next())) {\n                consume();\n                digits.push(code);\n              } else {\n                break;\n              }\n            }\n            if (whitespace(next()))\n              consume();\n            var value = parseInt(digits.map(function(x) {\n              return String.fromCharCode(x);\n            }).join(""), 16);\n            if (value > maximumallowedcodepoint)\n              value = 65533;\n            return value;\n          } else if (eof()) {\n            return 65533;\n          } else {\n            return code;\n          }\n        };\n        var areAValidEscape = function(c1, c2) {\n          if (c1 != 92)\n            return false;\n          if (newline(c2))\n            return false;\n          return true;\n        };\n        var startsWithAValidEscape = function() {\n          return areAValidEscape(code, next());\n        };\n        var wouldStartAnIdentifier = function(c1, c2, c3) {\n          if (c1 == 45) {\n            return namestartchar(c2) || c2 == 45 || areAValidEscape(c2, c3);\n          } else if (namestartchar(c1)) {\n            return true;\n          } else if (c1 == 92) {\n            return areAValidEscape(c1, c2);\n          } else {\n            return false;\n          }\n        };\n        var startsWithAnIdentifier = function() {\n          return wouldStartAnIdentifier(code, next(1), next(2));\n        };\n        var wouldStartANumber = function(c1, c2, c3) {\n          if (c1 == 43 || c1 == 45) {\n            if (digit(c2))\n              return true;\n            if (c2 == 46 && digit(c3))\n              return true;\n            return false;\n          } else if (c1 == 46) {\n            if (digit(c2))\n              return true;\n            return false;\n          } else if (digit(c1)) {\n            return true;\n          } else {\n            return false;\n          }\n        };\n        var startsWithANumber = function() {\n          return wouldStartANumber(code, next(1), next(2));\n        };\n        var consumeAName = function() {\n          var result = "";\n          while (consume()) {\n            if (namechar(code)) {\n              result += stringFromCode(code);\n            } else if (startsWithAValidEscape()) {\n              result += stringFromCode(consumeEscape());\n            } else {\n              reconsume();\n              return result;\n            }\n          }\n        };\n        var consumeANumber = function() {\n          var repr = [];\n          var type = "integer";\n          if (next() == 43 || next() == 45) {\n            consume();\n            repr += stringFromCode(code);\n          }\n          while (digit(next())) {\n            consume();\n            repr += stringFromCode(code);\n          }\n          if (next(1) == 46 && digit(next(2))) {\n            consume();\n            repr += stringFromCode(code);\n            consume();\n            repr += stringFromCode(code);\n            type = "number";\n            while (digit(next())) {\n              consume();\n              repr += stringFromCode(code);\n            }\n          }\n          var c1 = next(1), c2 = next(2), c3 = next(3);\n          if ((c1 == 69 || c1 == 101) && digit(c2)) {\n            consume();\n            repr += stringFromCode(code);\n            consume();\n            repr += stringFromCode(code);\n            type = "number";\n            while (digit(next())) {\n              consume();\n              repr += stringFromCode(code);\n            }\n          } else if ((c1 == 69 || c1 == 101) && (c2 == 43 || c2 == 45) && digit(c3)) {\n            consume();\n            repr += stringFromCode(code);\n            consume();\n            repr += stringFromCode(code);\n            consume();\n            repr += stringFromCode(code);\n            type = "number";\n            while (digit(next())) {\n              consume();\n              repr += stringFromCode(code);\n            }\n          }\n          var value = convertAStringToANumber(repr);\n          return { type, value, repr };\n        };\n        var convertAStringToANumber = function(string) {\n          return +string;\n        };\n        var consumeTheRemnantsOfABadURL = function() {\n          while (consume()) {\n            if (code == 41 || eof()) {\n              return;\n            } else if (startsWithAValidEscape()) {\n              consumeEscape();\n              donothing();\n            } else {\n              donothing();\n            }\n          }\n        };\n        var iterationCount = 0;\n        while (!eof(next())) {\n          tokens.push(consumeAToken());\n          iterationCount++;\n          if (iterationCount > str.length * 2)\n            return "I\'m infinite-looping!";\n        }\n        return tokens;\n      }\n      function CSSParserToken() {\n        throw "Abstract Base Class";\n      }\n      CSSParserToken.prototype.toJSON = function() {\n        return { token: this.tokenType };\n      };\n      CSSParserToken.prototype.toString = function() {\n        return this.tokenType;\n      };\n      CSSParserToken.prototype.toSource = function() {\n        return "" + this;\n      };\n      function BadStringToken2() {\n        return this;\n      }\n      BadStringToken2.prototype = Object.create(CSSParserToken.prototype);\n      BadStringToken2.prototype.tokenType = "BADSTRING";\n      function BadURLToken2() {\n        return this;\n      }\n      BadURLToken2.prototype = Object.create(CSSParserToken.prototype);\n      BadURLToken2.prototype.tokenType = "BADURL";\n      function WhitespaceToken2() {\n        return this;\n      }\n      WhitespaceToken2.prototype = Object.create(CSSParserToken.prototype);\n      WhitespaceToken2.prototype.tokenType = "WHITESPACE";\n      WhitespaceToken2.prototype.toString = function() {\n        return "WS";\n      };\n      WhitespaceToken2.prototype.toSource = function() {\n        return " ";\n      };\n      function CDOToken2() {\n        return this;\n      }\n      CDOToken2.prototype = Object.create(CSSParserToken.prototype);\n      CDOToken2.prototype.tokenType = "CDO";\n      CDOToken2.prototype.toSource = function() {\n        return "<!--";\n      };\n      function CDCToken2() {\n        return this;\n      }\n      CDCToken2.prototype = Object.create(CSSParserToken.prototype);\n      CDCToken2.prototype.tokenType = "CDC";\n      CDCToken2.prototype.toSource = function() {\n        return "-->";\n      };\n      function ColonToken2() {\n        return this;\n      }\n      ColonToken2.prototype = Object.create(CSSParserToken.prototype);\n      ColonToken2.prototype.tokenType = ":";\n      function SemicolonToken2() {\n        return this;\n      }\n      SemicolonToken2.prototype = Object.create(CSSParserToken.prototype);\n      SemicolonToken2.prototype.tokenType = ";";\n      function CommaToken2() {\n        return this;\n      }\n      CommaToken2.prototype = Object.create(CSSParserToken.prototype);\n      CommaToken2.prototype.tokenType = ",";\n      function GroupingToken() {\n        throw "Abstract Base Class";\n      }\n      GroupingToken.prototype = Object.create(CSSParserToken.prototype);\n      function OpenCurlyToken2() {\n        this.value = "{";\n        this.mirror = "}";\n        return this;\n      }\n      OpenCurlyToken2.prototype = Object.create(GroupingToken.prototype);\n      OpenCurlyToken2.prototype.tokenType = "{";\n      function CloseCurlyToken2() {\n        this.value = "}";\n        this.mirror = "{";\n        return this;\n      }\n      CloseCurlyToken2.prototype = Object.create(GroupingToken.prototype);\n      CloseCurlyToken2.prototype.tokenType = "}";\n      function OpenSquareToken2() {\n        this.value = "[";\n        this.mirror = "]";\n        return this;\n      }\n      OpenSquareToken2.prototype = Object.create(GroupingToken.prototype);\n      OpenSquareToken2.prototype.tokenType = "[";\n      function CloseSquareToken2() {\n        this.value = "]";\n        this.mirror = "[";\n        return this;\n      }\n      CloseSquareToken2.prototype = Object.create(GroupingToken.prototype);\n      CloseSquareToken2.prototype.tokenType = "]";\n      function OpenParenToken() {\n        this.value = "(";\n        this.mirror = ")";\n        return this;\n      }\n      OpenParenToken.prototype = Object.create(GroupingToken.prototype);\n      OpenParenToken.prototype.tokenType = "(";\n      function CloseParenToken2() {\n        this.value = ")";\n        this.mirror = "(";\n        return this;\n      }\n      CloseParenToken2.prototype = Object.create(GroupingToken.prototype);\n      CloseParenToken2.prototype.tokenType = ")";\n      function IncludeMatchToken() {\n        return this;\n      }\n      IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);\n      IncludeMatchToken.prototype.tokenType = "~=";\n      function DashMatchToken() {\n        return this;\n      }\n      DashMatchToken.prototype = Object.create(CSSParserToken.prototype);\n      DashMatchToken.prototype.tokenType = "|=";\n      function PrefixMatchToken() {\n        return this;\n      }\n      PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n      PrefixMatchToken.prototype.tokenType = "^=";\n      function SuffixMatchToken() {\n        return this;\n      }\n      SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n      SuffixMatchToken.prototype.tokenType = "$=";\n      function SubstringMatchToken() {\n        return this;\n      }\n      SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);\n      SubstringMatchToken.prototype.tokenType = "*=";\n      function ColumnToken2() {\n        return this;\n      }\n      ColumnToken2.prototype = Object.create(CSSParserToken.prototype);\n      ColumnToken2.prototype.tokenType = "||";\n      function EOFToken2() {\n        return this;\n      }\n      EOFToken2.prototype = Object.create(CSSParserToken.prototype);\n      EOFToken2.prototype.tokenType = "EOF";\n      EOFToken2.prototype.toSource = function() {\n        return "";\n      };\n      function DelimToken2(code) {\n        this.value = stringFromCode(code);\n        return this;\n      }\n      DelimToken2.prototype = Object.create(CSSParserToken.prototype);\n      DelimToken2.prototype.tokenType = "DELIM";\n      DelimToken2.prototype.toString = function() {\n        return "DELIM(" + this.value + ")";\n      };\n      DelimToken2.prototype.toJSON = function() {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        return json;\n      };\n      DelimToken2.prototype.toSource = function() {\n        if (this.value == "\\\\")\n          return "\\\\\\n";\n        else\n          return this.value;\n      };\n      function StringValuedToken() {\n        throw "Abstract Base Class";\n      }\n      StringValuedToken.prototype = Object.create(CSSParserToken.prototype);\n      StringValuedToken.prototype.ASCIIMatch = function(str) {\n        return this.value.toLowerCase() == str.toLowerCase();\n      };\n      StringValuedToken.prototype.toJSON = function() {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        return json;\n      };\n      function IdentToken2(val) {\n        this.value = val;\n      }\n      IdentToken2.prototype = Object.create(StringValuedToken.prototype);\n      IdentToken2.prototype.tokenType = "IDENT";\n      IdentToken2.prototype.toString = function() {\n        return "IDENT(" + this.value + ")";\n      };\n      IdentToken2.prototype.toSource = function() {\n        return escapeIdent(this.value);\n      };\n      function FunctionToken2(val) {\n        this.value = val;\n        this.mirror = ")";\n      }\n      FunctionToken2.prototype = Object.create(StringValuedToken.prototype);\n      FunctionToken2.prototype.tokenType = "FUNCTION";\n      FunctionToken2.prototype.toString = function() {\n        return "FUNCTION(" + this.value + ")";\n      };\n      FunctionToken2.prototype.toSource = function() {\n        return escapeIdent(this.value) + "(";\n      };\n      function AtKeywordToken2(val) {\n        this.value = val;\n      }\n      AtKeywordToken2.prototype = Object.create(StringValuedToken.prototype);\n      AtKeywordToken2.prototype.tokenType = "AT-KEYWORD";\n      AtKeywordToken2.prototype.toString = function() {\n        return "AT(" + this.value + ")";\n      };\n      AtKeywordToken2.prototype.toSource = function() {\n        return "@" + escapeIdent(this.value);\n      };\n      function HashToken2(val) {\n        this.value = val;\n        this.type = "unrestricted";\n      }\n      HashToken2.prototype = Object.create(StringValuedToken.prototype);\n      HashToken2.prototype.tokenType = "HASH";\n      HashToken2.prototype.toString = function() {\n        return "HASH(" + this.value + ")";\n      };\n      HashToken2.prototype.toJSON = function() {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        return json;\n      };\n      HashToken2.prototype.toSource = function() {\n        if (this.type == "id") {\n          return "#" + escapeIdent(this.value);\n        } else {\n          return "#" + escapeHash(this.value);\n        }\n      };\n      function StringToken2(val) {\n        this.value = val;\n      }\n      StringToken2.prototype = Object.create(StringValuedToken.prototype);\n      StringToken2.prototype.tokenType = "STRING";\n      StringToken2.prototype.toString = function() {\n        return \'"\' + escapeString(this.value) + \'"\';\n      };\n      function URLToken2(val) {\n        this.value = val;\n      }\n      URLToken2.prototype = Object.create(StringValuedToken.prototype);\n      URLToken2.prototype.tokenType = "URL";\n      URLToken2.prototype.toString = function() {\n        return "URL(" + this.value + ")";\n      };\n      URLToken2.prototype.toSource = function() {\n        return \'url("\' + escapeString(this.value) + \'")\';\n      };\n      function NumberToken2() {\n        this.value = null;\n        this.type = "integer";\n        this.repr = "";\n      }\n      NumberToken2.prototype = Object.create(CSSParserToken.prototype);\n      NumberToken2.prototype.tokenType = "NUMBER";\n      NumberToken2.prototype.toString = function() {\n        if (this.type == "integer")\n          return "INT(" + this.value + ")";\n        return "NUMBER(" + this.value + ")";\n      };\n      NumberToken2.prototype.toJSON = function() {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        json.repr = this.repr;\n        return json;\n      };\n      NumberToken2.prototype.toSource = function() {\n        return this.repr;\n      };\n      function PercentageToken2() {\n        this.value = null;\n        this.repr = "";\n      }\n      PercentageToken2.prototype = Object.create(CSSParserToken.prototype);\n      PercentageToken2.prototype.tokenType = "PERCENTAGE";\n      PercentageToken2.prototype.toString = function() {\n        return "PERCENTAGE(" + this.value + ")";\n      };\n      PercentageToken2.prototype.toJSON = function() {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.repr = this.repr;\n        return json;\n      };\n      PercentageToken2.prototype.toSource = function() {\n        return this.repr + "%";\n      };\n      function DimensionToken() {\n        this.value = null;\n        this.type = "integer";\n        this.repr = "";\n        this.unit = "";\n      }\n      DimensionToken.prototype = Object.create(CSSParserToken.prototype);\n      DimensionToken.prototype.tokenType = "DIMENSION";\n      DimensionToken.prototype.toString = function() {\n        return "DIM(" + this.value + "," + this.unit + ")";\n      };\n      DimensionToken.prototype.toJSON = function() {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        json.repr = this.repr;\n        json.unit = this.unit;\n        return json;\n      };\n      DimensionToken.prototype.toSource = function() {\n        var source = this.repr;\n        var unit = escapeIdent(this.unit);\n        if (unit[0].toLowerCase() == "e" && (unit[1] == "-" || between(unit.charCodeAt(1), 48, 57))) {\n          unit = "\\\\65 " + unit.slice(1, unit.length);\n        }\n        return source + unit;\n      };\n      function escapeIdent(string) {\n        string = "" + string;\n        var result = "";\n        var firstcode = string.charCodeAt(0);\n        for (var i = 0; i < string.length; i++) {\n          var code = string.charCodeAt(i);\n          if (code == 0) {\n            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n          }\n          if (between(code, 1, 31) || code == 127 || i == 0 && between(code, 48, 57) || i == 1 && between(code, 48, 57) && firstcode == 45) {\n            result += "\\\\" + code.toString(16) + " ";\n          } else if (code >= 128 || code == 45 || code == 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122)) {\n            result += string[i];\n          } else {\n            result += "\\\\" + string[i];\n          }\n        }\n        return result;\n      }\n      function escapeHash(string) {\n        string = "" + string;\n        var result = "";\n        var firstcode = string.charCodeAt(0);\n        for (var i = 0; i < string.length; i++) {\n          var code = string.charCodeAt(i);\n          if (code == 0) {\n            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n          }\n          if (code >= 128 || code == 45 || code == 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122)) {\n            result += string[i];\n          } else {\n            result += "\\\\" + code.toString(16) + " ";\n          }\n        }\n        return result;\n      }\n      function escapeString(string) {\n        string = "" + string;\n        var result = "";\n        for (var i = 0; i < string.length; i++) {\n          var code = string.charCodeAt(i);\n          if (code == 0) {\n            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n          }\n          if (between(code, 1, 31) || code == 127) {\n            result += "\\\\" + code.toString(16) + " ";\n          } else if (code == 34 || code == 92) {\n            result += "\\\\" + string[i];\n          } else {\n            result += string[i];\n          }\n        }\n        return result;\n      }\n      exports2.tokenize = tokenize2;\n      exports2.IdentToken = IdentToken2;\n      exports2.FunctionToken = FunctionToken2;\n      exports2.AtKeywordToken = AtKeywordToken2;\n      exports2.HashToken = HashToken2;\n      exports2.StringToken = StringToken2;\n      exports2.BadStringToken = BadStringToken2;\n      exports2.URLToken = URLToken2;\n      exports2.BadURLToken = BadURLToken2;\n      exports2.DelimToken = DelimToken2;\n      exports2.NumberToken = NumberToken2;\n      exports2.PercentageToken = PercentageToken2;\n      exports2.DimensionToken = DimensionToken;\n      exports2.IncludeMatchToken = IncludeMatchToken;\n      exports2.DashMatchToken = DashMatchToken;\n      exports2.PrefixMatchToken = PrefixMatchToken;\n      exports2.SuffixMatchToken = SuffixMatchToken;\n      exports2.SubstringMatchToken = SubstringMatchToken;\n      exports2.ColumnToken = ColumnToken2;\n      exports2.WhitespaceToken = WhitespaceToken2;\n      exports2.CDOToken = CDOToken2;\n      exports2.CDCToken = CDCToken2;\n      exports2.ColonToken = ColonToken2;\n      exports2.SemicolonToken = SemicolonToken2;\n      exports2.CommaToken = CommaToken2;\n      exports2.OpenParenToken = OpenParenToken;\n      exports2.CloseParenToken = CloseParenToken2;\n      exports2.OpenSquareToken = OpenSquareToken2;\n      exports2.CloseSquareToken = CloseSquareToken2;\n      exports2.OpenCurlyToken = OpenCurlyToken2;\n      exports2.CloseCurlyToken = CloseCurlyToken2;\n      exports2.EOFToken = EOFToken2;\n      exports2.CSSParserToken = CSSParserToken;\n      exports2.GroupingToken = GroupingToken;\n    });\n  }\n});\n\n// packages/playwright-core/src/server/injected/injectedScript.ts\nvar injectedScript_exports = {};\n__export(injectedScript_exports, {\n  InjectedScript: () => InjectedScript\n});\nmodule.exports = __toCommonJS(injectedScript_exports);\n\n// packages/playwright-core/src/server/injected/xpathSelectorEngine.ts\nvar XPathEngine = {\n  queryAll(root, selector) {\n    if (selector.startsWith("/"))\n      selector = "." + selector;\n    const result = [];\n    const document2 = root instanceof Document ? root : root.ownerDocument;\n    if (!document2)\n      return result;\n    const it = document2.evaluate(selector, root, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);\n    for (let node = it.iterateNext(); node; node = it.iterateNext()) {\n      if (node.nodeType === Node.ELEMENT_NODE)\n        result.push(node);\n    }\n    return result;\n  }\n};\n\n// packages/playwright-core/src/server/isomorphic/cssParser.ts\nvar css = __toESM(require_cssTokenizer());\nvar InvalidSelectorError = class extends Error {\n};\nfunction parseCSS(selector, customNames) {\n  let tokens;\n  try {\n    tokens = css.tokenize(selector);\n    if (!(tokens[tokens.length - 1] instanceof css.EOFToken))\n      tokens.push(new css.EOFToken());\n  } catch (e) {\n    const newMessage = e.message + ` while parsing selector "${selector}"`;\n    const index = (e.stack || "").indexOf(e.message);\n    if (index !== -1)\n      e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);\n    e.message = newMessage;\n    throw e;\n  }\n  const unsupportedToken = tokens.find((token) => {\n    return token instanceof css.AtKeywordToken || token instanceof css.BadStringToken || token instanceof css.BadURLToken || token instanceof css.ColumnToken || token instanceof css.CDOToken || token instanceof css.CDCToken || token instanceof css.SemicolonToken || token instanceof css.OpenCurlyToken || token instanceof css.CloseCurlyToken || token instanceof css.URLToken || token instanceof css.PercentageToken;\n  });\n  if (unsupportedToken)\n    throw new InvalidSelectorError(`Unsupported token "${unsupportedToken.toSource()}" while parsing selector "${selector}"`);\n  let pos = 0;\n  const names = /* @__PURE__ */ new Set();\n  function unexpected() {\n    return new InvalidSelectorError(`Unexpected token "${tokens[pos].toSource()}" while parsing selector "${selector}"`);\n  }\n  function skipWhitespace() {\n    while (tokens[pos] instanceof css.WhitespaceToken)\n      pos++;\n  }\n  function isIdent(p = pos) {\n    return tokens[p] instanceof css.IdentToken;\n  }\n  function isString(p = pos) {\n    return tokens[p] instanceof css.StringToken;\n  }\n  function isNumber(p = pos) {\n    return tokens[p] instanceof css.NumberToken;\n  }\n  function isComma(p = pos) {\n    return tokens[p] instanceof css.CommaToken;\n  }\n  function isCloseParen(p = pos) {\n    return tokens[p] instanceof css.CloseParenToken;\n  }\n  function isStar(p = pos) {\n    return tokens[p] instanceof css.DelimToken && tokens[p].value === "*";\n  }\n  function isEOF(p = pos) {\n    return tokens[p] instanceof css.EOFToken;\n  }\n  function isClauseCombinator(p = pos) {\n    return tokens[p] instanceof css.DelimToken && [">", "+", "~"].includes(tokens[p].value);\n  }\n  function isSelectorClauseEnd(p = pos) {\n    return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof css.WhitespaceToken;\n  }\n  function consumeFunctionArguments() {\n    const result2 = [consumeArgument()];\n    while (true) {\n      skipWhitespace();\n      if (!isComma())\n        break;\n      pos++;\n      result2.push(consumeArgument());\n    }\n    return result2;\n  }\n  function consumeArgument() {\n    skipWhitespace();\n    if (isNumber())\n      return tokens[pos++].value;\n    if (isString())\n      return tokens[pos++].value;\n    return consumeComplexSelector();\n  }\n  function consumeComplexSelector() {\n    const result2 = { simples: [] };\n    skipWhitespace();\n    if (isClauseCombinator()) {\n      result2.simples.push({ selector: { functions: [{ name: "scope", args: [] }] }, combinator: "" });\n    } else {\n      result2.simples.push({ selector: consumeSimpleSelector(), combinator: "" });\n    }\n    while (true) {\n      skipWhitespace();\n      if (isClauseCombinator()) {\n        result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;\n        skipWhitespace();\n      } else if (isSelectorClauseEnd()) {\n        break;\n      }\n      result2.simples.push({ combinator: "", selector: consumeSimpleSelector() });\n    }\n    return result2;\n  }\n  function consumeSimpleSelector() {\n    let rawCSSString = "";\n    const functions = [];\n    while (!isSelectorClauseEnd()) {\n      if (isIdent() || isStar()) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof css.HashToken) {\n        rawCSSString += tokens[pos++].toSource();\n      } else if (tokens[pos] instanceof css.DelimToken && tokens[pos].value === ".") {\n        pos++;\n        if (isIdent())\n          rawCSSString += "." + tokens[pos++].toSource();\n        else\n          throw unexpected();\n      } else if (tokens[pos] instanceof css.ColonToken) {\n        pos++;\n        if (isIdent()) {\n          if (!customNames.has(tokens[pos].value.toLowerCase())) {\n            rawCSSString += ":" + tokens[pos++].toSource();\n          } else {\n            const name = tokens[pos++].value.toLowerCase();\n            functions.push({ name, args: [] });\n            names.add(name);\n          }\n        } else if (tokens[pos] instanceof css.FunctionToken) {\n          const name = tokens[pos++].value.toLowerCase();\n          if (!customNames.has(name)) {\n            rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;\n          } else {\n            functions.push({ name, args: consumeFunctionArguments() });\n            names.add(name);\n          }\n          skipWhitespace();\n          if (!isCloseParen())\n            throw unexpected();\n          pos++;\n        } else {\n          throw unexpected();\n        }\n      } else if (tokens[pos] instanceof css.OpenSquareToken) {\n        rawCSSString += "[";\n        pos++;\n        while (!(tokens[pos] instanceof css.CloseSquareToken) && !isEOF())\n          rawCSSString += tokens[pos++].toSource();\n        if (!(tokens[pos] instanceof css.CloseSquareToken))\n          throw unexpected();\n        rawCSSString += "]";\n        pos++;\n      } else {\n        throw unexpected();\n      }\n    }\n    if (!rawCSSString && !functions.length)\n      throw unexpected();\n    return { css: rawCSSString || void 0, functions };\n  }\n  function consumeBuiltinFunctionArguments() {\n    let s = "";\n    while (!isCloseParen() && !isEOF())\n      s += tokens[pos++].toSource();\n    return s;\n  }\n  const result = consumeFunctionArguments();\n  if (!isEOF())\n    throw new InvalidSelectorError(`Error while parsing selector "${selector}"`);\n  if (result.some((arg) => typeof arg !== "object" || !("simples" in arg)))\n    throw new InvalidSelectorError(`Error while parsing selector "${selector}"`);\n  return { selector: result, names: Array.from(names) };\n}\n\n// packages/playwright-core/src/server/isomorphic/selectorParser.ts\nvar customCSSNames = /* @__PURE__ */ new Set(["not", "is", "where", "has", "scope", "light", "visible", "text", "text-matches", "text-is", "has-text", "above", "below", "right-of", "left-of", "near", "nth-match"]);\nvar kNestedSelectorNames = /* @__PURE__ */ new Set(["has"]);\nfunction parseSelector(selector) {\n  const result = parseSelectorString(selector);\n  const parts = result.parts.map((part) => {\n    if (part.name === "css" || part.name === "css:light") {\n      if (part.name === "css:light")\n        part.body = ":light(" + part.body + ")";\n      const parsedCSS = parseCSS(part.body, customCSSNames);\n      return {\n        name: "css",\n        body: parsedCSS.selector,\n        source: part.body\n      };\n    }\n    if (kNestedSelectorNames.has(part.name)) {\n      let innerSelector;\n      try {\n        const unescaped = JSON.parse(part.body);\n        if (typeof unescaped !== "string")\n          throw new Error(`Malformed selector: ${part.name}=` + part.body);\n        innerSelector = unescaped;\n      } catch (e) {\n        throw new Error(`Malformed selector: ${part.name}=` + part.body);\n      }\n      const result2 = { name: part.name, source: part.body, body: parseSelector(innerSelector) };\n      if (result2.body.parts.some((part2) => part2.name === "control" && part2.body === "enter-frame"))\n        throw new Error(`Frames are not allowed inside "${part.name}" selectors`);\n      return result2;\n    }\n    return { ...part, source: part.body };\n  });\n  if (kNestedSelectorNames.has(parts[0].name))\n    throw new Error(`"${parts[0].name}" selector cannot be first`);\n  return {\n    capture: result.capture,\n    parts\n  };\n}\nfunction stringifySelector(selector) {\n  if (typeof selector === "string")\n    return selector;\n  return selector.parts.map((p, i) => {\n    const prefix = p.name === "css" ? "" : p.name + "=";\n    return `${i === selector.capture ? "*" : ""}${prefix}${p.source}`;\n  }).join(" >> ");\n}\nfunction allEngineNames(selector) {\n  const result = /* @__PURE__ */ new Set();\n  const visit = (selector2) => {\n    for (const part of selector2.parts) {\n      result.add(part.name);\n      if (kNestedSelectorNames.has(part.name))\n        visit(part.body);\n    }\n  };\n  visit(selector);\n  return result;\n}\nfunction parseSelectorString(selector) {\n  let index = 0;\n  let quote;\n  let start = 0;\n  const result = { parts: [] };\n  const append = () => {\n    const part = selector.substring(start, index).trim();\n    const eqIndex = part.indexOf("=");\n    let name;\n    let body;\n    if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {\n      name = part.substring(0, eqIndex).trim();\n      body = part.substring(eqIndex + 1);\n    } else if (part.length > 1 && part[0] === \'"\' && part[part.length - 1] === \'"\') {\n      name = "text";\n      body = part;\n    } else if (part.length > 1 && part[0] === "\'" && part[part.length - 1] === "\'") {\n      name = "text";\n      body = part;\n    } else if (/^\\(*\\/\\//.test(part) || part.startsWith("..")) {\n      name = "xpath";\n      body = part;\n    } else {\n      name = "css";\n      body = part;\n    }\n    let capture = false;\n    if (name[0] === "*") {\n      capture = true;\n      name = name.substring(1);\n    }\n    result.parts.push({ name, body });\n    if (capture) {\n      if (result.capture !== void 0)\n        throw new InvalidSelectorError(`Only one of the selectors can capture using * modifier`);\n      result.capture = result.parts.length - 1;\n    }\n  };\n  if (!selector.includes(">>")) {\n    index = selector.length;\n    append();\n    return result;\n  }\n  const shouldIgnoreTextSelectorQuote = () => {\n    const prefix = selector.substring(start, index);\n    const match = prefix.match(/^\\s*text\\s*=(.*)$/);\n    return !!match && !!match[1];\n  };\n  while (index < selector.length) {\n    const c = selector[index];\n    if (c === "\\\\" && index + 1 < selector.length) {\n      index += 2;\n    } else if (c === quote) {\n      quote = void 0;\n      index++;\n    } else if (!quote && (c === \'"\' || c === "\'" || c === "`") && !shouldIgnoreTextSelectorQuote()) {\n      quote = c;\n      index++;\n    } else if (!quote && c === ">" && selector[index + 1] === ">") {\n      append();\n      index += 2;\n      start = index;\n    } else {\n      index++;\n    }\n  }\n  append();\n  return result;\n}\n\n// packages/playwright-core/src/server/injected/selectorEvaluator.ts\nvar SelectorEvaluatorImpl = class {\n  constructor(extraEngines) {\n    this._engines = /* @__PURE__ */ new Map();\n    this._cacheQueryCSS = /* @__PURE__ */ new Map();\n    this._cacheMatches = /* @__PURE__ */ new Map();\n    this._cacheQuery = /* @__PURE__ */ new Map();\n    this._cacheMatchesSimple = /* @__PURE__ */ new Map();\n    this._cacheMatchesParents = /* @__PURE__ */ new Map();\n    this._cacheCallMatches = /* @__PURE__ */ new Map();\n    this._cacheCallQuery = /* @__PURE__ */ new Map();\n    this._cacheQuerySimple = /* @__PURE__ */ new Map();\n    this._cacheText = /* @__PURE__ */ new Map();\n    this._retainCacheCounter = 0;\n    for (const [name, engine] of extraEngines)\n      this._engines.set(name, engine);\n    this._engines.set("not", notEngine);\n    this._engines.set("is", isEngine);\n    this._engines.set("where", isEngine);\n    this._engines.set("has", hasEngine);\n    this._engines.set("scope", scopeEngine);\n    this._engines.set("light", lightEngine);\n    this._engines.set("visible", visibleEngine);\n    this._engines.set("text", textEngine);\n    this._engines.set("text-is", textIsEngine);\n    this._engines.set("text-matches", textMatchesEngine);\n    this._engines.set("has-text", hasTextEngine);\n    this._engines.set("right-of", createPositionEngine("right-of", boxRightOf));\n    this._engines.set("left-of", createPositionEngine("left-of", boxLeftOf));\n    this._engines.set("above", createPositionEngine("above", boxAbove));\n    this._engines.set("below", createPositionEngine("below", boxBelow));\n    this._engines.set("near", createPositionEngine("near", boxNear));\n    this._engines.set("nth-match", nthMatchEngine);\n    const allNames = [...this._engines.keys()];\n    allNames.sort();\n    const parserNames = [...customCSSNames];\n    parserNames.sort();\n    if (allNames.join("|") !== parserNames.join("|"))\n      throw new Error(`Please keep customCSSNames in sync with evaluator engines: ${allNames.join("|")} vs ${parserNames.join("|")}`);\n  }\n  begin() {\n    ++this._retainCacheCounter;\n  }\n  end() {\n    --this._retainCacheCounter;\n    if (!this._retainCacheCounter) {\n      this._cacheQueryCSS.clear();\n      this._cacheMatches.clear();\n      this._cacheQuery.clear();\n      this._cacheMatchesSimple.clear();\n      this._cacheMatchesParents.clear();\n      this._cacheCallMatches.clear();\n      this._cacheCallQuery.clear();\n      this._cacheQuerySimple.clear();\n      this._cacheText.clear();\n    }\n  }\n  _cached(cache, main, rest, cb) {\n    if (!cache.has(main))\n      cache.set(main, []);\n    const entries = cache.get(main);\n    const entry = entries.find((e) => rest.every((value, index) => e.rest[index] === value));\n    if (entry)\n      return entry.result;\n    const result = cb();\n    entries.push({ rest, result });\n    return result;\n  }\n  _checkSelector(s) {\n    const wellFormed = typeof s === "object" && s && (Array.isArray(s) || "simples" in s && s.simples.length);\n    if (!wellFormed)\n      throw new Error(`Malformed selector "${s}"`);\n    return s;\n  }\n  matches(element, s, context) {\n    const selector = this._checkSelector(s);\n    this.begin();\n    try {\n      return this._cached(this._cacheMatches, element, [selector, context.scope, context.pierceShadow], () => {\n        if (Array.isArray(selector))\n          return this._matchesEngine(isEngine, element, selector, context);\n        if (!this._matchesSimple(element, selector.simples[selector.simples.length - 1].selector, context))\n          return false;\n        return this._matchesParents(element, selector, selector.simples.length - 2, context);\n      });\n    } finally {\n      this.end();\n    }\n  }\n  query(context, s) {\n    const selector = this._checkSelector(s);\n    this.begin();\n    try {\n      return this._cached(this._cacheQuery, selector, [context.scope, context.pierceShadow], () => {\n        if (Array.isArray(selector))\n          return this._queryEngine(isEngine, context, selector);\n        const previousScoreMap = this._scoreMap;\n        this._scoreMap = /* @__PURE__ */ new Map();\n        let elements = this._querySimple(context, selector.simples[selector.simples.length - 1].selector);\n        elements = elements.filter((element) => this._matchesParents(element, selector, selector.simples.length - 2, context));\n        if (this._scoreMap.size) {\n          elements.sort((a, b) => {\n            const aScore = this._scoreMap.get(a);\n            const bScore = this._scoreMap.get(b);\n            if (aScore === bScore)\n              return 0;\n            if (aScore === void 0)\n              return 1;\n            if (bScore === void 0)\n              return -1;\n            return aScore - bScore;\n          });\n        }\n        this._scoreMap = previousScoreMap;\n        return elements;\n      });\n    } finally {\n      this.end();\n    }\n  }\n  _markScore(element, score) {\n    if (this._scoreMap)\n      this._scoreMap.set(element, score);\n  }\n  _matchesSimple(element, simple, context) {\n    return this._cached(this._cacheMatchesSimple, element, [simple, context.scope, context.pierceShadow], () => {\n      const isPossiblyScopeClause = simple.functions.some((f) => f.name === "scope" || f.name === "is");\n      if (!isPossiblyScopeClause && element === context.scope)\n        return false;\n      if (simple.css && !this._matchesCSS(element, simple.css))\n        return false;\n      for (const func of simple.functions) {\n        if (!this._matchesEngine(this._getEngine(func.name), element, func.args, context))\n          return false;\n      }\n      return true;\n    });\n  }\n  _querySimple(context, simple) {\n    if (!simple.functions.length)\n      return this._queryCSS(context, simple.css || "*");\n    return this._cached(this._cacheQuerySimple, simple, [context.scope, context.pierceShadow], () => {\n      let css2 = simple.css;\n      const funcs = simple.functions;\n      if (css2 === "*" && funcs.length)\n        css2 = void 0;\n      let elements;\n      let firstIndex = -1;\n      if (css2 !== void 0) {\n        elements = this._queryCSS(context, css2);\n        const hasScopeClause = funcs.some((f) => f.name === "scope");\n        if (hasScopeClause && context.scope.nodeType === 1)\n          elements.unshift(context.scope);\n      } else {\n        firstIndex = funcs.findIndex((func) => this._getEngine(func.name).query !== void 0);\n        if (firstIndex === -1)\n          firstIndex = 0;\n        elements = this._queryEngine(this._getEngine(funcs[firstIndex].name), context, funcs[firstIndex].args);\n      }\n      for (let i = 0; i < funcs.length; i++) {\n        if (i === firstIndex)\n          continue;\n        const engine = this._getEngine(funcs[i].name);\n        if (engine.matches !== void 0)\n          elements = elements.filter((e) => this._matchesEngine(engine, e, funcs[i].args, context));\n      }\n      for (let i = 0; i < funcs.length; i++) {\n        if (i === firstIndex)\n          continue;\n        const engine = this._getEngine(funcs[i].name);\n        if (engine.matches === void 0)\n          elements = elements.filter((e) => this._matchesEngine(engine, e, funcs[i].args, context));\n      }\n      return elements;\n    });\n  }\n  _matchesParents(element, complex, index, context) {\n    if (index < 0)\n      return true;\n    return this._cached(this._cacheMatchesParents, element, [complex, index, context.scope, context.pierceShadow], () => {\n      const { selector: simple, combinator } = complex.simples[index];\n      if (combinator === ">") {\n        const parent = parentElementOrShadowHostInContext(element, context);\n        if (!parent || !this._matchesSimple(parent, simple, context))\n          return false;\n        return this._matchesParents(parent, complex, index - 1, context);\n      }\n      if (combinator === "+") {\n        const previousSibling = previousSiblingInContext(element, context);\n        if (!previousSibling || !this._matchesSimple(previousSibling, simple, context))\n          return false;\n        return this._matchesParents(previousSibling, complex, index - 1, context);\n      }\n      if (combinator === "") {\n        let parent = parentElementOrShadowHostInContext(element, context);\n        while (parent) {\n          if (this._matchesSimple(parent, simple, context)) {\n            if (this._matchesParents(parent, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === "")\n              break;\n          }\n          parent = parentElementOrShadowHostInContext(parent, context);\n        }\n        return false;\n      }\n      if (combinator === "~") {\n        let previousSibling = previousSiblingInContext(element, context);\n        while (previousSibling) {\n          if (this._matchesSimple(previousSibling, simple, context)) {\n            if (this._matchesParents(previousSibling, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === "~")\n              break;\n          }\n          previousSibling = previousSiblingInContext(previousSibling, context);\n        }\n        return false;\n      }\n      if (combinator === ">=") {\n        let parent = element;\n        while (parent) {\n          if (this._matchesSimple(parent, simple, context)) {\n            if (this._matchesParents(parent, complex, index - 1, context))\n              return true;\n            if (complex.simples[index - 1].combinator === "")\n              break;\n          }\n          parent = parentElementOrShadowHostInContext(parent, context);\n        }\n        return false;\n      }\n      throw new Error(`Unsupported combinator "${combinator}"`);\n    });\n  }\n  _matchesEngine(engine, element, args, context) {\n    if (engine.matches)\n      return this._callMatches(engine, element, args, context);\n    if (engine.query)\n      return this._callQuery(engine, args, context).includes(element);\n    throw new Error(`Selector engine should implement "matches" or "query"`);\n  }\n  _queryEngine(engine, context, args) {\n    if (engine.query)\n      return this._callQuery(engine, args, context);\n    if (engine.matches)\n      return this._queryCSS(context, "*").filter((element) => this._callMatches(engine, element, args, context));\n    throw new Error(`Selector engine should implement "matches" or "query"`);\n  }\n  _callMatches(engine, element, args, context) {\n    return this._cached(this._cacheCallMatches, element, [engine, context.scope, context.pierceShadow, ...args], () => {\n      return engine.matches(element, args, context, this);\n    });\n  }\n  _callQuery(engine, args, context) {\n    return this._cached(this._cacheCallQuery, engine, [context.scope, context.pierceShadow, ...args], () => {\n      return engine.query(context, args, this);\n    });\n  }\n  _matchesCSS(element, css2) {\n    return element.matches(css2);\n  }\n  _queryCSS(context, css2) {\n    return this._cached(this._cacheQueryCSS, css2, [context.scope, context.pierceShadow], () => {\n      let result = [];\n      function query(root) {\n        result = result.concat([...root.querySelectorAll(css2)]);\n        if (!context.pierceShadow)\n          return;\n        if (root.shadowRoot)\n          query(root.shadowRoot);\n        for (const element of root.querySelectorAll("*")) {\n          if (element.shadowRoot)\n            query(element.shadowRoot);\n        }\n      }\n      query(context.scope);\n      return result;\n    });\n  }\n  _getEngine(name) {\n    const engine = this._engines.get(name);\n    if (!engine)\n      throw new Error(`Unknown selector engine "${name}"`);\n    return engine;\n  }\n};\nvar isEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"is" engine expects non-empty selector list`);\n    return args.some((selector) => evaluator.matches(element, selector, context));\n  },\n  query(context, args, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"is" engine expects non-empty selector list`);\n    let elements = [];\n    for (const arg of args)\n      elements = elements.concat(evaluator.query(context, arg));\n    return args.length === 1 ? elements : sortInDOMOrder(elements);\n  }\n};\nvar hasEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"has" engine expects non-empty selector list`);\n    return evaluator.query({ ...context, scope: element }, args).length > 0;\n  }\n};\nvar scopeEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 0)\n      throw new Error(`"scope" engine expects no arguments`);\n    if (context.scope.nodeType === 9)\n      return element === context.scope.documentElement;\n    return element === context.scope;\n  },\n  query(context, args, evaluator) {\n    if (args.length !== 0)\n      throw new Error(`"scope" engine expects no arguments`);\n    if (context.scope.nodeType === 9) {\n      const root = context.scope.documentElement;\n      return root ? [root] : [];\n    }\n    if (context.scope.nodeType === 1)\n      return [context.scope];\n    return [];\n  }\n};\nvar notEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0)\n      throw new Error(`"not" engine expects non-empty selector list`);\n    return !evaluator.matches(element, args, context);\n  }\n};\nvar lightEngine = {\n  query(context, args, evaluator) {\n    return evaluator.query({ ...context, pierceShadow: false }, args);\n  },\n  matches(element, args, context, evaluator) {\n    return evaluator.matches(element, args, { ...context, pierceShadow: false });\n  }\n};\nvar visibleEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length)\n      throw new Error(`"visible" engine expects no arguments`);\n    return isVisible(element);\n  }\n};\nvar textEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== "string")\n      throw new Error(`"text" engine expects a single string`);\n    const matcher = createLaxTextMatcher(args[0]);\n    return elementMatchesText(evaluator, element, matcher) === "self";\n  }\n};\nvar textIsEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== "string")\n      throw new Error(`"text-is" engine expects a single string`);\n    const matcher = createStrictTextMatcher(args[0]);\n    return elementMatchesText(evaluator, element, matcher) !== "none";\n  }\n};\nvar textMatchesEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length === 0 || typeof args[0] !== "string" || args.length > 2 || args.length === 2 && typeof args[1] !== "string")\n      throw new Error(`"text-matches" engine expects a regexp body and optional regexp flags`);\n    const matcher = createRegexTextMatcher(args[0], args.length === 2 ? args[1] : void 0);\n    return elementMatchesText(evaluator, element, matcher) === "self";\n  }\n};\nvar hasTextEngine = {\n  matches(element, args, context, evaluator) {\n    if (args.length !== 1 || typeof args[0] !== "string")\n      throw new Error(`"has-text" engine expects a single string`);\n    if (shouldSkipForTextMatching(element))\n      return false;\n    const matcher = createLaxTextMatcher(args[0]);\n    return matcher(elementText(evaluator, element));\n  }\n};\nfunction createLaxTextMatcher(text) {\n  text = text.trim().replace(/\\s+/g, " ").toLowerCase();\n  return (elementText2) => {\n    const s = elementText2.full.trim().replace(/\\s+/g, " ").toLowerCase();\n    return s.includes(text);\n  };\n}\nfunction createStrictTextMatcher(text) {\n  text = text.trim().replace(/\\s+/g, " ");\n  return (elementText2) => {\n    if (!text && !elementText2.immediate.length)\n      return true;\n    return elementText2.immediate.some((s) => s.trim().replace(/\\s+/g, " ") === text);\n  };\n}\nfunction createRegexTextMatcher(source, flags) {\n  const re = new RegExp(source, flags);\n  return (elementText2) => {\n    return re.test(elementText2.full);\n  };\n}\nfunction shouldSkipForTextMatching(element) {\n  return element.nodeName === "SCRIPT" || element.nodeName === "STYLE" || document.head && document.head.contains(element);\n}\nfunction elementText(evaluator, root) {\n  let value = evaluator._cacheText.get(root);\n  if (value === void 0) {\n    value = { full: "", immediate: [] };\n    if (!shouldSkipForTextMatching(root)) {\n      let currentImmediate = "";\n      if (root instanceof HTMLInputElement && (root.type === "submit" || root.type === "button")) {\n        value = { full: root.value, immediate: [root.value] };\n      } else {\n        for (let child = root.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType === Node.TEXT_NODE) {\n            value.full += child.nodeValue || "";\n            currentImmediate += child.nodeValue || "";\n          } else {\n            if (currentImmediate)\n              value.immediate.push(currentImmediate);\n            currentImmediate = "";\n            if (child.nodeType === Node.ELEMENT_NODE)\n              value.full += elementText(evaluator, child).full;\n          }\n        }\n        if (currentImmediate)\n          value.immediate.push(currentImmediate);\n        if (root.shadowRoot)\n          value.full += elementText(evaluator, root.shadowRoot).full;\n      }\n    }\n    evaluator._cacheText.set(root, value);\n  }\n  return value;\n}\nfunction elementMatchesText(evaluator, element, matcher) {\n  if (shouldSkipForTextMatching(element))\n    return "none";\n  if (!matcher(elementText(evaluator, element)))\n    return "none";\n  for (let child = element.firstChild; child; child = child.nextSibling) {\n    if (child.nodeType === Node.ELEMENT_NODE && matcher(elementText(evaluator, child)))\n      return "selfAndChildren";\n  }\n  if (element.shadowRoot && matcher(elementText(evaluator, element.shadowRoot)))\n    return "selfAndChildren";\n  return "self";\n}\nfunction boxRightOf(box1, box2, maxDistance) {\n  const distance = box1.left - box2.right;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxLeftOf(box1, box2, maxDistance) {\n  const distance = box2.left - box1.right;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box2.bottom - box1.bottom, 0) + Math.max(box1.top - box2.top, 0);\n}\nfunction boxAbove(box1, box2, maxDistance) {\n  const distance = box2.top - box1.bottom;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxBelow(box1, box2, maxDistance) {\n  const distance = box1.top - box2.bottom;\n  if (distance < 0 || maxDistance !== void 0 && distance > maxDistance)\n    return;\n  return distance + Math.max(box1.left - box2.left, 0) + Math.max(box2.right - box1.right, 0);\n}\nfunction boxNear(box1, box2, maxDistance) {\n  const kThreshold = maxDistance === void 0 ? 50 : maxDistance;\n  let score = 0;\n  if (box1.left - box2.right >= 0)\n    score += box1.left - box2.right;\n  if (box2.left - box1.right >= 0)\n    score += box2.left - box1.right;\n  if (box2.top - box1.bottom >= 0)\n    score += box2.top - box1.bottom;\n  if (box1.top - box2.bottom >= 0)\n    score += box1.top - box2.bottom;\n  return score > kThreshold ? void 0 : score;\n}\nfunction createPositionEngine(name, scorer) {\n  return {\n    matches(element, args, context, evaluator) {\n      const maxDistance = args.length && typeof args[args.length - 1] === "number" ? args[args.length - 1] : void 0;\n      const queryArgs = maxDistance === void 0 ? args : args.slice(0, args.length - 1);\n      if (args.length < 1 + (maxDistance === void 0 ? 0 : 1))\n        throw new Error(`"${name}" engine expects a selector list and optional maximum distance in pixels`);\n      const box = element.getBoundingClientRect();\n      let bestScore;\n      for (const e of evaluator.query(context, queryArgs)) {\n        if (e === element)\n          continue;\n        const score = scorer(box, e.getBoundingClientRect(), maxDistance);\n        if (score === void 0)\n          continue;\n        if (bestScore === void 0 || score < bestScore)\n          bestScore = score;\n      }\n      if (bestScore === void 0)\n        return false;\n      evaluator._markScore(element, bestScore);\n      return true;\n    }\n  };\n}\nvar nthMatchEngine = {\n  query(context, args, evaluator) {\n    let index = args[args.length - 1];\n    if (args.length < 2)\n      throw new Error(`"nth-match" engine expects non-empty selector list and an index argument`);\n    if (typeof index !== "number" || index < 1)\n      throw new Error(`"nth-match" engine expects a one-based index as the last argument`);\n    const elements = isEngine.query(context, args.slice(0, args.length - 1), evaluator);\n    index--;\n    return index < elements.length ? [elements[index]] : [];\n  }\n};\nfunction isInsideScope(scope, element) {\n  while (element) {\n    if (scope.contains(element))\n      return true;\n    element = enclosingShadowHost(element);\n  }\n  return false;\n}\nfunction parentElementOrShadowHost(element) {\n  if (element.parentElement)\n    return element.parentElement;\n  if (!element.parentNode)\n    return;\n  if (element.parentNode.nodeType === 11 && element.parentNode.host)\n    return element.parentNode.host;\n}\nfunction enclosingShadowRootOrDocument(element) {\n  let node = element;\n  while (node.parentNode)\n    node = node.parentNode;\n  if (node.nodeType === 11 || node.nodeType === 9)\n    return node;\n}\nfunction enclosingShadowHost(element) {\n  while (element.parentElement)\n    element = element.parentElement;\n  return parentElementOrShadowHost(element);\n}\nfunction closestCrossShadow(element, css2) {\n  while (element) {\n    const closest = element.closest(css2);\n    if (closest)\n      return closest;\n    element = enclosingShadowHost(element);\n  }\n}\nfunction parentElementOrShadowHostInContext(element, context) {\n  if (element === context.scope)\n    return;\n  if (!context.pierceShadow)\n    return element.parentElement || void 0;\n  return parentElementOrShadowHost(element);\n}\nfunction previousSiblingInContext(element, context) {\n  if (element === context.scope)\n    return;\n  return element.previousElementSibling || void 0;\n}\nfunction isVisible(element) {\n  if (!element.ownerDocument || !element.ownerDocument.defaultView)\n    return true;\n  const style = element.ownerDocument.defaultView.getComputedStyle(element);\n  if (!style || style.visibility === "hidden")\n    return false;\n  if (style.display === "contents") {\n    for (let child = element.firstChild; child; child = child.nextSibling) {\n      if (child.nodeType === 1 && isVisible(child))\n        return true;\n      if (child.nodeType === 3 && isVisibleTextNode(child))\n        return true;\n    }\n    return false;\n  }\n  const rect = element.getBoundingClientRect();\n  return rect.width > 0 && rect.height > 0;\n}\nfunction isVisibleTextNode(node) {\n  const range = document.createRange();\n  range.selectNode(node);\n  const rect = range.getBoundingClientRect();\n  return rect.width > 0 && rect.height > 0;\n}\nfunction sortInDOMOrder(elements) {\n  const elementToEntry = /* @__PURE__ */ new Map();\n  const roots = [];\n  const result = [];\n  function append(element) {\n    let entry = elementToEntry.get(element);\n    if (entry)\n      return entry;\n    const parent = parentElementOrShadowHost(element);\n    if (parent) {\n      const parentEntry = append(parent);\n      parentEntry.children.push(element);\n    } else {\n      roots.push(element);\n    }\n    entry = { children: [], taken: false };\n    elementToEntry.set(element, entry);\n    return entry;\n  }\n  elements.forEach((e) => append(e).taken = true);\n  function visit(element) {\n    const entry = elementToEntry.get(element);\n    if (entry.taken)\n      result.push(element);\n    if (entry.children.length > 1) {\n      const set = new Set(entry.children);\n      entry.children = [];\n      let child = element.firstElementChild;\n      while (child && entry.children.length < set.size) {\n        if (set.has(child))\n          entry.children.push(child);\n        child = child.nextElementSibling;\n      }\n      child = element.shadowRoot ? element.shadowRoot.firstElementChild : null;\n      while (child && entry.children.length < set.size) {\n        if (set.has(child))\n          entry.children.push(child);\n        child = child.nextElementSibling;\n      }\n    }\n    entry.children.forEach(visit);\n  }\n  roots.forEach(visit);\n  return result;\n}\n\n// packages/playwright-core/src/server/injected/componentUtils.ts\nfunction checkComponentAttribute(obj, attr) {\n  for (const token of attr.jsonPath) {\n    if (obj !== void 0 && obj !== null)\n      obj = obj[token];\n  }\n  return matchesAttribute(obj, attr);\n}\nfunction matchesAttribute(value, attr) {\n  const objValue = typeof value === "string" && !attr.caseSensitive ? value.toUpperCase() : value;\n  const attrValue = typeof attr.value === "string" && !attr.caseSensitive ? attr.value.toUpperCase() : attr.value;\n  if (attr.op === "<truthy>")\n    return !!objValue;\n  if (attr.op === "=") {\n    if (attrValue instanceof RegExp)\n      return typeof objValue === "string" && !!objValue.match(attrValue);\n    return objValue === attrValue;\n  }\n  if (typeof objValue !== "string" || typeof attrValue !== "string")\n    return false;\n  if (attr.op === "*=")\n    return objValue.includes(attrValue);\n  if (attr.op === "^=")\n    return objValue.startsWith(attrValue);\n  if (attr.op === "$=")\n    return objValue.endsWith(attrValue);\n  if (attr.op === "|=")\n    return objValue === attrValue || objValue.startsWith(attrValue + "-");\n  if (attr.op === "~=")\n    return objValue.split(" ").includes(attrValue);\n  return false;\n}\nfunction parseComponentSelector(selector, allowUnquotedStrings) {\n  let wp = 0;\n  let EOL = selector.length === 0;\n  const next = () => selector[wp] || "";\n  const eat1 = () => {\n    const result2 = next();\n    ++wp;\n    EOL = wp >= selector.length;\n    return result2;\n  };\n  const syntaxError = (stage) => {\n    if (EOL)\n      throw new Error(`Unexpected end of selector while parsing selector \\`${selector}\\``);\n    throw new Error(`Error while parsing selector \\`${selector}\\` - unexpected symbol "${next()}" at position ${wp}` + (stage ? " during " + stage : ""));\n  };\n  function skipSpaces() {\n    while (!EOL && /\\s/.test(next()))\n      eat1();\n  }\n  function isCSSNameChar(char) {\n    return char >= "\\x80" || char >= "0" && char <= "9" || char >= "A" && char <= "Z" || char >= "a" && char <= "z" || char >= "0" && char <= "9" || char === "_" || char === "-";\n  }\n  function readIdentifier() {\n    let result2 = "";\n    skipSpaces();\n    while (!EOL && isCSSNameChar(next()))\n      result2 += eat1();\n    return result2;\n  }\n  function readQuotedString(quote) {\n    let result2 = eat1();\n    if (result2 !== quote)\n      syntaxError("parsing quoted string");\n    while (!EOL && next() !== quote) {\n      if (next() === "\\\\")\n        eat1();\n      result2 += eat1();\n    }\n    if (next() !== quote)\n      syntaxError("parsing quoted string");\n    result2 += eat1();\n    return result2;\n  }\n  function readRegularExpression() {\n    if (eat1() !== "/")\n      syntaxError("parsing regular expression");\n    let source = "";\n    let inClass = false;\n    while (!EOL) {\n      if (next() === "\\\\") {\n        source += eat1();\n        if (EOL)\n          syntaxError("parsing regular expressiion");\n      } else if (inClass && next() === "]") {\n        inClass = false;\n      } else if (!inClass && next() === "[") {\n        inClass = true;\n      } else if (!inClass && next() === "/") {\n        break;\n      }\n      source += eat1();\n    }\n    if (eat1() !== "/")\n      syntaxError("parsing regular expression");\n    let flags = "";\n    while (!EOL && next().match(/[dgimsuy]/))\n      flags += eat1();\n    try {\n      return new RegExp(source, flags);\n    } catch (e) {\n      throw new Error(`Error while parsing selector \\`${selector}\\`: ${e.message}`);\n    }\n  }\n  function readAttributeToken() {\n    let token = "";\n    skipSpaces();\n    if (next() === `\'` || next() === `"`)\n      token = readQuotedString(next()).slice(1, -1);\n    else\n      token = readIdentifier();\n    if (!token)\n      syntaxError("parsing property path");\n    return token;\n  }\n  function readOperator() {\n    skipSpaces();\n    let op = "";\n    if (!EOL)\n      op += eat1();\n    if (!EOL && op !== "=")\n      op += eat1();\n    if (!["=", "*=", "^=", "$=", "|=", "~="].includes(op))\n      syntaxError("parsing operator");\n    return op;\n  }\n  function readAttribute() {\n    eat1();\n    const jsonPath = [];\n    jsonPath.push(readAttributeToken());\n    skipSpaces();\n    while (next() === ".") {\n      eat1();\n      jsonPath.push(readAttributeToken());\n      skipSpaces();\n    }\n    if (next() === "]") {\n      eat1();\n      return { name: jsonPath.join("."), jsonPath, op: "<truthy>", value: null, caseSensitive: false };\n    }\n    const operator = readOperator();\n    let value = void 0;\n    let caseSensitive = true;\n    skipSpaces();\n    if (next() === "/") {\n      if (operator !== "=")\n        throw new Error(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with regular expression`);\n      value = readRegularExpression();\n    } else if (next() === `\'` || next() === `"`) {\n      value = readQuotedString(next()).slice(1, -1);\n      skipSpaces();\n      if (next() === "i" || next() === "I") {\n        caseSensitive = false;\n        eat1();\n      } else if (next() === "s" || next() === "S") {\n        caseSensitive = true;\n        eat1();\n      }\n    } else {\n      value = "";\n      while (!EOL && (isCSSNameChar(next()) || next() === "+" || next() === "."))\n        value += eat1();\n      if (value === "true") {\n        value = true;\n      } else if (value === "false") {\n        value = false;\n      } else {\n        if (!allowUnquotedStrings) {\n          value = +value;\n          if (Number.isNaN(value))\n            syntaxError("parsing attribute value");\n        }\n      }\n    }\n    skipSpaces();\n    if (next() !== "]")\n      syntaxError("parsing attribute value");\n    eat1();\n    if (operator !== "=" && typeof value !== "string")\n      throw new Error(`Error while parsing selector \\`${selector}\\` - cannot use ${operator} in attribute with non-string matching value - ${value}`);\n    return { name: jsonPath.join("."), jsonPath, op: operator, value, caseSensitive };\n  }\n  const result = {\n    name: "",\n    attributes: []\n  };\n  result.name = readIdentifier();\n  skipSpaces();\n  while (next() === "[") {\n    result.attributes.push(readAttribute());\n    skipSpaces();\n  }\n  if (!EOL)\n    syntaxError(void 0);\n  if (!result.name && !result.attributes.length)\n    throw new Error(`Error while parsing selector \\`${selector}\\` - selector cannot be empty`);\n  return result;\n}\n\n// packages/playwright-core/src/server/injected/reactSelectorEngine.ts\nfunction getComponentName(reactElement) {\n  if (typeof reactElement.type === "function")\n    return reactElement.type.displayName || reactElement.type.name || "Anonymous";\n  if (typeof reactElement.type === "string")\n    return reactElement.type;\n  if (reactElement._currentElement) {\n    const elementType = reactElement._currentElement.type;\n    if (typeof elementType === "string")\n      return elementType;\n    if (typeof elementType === "function")\n      return elementType.displayName || elementType.name || "Anonymous";\n  }\n  return "";\n}\nfunction getComponentKey(reactElement) {\n  var _a, _b;\n  return (_b = reactElement.key) != null ? _b : (_a = reactElement._currentElement) == null ? void 0 : _a.key;\n}\nfunction getChildren(reactElement) {\n  if (reactElement.child) {\n    const children = [];\n    for (let child = reactElement.child; child; child = child.sibling)\n      children.push(child);\n    return children;\n  }\n  if (!reactElement._currentElement)\n    return [];\n  const isKnownElement = (reactElement2) => {\n    var _a;\n    const elementType = (_a = reactElement2._currentElement) == null ? void 0 : _a.type;\n    return typeof elementType === "function" || typeof elementType === "string";\n  };\n  if (reactElement._renderedComponent) {\n    const child = reactElement._renderedComponent;\n    return isKnownElement(child) ? [child] : [];\n  }\n  if (reactElement._renderedChildren)\n    return [...Object.values(reactElement._renderedChildren)].filter(isKnownElement);\n  return [];\n}\nfunction getProps(reactElement) {\n  var _a;\n  const props = reactElement.memoizedProps || ((_a = reactElement._currentElement) == null ? void 0 : _a.props);\n  if (!props || typeof props === "string")\n    return props;\n  const result = { ...props };\n  delete result.children;\n  return result;\n}\nfunction buildComponentsTree(reactElement) {\n  var _a;\n  const treeNode = {\n    key: getComponentKey(reactElement),\n    name: getComponentName(reactElement),\n    children: getChildren(reactElement).map(buildComponentsTree),\n    rootElements: [],\n    props: getProps(reactElement)\n  };\n  const rootElement = reactElement.stateNode || reactElement._hostNode || ((_a = reactElement._renderedComponent) == null ? void 0 : _a._hostNode);\n  if (rootElement instanceof Element) {\n    treeNode.rootElements.push(rootElement);\n  } else {\n    for (const child of treeNode.children)\n      treeNode.rootElements.push(...child.rootElements);\n  }\n  return treeNode;\n}\nfunction filterComponentsTree(treeNode, searchFn, result = []) {\n  if (searchFn(treeNode))\n    result.push(treeNode);\n  for (const child of treeNode.children)\n    filterComponentsTree(child, searchFn, result);\n  return result;\n}\nfunction findReactRoots(root, roots = []) {\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  do {\n    const node = walker.currentNode;\n    if (node.hasOwnProperty("_reactRootContainer"))\n      roots.push(node._reactRootContainer._internalRoot.current);\n    if (node instanceof Element && node.hasAttribute("data-reactroot")) {\n      for (const key of Object.keys(node)) {\n        if (key.startsWith("__reactInternalInstance") || key.startsWith("__reactFiber"))\n          roots.push(node[key]);\n      }\n    }\n    const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n    if (shadowRoot)\n      findReactRoots(shadowRoot, roots);\n  } while (walker.nextNode());\n  return roots;\n}\nvar ReactEngine = {\n  queryAll(scope, selector) {\n    const { name, attributes } = parseComponentSelector(selector, false);\n    const reactRoots = findReactRoots(document);\n    const trees = reactRoots.map((reactRoot) => buildComponentsTree(reactRoot));\n    const treeNodes = trees.map((tree) => filterComponentsTree(tree, (treeNode) => {\n      var _a;\n      const props = (_a = treeNode.props) != null ? _a : {};\n      if (treeNode.key !== void 0)\n        props.key = treeNode.key;\n      if (name && treeNode.name !== name)\n        return false;\n      if (treeNode.rootElements.some((domNode) => !isInsideScope(scope, domNode)))\n        return false;\n      for (const attr of attributes) {\n        if (!checkComponentAttribute(props, attr))\n          return false;\n      }\n      return true;\n    })).flat();\n    const allRootElements = /* @__PURE__ */ new Set();\n    for (const treeNode of treeNodes) {\n      for (const domNode of treeNode.rootElements)\n        allRootElements.add(domNode);\n    }\n    return [...allRootElements];\n  }\n};\n\n// packages/playwright-core/src/server/injected/vueSelectorEngine.ts\nfunction basename(filename, ext) {\n  const normalized = filename.replace(/^[a-zA-Z]:/, "").replace(/\\\\/g, "/");\n  let result = normalized.substring(normalized.lastIndexOf("/") + 1);\n  if (ext && result.endsWith(ext))\n    result = result.substring(0, result.length - ext.length);\n  return result;\n}\nfunction toUpper(_, c) {\n  return c ? c.toUpperCase() : "";\n}\nvar classifyRE = /(?:^|[-_/])(\\w)/g;\nvar classify = (str) => {\n  return str && str.replace(classifyRE, toUpper);\n};\nfunction buildComponentsTreeVue3(instance) {\n  function getComponentTypeName(options) {\n    const name = options.name || options._componentTag || options.__playwright_guessedName;\n    if (name)\n      return name;\n    const file = options.__file;\n    if (file)\n      return classify(basename(file, ".vue"));\n  }\n  function saveComponentName(instance2, key) {\n    instance2.type.__playwright_guessedName = key;\n    return key;\n  }\n  function getInstanceName(instance2) {\n    var _a, _b, _c, _d;\n    const name = getComponentTypeName(instance2.type || {});\n    if (name)\n      return name;\n    if (instance2.root === instance2)\n      return "Root";\n    for (const key in (_b = (_a = instance2.parent) == null ? void 0 : _a.type) == null ? void 0 : _b.components)\n      if (((_c = instance2.parent) == null ? void 0 : _c.type.components[key]) === instance2.type)\n        return saveComponentName(instance2, key);\n    for (const key in (_d = instance2.appContext) == null ? void 0 : _d.components)\n      if (instance2.appContext.components[key] === instance2.type)\n        return saveComponentName(instance2, key);\n    return "Anonymous Component";\n  }\n  function isBeingDestroyed(instance2) {\n    return instance2._isBeingDestroyed || instance2.isUnmounted;\n  }\n  function isFragment(instance2) {\n    return instance2.subTree.type.toString() === "Symbol(Fragment)";\n  }\n  function getInternalInstanceChildren(subTree) {\n    const list = [];\n    if (subTree.component)\n      list.push(subTree.component);\n    if (subTree.suspense)\n      list.push(...getInternalInstanceChildren(subTree.suspense.activeBranch));\n    if (Array.isArray(subTree.children)) {\n      subTree.children.forEach((childSubTree) => {\n        if (childSubTree.component)\n          list.push(childSubTree.component);\n        else\n          list.push(...getInternalInstanceChildren(childSubTree));\n      });\n    }\n    return list.filter((child) => {\n      var _a;\n      return !isBeingDestroyed(child) && !((_a = child.type.devtools) == null ? void 0 : _a.hide);\n    });\n  }\n  function getRootElementsFromComponentInstance(instance2) {\n    if (isFragment(instance2))\n      return getFragmentRootElements(instance2.subTree);\n    return [instance2.subTree.el];\n  }\n  function getFragmentRootElements(vnode) {\n    if (!vnode.children)\n      return [];\n    const list = [];\n    for (let i = 0, l = vnode.children.length; i < l; i++) {\n      const childVnode = vnode.children[i];\n      if (childVnode.component)\n        list.push(...getRootElementsFromComponentInstance(childVnode.component));\n      else if (childVnode.el)\n        list.push(childVnode.el);\n    }\n    return list;\n  }\n  function buildComponentsTree2(instance2) {\n    return {\n      name: getInstanceName(instance2),\n      children: getInternalInstanceChildren(instance2.subTree).map(buildComponentsTree2),\n      rootElements: getRootElementsFromComponentInstance(instance2),\n      props: instance2.props\n    };\n  }\n  return buildComponentsTree2(instance);\n}\nfunction buildComponentsTreeVue2(instance) {\n  function getComponentName2(options) {\n    const name = options.displayName || options.name || options._componentTag;\n    if (name)\n      return name;\n    const file = options.__file;\n    if (file)\n      return classify(basename(file, ".vue"));\n  }\n  function getInstanceName(instance2) {\n    const name = getComponentName2(instance2.$options || instance2.fnOptions || {});\n    if (name)\n      return name;\n    return instance2.$root === instance2 ? "Root" : "Anonymous Component";\n  }\n  function getInternalInstanceChildren(instance2) {\n    if (instance2.$children)\n      return instance2.$children;\n    if (Array.isArray(instance2.subTree.children))\n      return instance2.subTree.children.filter((vnode) => !!vnode.component).map((vnode) => vnode.component);\n    return [];\n  }\n  function buildComponentsTree2(instance2) {\n    return {\n      name: getInstanceName(instance2),\n      children: getInternalInstanceChildren(instance2).map(buildComponentsTree2),\n      rootElements: [instance2.$el],\n      props: instance2._props\n    };\n  }\n  return buildComponentsTree2(instance);\n}\nfunction filterComponentsTree2(treeNode, searchFn, result = []) {\n  if (searchFn(treeNode))\n    result.push(treeNode);\n  for (const child of treeNode.children)\n    filterComponentsTree2(child, searchFn, result);\n  return result;\n}\nfunction findVueRoots(root, roots = []) {\n  const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);\n  const vue2Roots = /* @__PURE__ */ new Set();\n  do {\n    const node = walker.currentNode;\n    if (node.__vue__)\n      vue2Roots.add(node.__vue__.$root);\n    if (node.__vue_app__ && node._vnode && node._vnode.component)\n      roots.push({ root: node._vnode.component, version: 3 });\n    const shadowRoot = node instanceof Element ? node.shadowRoot : null;\n    if (shadowRoot)\n      findVueRoots(shadowRoot, roots);\n  } while (walker.nextNode());\n  for (const vue2root of vue2Roots) {\n    roots.push({\n      version: 2,\n      root: vue2root\n    });\n  }\n  return roots;\n}\nvar VueEngine = {\n  queryAll(scope, selector) {\n    const { name, attributes } = parseComponentSelector(selector, false);\n    const vueRoots = findVueRoots(document);\n    const trees = vueRoots.map((vueRoot) => vueRoot.version === 3 ? buildComponentsTreeVue3(vueRoot.root) : buildComponentsTreeVue2(vueRoot.root));\n    const treeNodes = trees.map((tree) => filterComponentsTree2(tree, (treeNode) => {\n      if (name && treeNode.name !== name)\n        return false;\n      if (treeNode.rootElements.some((rootElement) => !isInsideScope(scope, rootElement)))\n        return false;\n      for (const attr of attributes) {\n        if (!checkComponentAttribute(treeNode.props, attr))\n          return false;\n      }\n      return true;\n    })).flat();\n    const allRootElements = /* @__PURE__ */ new Set();\n    for (const treeNode of treeNodes) {\n      for (const rootElement of treeNode.rootElements)\n        allRootElements.add(rootElement);\n    }\n    return [...allRootElements];\n  }\n};\n\n// packages/playwright-core/src/server/injected/roleUtils.ts\nfunction hasExplicitAccessibleName(e) {\n  return e.hasAttribute("aria-label") || e.hasAttribute("aria-labelledby");\n}\nvar kAncestorPreventingLandmark = "article:not([role]), aside:not([role]), main:not([role]), nav:not([role]), section:not([role]), [role=article], [role=complementary], [role=main], [role=navigation], [role=region]";\nvar kGlobalAriaAttributes = [\n  "aria-atomic",\n  "aria-busy",\n  "aria-controls",\n  "aria-current",\n  "aria-describedby",\n  "aria-details",\n  "aria-disabled",\n  "aria-dropeffect",\n  "aria-errormessage",\n  "aria-flowto",\n  "aria-grabbed",\n  "aria-haspopup",\n  "aria-hidden",\n  "aria-invalid",\n  "aria-keyshortcuts",\n  "aria-label",\n  "aria-labelledby",\n  "aria-live",\n  "aria-owns",\n  "aria-relevant",\n  "aria-roledescription"\n];\nfunction hasGlobalAriaAttribute(e) {\n  return kGlobalAriaAttributes.some((a) => e.hasAttribute(a));\n}\nvar kImplicitRoleByTagName = {\n  "A": (e) => {\n    return e.hasAttribute("href") ? "link" : null;\n  },\n  "AREA": (e) => {\n    return e.hasAttribute("href") ? "link" : null;\n  },\n  "ARTICLE": () => "article",\n  "ASIDE": () => "complementary",\n  "BLOCKQUOTE": () => "blockquote",\n  "BUTTON": () => "button",\n  "CAPTION": () => "caption",\n  "CODE": () => "code",\n  "DATALIST": () => "listbox",\n  "DD": () => "definition",\n  "DEL": () => "deletion",\n  "DETAILS": () => "group",\n  "DFN": () => "term",\n  "DIALOG": () => "dialog",\n  "DT": () => "term",\n  "EM": () => "emphasis",\n  "FIELDSET": () => "group",\n  "FIGURE": () => "figure",\n  "FOOTER": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : "contentinfo",\n  "FORM": (e) => hasExplicitAccessibleName(e) ? "form" : null,\n  "H1": () => "heading",\n  "H2": () => "heading",\n  "H3": () => "heading",\n  "H4": () => "heading",\n  "H5": () => "heading",\n  "H6": () => "heading",\n  "HEADER": (e) => closestCrossShadow(e, kAncestorPreventingLandmark) ? null : "banner",\n  "HR": () => "separator",\n  "HTML": () => "document",\n  "IMG": (e) => e.getAttribute("alt") === "" && !hasGlobalAriaAttribute(e) && Number.isNaN(Number(String(e.getAttribute("tabindex")))) ? "presentation" : "img",\n  "INPUT": (e) => {\n    const type = e.type.toLowerCase();\n    if (type === "search")\n      return e.hasAttribute("list") ? "combobox" : "searchbox";\n    if (["email", "tel", "text", "url", ""].includes(type)) {\n      const list = getIdRefs(e, e.getAttribute("list"))[0];\n      return list && list.tagName === "DATALIST" ? "combobox" : "textbox";\n    }\n    if (type === "hidden")\n      return "";\n    return {\n      "button": "button",\n      "checkbox": "checkbox",\n      "image": "button",\n      "number": "spinbutton",\n      "radio": "radio",\n      "range": "slider",\n      "reset": "button",\n      "submit": "button"\n    }[type] || "textbox";\n  },\n  "INS": () => "insertion",\n  "LI": () => "listitem",\n  "MAIN": () => "main",\n  "MARK": () => "mark",\n  "MATH": () => "math",\n  "MENU": () => "list",\n  "METER": () => "meter",\n  "NAV": () => "navigation",\n  "OL": () => "list",\n  "OPTGROUP": () => "group",\n  "OPTION": () => "option",\n  "OUTPUT": () => "status",\n  "P": () => "paragraph",\n  "PROGRESS": () => "progressbar",\n  "SECTION": (e) => hasExplicitAccessibleName(e) ? "region" : null,\n  "SELECT": (e) => e.hasAttribute("multiple") || e.size > 1 ? "listbox" : "combobox",\n  "STRONG": () => "strong",\n  "SUB": () => "subscript",\n  "SUP": () => "superscript",\n  "TABLE": () => "table",\n  "TBODY": () => "rowgroup",\n  "TD": (e) => {\n    const table = closestCrossShadow(e, "table");\n    const role = table ? getExplicitAriaRole(table) : "";\n    return role === "grid" || role === "treegrid" ? "gridcell" : "cell";\n  },\n  "TEXTAREA": () => "textbox",\n  "TFOOT": () => "rowgroup",\n  "TH": (e) => {\n    if (e.getAttribute("scope") === "col")\n      return "columnheader";\n    if (e.getAttribute("scope") === "row")\n      return "rowheader";\n    const table = closestCrossShadow(e, "table");\n    const role = table ? getExplicitAriaRole(table) : "";\n    return role === "grid" || role === "treegrid" ? "gridcell" : "cell";\n  },\n  "THEAD": () => "rowgroup",\n  "TIME": () => "time",\n  "TR": () => "row",\n  "UL": () => "list"\n};\nvar kPresentationInheritanceParents = {\n  "DD": ["DL", "DIV"],\n  "DIV": ["DL"],\n  "DT": ["DL", "DIV"],\n  "LI": ["OL", "UL"],\n  "TBODY": ["TABLE"],\n  "TD": ["TR"],\n  "TFOOT": ["TABLE"],\n  "TH": ["TR"],\n  "THEAD": ["TABLE"],\n  "TR": ["THEAD", "TBODY", "TFOOT", "TABLE"]\n};\nfunction getImplicitAriaRole(element) {\n  var _a;\n  const implicitRole = ((_a = kImplicitRoleByTagName[element.tagName]) == null ? void 0 : _a.call(kImplicitRoleByTagName, element)) || "";\n  if (!implicitRole)\n    return null;\n  let ancestor = element;\n  while (ancestor) {\n    const parent = parentElementOrShadowHost(ancestor);\n    const parents = kPresentationInheritanceParents[ancestor.tagName];\n    if (!parents || !parent || !parents.includes(parent.tagName))\n      break;\n    const parentExplicitRole = getExplicitAriaRole(parent);\n    if ((parentExplicitRole === "none" || parentExplicitRole === "presentation") && !hasPresentationConflictResolution(parent))\n      return parentExplicitRole;\n    ancestor = parent;\n  }\n  return implicitRole;\n}\nvar allRoles = [\n  "alert",\n  "alertdialog",\n  "application",\n  "article",\n  "banner",\n  "blockquote",\n  "button",\n  "caption",\n  "cell",\n  "checkbox",\n  "code",\n  "columnheader",\n  "combobox",\n  "command",\n  "complementary",\n  "composite",\n  "contentinfo",\n  "definition",\n  "deletion",\n  "dialog",\n  "directory",\n  "document",\n  "emphasis",\n  "feed",\n  "figure",\n  "form",\n  "generic",\n  "grid",\n  "gridcell",\n  "group",\n  "heading",\n  "img",\n  "input",\n  "insertion",\n  "landmark",\n  "link",\n  "list",\n  "listbox",\n  "listitem",\n  "log",\n  "main",\n  "marquee",\n  "math",\n  "meter",\n  "menu",\n  "menubar",\n  "menuitem",\n  "menuitemcheckbox",\n  "menuitemradio",\n  "navigation",\n  "none",\n  "note",\n  "option",\n  "paragraph",\n  "presentation",\n  "progressbar",\n  "radio",\n  "radiogroup",\n  "range",\n  "region",\n  "roletype",\n  "row",\n  "rowgroup",\n  "rowheader",\n  "scrollbar",\n  "search",\n  "searchbox",\n  "section",\n  "sectionhead",\n  "select",\n  "separator",\n  "slider",\n  "spinbutton",\n  "status",\n  "strong",\n  "structure",\n  "subscript",\n  "superscript",\n  "switch",\n  "tab",\n  "table",\n  "tablist",\n  "tabpanel",\n  "term",\n  "textbox",\n  "time",\n  "timer",\n  "toolbar",\n  "tooltip",\n  "tree",\n  "treegrid",\n  "treeitem",\n  "widget",\n  "window"\n];\nvar abstractRoles = ["command", "composite", "input", "landmark", "range", "roletype", "section", "sectionhead", "select", "structure", "widget", "window"];\nvar validRoles = allRoles.filter((role) => !abstractRoles.includes(role));\nfunction getExplicitAriaRole(element) {\n  const roles = (element.getAttribute("role") || "").split(" ").map((role) => role.trim());\n  return roles.find((role) => validRoles.includes(role)) || null;\n}\nfunction hasPresentationConflictResolution(element) {\n  return !hasGlobalAriaAttribute(element);\n}\nfunction getAriaRole(element) {\n  const explicitRole = getExplicitAriaRole(element);\n  if (!explicitRole)\n    return getImplicitAriaRole(element);\n  if ((explicitRole === "none" || explicitRole === "presentation") && hasPresentationConflictResolution(element))\n    return getImplicitAriaRole(element);\n  return explicitRole;\n}\nfunction getAriaBoolean(attr) {\n  return attr === null ? void 0 : attr.toLowerCase() === "true";\n}\nfunction getComputedStyle(element, pseudo) {\n  return element.ownerDocument && element.ownerDocument.defaultView ? element.ownerDocument.defaultView.getComputedStyle(element, pseudo) : void 0;\n}\nfunction isElementHiddenForAria(element, cache) {\n  if (["STYLE", "SCRIPT", "NOSCRIPT", "TEMPLATE"].includes(element.tagName))\n    return true;\n  const style = getComputedStyle(element);\n  if (!style || style.visibility === "hidden")\n    return true;\n  return belongsToDisplayNoneOrAriaHidden(element, cache);\n}\nfunction belongsToDisplayNoneOrAriaHidden(element, cache) {\n  if (!cache.has(element)) {\n    const style = getComputedStyle(element);\n    let hidden = !style || style.display === "none" || getAriaBoolean(element.getAttribute("aria-hidden")) === true;\n    if (!hidden) {\n      const parent = parentElementOrShadowHost(element);\n      if (parent)\n        hidden = hidden || belongsToDisplayNoneOrAriaHidden(parent, cache);\n    }\n    cache.set(element, hidden);\n  }\n  return cache.get(element);\n}\nfunction getIdRefs(element, ref) {\n  if (!ref)\n    return [];\n  const root = enclosingShadowRootOrDocument(element);\n  if (!root)\n    return [];\n  try {\n    const ids = ref.split(" ").filter((id) => !!id);\n    const set = /* @__PURE__ */ new Set();\n    for (const id of ids) {\n      const firstElement = root.querySelector("#" + CSS.escape(id));\n      if (firstElement)\n        set.add(firstElement);\n    }\n    return [...set];\n  } catch (e) {\n    return [];\n  }\n}\nfunction normalizeAccessbileName(s) {\n  return s.replace(/\\r\\n/g, "\\n").replace(/\\u00A0/g, " ").replace(/\\s\\s+/g, " ").trim();\n}\nfunction queryInAriaOwned(element, selector) {\n  const result = [...element.querySelectorAll(selector)];\n  for (const owned of getIdRefs(element, element.getAttribute("aria-owns"))) {\n    if (owned.matches(selector))\n      result.push(owned);\n    result.push(...owned.querySelectorAll(selector));\n  }\n  return result;\n}\nfunction getPseudoContent(pseudoStyle) {\n  if (!pseudoStyle)\n    return "";\n  const content = pseudoStyle.getPropertyValue("content");\n  if (content[0] === "\'" && content[content.length - 1] === "\'" || content[0] === \'"\' && content[content.length - 1] === \'"\') {\n    const unquoted = content.substring(1, content.length - 1);\n    const display = pseudoStyle.getPropertyValue("display") || "inline";\n    if (display !== "inline")\n      return " " + unquoted + " ";\n    return unquoted;\n  }\n  return "";\n}\nfunction getElementAccessibleName(element, includeHidden, hiddenCache) {\n  const elementProhibitsNaming = ["caption", "code", "definition", "deletion", "emphasis", "generic", "insertion", "mark", "paragraph", "presentation", "strong", "subscript", "suggestion", "superscript", "term", "time"].includes(getAriaRole(element) || "");\n  if (elementProhibitsNaming)\n    return "";\n  const accessibleName = normalizeAccessbileName(getElementAccessibleNameInternal(element, {\n    includeHidden,\n    hiddenCache,\n    visitedElements: /* @__PURE__ */ new Set(),\n    embeddedInLabelledBy: "none",\n    embeddedInLabel: "none",\n    embeddedInTextAlternativeElement: false,\n    embeddedInTargetElement: "self"\n  }));\n  return accessibleName;\n}\nfunction getElementAccessibleNameInternal(element, options) {\n  if (options.visitedElements.has(element))\n    return "";\n  const childOptions = {\n    ...options,\n    embeddedInLabel: options.embeddedInLabel === "self" ? "descendant" : options.embeddedInLabel,\n    embeddedInLabelledBy: options.embeddedInLabelledBy === "self" ? "descendant" : options.embeddedInLabelledBy,\n    embeddedInTargetElement: options.embeddedInTargetElement === "self" ? "descendant" : options.embeddedInTargetElement\n  };\n  if (!options.includeHidden && options.embeddedInLabelledBy !== "self" && isElementHiddenForAria(element, options.hiddenCache)) {\n    options.visitedElements.add(element);\n    return "";\n  }\n  if (options.embeddedInLabelledBy === "none") {\n    const refs = getIdRefs(element, element.getAttribute("aria-labelledby"));\n    const accessibleName = refs.map((ref) => getElementAccessibleNameInternal(ref, {\n      ...options,\n      embeddedInLabelledBy: "self",\n      embeddedInTargetElement: "none",\n      embeddedInLabel: "none",\n      embeddedInTextAlternativeElement: false\n    })).join(" ");\n    if (accessibleName)\n      return accessibleName;\n  }\n  const role = getAriaRole(element) || "";\n  if (options.embeddedInLabel !== "none" || options.embeddedInLabelledBy !== "none") {\n    const isOwnLabel = [...element.labels || []].includes(element);\n    const isOwnLabelledBy = getIdRefs(element, element.getAttribute("aria-labelledby")).includes(element);\n    if (!isOwnLabel && !isOwnLabelledBy) {\n      if (role === "textbox") {\n        options.visitedElements.add(element);\n        if (element.tagName === "INPUT" || element.tagName === "TEXTAREA")\n          return element.value;\n        return element.textContent || "";\n      }\n      if (["combobox", "listbox"].includes(role)) {\n        options.visitedElements.add(element);\n        let selectedOptions;\n        if (element.tagName === "SELECT") {\n          selectedOptions = [...element.selectedOptions];\n          if (!selectedOptions.length && element.options.length)\n            selectedOptions.push(element.options[0]);\n        } else {\n          const listbox = role === "combobox" ? queryInAriaOwned(element, "*").find((e) => getAriaRole(e) === "listbox") : element;\n          selectedOptions = listbox ? queryInAriaOwned(listbox, \'[aria-selected="true"]\').filter((e) => getAriaRole(e) === "option") : [];\n        }\n        return selectedOptions.map((option) => getElementAccessibleNameInternal(option, childOptions)).join(" ");\n      }\n      if (["progressbar", "scrollbar", "slider", "spinbutton", "meter"].includes(role)) {\n        options.visitedElements.add(element);\n        if (element.hasAttribute("aria-valuetext"))\n          return element.getAttribute("aria-valuetext") || "";\n        if (element.hasAttribute("aria-valuenow"))\n          return element.getAttribute("aria-valuenow") || "";\n        return element.getAttribute("value") || "";\n      }\n      if (["menu"].includes(role)) {\n        options.visitedElements.add(element);\n        return "";\n      }\n    }\n  }\n  const ariaLabel = element.getAttribute("aria-label") || "";\n  if (ariaLabel.trim()) {\n    options.visitedElements.add(element);\n    return ariaLabel;\n  }\n  if (!["presentation", "none"].includes(role)) {\n    if (element.tagName === "INPUT" && ["button", "submit", "reset"].includes(element.type)) {\n      options.visitedElements.add(element);\n      const value = element.value || "";\n      if (value.trim())\n        return value;\n      if (element.type === "submit")\n        return "Submit";\n      if (element.type === "reset")\n        return "Reset";\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (element.tagName === "INPUT" && element.type === "image") {\n      options.visitedElements.add(element);\n      const alt = element.getAttribute("alt") || "";\n      if (alt.trim())\n        return alt;\n      const labels = element.labels || [];\n      if (labels.length) {\n        return [...labels].map((label) => getElementAccessibleNameInternal(label, {\n          ...options,\n          embeddedInLabel: "self",\n          embeddedInTextAlternativeElement: false,\n          embeddedInLabelledBy: "none",\n          embeddedInTargetElement: "none"\n        })).filter((accessibleName) => !!accessibleName).join(" ");\n      }\n      const title = element.getAttribute("title") || "";\n      if (title.trim())\n        return title;\n      return "Submit";\n    }\n    if (element.tagName === "TEXTAREA" || element.tagName === "SELECT" || element.tagName === "INPUT") {\n      options.visitedElements.add(element);\n      const labels = element.labels || [];\n      if (labels.length) {\n        return [...labels].map((label) => getElementAccessibleNameInternal(label, {\n          ...options,\n          embeddedInLabel: "self",\n          embeddedInTextAlternativeElement: false,\n          embeddedInLabelledBy: "none",\n          embeddedInTargetElement: "none"\n        })).filter((accessibleName) => !!accessibleName).join(" ");\n      }\n      const usePlaceholder = element.tagName === "INPUT" && ["text", "password", "search", "tel", "email", "url"].includes(element.type) || element.tagName === "TEXTAREA";\n      const placeholder = element.getAttribute("placeholder") || "";\n      const title = element.getAttribute("title") || "";\n      if (!usePlaceholder || title)\n        return title;\n      return placeholder;\n    }\n    if (element.tagName === "FIELDSET") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (child.tagName === "LEGEND") {\n          return getElementAccessibleNameInternal(child, {\n            ...childOptions,\n            embeddedInTextAlternativeElement: true\n          });\n        }\n      }\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (element.tagName === "FIGURE") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (child.tagName === "FIGCAPTION") {\n          return getElementAccessibleNameInternal(child, {\n            ...childOptions,\n            embeddedInTextAlternativeElement: true\n          });\n        }\n      }\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (element.tagName === "IMG") {\n      options.visitedElements.add(element);\n      const alt = element.getAttribute("alt") || "";\n      if (alt.trim())\n        return alt;\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (element.tagName === "TABLE") {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (child.tagName === "CAPTION") {\n          return getElementAccessibleNameInternal(child, {\n            ...childOptions,\n            embeddedInTextAlternativeElement: true\n          });\n        }\n      }\n      const summary = element.getAttribute("summary") || "";\n      if (summary)\n        return summary;\n    }\n    if (element.tagName === "AREA") {\n      options.visitedElements.add(element);\n      const alt = element.getAttribute("alt") || "";\n      if (alt.trim())\n        return alt;\n      const title = element.getAttribute("title") || "";\n      return title;\n    }\n    if (element.tagName === "SVG" && element.ownerSVGElement) {\n      options.visitedElements.add(element);\n      for (let child = element.firstElementChild; child; child = child.nextElementSibling) {\n        if (child.tagName === "TITLE" && element.ownerSVGElement) {\n          return getElementAccessibleNameInternal(child, {\n            ...childOptions,\n            embeddedInTextAlternativeElement: true\n          });\n        }\n      }\n    }\n  }\n  const allowsNameFromContent = ["button", "cell", "checkbox", "columnheader", "gridcell", "heading", "link", "menuitem", "menuitemcheckbox", "menuitemradio", "option", "radio", "row", "rowheader", "switch", "tab", "tooltip", "treeitem"].includes(role);\n  if (allowsNameFromContent || options.embeddedInLabelledBy !== "none" || options.embeddedInLabel !== "none" || options.embeddedInTextAlternativeElement || options.embeddedInTargetElement === "descendant") {\n    options.visitedElements.add(element);\n    const tokens = [];\n    const visit = (node) => {\n      var _a;\n      if (node.nodeType === 1) {\n        const display = ((_a = getComputedStyle(node)) == null ? void 0 : _a.getPropertyValue("display")) || "inline";\n        let token = getElementAccessibleNameInternal(node, childOptions);\n        if (display !== "inline" || node.nodeName === "BR")\n          token = " " + token + " ";\n        tokens.push(token);\n      } else if (node.nodeType === 3) {\n        tokens.push(node.textContent || "");\n      }\n    };\n    tokens.push(getPseudoContent(getComputedStyle(element, "::before")));\n    for (let child = element.firstChild; child; child = child.nextSibling)\n      visit(child);\n    if (element.shadowRoot) {\n      for (let child = element.shadowRoot.firstChild; child; child = child.nextSibling)\n        visit(child);\n    }\n    for (const owned of getIdRefs(element, element.getAttribute("aria-owns")))\n      visit(owned);\n    tokens.push(getPseudoContent(getComputedStyle(element, "::after")));\n    const accessibleName = tokens.join("");\n    if (accessibleName.trim())\n      return accessibleName;\n  }\n  if (!["presentation", "none"].includes(role) || element.tagName === "IFRAME") {\n    options.visitedElements.add(element);\n    const title = element.getAttribute("title") || "";\n    if (title.trim())\n      return title;\n  }\n  options.visitedElements.add(element);\n  return "";\n}\nvar kAriaSelectedRoles = ["gridcell", "option", "row", "tab", "rowheader", "columnheader", "treeitem"];\nfunction getAriaSelected(element) {\n  if (element.tagName === "OPTION")\n    return element.selected;\n  if (kAriaSelectedRoles.includes(getAriaRole(element) || ""))\n    return getAriaBoolean(element.getAttribute("aria-selected")) === true;\n  return false;\n}\nvar kAriaCheckedRoles = ["checkbox", "menuitemcheckbox", "option", "radio", "switch", "menuitemradio", "treeitem"];\nfunction getAriaChecked(element) {\n  if (element.tagName === "INPUT" && element.indeterminate)\n    return "mixed";\n  if (element.tagName === "INPUT" && ["checkbox", "radio"].includes(element.type))\n    return element.checked;\n  if (kAriaCheckedRoles.includes(getAriaRole(element) || "")) {\n    const checked = element.getAttribute("aria-checked");\n    if (checked === "true")\n      return true;\n    if (checked === "mixed")\n      return "mixed";\n  }\n  return false;\n}\nvar kAriaPressedRoles = ["button"];\nfunction getAriaPressed(element) {\n  if (kAriaPressedRoles.includes(getAriaRole(element) || "")) {\n    const pressed = element.getAttribute("aria-pressed");\n    if (pressed === "true")\n      return true;\n    if (pressed === "mixed")\n      return "mixed";\n  }\n  return false;\n}\nvar kAriaExpandedRoles = ["application", "button", "checkbox", "combobox", "gridcell", "link", "listbox", "menuitem", "row", "rowheader", "tab", "treeitem", "columnheader", "menuitemcheckbox", "menuitemradio", "rowheader", "switch"];\nfunction getAriaExpanded(element) {\n  if (element.tagName === "DETAILS")\n    return element.open;\n  if (kAriaExpandedRoles.includes(getAriaRole(element) || ""))\n    return getAriaBoolean(element.getAttribute("aria-expanded")) === true;\n  return false;\n}\nvar kAriaLevelRoles = ["heading", "listitem", "row", "treeitem"];\nfunction getAriaLevel(element) {\n  const native = { "H1": 1, "H2": 2, "H3": 3, "H4": 4, "H5": 5, "H6": 6 }[element.tagName];\n  if (native)\n    return native;\n  if (kAriaLevelRoles.includes(getAriaRole(element) || "")) {\n    const attr = element.getAttribute("aria-level");\n    const value = attr === null ? Number.NaN : Number(attr);\n    if (Number.isInteger(value) && value >= 1)\n      return value;\n  }\n  return 0;\n}\nvar kAriaDisabledRoles = ["application", "button", "composite", "gridcell", "group", "input", "link", "menuitem", "scrollbar", "separator", "tab", "checkbox", "columnheader", "combobox", "grid", "listbox", "menu", "menubar", "menuitemcheckbox", "menuitemradio", "option", "radio", "radiogroup", "row", "rowheader", "searchbox", "select", "slider", "spinbutton", "switch", "tablist", "textbox", "toolbar", "tree", "treegrid", "treeitem"];\nfunction getAriaDisabled(element) {\n  const isNativeFormControl = ["BUTTON", "INPUT", "SELECT", "TEXTAREA", "OPTION", "OPTGROUP"].includes(element.tagName);\n  if (isNativeFormControl && (element.hasAttribute("disabled") || belongsToDisabledFieldSet(element)))\n    return true;\n  return hasExplicitAriaDisabled(element);\n}\nfunction belongsToDisabledFieldSet(element) {\n  if (!element)\n    return false;\n  if (element.tagName === "FIELDSET" && element.hasAttribute("disabled"))\n    return true;\n  return belongsToDisabledFieldSet(element.parentElement);\n}\nfunction hasExplicitAriaDisabled(element) {\n  if (!element)\n    return false;\n  if (kAriaDisabledRoles.includes(getAriaRole(element) || "")) {\n    const attribute = (element.getAttribute("aria-disabled") || "").toLowerCase();\n    if (attribute === "true")\n      return true;\n    if (attribute === "false")\n      return false;\n  }\n  return hasExplicitAriaDisabled(parentElementOrShadowHost(element));\n}\n\n// packages/playwright-core/src/server/injected/roleSelectorEngine.ts\nvar kSupportedAttributes = ["selected", "checked", "pressed", "expanded", "level", "disabled", "name", "include-hidden"];\nkSupportedAttributes.sort();\nfunction validateSupportedRole(attr, roles, role) {\n  if (!roles.includes(role))\n    throw new Error(`"${attr}" attribute is only supported for roles: ${roles.slice().sort().map((role2) => `"${role2}"`).join(", ")}`);\n}\nfunction validateSupportedValues(attr, values) {\n  if (attr.op !== "<truthy>" && !values.includes(attr.value))\n    throw new Error(`"${attr.name}" must be one of ${values.map((v) => JSON.stringify(v)).join(", ")}`);\n}\nfunction validateSupportedOp(attr, ops) {\n  if (!ops.includes(attr.op))\n    throw new Error(`"${attr.name}" does not support "${attr.op}" matcher`);\n}\nfunction validateAttributes(attrs, role) {\n  for (const attr of attrs) {\n    switch (attr.name) {\n      case "checked": {\n        validateSupportedRole(attr.name, kAriaCheckedRoles, role);\n        validateSupportedValues(attr, [true, false, "mixed"]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        if (attr.op === "<truthy>") {\n          attr.op = "=";\n          attr.value = true;\n        }\n        break;\n      }\n      case "pressed": {\n        validateSupportedRole(attr.name, kAriaPressedRoles, role);\n        validateSupportedValues(attr, [true, false, "mixed"]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        if (attr.op === "<truthy>") {\n          attr.op = "=";\n          attr.value = true;\n        }\n        break;\n      }\n      case "selected": {\n        validateSupportedRole(attr.name, kAriaSelectedRoles, role);\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        break;\n      }\n      case "expanded": {\n        validateSupportedRole(attr.name, kAriaExpandedRoles, role);\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        break;\n      }\n      case "level": {\n        validateSupportedRole(attr.name, kAriaLevelRoles, role);\n        if (typeof attr.value === "string")\n          attr.value = +attr.value;\n        if (attr.op !== "=" || typeof attr.value !== "number" || Number.isNaN(attr.value))\n          throw new Error(`"level" attribute must be compared to a number`);\n        break;\n      }\n      case "disabled": {\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        break;\n      }\n      case "name": {\n        if (attr.op === "<truthy>")\n          throw new Error(`"name" attribute must have a value`);\n        if (typeof attr.value !== "string" && !(attr.value instanceof RegExp))\n          throw new Error(`"name" attribute must be a string or a regular expression`);\n        break;\n      }\n      case "include-hidden": {\n        validateSupportedValues(attr, [true, false]);\n        validateSupportedOp(attr, ["<truthy>", "="]);\n        break;\n      }\n      default: {\n        throw new Error(`Unknown attribute "${attr.name}", must be one of ${kSupportedAttributes.map((a) => `"${a}"`).join(", ")}.`);\n      }\n    }\n  }\n}\nvar RoleEngine = {\n  queryAll(scope, selector) {\n    const parsed = parseComponentSelector(selector, true);\n    const role = parsed.name.toLowerCase();\n    if (!role)\n      throw new Error(`Role must not be empty`);\n    validateAttributes(parsed.attributes, role);\n    const hiddenCache = /* @__PURE__ */ new Map();\n    const result = [];\n    const match = (element) => {\n      if (getAriaRole(element) !== role)\n        return;\n      let includeHidden = false;\n      let nameAttr;\n      for (const attr of parsed.attributes) {\n        if (attr.name === "include-hidden") {\n          includeHidden = attr.op === "<truthy>" || !!attr.value;\n          continue;\n        }\n        if (attr.name === "name") {\n          nameAttr = attr;\n          continue;\n        }\n        let actual;\n        switch (attr.name) {\n          case "selected":\n            actual = getAriaSelected(element);\n            break;\n          case "checked":\n            actual = getAriaChecked(element);\n            break;\n          case "pressed":\n            actual = getAriaPressed(element);\n            break;\n          case "expanded":\n            actual = getAriaExpanded(element);\n            break;\n          case "level":\n            actual = getAriaLevel(element);\n            break;\n          case "disabled":\n            actual = getAriaDisabled(element);\n            break;\n        }\n        if (!matchesAttribute(actual, attr))\n          return;\n      }\n      if (!includeHidden) {\n        const isHidden = isElementHiddenForAria(element, hiddenCache);\n        if (isHidden)\n          return;\n      }\n      if (nameAttr !== void 0) {\n        const accessibleName = getElementAccessibleName(element, includeHidden, hiddenCache);\n        if (!matchesAttribute(accessibleName, nameAttr))\n          return;\n      }\n      result.push(element);\n    };\n    const query = (root) => {\n      const shadows = [];\n      if (root.shadowRoot)\n        shadows.push(root.shadowRoot);\n      for (const element of root.querySelectorAll("*")) {\n        match(element);\n        if (element.shadowRoot)\n          shadows.push(element.shadowRoot);\n      }\n      shadows.forEach(query);\n    };\n    query(scope);\n    return result;\n  }\n};\n\n// packages/playwright-core/src/server/injected/selectorGenerator.ts\nvar cacheAllowText = /* @__PURE__ */ new Map();\nvar cacheDisallowText = /* @__PURE__ */ new Map();\nvar kNthScore = 1e3;\nfunction generateSelector(injectedScript, targetElement, strict) {\n  injectedScript._evaluator.begin();\n  try {\n    targetElement = targetElement.closest("button,select,input,[role=button],[role=checkbox],[role=radio]") || targetElement;\n    const targetTokens = generateSelectorFor(injectedScript, targetElement, strict);\n    const bestTokens = targetTokens || cssFallback(injectedScript, targetElement, strict);\n    const selector = joinTokens(bestTokens);\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n      selector,\n      elements: injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument)\n    };\n  } finally {\n    cacheAllowText.clear();\n    cacheDisallowText.clear();\n    injectedScript._evaluator.end();\n  }\n}\nfunction filterRegexTokens(textCandidates) {\n  return textCandidates.filter((c) => c[0].selector[0] !== "/");\n}\nfunction generateSelectorFor(injectedScript, targetElement, strict) {\n  if (targetElement.ownerDocument.documentElement === targetElement)\n    return [{ engine: "css", selector: "html", score: 1 }];\n  const calculate = (element, allowText) => {\n    const allowNthMatch = element === targetElement;\n    let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement).map((token) => [token]) : [];\n    if (element !== targetElement) {\n      textCandidates = filterRegexTokens(textCandidates);\n    }\n    const noTextCandidates = buildCandidates(injectedScript, element).map((token) => [token]);\n    let result = chooseFirstSelector(injectedScript, targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch, strict);\n    textCandidates = filterRegexTokens(textCandidates);\n    const checkWithText = (textCandidatesToUse) => {\n      const allowParentText = allowText && !textCandidatesToUse.length;\n      const candidates = [...textCandidatesToUse, ...noTextCandidates].filter((c) => {\n        if (!result)\n          return true;\n        return combineScores(c) < combineScores(result);\n      });\n      let bestPossibleInParent = candidates[0];\n      if (!bestPossibleInParent)\n        return;\n      for (let parent = parentElementOrShadowHost2(element); parent; parent = parentElementOrShadowHost2(parent)) {\n        const parentTokens = calculateCached(parent, allowParentText);\n        if (!parentTokens)\n          continue;\n        if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))\n          continue;\n        bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch, strict);\n        if (!bestPossibleInParent)\n          return;\n        const combined = [...parentTokens, ...bestPossibleInParent];\n        if (!result || combineScores(combined) < combineScores(result))\n          result = combined;\n      }\n    };\n    checkWithText(textCandidates);\n    if (element === targetElement && textCandidates.length)\n      checkWithText([]);\n    return result;\n  };\n  const calculateCached = (element, allowText) => {\n    const cache = allowText ? cacheAllowText : cacheDisallowText;\n    let value = cache.get(element);\n    if (value === void 0) {\n      value = calculate(element, allowText);\n      cache.set(element, value);\n    }\n    return value;\n  };\n  return calculateCached(targetElement, true);\n}\nfunction buildCandidates(injectedScript, element) {\n  const candidates = [];\n  for (const attribute of ["data-testid", "data-test-id", "data-test"]) {\n    if (element.getAttribute(attribute))\n      candidates.push({ engine: "css", selector: `[${attribute}=${quoteAttributeValue(element.getAttribute(attribute))}]`, score: 1 });\n  }\n  if (element.nodeName === "INPUT") {\n    const input = element;\n    if (input.placeholder)\n      candidates.push({ engine: "css", selector: `[placeholder=${quoteAttributeValue(input.placeholder)}]`, score: 10 });\n  }\n  if (element.getAttribute("aria-label"))\n    candidates.push({ engine: "css", selector: `[aria-label=${quoteAttributeValue(element.getAttribute("aria-label"))}]`, score: 10 });\n  if (element.getAttribute("alt") && ["APPLET", "AREA", "IMG", "INPUT"].includes(element.nodeName))\n    candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[alt=${quoteAttributeValue(element.getAttribute("alt"))}]`, score: 10 });\n  if (element.getAttribute("role"))\n    candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[role=${quoteAttributeValue(element.getAttribute("role"))}]`, score: 50 });\n  if (element.getAttribute("name") && ["BUTTON", "FORM", "FIELDSET", "IFRAME", "INPUT", "KEYGEN", "OBJECT", "OUTPUT", "SELECT", "TEXTAREA", "MAP", "META", "PARAM"].includes(element.nodeName))\n    candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[name=${quoteAttributeValue(element.getAttribute("name"))}]`, score: 50 });\n  if (["INPUT", "TEXTAREA"].includes(element.nodeName) && element.getAttribute("type") !== "hidden") {\n    if (element.getAttribute("type"))\n      candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[type=${quoteAttributeValue(element.getAttribute("type"))}]`, score: 50 });\n  }\n  if (["INPUT", "TEXTAREA", "SELECT"].includes(element.nodeName))\n    candidates.push({ engine: "css", selector: cssEscape(element.nodeName.toLowerCase()), score: 50 });\n  const idAttr = element.getAttribute("id");\n  if (idAttr && !isGuidLike(idAttr))\n    candidates.push({ engine: "css", selector: makeSelectorForId(idAttr), score: 100 });\n  candidates.push({ engine: "css", selector: cssEscape(element.nodeName.toLowerCase()), score: 200 });\n  return candidates;\n}\nfunction buildTextCandidates(injectedScript, element, allowHasText) {\n  if (element.nodeName === "SELECT")\n    return [];\n  const text = elementText(injectedScript._evaluator, element).full.trim().replace(/\\s+/g, " ").substring(0, 80);\n  if (!text)\n    return [];\n  const candidates = [];\n  let escaped = text;\n  if (text.includes(\'"\') || text.includes(">>") || text[0] === "/")\n    escaped = `/.*${escapeForRegex(text)}.*/`;\n  candidates.push({ engine: "text", selector: escaped, score: 10 });\n  if (allowHasText && escaped === text) {\n    let prefix = element.nodeName.toLowerCase();\n    if (element.hasAttribute("role"))\n      prefix += `[role=${quoteAttributeValue(element.getAttribute("role"))}]`;\n    candidates.push({ engine: "css", selector: `${prefix}:has-text("${text}")`, score: 30 });\n  }\n  return candidates;\n}\nfunction parentElementOrShadowHost2(element) {\n  if (element.parentElement)\n    return element.parentElement;\n  if (!element.parentNode)\n    return null;\n  if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\n    return element.parentNode.host;\n  return null;\n}\nfunction makeSelectorForId(id) {\n  return /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(id) ? "#" + id : `[id="${cssEscape(id)}"]`;\n}\nfunction cssFallback(injectedScript, targetElement, strict) {\n  const kFallbackScore = 1e7;\n  const root = targetElement.ownerDocument;\n  const tokens = [];\n  function uniqueCSSSelector(prefix) {\n    const path = tokens.slice();\n    if (prefix)\n      path.unshift(prefix);\n    const selector = path.join(" ");\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const node = injectedScript.querySelector(parsedSelector, targetElement.ownerDocument, false);\n    return node === targetElement ? selector : void 0;\n  }\n  function makeStrict(selector) {\n    const token = { engine: "css", selector, score: kFallbackScore };\n    if (!strict)\n      return [token];\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const elements = injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument);\n    if (elements.length === 1)\n      return [token];\n    const nth = { engine: "nth", selector: String(elements.indexOf(targetElement)), score: kNthScore };\n    return [token, nth];\n  }\n  for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost2(element)) {\n    const nodeName = element.nodeName.toLowerCase();\n    let bestTokenForLevel = "";\n    if (element.id) {\n      const token = makeSelectorForId(element.id);\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      bestTokenForLevel = token;\n    }\n    const parent = element.parentNode;\n    const classes = [...element.classList];\n    for (let i = 0; i < classes.length; ++i) {\n      const token = "." + classes.slice(0, i + 1).join(".");\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel && parent) {\n        const sameClassSiblings = parent.querySelectorAll(token);\n        if (sameClassSiblings.length === 1)\n          bestTokenForLevel = token;\n      }\n    }\n    if (parent) {\n      const siblings = [...parent.children];\n      const sameTagSiblings = siblings.filter((sibling) => sibling.nodeName.toLowerCase() === nodeName);\n      const token = sameTagSiblings.indexOf(element) === 0 ? cssEscape(nodeName) : `${cssEscape(nodeName)}:nth-child(${1 + siblings.indexOf(element)})`;\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel)\n        bestTokenForLevel = token;\n    } else if (!bestTokenForLevel) {\n      bestTokenForLevel = nodeName;\n    }\n    tokens.unshift(bestTokenForLevel);\n  }\n  return makeStrict(uniqueCSSSelector());\n}\nfunction escapeForRegex(text) {\n  return text.replace(/[.*+?^>${}()|[\\]\\\\]/g, "\\\\$&");\n}\nfunction quoteAttributeValue(text) {\n  return `"${cssEscape(text).replace(/\\\\ /g, " ")}"`;\n}\nfunction joinTokens(tokens) {\n  const parts = [];\n  let lastEngine = "";\n  for (const { engine, selector } of tokens) {\n    if (parts.length && (lastEngine !== "css" || engine !== "css" || selector.startsWith(":nth-match(")))\n      parts.push(">>");\n    lastEngine = engine;\n    if (engine === "css")\n      parts.push(selector);\n    else\n      parts.push(`${engine}=${selector}`);\n  }\n  return parts.join(" ");\n}\nfunction combineScores(tokens) {\n  let score = 0;\n  for (let i = 0; i < tokens.length; i++)\n    score += tokens[i].score * (tokens.length - i);\n  return score;\n}\nfunction chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch, strict) {\n  const joined = selectors.map((tokens) => ({ tokens, score: combineScores(tokens) }));\n  joined.sort((a, b) => a.score - b.score);\n  let bestWithIndex = null;\n  for (const { tokens } of joined) {\n    const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));\n    const result = injectedScript.querySelectorAll(parsedSelector, scope);\n    const isStrictEnough = !strict || result.length === 1;\n    const index = result.indexOf(targetElement);\n    if (index === 0 && isStrictEnough) {\n      return tokens;\n    }\n    if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)\n      continue;\n    const nth = { engine: "nth", selector: String(index), score: kNthScore };\n    bestWithIndex = [...tokens, nth];\n  }\n  return bestWithIndex;\n}\nfunction isGuidLike(id) {\n  let lastCharacterType;\n  let transitionCount = 0;\n  for (let i = 0; i < id.length; ++i) {\n    const c = id[i];\n    let characterType;\n    if (c === "-" || c === "_")\n      continue;\n    if (c >= "a" && c <= "z")\n      characterType = "lower";\n    else if (c >= "A" && c <= "Z")\n      characterType = "upper";\n    else if (c >= "0" && c <= "9")\n      characterType = "digit";\n    else\n      characterType = "other";\n    if (characterType === "lower" && lastCharacterType === "upper") {\n      lastCharacterType = characterType;\n      continue;\n    }\n    if (lastCharacterType && lastCharacterType !== characterType)\n      ++transitionCount;\n    lastCharacterType = characterType;\n  }\n  return transitionCount >= id.length / 4;\n}\nfunction cssEscape(s) {\n  let result = "";\n  for (let i = 0; i < s.length; i++)\n    result += cssEscapeOne(s, i);\n  return result;\n}\nfunction cssEscapeOne(s, i) {\n  const c = s.charCodeAt(i);\n  if (c === 0)\n    return "\\uFFFD";\n  if (c >= 1 && c <= 31 || c >= 48 && c <= 57 && (i === 0 || i === 1 && s.charCodeAt(0) === 45))\n    return "\\\\" + c.toString(16) + " ";\n  if (i === 0 && c === 45 && s.length === 1)\n    return "\\\\" + s.charAt(i);\n  if (c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122)\n    return s.charAt(i);\n  return "\\\\" + s.charAt(i);\n}\n\n// packages/playwright-core/src/server/injected/highlight.ts\nvar Highlight = class {\n  constructor(isUnderTest) {\n    this._highlightElements = [];\n    this._isUnderTest = isUnderTest;\n    this._outerGlassPaneElement = document.createElement("x-pw-glass");\n    this._outerGlassPaneElement.style.position = "fixed";\n    this._outerGlassPaneElement.style.top = "0";\n    this._outerGlassPaneElement.style.right = "0";\n    this._outerGlassPaneElement.style.bottom = "0";\n    this._outerGlassPaneElement.style.left = "0";\n    this._outerGlassPaneElement.style.zIndex = "2147483647";\n    this._outerGlassPaneElement.style.pointerEvents = "none";\n    this._outerGlassPaneElement.style.display = "flex";\n    this._tooltipElement = document.createElement("x-pw-tooltip");\n    this._actionPointElement = document.createElement("x-pw-action-point");\n    this._actionPointElement.setAttribute("hidden", "true");\n    this._innerGlassPaneElement = document.createElement("x-pw-glass-inner");\n    this._innerGlassPaneElement.style.flex = "auto";\n    this._innerGlassPaneElement.appendChild(this._tooltipElement);\n    this._glassPaneShadow = this._outerGlassPaneElement.attachShadow({ mode: isUnderTest ? "open" : "closed" });\n    this._glassPaneShadow.appendChild(this._innerGlassPaneElement);\n    this._glassPaneShadow.appendChild(this._actionPointElement);\n    const styleElement = document.createElement("style");\n    styleElement.textContent = `\n        x-pw-tooltip {\n          align-items: center;\n          backdrop-filter: blur(5px);\n          background-color: rgba(0, 0, 0, 0.7);\n          border-radius: 2px;\n          box-shadow: rgba(0, 0, 0, 0.1) 0px 3.6px 3.7px,\n                      rgba(0, 0, 0, 0.15) 0px 12.1px 12.3px,\n                      rgba(0, 0, 0, 0.1) 0px -2px 4px,\n                      rgba(0, 0, 0, 0.15) 0px -12.1px 24px,\n                      rgba(0, 0, 0, 0.25) 0px 54px 55px;\n          color: rgb(204, 204, 204);\n          display: none;\n          font-family: \'Dank Mono\', \'Operator Mono\', Inconsolata, \'Fira Mono\',\n                      \'SF Mono\', Monaco, \'Droid Sans Mono\', \'Source Code Pro\', monospace;\n          font-size: 12.8px;\n          font-weight: normal;\n          left: 0;\n          line-height: 1.5;\n          max-width: 600px;\n          padding: 3.2px 5.12px 3.2px;\n          position: absolute;\n          top: 0;\n        }\n        x-pw-action-point {\n          position: absolute;\n          width: 20px;\n          height: 20px;\n          background: red;\n          border-radius: 10px;\n          pointer-events: none;\n          margin: -10px 0 0 -10px;\n          z-index: 2;\n        }\n        *[hidden] {\n          display: none !important;\n        }\n    `;\n    this._glassPaneShadow.appendChild(styleElement);\n  }\n  install() {\n    document.documentElement.appendChild(this._outerGlassPaneElement);\n  }\n  uninstall() {\n    this._outerGlassPaneElement.remove();\n  }\n  isInstalled() {\n    return this._outerGlassPaneElement.parentElement === document.documentElement && !this._outerGlassPaneElement.nextElementSibling;\n  }\n  showActionPoint(x, y) {\n    this._actionPointElement.style.top = y + "px";\n    this._actionPointElement.style.left = x + "px";\n    this._actionPointElement.hidden = false;\n    if (this._isUnderTest)\n      console.error("Action point for test: " + JSON.stringify({ x, y }));\n  }\n  hideActionPoint() {\n    this._actionPointElement.hidden = true;\n  }\n  updateHighlight(elements, selector, isRecording) {\n    this._tooltipElement.textContent = selector;\n    this._tooltipElement.style.top = "0";\n    this._tooltipElement.style.left = "0";\n    this._tooltipElement.style.display = "flex";\n    const boxes = elements.map((e) => e.getBoundingClientRect());\n    const tooltipWidth = this._tooltipElement.offsetWidth;\n    const tooltipHeight = this._tooltipElement.offsetHeight;\n    const totalWidth = this._innerGlassPaneElement.offsetWidth;\n    const totalHeight = this._innerGlassPaneElement.offsetHeight;\n    if (boxes.length) {\n      const primaryBox = boxes[0];\n      let anchorLeft = primaryBox.left;\n      if (anchorLeft + tooltipWidth > totalWidth - 5)\n        anchorLeft = totalWidth - tooltipWidth - 5;\n      let anchorTop = primaryBox.bottom + 5;\n      if (anchorTop + tooltipHeight > totalHeight - 5) {\n        if (primaryBox.top > tooltipHeight + 5) {\n          anchorTop = primaryBox.top - tooltipHeight - 5;\n        } else {\n          anchorTop = totalHeight - 5 - tooltipHeight;\n        }\n      }\n      this._tooltipElement.style.top = anchorTop + "px";\n      this._tooltipElement.style.left = anchorLeft + "px";\n    } else {\n      this._tooltipElement.style.display = "none";\n    }\n    const pool = this._highlightElements;\n    this._highlightElements = [];\n    for (const box of boxes) {\n      const highlightElement = pool.length ? pool.shift() : this._createHighlightElement();\n      const color = isRecording ? "#dc6f6f7f" : "#6fa8dc7f";\n      highlightElement.style.backgroundColor = this._highlightElements.length ? "#f6b26b7f" : color;\n      highlightElement.style.left = box.x + "px";\n      highlightElement.style.top = box.y + "px";\n      highlightElement.style.width = box.width + "px";\n      highlightElement.style.height = box.height + "px";\n      highlightElement.style.display = "block";\n      this._highlightElements.push(highlightElement);\n      if (this._isUnderTest)\n        console.error("Highlight box for test: " + JSON.stringify({ x: box.x, y: box.y, width: box.width, height: box.height }));\n    }\n    for (const highlightElement of pool) {\n      highlightElement.style.display = "none";\n      this._highlightElements.push(highlightElement);\n    }\n  }\n  maskElements(elements) {\n    const boxes = elements.map((e) => e.getBoundingClientRect());\n    const pool = this._highlightElements;\n    this._highlightElements = [];\n    for (const box of boxes) {\n      const highlightElement = pool.length ? pool.shift() : this._createHighlightElement();\n      highlightElement.style.backgroundColor = "#F0F";\n      highlightElement.style.left = box.x + "px";\n      highlightElement.style.top = box.y + "px";\n      highlightElement.style.width = box.width + "px";\n      highlightElement.style.height = box.height + "px";\n      highlightElement.style.display = "block";\n      this._highlightElements.push(highlightElement);\n    }\n    for (const highlightElement of pool) {\n      highlightElement.style.display = "none";\n      this._highlightElements.push(highlightElement);\n    }\n  }\n  _createHighlightElement() {\n    const highlightElement = document.createElement("x-pw-highlight");\n    highlightElement.style.position = "absolute";\n    highlightElement.style.top = "0";\n    highlightElement.style.left = "0";\n    highlightElement.style.width = "0";\n    highlightElement.style.height = "0";\n    highlightElement.style.boxSizing = "border-box";\n    this._glassPaneShadow.appendChild(highlightElement);\n    return highlightElement;\n  }\n};\n\n// packages/playwright-core/src/server/injected/injectedScript.ts\nvar InjectedScript = class {\n  constructor(isUnderTest, stableRafCount, browserName, experimentalFeaturesEnabled, customEngines) {\n    this.onGlobalListenersRemoved = /* @__PURE__ */ new Set();\n    this.isUnderTest = isUnderTest;\n    this._evaluator = new SelectorEvaluatorImpl(/* @__PURE__ */ new Map());\n    this._engines = /* @__PURE__ */ new Map();\n    this._engines.set("xpath", XPathEngine);\n    this._engines.set("xpath:light", XPathEngine);\n    this._engines.set("_react", ReactEngine);\n    this._engines.set("_vue", VueEngine);\n    if (experimentalFeaturesEnabled)\n      this._engines.set("role", RoleEngine);\n    this._engines.set("text", this._createTextEngine(true));\n    this._engines.set("text:light", this._createTextEngine(false));\n    this._engines.set("id", this._createAttributeEngine("id", true));\n    this._engines.set("id:light", this._createAttributeEngine("id", false));\n    this._engines.set("data-testid", this._createAttributeEngine("data-testid", true));\n    this._engines.set("data-testid:light", this._createAttributeEngine("data-testid", false));\n    this._engines.set("data-test-id", this._createAttributeEngine("data-test-id", true));\n    this._engines.set("data-test-id:light", this._createAttributeEngine("data-test-id", false));\n    this._engines.set("data-test", this._createAttributeEngine("data-test", true));\n    this._engines.set("data-test:light", this._createAttributeEngine("data-test", false));\n    this._engines.set("css", this._createCSSEngine());\n    this._engines.set("nth", { queryAll: () => [] });\n    this._engines.set("visible", { queryAll: () => [] });\n    this._engines.set("control", this._createControlEngine());\n    this._engines.set("has", this._createHasEngine());\n    for (const { name, engine } of customEngines)\n      this._engines.set(name, engine);\n    this._stableRafCount = stableRafCount;\n    this._browserName = browserName;\n    this._setupGlobalListenersRemovalDetection();\n    this._setupHitTargetInterceptors();\n    if (isUnderTest)\n      window.__injectedScript = this;\n  }\n  eval(expression) {\n    return globalThis.eval(expression);\n  }\n  parseSelector(selector) {\n    const result = parseSelector(selector);\n    for (const name of allEngineNames(result)) {\n      if (!this._engines.has(name))\n        throw this.createStacklessError(`Unknown engine "${name}" while parsing selector ${selector}`);\n    }\n    return result;\n  }\n  generateSelector(targetElement) {\n    return generateSelector(this, targetElement, true).selector;\n  }\n  querySelector(selector, root, strict) {\n    var _a, _b;\n    if (!root["querySelector"])\n      throw this.createStacklessError("Node is not queryable.");\n    this._evaluator.begin();\n    try {\n      const result = this._querySelectorRecursively([{ element: root, capture: void 0 }], selector, 0, /* @__PURE__ */ new Map());\n      if (strict && result.length > 1)\n        throw this.strictModeViolationError(selector, result.map((r) => r.element));\n      return ((_a = result[0]) == null ? void 0 : _a.capture) || ((_b = result[0]) == null ? void 0 : _b.element);\n    } finally {\n      this._evaluator.end();\n    }\n  }\n  _querySelectorRecursively(roots, selector, index, queryCache) {\n    if (index === selector.parts.length)\n      return roots;\n    const part = selector.parts[index];\n    if (part.name === "nth") {\n      let filtered = [];\n      if (part.body === "0") {\n        filtered = roots.slice(0, 1);\n      } else if (part.body === "-1") {\n        if (roots.length)\n          filtered = roots.slice(roots.length - 1);\n      } else {\n        if (typeof selector.capture === "number")\n          throw this.createStacklessError(`Can\'t query n-th element in a request with the capture.`);\n        const nth = +part.body;\n        const set = /* @__PURE__ */ new Set();\n        for (const root of roots) {\n          set.add(root.element);\n          if (nth + 1 === set.size)\n            filtered = [root];\n        }\n      }\n      return this._querySelectorRecursively(filtered, selector, index + 1, queryCache);\n    }\n    if (part.name === "visible") {\n      const visible = Boolean(part.body);\n      const filtered = roots.filter((match) => visible === isVisible(match.element));\n      return this._querySelectorRecursively(filtered, selector, index + 1, queryCache);\n    }\n    const result = [];\n    for (const root of roots) {\n      const capture = index - 1 === selector.capture ? root.element : root.capture;\n      let queryResults = queryCache.get(root.element);\n      if (!queryResults) {\n        queryResults = [];\n        queryCache.set(root.element, queryResults);\n      }\n      let all = queryResults[index];\n      if (!all) {\n        all = this._queryEngineAll(part, root.element);\n        queryResults[index] = all;\n      }\n      for (const element of all) {\n        if (!("nodeName" in element))\n          throw this.createStacklessError(`Expected a Node but got ${Object.prototype.toString.call(element)}`);\n        result.push({ element, capture });\n      }\n    }\n    return this._querySelectorRecursively(result, selector, index + 1, queryCache);\n  }\n  querySelectorAll(selector, root) {\n    if (!root["querySelectorAll"])\n      throw this.createStacklessError("Node is not queryable.");\n    this._evaluator.begin();\n    try {\n      const result = this._querySelectorRecursively([{ element: root, capture: void 0 }], selector, 0, /* @__PURE__ */ new Map());\n      const set = /* @__PURE__ */ new Set();\n      for (const r of result)\n        set.add(r.capture || r.element);\n      return [...set];\n    } finally {\n      this._evaluator.end();\n    }\n  }\n  _queryEngineAll(part, root) {\n    return this._engines.get(part.name).queryAll(root, part.body);\n  }\n  _createAttributeEngine(attribute, shadow) {\n    const toCSS = (selector) => {\n      const css2 = `[${attribute}=${JSON.stringify(selector)}]`;\n      return [{ simples: [{ selector: { css: css2, functions: [] }, combinator: "" }] }];\n    };\n    return {\n      queryAll: (root, selector) => {\n        return this._evaluator.query({ scope: root, pierceShadow: shadow }, toCSS(selector));\n      }\n    };\n  }\n  _createCSSEngine() {\n    const evaluator = this._evaluator;\n    return {\n      queryAll(root, body) {\n        return evaluator.query({ scope: root, pierceShadow: true }, body);\n      }\n    };\n  }\n  _createTextEngine(shadow) {\n    const queryList = (root, selector) => {\n      const { matcher, kind } = createTextMatcher(selector);\n      const result = [];\n      let lastDidNotMatchSelf = null;\n      const appendElement = (element) => {\n        if (kind === "lax" && lastDidNotMatchSelf && lastDidNotMatchSelf.contains(element))\n          return false;\n        const matches = elementMatchesText(this._evaluator, element, matcher);\n        if (matches === "none")\n          lastDidNotMatchSelf = element;\n        if (matches === "self" || matches === "selfAndChildren" && kind === "strict")\n          result.push(element);\n      };\n      if (root.nodeType === Node.ELEMENT_NODE)\n        appendElement(root);\n      const elements = this._evaluator._queryCSS({ scope: root, pierceShadow: shadow }, "*");\n      for (const element of elements)\n        appendElement(element);\n      return result;\n    };\n    return {\n      queryAll: (root, selector) => {\n        return queryList(root, selector);\n      }\n    };\n  }\n  _createControlEngine() {\n    return {\n      queryAll(root, body) {\n        if (body === "enter-frame")\n          return [];\n        if (body === "return-empty")\n          return [];\n        throw new Error(`Internal error, unknown control selector ${body}`);\n      }\n    };\n  }\n  _createHasEngine() {\n    const queryAll = (root, body) => {\n      if (root.nodeType !== 1)\n        return [];\n      const has = !!this.querySelector(body, root, false);\n      return has ? [root] : [];\n    };\n    return { queryAll };\n  }\n  extend(source, params) {\n    const constrFunction = globalThis.eval(`\n    (() => {\n      const module = {};\n      ${source}\n      return module.exports;\n    })()`);\n    return new constrFunction(this, params);\n  }\n  isVisible(element) {\n    return isVisible(element);\n  }\n  pollRaf(predicate) {\n    return this.poll(predicate, (next) => requestAnimationFrame(next));\n  }\n  pollInterval(pollInterval, predicate) {\n    return this.poll(predicate, (next) => setTimeout(next, pollInterval));\n  }\n  pollLogScale(predicate) {\n    const pollIntervals = [100, 250, 500];\n    let attempts = 0;\n    return this.poll(predicate, (next) => setTimeout(next, pollIntervals[attempts++] || 1e3));\n  }\n  poll(predicate, scheduleNext) {\n    return this._runAbortableTask((progress) => {\n      let fulfill;\n      let reject;\n      const result = new Promise((f, r) => {\n        fulfill = f;\n        reject = r;\n      });\n      const next = () => {\n        if (progress.aborted)\n          return;\n        try {\n          const success = predicate(progress);\n          if (success !== progress.continuePolling)\n            fulfill(success);\n          else\n            scheduleNext(next);\n        } catch (e) {\n          progress.log("  " + e.message);\n          reject(e);\n        }\n      };\n      next();\n      return result;\n    });\n  }\n  _runAbortableTask(task) {\n    let unsentLog = [];\n    let takeNextLogsCallback;\n    let taskFinished = false;\n    const logReady = () => {\n      if (!takeNextLogsCallback)\n        return;\n      takeNextLogsCallback(unsentLog);\n      unsentLog = [];\n      takeNextLogsCallback = void 0;\n    };\n    const takeNextLogs = () => new Promise((fulfill) => {\n      takeNextLogsCallback = fulfill;\n      if (unsentLog.length || taskFinished)\n        logReady();\n    });\n    let lastMessage = "";\n    let lastIntermediateResult = void 0;\n    const progress = {\n      injectedScript: this,\n      aborted: false,\n      continuePolling: Symbol("continuePolling"),\n      log: (message) => {\n        lastMessage = message;\n        unsentLog.push({ message });\n        logReady();\n      },\n      logRepeating: (message) => {\n        if (message !== lastMessage)\n          progress.log(message);\n      },\n      setIntermediateResult: (intermediateResult) => {\n        if (lastIntermediateResult === intermediateResult)\n          return;\n        lastIntermediateResult = intermediateResult;\n        unsentLog.push({ intermediateResult });\n        logReady();\n      }\n    };\n    const run = () => {\n      const result = task(progress);\n      result.finally(() => {\n        taskFinished = true;\n        logReady();\n      });\n      return result;\n    };\n    return {\n      takeNextLogs,\n      run,\n      cancel: () => {\n        progress.aborted = true;\n      },\n      takeLastLogs: () => unsentLog\n    };\n  }\n  getElementBorderWidth(node) {\n    if (node.nodeType !== Node.ELEMENT_NODE || !node.ownerDocument || !node.ownerDocument.defaultView)\n      return { left: 0, top: 0 };\n    const style = node.ownerDocument.defaultView.getComputedStyle(node);\n    return { left: parseInt(style.borderLeftWidth || "", 10), top: parseInt(style.borderTopWidth || "", 10) };\n  }\n  retarget(node, behavior) {\n    let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\n    if (!element)\n      return null;\n    if (!element.matches("input, textarea, select"))\n      element = element.closest("button, [role=button], [role=checkbox], [role=radio]") || element;\n    if (behavior === "follow-label") {\n      if (!element.matches("input, textarea, button, select, [role=button], [role=checkbox], [role=radio]") && !element.isContentEditable) {\n        element = element.closest("label") || element;\n      }\n      if (element.nodeName === "LABEL")\n        element = element.control || element;\n    }\n    return element;\n  }\n  waitForElementStatesAndPerformAction(node, states, force, callback) {\n    let lastRect;\n    let counter = 0;\n    let samePositionCounter = 0;\n    let lastTime = 0;\n    return this.pollRaf((progress) => {\n      if (force) {\n        progress.log(`    forcing action`);\n        return callback(node, progress);\n      }\n      for (const state of states) {\n        if (state !== "stable") {\n          const result = this.elementState(node, state);\n          if (typeof result !== "boolean")\n            return result;\n          if (!result) {\n            progress.logRepeating(`    element is not ${state} - waiting...`);\n            return progress.continuePolling;\n          }\n          continue;\n        }\n        const element = this.retarget(node, "no-follow-label");\n        if (!element)\n          return "error:notconnected";\n        if (++counter === 1)\n          return progress.continuePolling;\n        const time = performance.now();\n        if (this._stableRafCount > 1 && time - lastTime < 15)\n          return progress.continuePolling;\n        lastTime = time;\n        const clientRect = element.getBoundingClientRect();\n        const rect = { x: clientRect.top, y: clientRect.left, width: clientRect.width, height: clientRect.height };\n        const samePosition = lastRect && rect.x === lastRect.x && rect.y === lastRect.y && rect.width === lastRect.width && rect.height === lastRect.height;\n        if (samePosition)\n          ++samePositionCounter;\n        else\n          samePositionCounter = 0;\n        const isStable = samePositionCounter >= this._stableRafCount;\n        const isStableForLogs = isStable || !lastRect;\n        lastRect = rect;\n        if (!isStableForLogs)\n          progress.logRepeating(`    element is not stable - waiting...`);\n        if (!isStable)\n          return progress.continuePolling;\n      }\n      return callback(node, progress);\n    });\n  }\n  elementState(node, state) {\n    const element = this.retarget(node, ["stable", "visible", "hidden"].includes(state) ? "no-follow-label" : "follow-label");\n    if (!element || !element.isConnected) {\n      if (state === "hidden")\n        return true;\n      return "error:notconnected";\n    }\n    if (state === "visible")\n      return this.isVisible(element);\n    if (state === "hidden")\n      return !this.isVisible(element);\n    const disabled = getAriaDisabled(element);\n    if (state === "disabled")\n      return disabled;\n    if (state === "enabled")\n      return !disabled;\n    const editable = !(["INPUT", "TEXTAREA", "SELECT"].includes(element.nodeName) && element.hasAttribute("readonly"));\n    if (state === "editable")\n      return !disabled && editable;\n    if (state === "checked" || state === "unchecked") {\n      if (["checkbox", "radio"].includes(element.getAttribute("role") || "")) {\n        const result2 = element.getAttribute("aria-checked") === "true";\n        return state === "checked" ? result2 : !result2;\n      }\n      if (element.nodeName !== "INPUT")\n        throw this.createStacklessError("Not a checkbox or radio button");\n      if (!["radio", "checkbox"].includes(element.type.toLowerCase()))\n        throw this.createStacklessError("Not a checkbox or radio button");\n      const result = element.checked;\n      return state === "checked" ? result : !result;\n    }\n    throw this.createStacklessError(`Unexpected element state "${state}"`);\n  }\n  selectOptions(optionsToSelect, node, progress) {\n    const element = this.retarget(node, "follow-label");\n    if (!element)\n      return "error:notconnected";\n    if (element.nodeName.toLowerCase() !== "select")\n      throw this.createStacklessError("Element is not a <select> element");\n    const select = element;\n    const options = [...select.options];\n    const selectedOptions = [];\n    let remainingOptionsToSelect = optionsToSelect.slice();\n    for (let index = 0; index < options.length; index++) {\n      const option = options[index];\n      const filter = (optionToSelect) => {\n        if (optionToSelect instanceof Node)\n          return option === optionToSelect;\n        let matches = true;\n        if (optionToSelect.value !== void 0)\n          matches = matches && optionToSelect.value === option.value;\n        if (optionToSelect.label !== void 0)\n          matches = matches && optionToSelect.label === option.label;\n        if (optionToSelect.index !== void 0)\n          matches = matches && optionToSelect.index === index;\n        return matches;\n      };\n      if (!remainingOptionsToSelect.some(filter))\n        continue;\n      selectedOptions.push(option);\n      if (select.multiple) {\n        remainingOptionsToSelect = remainingOptionsToSelect.filter((o) => !filter(o));\n      } else {\n        remainingOptionsToSelect = [];\n        break;\n      }\n    }\n    if (remainingOptionsToSelect.length) {\n      progress.logRepeating("    did not find some options - waiting... ");\n      return progress.continuePolling;\n    }\n    select.value = void 0;\n    selectedOptions.forEach((option) => option.selected = true);\n    progress.log("    selected specified option(s)");\n    select.dispatchEvent(new Event("input", { "bubbles": true }));\n    select.dispatchEvent(new Event("change", { "bubbles": true }));\n    return selectedOptions.map((option) => option.value);\n  }\n  fill(value, node, progress) {\n    const element = this.retarget(node, "follow-label");\n    if (!element)\n      return "error:notconnected";\n    if (element.nodeName.toLowerCase() === "input") {\n      const input = element;\n      const type = input.type.toLowerCase();\n      const kInputTypesToSetValue = /* @__PURE__ */ new Set(["color", "date", "time", "datetime", "datetime-local", "month", "range", "week"]);\n      const kInputTypesToTypeInto = /* @__PURE__ */ new Set(["", "email", "number", "password", "search", "tel", "text", "url"]);\n      if (!kInputTypesToTypeInto.has(type) && !kInputTypesToSetValue.has(type)) {\n        progress.log(`    input of type "${type}" cannot be filled`);\n        throw this.createStacklessError(`Input of type "${type}" cannot be filled`);\n      }\n      if (type === "number") {\n        value = value.trim();\n        if (isNaN(Number(value)))\n          throw this.createStacklessError("Cannot type text into input[type=number]");\n      }\n      if (kInputTypesToSetValue.has(type)) {\n        value = value.trim();\n        input.focus();\n        input.value = value;\n        if (input.value !== value)\n          throw this.createStacklessError("Malformed value");\n        element.dispatchEvent(new Event("input", { "bubbles": true }));\n        element.dispatchEvent(new Event("change", { "bubbles": true }));\n        return "done";\n      }\n    } else if (element.nodeName.toLowerCase() === "textarea") {\n    } else if (!element.isContentEditable) {\n      throw this.createStacklessError("Element is not an <input>, <textarea> or [contenteditable] element");\n    }\n    this.selectText(element);\n    return "needsinput";\n  }\n  selectText(node) {\n    const element = this.retarget(node, "follow-label");\n    if (!element)\n      return "error:notconnected";\n    if (element.nodeName.toLowerCase() === "input") {\n      const input = element;\n      input.select();\n      input.focus();\n      return "done";\n    }\n    if (element.nodeName.toLowerCase() === "textarea") {\n      const textarea = element;\n      textarea.selectionStart = 0;\n      textarea.selectionEnd = textarea.value.length;\n      textarea.focus();\n      return "done";\n    }\n    const range = element.ownerDocument.createRange();\n    range.selectNodeContents(element);\n    const selection = element.ownerDocument.defaultView.getSelection();\n    if (selection) {\n      selection.removeAllRanges();\n      selection.addRange(range);\n    }\n    element.focus();\n    return "done";\n  }\n  focusNode(node, resetSelectionIfNotFocused) {\n    if (!node.isConnected)\n      return "error:notconnected";\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      throw this.createStacklessError("Node is not an element");\n    const wasFocused = node.getRootNode().activeElement === node && node.ownerDocument && node.ownerDocument.hasFocus();\n    node.focus();\n    if (resetSelectionIfNotFocused && !wasFocused && node.nodeName.toLowerCase() === "input") {\n      try {\n        const input = node;\n        input.setSelectionRange(0, 0);\n      } catch (e) {\n      }\n    }\n    return "done";\n  }\n  setInputFiles(node, payloads) {\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return "Node is not of type HTMLElement";\n    const element = node;\n    if (element.nodeName !== "INPUT")\n      return "Not an <input> element";\n    const input = element;\n    const type = (input.getAttribute("type") || "").toLowerCase();\n    if (type !== "file")\n      return "Not an input[type=file] element";\n    const files = payloads.map((file) => {\n      const bytes = Uint8Array.from(atob(file.buffer), (c) => c.charCodeAt(0));\n      return new File([bytes], file.name, { type: file.mimeType });\n    });\n    const dt = new DataTransfer();\n    for (const file of files)\n      dt.items.add(file);\n    input.files = dt.files;\n    input.dispatchEvent(new Event("input", { "bubbles": true }));\n    input.dispatchEvent(new Event("change", { "bubbles": true }));\n  }\n  checkHitTargetAt(node, point) {\n    let element = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\n    if (!element || !element.isConnected)\n      return "error:notconnected";\n    element = element.closest("button, [role=button]") || element;\n    const hitElement = this.deepElementFromPoint(document, point.x, point.y);\n    return this._expectHitTargetParent(hitElement, element);\n  }\n  _expectHitTargetParent(hitElement, targetElement) {\n    const hitParents = [];\n    while (hitElement && hitElement !== targetElement) {\n      hitParents.push(hitElement);\n      hitElement = parentElementOrShadowHost(hitElement);\n    }\n    if (hitElement === targetElement)\n      return "done";\n    const hitTargetDescription = this.previewNode(hitParents[0] || document.documentElement);\n    let rootHitTargetDescription;\n    let element = targetElement;\n    while (element) {\n      const index = hitParents.indexOf(element);\n      if (index !== -1) {\n        if (index > 1)\n          rootHitTargetDescription = this.previewNode(hitParents[index - 1]);\n        break;\n      }\n      element = parentElementOrShadowHost(element);\n    }\n    if (rootHitTargetDescription)\n      return { hitTargetDescription: `${hitTargetDescription} from ${rootHitTargetDescription} subtree` };\n    return { hitTargetDescription };\n  }\n  setupHitTargetInterceptor(node, action, blockAllEvents) {\n    const maybeElement = node.nodeType === Node.ELEMENT_NODE ? node : node.parentElement;\n    if (!maybeElement || !maybeElement.isConnected)\n      return "error:notconnected";\n    const element = maybeElement.closest("button, [role=button]") || maybeElement;\n    const events = {\n      "hover": kHoverHitTargetInterceptorEvents,\n      "tap": kTapHitTargetInterceptorEvents,\n      "mouse": kMouseHitTargetInterceptorEvents\n    }[action];\n    let result;\n    const listener = (event) => {\n      if (!events.has(event.type))\n        return;\n      if (!event.isTrusted)\n        return;\n      const point = !!window.TouchEvent && event instanceof window.TouchEvent ? event.touches[0] : event;\n      if (result === void 0 && point) {\n        const hitElement = this.deepElementFromPoint(document, point.clientX, point.clientY);\n        result = this._expectHitTargetParent(hitElement, element);\n      }\n      if (blockAllEvents || result !== "done" && result !== void 0) {\n        event.preventDefault();\n        event.stopPropagation();\n        event.stopImmediatePropagation();\n      }\n    };\n    const stop = () => {\n      if (this._hitTargetInterceptor === listener)\n        this._hitTargetInterceptor = void 0;\n      return result || "done";\n    };\n    this._hitTargetInterceptor = listener;\n    return { stop };\n  }\n  dispatchEvent(node, type, eventInit) {\n    let event;\n    eventInit = { bubbles: true, cancelable: true, composed: true, ...eventInit };\n    switch (eventType.get(type)) {\n      case "mouse":\n        event = new MouseEvent(type, eventInit);\n        break;\n      case "keyboard":\n        event = new KeyboardEvent(type, eventInit);\n        break;\n      case "touch":\n        event = new TouchEvent(type, eventInit);\n        break;\n      case "pointer":\n        event = new PointerEvent(type, eventInit);\n        break;\n      case "focus":\n        event = new FocusEvent(type, eventInit);\n        break;\n      case "drag":\n        event = new DragEvent(type, eventInit);\n        break;\n      default:\n        event = new Event(type, eventInit);\n        break;\n    }\n    node.dispatchEvent(event);\n  }\n  deepElementFromPoint(document2, x, y) {\n    let container = document2;\n    let element;\n    while (container) {\n      const elements = container.elementsFromPoint(x, y);\n      const innerElement = elements[0];\n      if (!innerElement || element === innerElement)\n        break;\n      element = innerElement;\n      container = element.shadowRoot;\n    }\n    return element;\n  }\n  previewNode(node) {\n    if (node.nodeType === Node.TEXT_NODE)\n      return oneLine(`#text=${node.nodeValue || ""}`);\n    if (node.nodeType !== Node.ELEMENT_NODE)\n      return oneLine(`<${node.nodeName.toLowerCase()} />`);\n    const element = node;\n    const attrs = [];\n    for (let i = 0; i < element.attributes.length; i++) {\n      const { name, value } = element.attributes[i];\n      if (name === "style" || name.startsWith("__playwright"))\n        continue;\n      if (!value && booleanAttributes.has(name))\n        attrs.push(` ${name}`);\n      else\n        attrs.push(` ${name}="${value}"`);\n    }\n    attrs.sort((a, b) => a.length - b.length);\n    let attrText = attrs.join("");\n    if (attrText.length > 50)\n      attrText = attrText.substring(0, 49) + "\\u2026";\n    if (autoClosingTags.has(element.nodeName))\n      return oneLine(`<${element.nodeName.toLowerCase()}${attrText}/>`);\n    const children = element.childNodes;\n    let onlyText = false;\n    if (children.length <= 5) {\n      onlyText = true;\n      for (let i = 0; i < children.length; i++)\n        onlyText = onlyText && children[i].nodeType === Node.TEXT_NODE;\n    }\n    let text = onlyText ? element.textContent || "" : children.length ? "\\u2026" : "";\n    if (text.length > 50)\n      text = text.substring(0, 49) + "\\u2026";\n    return oneLine(`<${element.nodeName.toLowerCase()}${attrText}>${text}</${element.nodeName.toLowerCase()}>`);\n  }\n  strictModeViolationError(selector, matches) {\n    const infos = matches.slice(0, 10).map((m) => ({\n      preview: this.previewNode(m),\n      selector: this.generateSelector(m)\n    }));\n    const lines = infos.map((info, i) => `\n    ${i + 1}) ${info.preview} aka playwright.$("${info.selector}")`);\n    if (infos.length < matches.length)\n      lines.push("\\n    ...");\n    return this.createStacklessError(`strict mode violation: "${stringifySelector(selector)}" resolved to ${matches.length} elements:${lines.join("")}\n`);\n  }\n  createStacklessError(message) {\n    if (this._browserName === "firefox") {\n      const error2 = new Error("Error: " + message);\n      error2.stack = "";\n      return error2;\n    }\n    const error = new Error(message);\n    delete error.stack;\n    return error;\n  }\n  maskSelectors(selectors) {\n    if (this._highlight)\n      this.hideHighlight();\n    this._highlight = new Highlight(this.isUnderTest);\n    this._highlight.install();\n    const elements = [];\n    for (const selector of selectors)\n      elements.push(this.querySelectorAll(selector, document.documentElement));\n    this._highlight.maskElements(elements.flat());\n  }\n  highlight(selector) {\n    if (!this._highlight) {\n      this._highlight = new Highlight(this.isUnderTest);\n      this._highlight.install();\n    }\n    this._runHighlightOnRaf(selector);\n  }\n  _runHighlightOnRaf(selector) {\n    if (!this._highlight)\n      return;\n    this._highlight.updateHighlight(this.querySelectorAll(selector, document.documentElement), stringifySelector(selector), false);\n    requestAnimationFrame(() => this._runHighlightOnRaf(selector));\n  }\n  hideHighlight() {\n    if (this._highlight) {\n      this._highlight.uninstall();\n      delete this._highlight;\n    }\n  }\n  _setupGlobalListenersRemovalDetection() {\n    const customEventName = "__playwright_global_listeners_check__";\n    let seenEvent = false;\n    const handleCustomEvent = () => seenEvent = true;\n    window.addEventListener(customEventName, handleCustomEvent);\n    new MutationObserver((entries) => {\n      const newDocumentElement = entries.some((entry) => Array.from(entry.addedNodes).includes(document.documentElement));\n      if (!newDocumentElement)\n        return;\n      seenEvent = false;\n      window.dispatchEvent(new CustomEvent(customEventName));\n      if (seenEvent)\n        return;\n      window.addEventListener(customEventName, handleCustomEvent);\n      for (const callback of this.onGlobalListenersRemoved)\n        callback();\n    }).observe(document, { childList: true });\n  }\n  _setupHitTargetInterceptors() {\n    const listener = (event) => {\n      var _a;\n      return (_a = this._hitTargetInterceptor) == null ? void 0 : _a.call(this, event);\n    };\n    const addHitTargetInterceptorListeners = () => {\n      for (const event of kAllHitTargetInterceptorEvents)\n        window.addEventListener(event, listener, { capture: true, passive: false });\n    };\n    addHitTargetInterceptorListeners();\n    this.onGlobalListenersRemoved.add(addHitTargetInterceptorListeners);\n  }\n  expectSingleElement(progress, element, options) {\n    var _a;\n    const injected = progress.injectedScript;\n    const expression = options.expression;\n    {\n      let elementState;\n      if (expression === "to.be.checked") {\n        elementState = progress.injectedScript.elementState(element, "checked");\n      } else if (expression === "to.be.unchecked") {\n        elementState = progress.injectedScript.elementState(element, "unchecked");\n      } else if (expression === "to.be.disabled") {\n        elementState = progress.injectedScript.elementState(element, "disabled");\n      } else if (expression === "to.be.editable") {\n        elementState = progress.injectedScript.elementState(element, "editable");\n      } else if (expression === "to.be.empty") {\n        if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA")\n          elementState = !element.value;\n        else\n          elementState = !((_a = element.textContent) == null ? void 0 : _a.trim());\n      } else if (expression === "to.be.enabled") {\n        elementState = progress.injectedScript.elementState(element, "enabled");\n      } else if (expression === "to.be.focused") {\n        elementState = document.activeElement === element;\n      } else if (expression === "to.be.hidden") {\n        elementState = progress.injectedScript.elementState(element, "hidden");\n      } else if (expression === "to.be.visible") {\n        elementState = progress.injectedScript.elementState(element, "visible");\n      }\n      if (elementState !== void 0) {\n        if (elementState === "error:notcheckbox")\n          throw injected.createStacklessError("Element is not a checkbox");\n        if (elementState === "error:notconnected")\n          throw injected.createStacklessError("Element is not connected");\n        return { received: elementState, matches: elementState };\n      }\n    }\n    {\n      if (expression === "to.have.property") {\n        const received = element[options.expressionArg];\n        const matches = deepEquals(received, options.expectedValue);\n        return { received, matches };\n      }\n    }\n    {\n      let received;\n      if (expression === "to.have.attribute") {\n        received = element.getAttribute(options.expressionArg) || "";\n      } else if (expression === "to.have.class") {\n        received = element.className;\n      } else if (expression === "to.have.css") {\n        received = window.getComputedStyle(element).getPropertyValue(options.expressionArg);\n      } else if (expression === "to.have.id") {\n        received = element.id;\n      } else if (expression === "to.have.text") {\n        received = options.useInnerText ? element.innerText : element.textContent || "";\n      } else if (expression === "to.have.title") {\n        received = document.title;\n      } else if (expression === "to.have.url") {\n        received = document.location.href;\n      } else if (expression === "to.have.value") {\n        element = this.retarget(element, "follow-label");\n        if (element.nodeName !== "INPUT" && element.nodeName !== "TEXTAREA" && element.nodeName !== "SELECT")\n          throw this.createStacklessError("Not an input element");\n        received = element.value;\n      }\n      if (received !== void 0 && options.expectedText) {\n        const matcher = new ExpectedTextMatcher(options.expectedText[0]);\n        return { received, matches: matcher.matches(received) };\n      }\n    }\n    throw this.createStacklessError("Unknown expect matcher: " + expression);\n  }\n  expectArray(elements, options) {\n    const expression = options.expression;\n    if (expression === "to.have.count") {\n      const received2 = elements.length;\n      const matches = received2 === options.expectedNumber;\n      return { received: received2, matches };\n    }\n    let received;\n    if (expression === "to.have.text.array" || expression === "to.contain.text.array")\n      received = elements.map((e) => options.useInnerText ? e.innerText : e.textContent || "");\n    else if (expression === "to.have.class.array")\n      received = elements.map((e) => e.className);\n    if (received && options.expectedText) {\n      const lengthShouldMatch = expression !== "to.contain.text.array";\n      const matchesLength = received.length === options.expectedText.length || !lengthShouldMatch;\n      if (!matchesLength)\n        return { received, matches: false };\n      let i = 0;\n      const matchers = options.expectedText.map((e) => new ExpectedTextMatcher(e));\n      let allMatchesFound = true;\n      for (const matcher of matchers) {\n        while (i < received.length && !matcher.matches(received[i]))\n          i++;\n        if (i >= received.length) {\n          allMatchesFound = false;\n          break;\n        }\n      }\n      return { received, matches: allMatchesFound };\n    }\n    throw this.createStacklessError("Unknown expect matcher: " + expression);\n  }\n  getElementAccessibleName(element, includeHidden) {\n    const hiddenCache = /* @__PURE__ */ new Map();\n    return getElementAccessibleName(element, !!includeHidden, hiddenCache);\n  }\n  getAriaRole(element) {\n    return getAriaRole(element);\n  }\n};\nvar autoClosingTags = /* @__PURE__ */ new Set(["AREA", "BASE", "BR", "COL", "COMMAND", "EMBED", "HR", "IMG", "INPUT", "KEYGEN", "LINK", "MENUITEM", "META", "PARAM", "SOURCE", "TRACK", "WBR"]);\nvar booleanAttributes = /* @__PURE__ */ new Set(["checked", "selected", "disabled", "readonly", "multiple"]);\nfunction oneLine(s) {\n  return s.replace(/\\n/g, "\\u21B5").replace(/\\t/g, "\\u21C6");\n}\nvar eventType = /* @__PURE__ */ new Map([\n  ["auxclick", "mouse"],\n  ["click", "mouse"],\n  ["dblclick", "mouse"],\n  ["mousedown", "mouse"],\n  ["mouseeenter", "mouse"],\n  ["mouseleave", "mouse"],\n  ["mousemove", "mouse"],\n  ["mouseout", "mouse"],\n  ["mouseover", "mouse"],\n  ["mouseup", "mouse"],\n  ["mouseleave", "mouse"],\n  ["mousewheel", "mouse"],\n  ["keydown", "keyboard"],\n  ["keyup", "keyboard"],\n  ["keypress", "keyboard"],\n  ["textInput", "keyboard"],\n  ["touchstart", "touch"],\n  ["touchmove", "touch"],\n  ["touchend", "touch"],\n  ["touchcancel", "touch"],\n  ["pointerover", "pointer"],\n  ["pointerout", "pointer"],\n  ["pointerenter", "pointer"],\n  ["pointerleave", "pointer"],\n  ["pointerdown", "pointer"],\n  ["pointerup", "pointer"],\n  ["pointermove", "pointer"],\n  ["pointercancel", "pointer"],\n  ["gotpointercapture", "pointer"],\n  ["lostpointercapture", "pointer"],\n  ["focus", "focus"],\n  ["blur", "focus"],\n  ["drag", "drag"],\n  ["dragstart", "drag"],\n  ["dragend", "drag"],\n  ["dragover", "drag"],\n  ["dragenter", "drag"],\n  ["dragleave", "drag"],\n  ["dragexit", "drag"],\n  ["drop", "drag"]\n]);\nvar kHoverHitTargetInterceptorEvents = /* @__PURE__ */ new Set(["mousemove"]);\nvar kTapHitTargetInterceptorEvents = /* @__PURE__ */ new Set(["pointerdown", "pointerup", "touchstart", "touchend", "touchcancel"]);\nvar kMouseHitTargetInterceptorEvents = /* @__PURE__ */ new Set(["mousedown", "mouseup", "pointerdown", "pointerup", "click", "auxclick", "dblclick", "contextmenu"]);\nvar kAllHitTargetInterceptorEvents = /* @__PURE__ */ new Set([...kHoverHitTargetInterceptorEvents, ...kTapHitTargetInterceptorEvents, ...kMouseHitTargetInterceptorEvents]);\nfunction unescape(s) {\n  if (!s.includes("\\\\"))\n    return s;\n  const r = [];\n  let i = 0;\n  while (i < s.length) {\n    if (s[i] === "\\\\" && i + 1 < s.length)\n      i++;\n    r.push(s[i++]);\n  }\n  return r.join("");\n}\nfunction createTextMatcher(selector) {\n  if (selector[0] === "/" && selector.lastIndexOf("/") > 0) {\n    const lastSlash = selector.lastIndexOf("/");\n    const matcher2 = createRegexTextMatcher(selector.substring(1, lastSlash), selector.substring(lastSlash + 1));\n    return { matcher: matcher2, kind: "regex" };\n  }\n  let strict = false;\n  if (selector.length > 1 && selector[0] === \'"\' && selector[selector.length - 1] === \'"\') {\n    selector = unescape(selector.substring(1, selector.length - 1));\n    strict = true;\n  }\n  if (selector.length > 1 && selector[0] === "\'" && selector[selector.length - 1] === "\'") {\n    selector = unescape(selector.substring(1, selector.length - 1));\n    strict = true;\n  }\n  const matcher = strict ? createStrictTextMatcher(selector) : createLaxTextMatcher(selector);\n  return { matcher, kind: strict ? "strict" : "lax" };\n}\nvar ExpectedTextMatcher = class {\n  constructor(expected) {\n    this._normalizeWhiteSpace = expected.normalizeWhiteSpace;\n    this._string = expected.matchSubstring ? void 0 : this.normalizeWhiteSpace(expected.string);\n    this._substring = expected.matchSubstring ? this.normalizeWhiteSpace(expected.string) : void 0;\n    this._regex = expected.regexSource ? new RegExp(expected.regexSource, expected.regexFlags) : void 0;\n  }\n  matches(text) {\n    if (this._normalizeWhiteSpace && !this._regex)\n      text = this.normalizeWhiteSpace(text);\n    if (this._string !== void 0)\n      return text === this._string;\n    if (this._substring !== void 0)\n      return text.includes(this._substring);\n    if (this._regex)\n      return !!this._regex.test(text);\n    return false;\n  }\n  normalizeWhiteSpace(s) {\n    if (!s)\n      return s;\n    return this._normalizeWhiteSpace ? s.trim().replace(/\\u200b/g, "").replace(/\\s+/g, " ") : s;\n  }\n};\nfunction deepEquals(a, b) {\n  if (a === b)\n    return true;\n  if (a && b && typeof a === "object" && typeof b === "object") {\n    if (a.constructor !== b.constructor)\n      return false;\n    if (Array.isArray(a)) {\n      if (a.length !== b.length)\n        return false;\n      for (let i = 0; i < a.length; ++i) {\n        if (!deepEquals(a[i], b[i]))\n          return false;\n      }\n      return true;\n    }\n    if (a instanceof RegExp)\n      return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf)\n      return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString)\n      return a.toString() === b.toString();\n    const keys = Object.keys(a);\n    if (keys.length !== Object.keys(b).length)\n      return false;\n    for (let i = 0; i < keys.length; ++i) {\n      if (!b.hasOwnProperty(keys[i]))\n        return false;\n    }\n    for (const key of keys) {\n      if (!deepEquals(a[key], b[key]))\n        return false;\n    }\n    return true;\n  }\n  if (typeof a === "number" && typeof b === "number")\n    return isNaN(a) && isNaN(b);\n  return false;\n}\nmodule.exports = InjectedScript;\n';
    exports2.source = source;
  }
});

// node_modules/playwright-core/lib/server/protocolError.js
var require_protocolError = __commonJS({
  "node_modules/playwright-core/lib/server/protocolError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ProtocolError = void 0;
    exports2.isSessionClosedError = isSessionClosedError;
    var ProtocolError = class extends Error {
      constructor(sessionClosed, message) {
        super(message);
        this.sessionClosed = void 0;
        this.sessionClosed = sessionClosed || false;
      }
    };
    exports2.ProtocolError = ProtocolError;
    function isSessionClosedError(e) {
      return e instanceof ProtocolError && e.sessionClosed;
    }
  }
});

// node_modules/playwright-core/lib/generated/utilityScriptSource.js
var require_utilityScriptSource = __commonJS({
  "node_modules/playwright-core/lib/generated/utilityScriptSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.source = void 0;
    var source = 'var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === "object" || typeof from === "function") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);\n\n// packages/playwright-core/src/server/injected/utilityScript.ts\nvar utilityScript_exports = {};\n__export(utilityScript_exports, {\n  UtilityScript: () => UtilityScript\n});\nmodule.exports = __toCommonJS(utilityScript_exports);\n\n// packages/playwright-core/src/server/isomorphic/utilityScriptSerializers.ts\nfunction isRegExp(obj) {\n  return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";\n}\nfunction isDate(obj) {\n  return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";\n}\nfunction isError(obj) {\n  return obj instanceof Error || obj && obj.__proto__ && obj.__proto__.name === "Error";\n}\nfunction parseEvaluationResultValue(value, handles = []) {\n  if (Object.is(value, void 0))\n    return void 0;\n  if (typeof value === "object" && value) {\n    if ("v" in value) {\n      if (value.v === "undefined")\n        return void 0;\n      if (value.v === "null")\n        return null;\n      if (value.v === "NaN")\n        return NaN;\n      if (value.v === "Infinity")\n        return Infinity;\n      if (value.v === "-Infinity")\n        return -Infinity;\n      if (value.v === "-0")\n        return -0;\n      return void 0;\n    }\n    if ("d" in value)\n      return new Date(value.d);\n    if ("r" in value)\n      return new RegExp(value.r.p, value.r.f);\n    if ("a" in value)\n      return value.a.map((a) => parseEvaluationResultValue(a, handles));\n    if ("o" in value) {\n      const result = {};\n      for (const { k, v } of value.o)\n        result[k] = parseEvaluationResultValue(v, handles);\n      return result;\n    }\n    if ("h" in value)\n      return handles[value.h];\n  }\n  return value;\n}\nfunction serializeAsCallArgument(value, handleSerializer) {\n  return serialize(value, handleSerializer, /* @__PURE__ */ new Set());\n}\nfunction serialize(value, handleSerializer, visited) {\n  const result = handleSerializer(value);\n  if ("fallThrough" in result)\n    value = result.fallThrough;\n  else\n    return result;\n  if (visited.has(value))\n    throw new Error("Argument is a circular structure");\n  if (typeof value === "symbol")\n    return { v: "undefined" };\n  if (Object.is(value, void 0))\n    return { v: "undefined" };\n  if (Object.is(value, null))\n    return { v: "null" };\n  if (Object.is(value, NaN))\n    return { v: "NaN" };\n  if (Object.is(value, Infinity))\n    return { v: "Infinity" };\n  if (Object.is(value, -Infinity))\n    return { v: "-Infinity" };\n  if (Object.is(value, -0))\n    return { v: "-0" };\n  if (typeof value === "boolean")\n    return value;\n  if (typeof value === "number")\n    return value;\n  if (typeof value === "string")\n    return value;\n  if (isError(value)) {\n    const error = value;\n    if ("captureStackTrace" in globalThis.Error) {\n      return error.stack || "";\n    }\n    return `${error.name}: ${error.message}\n${error.stack}`;\n  }\n  if (isDate(value))\n    return { d: value.toJSON() };\n  if (isRegExp(value))\n    return { r: { p: value.source, f: value.flags } };\n  if (Array.isArray(value)) {\n    const a = [];\n    visited.add(value);\n    for (let i = 0; i < value.length; ++i)\n      a.push(serialize(value[i], handleSerializer, visited));\n    visited.delete(value);\n    return { a };\n  }\n  if (typeof value === "object") {\n    const o = [];\n    visited.add(value);\n    for (const name of Object.keys(value)) {\n      let item;\n      try {\n        item = value[name];\n      } catch (e) {\n        continue;\n      }\n      if (name === "toJSON" && typeof item === "function")\n        o.push({ k: name, v: { o: [] } });\n      else\n        o.push({ k: name, v: serialize(item, handleSerializer, visited) });\n    }\n    visited.delete(value);\n    return { o };\n  }\n}\n\n// packages/playwright-core/src/server/injected/utilityScript.ts\nvar UtilityScript = class {\n  evaluate(isFunction, returnByValue, expression, argCount, ...argsAndHandles) {\n    const args = argsAndHandles.slice(0, argCount);\n    const handles = argsAndHandles.slice(argCount);\n    const parameters = args.map((a) => parseEvaluationResultValue(a, handles));\n    let result = globalThis.eval(expression);\n    if (isFunction === true) {\n      result = result(...parameters);\n    } else if (isFunction === false) {\n      result = result;\n    } else {\n      if (typeof result === "function")\n        result = result(...parameters);\n    }\n    return returnByValue ? this._promiseAwareJsonValueNoThrow(result) : result;\n  }\n  jsonValue(returnByValue, value) {\n    if (Object.is(value, void 0))\n      return void 0;\n    return serializeAsCallArgument(value, (value2) => ({ fallThrough: value2 }));\n  }\n  _promiseAwareJsonValueNoThrow(value) {\n    const safeJson = (value2) => {\n      try {\n        return this.jsonValue(true, value2);\n      } catch (e) {\n        return void 0;\n      }\n    };\n    if (value && typeof value === "object" && typeof value.then === "function") {\n      return (async () => {\n        const promiseValue = await value;\n        return safeJson(promiseValue);\n      })();\n    }\n    return safeJson(value);\n  }\n};\nmodule.exports = UtilityScript;\n';
    exports2.source = source;
  }
});

// node_modules/playwright-core/lib/server/isomorphic/utilityScriptSerializers.js
var require_utilityScriptSerializers = __commonJS({
  "node_modules/playwright-core/lib/server/isomorphic/utilityScriptSerializers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.parseEvaluationResultValue = parseEvaluationResultValue;
    exports2.serializeAsCallArgument = serializeAsCallArgument;
    function isRegExp(obj) {
      return obj instanceof RegExp || Object.prototype.toString.call(obj) === "[object RegExp]";
    }
    function isDate(obj) {
      return obj instanceof Date || Object.prototype.toString.call(obj) === "[object Date]";
    }
    function isError(obj) {
      return obj instanceof Error || obj && obj.__proto__ && obj.__proto__.name === "Error";
    }
    function parseEvaluationResultValue(value, handles = []) {
      if (Object.is(value, void 0))
        return void 0;
      if (typeof value === "object" && value) {
        if ("v" in value) {
          if (value.v === "undefined")
            return void 0;
          if (value.v === "null")
            return null;
          if (value.v === "NaN")
            return NaN;
          if (value.v === "Infinity")
            return Infinity;
          if (value.v === "-Infinity")
            return -Infinity;
          if (value.v === "-0")
            return -0;
          return void 0;
        }
        if ("d" in value)
          return new Date(value.d);
        if ("r" in value)
          return new RegExp(value.r.p, value.r.f);
        if ("a" in value)
          return value.a.map((a) => parseEvaluationResultValue(a, handles));
        if ("o" in value) {
          const result = {};
          for (const {
            k,
            v
          } of value.o)
            result[k] = parseEvaluationResultValue(v, handles);
          return result;
        }
        if ("h" in value)
          return handles[value.h];
      }
      return value;
    }
    function serializeAsCallArgument(value, handleSerializer) {
      return serialize(value, handleSerializer, /* @__PURE__ */ new Set());
    }
    function serialize(value, handleSerializer, visited) {
      const result = handleSerializer(value);
      if ("fallThrough" in result)
        value = result.fallThrough;
      else
        return result;
      if (visited.has(value))
        throw new Error("Argument is a circular structure");
      if (typeof value === "symbol")
        return {
          v: "undefined"
        };
      if (Object.is(value, void 0))
        return {
          v: "undefined"
        };
      if (Object.is(value, null))
        return {
          v: "null"
        };
      if (Object.is(value, NaN))
        return {
          v: "NaN"
        };
      if (Object.is(value, Infinity))
        return {
          v: "Infinity"
        };
      if (Object.is(value, -Infinity))
        return {
          v: "-Infinity"
        };
      if (Object.is(value, -0))
        return {
          v: "-0"
        };
      if (typeof value === "boolean")
        return value;
      if (typeof value === "number")
        return value;
      if (typeof value === "string")
        return value;
      if (isError(value)) {
        const error = value;
        if ("captureStackTrace" in globalThis.Error) {
          return error.stack || "";
        }
        return `${error.name}: ${error.message}
${error.stack}`;
      }
      if (isDate(value))
        return {
          d: value.toJSON()
        };
      if (isRegExp(value))
        return {
          r: {
            p: value.source,
            f: value.flags
          }
        };
      if (Array.isArray(value)) {
        const a = [];
        visited.add(value);
        for (let i = 0; i < value.length; ++i)
          a.push(serialize(value[i], handleSerializer, visited));
        visited.delete(value);
        return {
          a
        };
      }
      if (typeof value === "object") {
        const o = [];
        visited.add(value);
        for (const name of Object.keys(value)) {
          let item;
          try {
            item = value[name];
          } catch (e) {
            continue;
          }
          if (name === "toJSON" && typeof item === "function")
            o.push({
              k: name,
              v: {
                o: []
              }
            });
          else
            o.push({
              k: name,
              v: serialize(item, handleSerializer, visited)
            });
        }
        visited.delete(value);
        return {
          o
        };
      }
    }
  }
});

// node_modules/playwright-core/lib/server/javascript.js
var require_javascript = __commonJS({
  "node_modules/playwright-core/lib/server/javascript.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JavaScriptErrorInEvaluate = exports2.JSHandle = exports2.ExecutionContext = void 0;
    exports2.evaluate = evaluate;
    exports2.evaluateExpression = evaluateExpression;
    exports2.evaluateExpressionAndWaitForSignals = evaluateExpressionAndWaitForSignals;
    exports2.isJavaScriptErrorInEvaluate = isJavaScriptErrorInEvaluate;
    exports2.normalizeEvaluationExpression = normalizeEvaluationExpression;
    exports2.parseUnserializableValue = parseUnserializableValue;
    var utilityScriptSource = _interopRequireWildcard(require_utilityScriptSource());
    var _utilityScriptSerializers = require_utilityScriptSerializers();
    var _instrumentation = require_instrumentation();
    var _manualPromise = require_manualPromise();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var ExecutionContext = class extends _instrumentation.SdkObject {
      constructor(parent, delegate) {
        super(parent, "execution-context");
        this._delegate = void 0;
        this._utilityScriptPromise = void 0;
        this._destroyedPromise = new _manualPromise.ManualPromise();
        this._delegate = delegate;
      }
      contextDestroyed(error) {
        this._destroyedPromise.resolve(error);
      }
      _raceAgainstContextDestroyed(promise) {
        return Promise.race([this._destroyedPromise.then((e) => {
          throw e;
        }), promise]);
      }
      rawEvaluateJSON(expression) {
        return this._raceAgainstContextDestroyed(this._delegate.rawEvaluateJSON(expression));
      }
      rawEvaluateHandle(expression) {
        return this._raceAgainstContextDestroyed(this._delegate.rawEvaluateHandle(expression));
      }
      rawCallFunctionNoReply(func, ...args) {
        this._delegate.rawCallFunctionNoReply(func, ...args);
      }
      evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        return this._raceAgainstContextDestroyed(this._delegate.evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds));
      }
      getProperties(context, objectId) {
        return this._raceAgainstContextDestroyed(this._delegate.getProperties(context, objectId));
      }
      createHandle(remoteObject) {
        return this._delegate.createHandle(this, remoteObject);
      }
      releaseHandle(objectId) {
        return this._delegate.releaseHandle(objectId);
      }
      waitForSignalsCreatedBy(action) {
        return __async(this, null, function* () {
          return action();
        });
      }
      adoptIfNeeded(handle) {
        return null;
      }
      utilityScript() {
        if (!this._utilityScriptPromise) {
          const source = `
      (() => {
        const module = {};
        ${utilityScriptSource.source}
        return new module.exports();
      })();`;
          this._utilityScriptPromise = this._raceAgainstContextDestroyed(this._delegate.rawEvaluateHandle(source).then((objectId) => new JSHandle(this, "object", void 0, objectId)));
        }
        return this._utilityScriptPromise;
      }
      doSlowMo() {
        return __async(this, null, function* () {
        });
      }
    };
    exports2.ExecutionContext = ExecutionContext;
    var JSHandle = class extends _instrumentation.SdkObject {
      constructor(context, type, preview, objectId, value) {
        super(context, "handle");
        this._context = void 0;
        this._disposed = false;
        this._objectId = void 0;
        this._value = void 0;
        this._objectType = void 0;
        this._preview = void 0;
        this._previewCallback = void 0;
        this._context = context;
        this._objectId = objectId;
        this._value = value;
        this._objectType = type;
        this._preview = this._objectId ? preview || `JSHandle@${this._objectType}` : String(value);
      }
      callFunctionNoReply(func, arg) {
        this._context.rawCallFunctionNoReply(func, this, arg);
      }
      evaluate(pageFunction, arg) {
        return __async(this, null, function* () {
          return evaluate(this._context, true, pageFunction, this, arg);
        });
      }
      evaluateHandle(pageFunction, arg) {
        return __async(this, null, function* () {
          return evaluate(this._context, false, pageFunction, this, arg);
        });
      }
      evaluateExpressionAndWaitForSignals(expression, isFunction, returnByValue, arg) {
        return __async(this, null, function* () {
          const value = yield evaluateExpressionAndWaitForSignals(this._context, returnByValue, expression, isFunction, this, arg);
          yield this._context.doSlowMo();
          return value;
        });
      }
      getProperty(propertyName) {
        return __async(this, null, function* () {
          const objectHandle = yield this.evaluateHandle((object, propertyName2) => {
            const result2 = {
              __proto__: null
            };
            result2[propertyName2] = object[propertyName2];
            return result2;
          }, propertyName);
          const properties = yield objectHandle.getProperties();
          const result = properties.get(propertyName);
          objectHandle.dispose();
          return result;
        });
      }
      getProperties() {
        return __async(this, null, function* () {
          if (!this._objectId)
            return /* @__PURE__ */ new Map();
          return this._context.getProperties(this._context, this._objectId);
        });
      }
      rawValue() {
        return this._value;
      }
      jsonValue() {
        return __async(this, null, function* () {
          if (!this._objectId)
            return this._value;
          const utilityScript = yield this._context.utilityScript();
          const script = `(utilityScript, ...args) => utilityScript.jsonValue(...args)`;
          return this._context.evaluateWithArguments(script, true, utilityScript, [true], [this._objectId]);
        });
      }
      asElement() {
        return null;
      }
      dispose() {
        if (this._disposed)
          return;
        this._disposed = true;
        if (this._objectId)
          this._context.releaseHandle(this._objectId).catch((e) => {
          });
      }
      toString() {
        return this._preview;
      }
      _setPreviewCallback(callback) {
        this._previewCallback = callback;
      }
      preview() {
        return this._preview;
      }
      _setPreview(preview) {
        this._preview = preview;
        if (this._previewCallback)
          this._previewCallback(preview);
      }
    };
    exports2.JSHandle = JSHandle;
    function evaluate(context, returnByValue, pageFunction, ...args) {
      return __async(this, null, function* () {
        return evaluateExpression(context, returnByValue, String(pageFunction), typeof pageFunction === "function", ...args);
      });
    }
    function evaluateExpression(context, returnByValue, expression, isFunction, ...args) {
      return __async(this, null, function* () {
        const utilityScript = yield context.utilityScript();
        expression = normalizeEvaluationExpression(expression, isFunction);
        const handles = [];
        const toDispose = [];
        const pushHandle = (handle) => {
          handles.push(handle);
          return handles.length - 1;
        };
        args = args.map((arg) => (0, _utilityScriptSerializers.serializeAsCallArgument)(arg, (handle) => {
          if (handle instanceof JSHandle) {
            if (!handle._objectId)
              return {
                fallThrough: handle._value
              };
            if (handle._disposed)
              throw new Error("JSHandle is disposed!");
            const adopted = context.adoptIfNeeded(handle);
            if (adopted === null)
              return {
                h: pushHandle(Promise.resolve(handle))
              };
            toDispose.push(adopted);
            return {
              h: pushHandle(adopted)
            };
          }
          return {
            fallThrough: handle
          };
        }));
        const utilityScriptObjectIds = [];
        for (const handle of yield Promise.all(handles)) {
          if (handle._context !== context)
            throw new Error("JSHandles can be evaluated only in the context they were created!");
          utilityScriptObjectIds.push(handle._objectId);
        }
        const utilityScriptValues = [isFunction, returnByValue, expression, args.length, ...args];
        const script = `(utilityScript, ...args) => utilityScript.evaluate(...args)`;
        try {
          return yield context.evaluateWithArguments(script, returnByValue, utilityScript, utilityScriptValues, utilityScriptObjectIds);
        } finally {
          toDispose.map((handlePromise) => handlePromise.then((handle) => handle.dispose()));
        }
      });
    }
    function evaluateExpressionAndWaitForSignals(context, returnByValue, expression, isFunction, ...args) {
      return __async(this, null, function* () {
        return yield context.waitForSignalsCreatedBy(() => evaluateExpression(context, returnByValue, expression, isFunction, ...args));
      });
    }
    function parseUnserializableValue(unserializableValue) {
      if (unserializableValue === "NaN")
        return NaN;
      if (unserializableValue === "Infinity")
        return Infinity;
      if (unserializableValue === "-Infinity")
        return -Infinity;
      if (unserializableValue === "-0")
        return -0;
    }
    function normalizeEvaluationExpression(expression, isFunction) {
      expression = expression.trim();
      if (isFunction) {
        try {
          new Function("(" + expression + ")");
        } catch (e1) {
          if (expression.startsWith("async "))
            expression = "async function " + expression.substring("async ".length);
          else
            expression = "function " + expression;
          try {
            new Function("(" + expression + ")");
          } catch (e2) {
            throw new Error("Passed function is not well-serializable!");
          }
        }
      }
      if (/^(async)?\s*function(\s|\()/.test(expression))
        expression = "(" + expression + ")";
      return expression;
    }
    var JavaScriptErrorInEvaluate = class extends Error {
    };
    exports2.JavaScriptErrorInEvaluate = JavaScriptErrorInEvaluate;
    function isJavaScriptErrorInEvaluate(error) {
      return error instanceof JavaScriptErrorInEvaluate;
    }
  }
});

// node_modules/playwright-core/lib/server/progress.js
var require_progress2 = __commonJS({
  "node_modules/playwright-core/lib/server/progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ProgressController = void 0;
    var _errors = require_errors();
    var _utils = require_utils();
    var _manualPromise = require_manualPromise();
    var ProgressController = class {
      constructor(metadata, sdkObject) {
        this._forceAbortPromise = new _manualPromise.ManualPromise();
        this._cleanups = [];
        this._logName = "api";
        this._state = "before";
        this._deadline = 0;
        this._timeout = 0;
        this._lastIntermediateResult = void 0;
        this.metadata = void 0;
        this.instrumentation = void 0;
        this.sdkObject = void 0;
        this.metadata = metadata;
        this.sdkObject = sdkObject;
        this.instrumentation = sdkObject.instrumentation;
        this._forceAbortPromise.catch((e) => null);
      }
      setLogName(logName) {
        this._logName = logName;
      }
      lastIntermediateResult() {
        return this._lastIntermediateResult;
      }
      run(task, timeout) {
        return __async(this, null, function* () {
          if (timeout) {
            this._timeout = timeout;
            this._deadline = timeout ? (0, _utils.monotonicTime)() + timeout : 0;
          }
          (0, _utils.assert)(this._state === "before");
          this._state = "running";
          const progress = {
            log: (message) => {
              progress.logEntry({
                message
              });
            },
            logEntry: (entry) => {
              if ("message" in entry) {
                const message = entry.message;
                if (this._state === "running")
                  this.metadata.log.push(message);
                this.instrumentation.onCallLog(this.sdkObject, this.metadata, this._logName, message);
              }
              if ("intermediateResult" in entry)
                this._lastIntermediateResult = entry.intermediateResult;
            },
            timeUntilDeadline: () => this._deadline ? this._deadline - (0, _utils.monotonicTime)() : 2147483647,
            isRunning: () => this._state === "running",
            cleanupWhenAborted: (cleanup) => {
              if (this._state === "running")
                this._cleanups.push(cleanup);
              else
                runCleanup(cleanup);
            },
            throwIfAborted: () => {
              if (this._state === "aborted")
                throw new AbortedError();
            },
            beforeInputAction: (element) => __async(this, null, function* () {
              yield this.instrumentation.onBeforeInputAction(this.sdkObject, this.metadata, element);
            }),
            metadata: this.metadata
          };
          const timeoutError = new _errors.TimeoutError(`Timeout ${this._timeout}ms exceeded.`);
          const timer = setTimeout(() => this._forceAbortPromise.reject(timeoutError), progress.timeUntilDeadline());
          try {
            const promise = task(progress);
            const result = yield Promise.race([promise, this._forceAbortPromise]);
            this._state = "finished";
            return result;
          } catch (e) {
            this._state = "aborted";
            yield Promise.all(this._cleanups.splice(0).map(runCleanup));
            throw e;
          } finally {
            clearTimeout(timer);
          }
        });
      }
    };
    exports2.ProgressController = ProgressController;
    function runCleanup(cleanup) {
      return __async(this, null, function* () {
        try {
          yield cleanup();
        } catch (e) {
        }
      });
    }
    var AbortedError = class extends Error {
    };
  }
});

// node_modules/playwright-core/lib/server/dom.js
var require_dom = __commonJS({
  "node_modules/playwright-core/lib/server/dom.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.NonRecoverableDOMError = exports2.InjectedScriptPollHandler = exports2.FrameExecutionContext = exports2.ElementHandle = void 0;
    exports2.assertDone = assertDone;
    exports2.isNonRecoverableDOMError = isNonRecoverableDOMError;
    exports2.kUnableToAdoptErrorMessage = void 0;
    exports2.throwRetargetableDOMError = throwRetargetableDOMError;
    exports2.waitForSelectorTask = waitForSelectorTask;
    var mime = _interopRequireWildcard(require_mime());
    var injectedScriptSource = _interopRequireWildcard(require_injectedScriptSource());
    var _protocolError = require_protocolError();
    var js = _interopRequireWildcard(require_javascript());
    var _progress = require_progress2();
    var _utils = require_utils();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var NonRecoverableDOMError = class extends Error {
    };
    exports2.NonRecoverableDOMError = NonRecoverableDOMError;
    function isNonRecoverableDOMError(error) {
      return error instanceof NonRecoverableDOMError;
    }
    var FrameExecutionContext = class extends js.ExecutionContext {
      constructor(delegate, frame, world) {
        super(frame, delegate);
        this.frame = void 0;
        this._injectedScriptPromise = void 0;
        this.world = void 0;
        this.frame = frame;
        this.world = world;
      }
      waitForSignalsCreatedBy(action) {
        return __async(this, null, function* () {
          return this.frame._page._frameManager.waitForSignalsCreatedBy(null, false, action);
        });
      }
      adoptIfNeeded(handle) {
        if (handle instanceof ElementHandle && handle._context !== this)
          return this.frame._page._delegate.adoptElementHandle(handle, this);
        return null;
      }
      evaluate(pageFunction, arg) {
        return __async(this, null, function* () {
          return js.evaluate(this, true, pageFunction, arg);
        });
      }
      evaluateHandle(pageFunction, arg) {
        return __async(this, null, function* () {
          return js.evaluate(this, false, pageFunction, arg);
        });
      }
      evaluateExpression(expression, isFunction, arg) {
        return __async(this, null, function* () {
          return js.evaluateExpression(this, true, expression, isFunction, arg);
        });
      }
      evaluateExpressionAndWaitForSignals(expression, isFunction, arg) {
        return __async(this, null, function* () {
          return yield this.frame._page._frameManager.waitForSignalsCreatedBy(null, false, () => __async(this, null, function* () {
            return this.evaluateExpression(expression, isFunction, arg);
          }));
        });
      }
      evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg) {
        return __async(this, null, function* () {
          return yield this.frame._page._frameManager.waitForSignalsCreatedBy(null, false, () => __async(this, null, function* () {
            return js.evaluateExpression(this, false, expression, isFunction, arg);
          }));
        });
      }
      createHandle(remoteObject) {
        if (this.frame._page._delegate.isElementHandle(remoteObject))
          return new ElementHandle(this, remoteObject.objectId);
        return super.createHandle(remoteObject);
      }
      injectedScript() {
        if (!this._injectedScriptPromise) {
          const custom = [];
          for (const [name, {
            source: source2
          }] of this.frame._page.selectors._engines)
            custom.push(`{ name: '${name}', engine: (${source2}) }`);
          const source = `
        (() => {
        const module = {};
        ${injectedScriptSource.source}
        return new module.exports(
          ${(0, _utils.isUnderTest)()},
          ${this.frame._page._delegate.rafCountForStablePosition()},
          "${this.frame._page._browserContext._browser.options.name}",
          ${(0, _utils.experimentalFeaturesEnabled)()},
          [${custom.join(",\n")}]
        );
        })();
      `;
          this._injectedScriptPromise = this.rawEvaluateHandle(source).then((objectId) => new js.JSHandle(this, "object", void 0, objectId));
        }
        return this._injectedScriptPromise;
      }
      doSlowMo() {
        return __async(this, null, function* () {
          return this.frame._page._doSlowMo();
        });
      }
    };
    exports2.FrameExecutionContext = FrameExecutionContext;
    var ElementHandle = class extends js.JSHandle {
      constructor(context, objectId) {
        super(context, "node", void 0, objectId);
        this._page = void 0;
        this._frame = void 0;
        this._page = context.frame._page;
        this._frame = context.frame;
        this._initializePreview().catch((e) => {
        });
      }
      _initializePreview() {
        return __async(this, null, function* () {
          const utility = yield this._context.injectedScript();
          this._setPreview(yield utility.evaluate((injected, e) => "JSHandle@" + injected.previewNode(e), this));
        });
      }
      asElement() {
        return this;
      }
      evaluateInUtility(pageFunction, arg) {
        return __async(this, null, function* () {
          try {
            const utility = yield this._frame._utilityContext();
            return yield utility.evaluate(pageFunction, [yield utility.injectedScript(), this, arg]);
          } catch (e) {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
              throw e;
            return "error:notconnected";
          }
        });
      }
      evaluateHandleInUtility(pageFunction, arg) {
        return __async(this, null, function* () {
          try {
            const utility = yield this._frame._utilityContext();
            return yield utility.evaluateHandle(pageFunction, [yield utility.injectedScript(), this, arg]);
          } catch (e) {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
              throw e;
            return "error:notconnected";
          }
        });
      }
      evaluatePoll(progress, pageFunction, arg) {
        return __async(this, null, function* () {
          try {
            const utility = yield this._frame._utilityContext();
            const poll = yield utility.evaluateHandle(pageFunction, [yield utility.injectedScript(), this, arg]);
            const pollHandler = new InjectedScriptPollHandler(progress, poll);
            return yield pollHandler.finish();
          } catch (e) {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
              throw e;
            return "error:notconnected";
          }
        });
      }
      ownerFrame() {
        return __async(this, null, function* () {
          const frameId = yield this._page._delegate.getOwnerFrame(this);
          if (!frameId)
            return null;
          const frame = this._page._frameManager.frame(frameId);
          if (frame)
            return frame;
          for (const page of this._page._browserContext.pages()) {
            const frame2 = page._frameManager.frame(frameId);
            if (frame2)
              return frame2;
          }
          return null;
        });
      }
      isIframeElement() {
        return __async(this, null, function* () {
          return this.evaluateInUtility(([injected, node]) => node && (node.nodeName === "IFRAME" || node.nodeName === "FRAME"), {});
        });
      }
      contentFrame() {
        return __async(this, null, function* () {
          const isFrameElement = throwRetargetableDOMError(yield this.isIframeElement());
          if (!isFrameElement)
            return null;
          return this._page._delegate.getContentFrame(this);
        });
      }
      getAttribute(name) {
        return __async(this, null, function* () {
          return throwRetargetableDOMError(yield this.evaluateInUtility(([injected, node, name2]) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
              throw injected.createStacklessError("Node is not an element");
            const element = node;
            return {
              value: element.getAttribute(name2)
            };
          }, name)).value;
        });
      }
      inputValue() {
        return __async(this, null, function* () {
          return throwRetargetableDOMError(yield this.evaluateInUtility(([injected, node]) => {
            const element = injected.retarget(node, "follow-label");
            if (!element || element.nodeName !== "INPUT" && element.nodeName !== "TEXTAREA" && element.nodeName !== "SELECT")
              throw injected.createStacklessError("Node is not an <input>, <textarea> or <select> element");
            return {
              value: element.value
            };
          }, void 0)).value;
        });
      }
      textContent() {
        return __async(this, null, function* () {
          return throwRetargetableDOMError(yield this.evaluateInUtility(([injected, node]) => {
            return {
              value: node.textContent
            };
          }, void 0)).value;
        });
      }
      innerText() {
        return __async(this, null, function* () {
          return throwRetargetableDOMError(yield this.evaluateInUtility(([injected, node]) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
              throw injected.createStacklessError("Node is not an element");
            if (node.namespaceURI !== "http://www.w3.org/1999/xhtml")
              throw injected.createStacklessError("Node is not an HTMLElement");
            const element = node;
            return {
              value: element.innerText
            };
          }, void 0)).value;
        });
      }
      innerHTML() {
        return __async(this, null, function* () {
          return throwRetargetableDOMError(yield this.evaluateInUtility(([injected, node]) => {
            if (node.nodeType !== Node.ELEMENT_NODE)
              throw injected.createStacklessError("Node is not an element");
            const element = node;
            return {
              value: element.innerHTML
            };
          }, void 0)).value;
        });
      }
      dispatchEvent(_0) {
        return __async(this, arguments, function* (type, eventInit = {}) {
          const main = yield this._frame._mainContext();
          yield this._page._frameManager.waitForSignalsCreatedBy(null, false, () => __async(this, null, function* () {
            return main.evaluate(([injected, node, {
              type: type2,
              eventInit: eventInit2
            }]) => injected.dispatchEvent(node, type2, eventInit2), [yield main.injectedScript(), this, {
              type,
              eventInit
            }]);
          }));
          yield this._page._doSlowMo();
        });
      }
      _scrollRectIntoViewIfNeeded(rect) {
        return __async(this, null, function* () {
          return yield this._page._delegate.scrollRectIntoViewIfNeeded(this, rect);
        });
      }
      _waitAndScrollIntoViewIfNeeded(progress) {
        return __async(this, null, function* () {
          while (progress.isRunning()) {
            assertDone(throwRetargetableDOMError(yield this._waitForDisplayedAtStablePosition(progress, false, false)));
            progress.throwIfAborted();
            const result = throwRetargetableDOMError(yield this._scrollRectIntoViewIfNeeded());
            if (result === "error:notvisible")
              continue;
            assertDone(result);
            return;
          }
        });
      }
      scrollIntoViewIfNeeded(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => this._waitAndScrollIntoViewIfNeeded(progress), this._page._timeoutSettings.timeout(options));
        });
      }
      _clickablePoint() {
        return __async(this, null, function* () {
          const intersectQuadWithViewport = (quad) => {
            return quad.map((point) => ({
              x: Math.min(Math.max(point.x, 0), metrics.width),
              y: Math.min(Math.max(point.y, 0), metrics.height)
            }));
          };
          const computeQuadArea = (quad) => {
            let area = 0;
            for (let i = 0; i < quad.length; ++i) {
              const p1 = quad[i];
              const p2 = quad[(i + 1) % quad.length];
              area += (p1.x * p2.y - p2.x * p1.y) / 2;
            }
            return Math.abs(area);
          };
          const [quads, metrics] = yield Promise.all([this._page._delegate.getContentQuads(this), this._page.mainFrame()._utilityContext().then((utility) => utility.evaluate(() => ({
            width: innerWidth,
            height: innerHeight
          })))]);
          if (!quads || !quads.length)
            return "error:notvisible";
          const filtered = quads.map((quad) => intersectQuadWithViewport(quad)).filter((quad) => computeQuadArea(quad) > 0.99);
          if (!filtered.length)
            return "error:notinviewport";
          const result = {
            x: 0,
            y: 0
          };
          for (const point of filtered[0]) {
            result.x += point.x / 4;
            result.y += point.y / 4;
          }
          compensateHalfIntegerRoundingError(result);
          return result;
        });
      }
      _offsetPoint(offset) {
        return __async(this, null, function* () {
          const [box, border] = yield Promise.all([this.boundingBox(), this.evaluateInUtility(([injected, node]) => injected.getElementBorderWidth(node), {}).catch((e) => {
          })]);
          if (!box || !border)
            return "error:notvisible";
          if (border === "error:notconnected")
            return border;
          return {
            x: box.x + border.left + offset.x,
            y: box.y + border.top + offset.y
          };
        });
      }
      _retryPointerAction(progress, actionName, waitForEnabled, action, options) {
        return __async(this, null, function* () {
          let retry = 0;
          const waitTime = [0, 20, 100, 100, 500];
          const scrollOptions = [void 0, {
            block: "end",
            inline: "end"
          }, {
            block: "center",
            inline: "center"
          }, {
            block: "start",
            inline: "start"
          }];
          while (progress.isRunning()) {
            if (retry) {
              progress.log(`retrying ${actionName} action${options.trial ? " (trial run)" : ""}, attempt #${retry}`);
              const timeout = waitTime[Math.min(retry - 1, waitTime.length - 1)];
              if (timeout) {
                progress.log(`  waiting ${timeout}ms`);
                const result2 = yield this.evaluateInUtility(([injected, node, timeout2]) => new Promise((f) => setTimeout(f, timeout2)), timeout);
                if (result2 === "error:notconnected")
                  return result2;
              }
            } else {
              progress.log(`attempting ${actionName} action${options.trial ? " (trial run)" : ""}`);
            }
            const forceScrollOptions = scrollOptions[retry % scrollOptions.length];
            const result = yield this._performPointerAction(progress, actionName, waitForEnabled, action, forceScrollOptions, options);
            ++retry;
            if (result === "error:notvisible") {
              if (options.force)
                throw new NonRecoverableDOMError("Element is not visible");
              progress.log("  element is not visible");
              continue;
            }
            if (result === "error:notinviewport") {
              if (options.force)
                throw new NonRecoverableDOMError("Element is outside of the viewport");
              progress.log("  element is outside of the viewport");
              continue;
            }
            if (typeof result === "object" && "hitTargetDescription" in result) {
              progress.log(`  ${result.hitTargetDescription} intercepts pointer events`);
              continue;
            }
            return result;
          }
          return "done";
        });
      }
      _performPointerAction(progress, actionName, waitForEnabled, action, forceScrollOptions, options) {
        return __async(this, null, function* () {
          const {
            force = false,
            position
          } = options;
          if (options.__testHookBeforeStable)
            yield options.__testHookBeforeStable();
          const result = yield this._waitForDisplayedAtStablePosition(progress, force, waitForEnabled);
          if (result !== "done")
            return result;
          if (options.__testHookAfterStable)
            yield options.__testHookAfterStable();
          progress.log("  scrolling into view if needed");
          progress.throwIfAborted();
          if (forceScrollOptions) {
            const scrolled = yield this.evaluateInUtility(([injected, node, options2]) => {
              if (node.nodeType === 1)
                node.scrollIntoView(options2);
            }, forceScrollOptions);
            if (scrolled === "error:notconnected")
              return scrolled;
          } else {
            const scrolled = yield this._scrollRectIntoViewIfNeeded(position ? {
              x: position.x,
              y: position.y,
              width: 0,
              height: 0
            } : void 0);
            if (scrolled !== "done")
              return scrolled;
          }
          progress.log("  done scrolling");
          const maybePoint = position ? yield this._offsetPoint(position) : yield this._clickablePoint();
          if (typeof maybePoint === "string")
            return maybePoint;
          const point = roundPoint(maybePoint);
          progress.metadata.point = point;
          yield progress.beforeInputAction(this);
          let hitTargetInterceptionHandle;
          if (!options.force) {
            if (options.__testHookBeforeHitTarget)
              yield options.__testHookBeforeHitTarget();
            if (actionName === "move and up") {
              progress.log(`  checking that element receives pointer events at (${point.x},${point.y})`);
              const hitTargetResult = yield this._checkHitTargetAt(point);
              if (hitTargetResult !== "done")
                return hitTargetResult;
              progress.log(`  element does receive pointer events`);
              if (options.trial) {
                progress.log(`  trial ${actionName} has finished`);
                return "done";
              }
            } else {
              const actionType = actionName === "hover" || actionName === "tap" ? actionName : "mouse";
              const handle = yield this.evaluateHandleInUtility(([injected, node, {
                actionType: actionType2,
                trial
              }]) => injected.setupHitTargetInterceptor(node, actionType2, trial), {
                actionType,
                trial: !!options.trial
              });
              if (handle === "error:notconnected")
                return handle;
              if (!handle._objectId)
                return handle.rawValue();
              hitTargetInterceptionHandle = handle;
              progress.cleanupWhenAborted(() => {
                hitTargetInterceptionHandle.evaluate((h) => h.stop()).catch((e) => {
                });
              });
            }
          }
          const actionResult = yield this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, () => __async(this, null, function* () {
            if (options.__testHookBeforePointerAction)
              yield options.__testHookBeforePointerAction();
            progress.throwIfAborted();
            let restoreModifiers;
            if (options && options.modifiers)
              restoreModifiers = yield this._page.keyboard._ensureModifiers(options.modifiers);
            progress.log(`  performing ${actionName} action`);
            yield action(point);
            if (restoreModifiers)
              yield this._page.keyboard._ensureModifiers(restoreModifiers);
            if (hitTargetInterceptionHandle) {
              const stopHitTargetInterception = hitTargetInterceptionHandle.evaluate((h) => h.stop()).catch((e) => "done");
              if (!options.noWaitAfter) {
                const hitTargetResult = yield stopHitTargetInterception;
                if (hitTargetResult !== "done")
                  return hitTargetResult;
              }
            }
            progress.log(`  ${options.trial ? "trial " : ""}${actionName} action done`);
            progress.log("  waiting for scheduled navigations to finish");
            if (options.__testHookAfterPointerAction)
              yield options.__testHookAfterPointerAction();
            return "done";
          }), "input");
          if (actionResult !== "done")
            return actionResult;
          progress.log("  navigations have finished");
          return "done";
        });
      }
      hover(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._hover(progress, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _hover(progress, options) {
        return this._retryPointerAction(progress, "hover", false, (point) => this._page.mouse.move(point.x, point.y), options);
      }
      click(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._click(progress, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _click(progress, options) {
        return this._retryPointerAction(progress, "click", true, (point) => this._page.mouse.click(point.x, point.y, options), options);
      }
      dblclick(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._dblclick(progress, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _dblclick(progress, options) {
        return this._retryPointerAction(progress, "dblclick", true, (point) => this._page.mouse.dblclick(point.x, point.y, options), options);
      }
      tap(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._tap(progress, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _tap(progress, options) {
        return this._retryPointerAction(progress, "tap", true, (point) => this._page.touchscreen.tap(point.x, point.y), options);
      }
      selectOption(metadata, elements, values, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._selectOption(progress, elements, values, options);
            return throwRetargetableDOMError(result);
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _selectOption(progress, elements, values, options) {
        return __async(this, null, function* () {
          const optionsToSelect = [...elements, ...values];
          yield progress.beforeInputAction(this);
          return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, () => __async(this, null, function* () {
            progress.throwIfAborted();
            progress.log("  selecting specified option(s)");
            const result = yield this.evaluatePoll(progress, ([injected, node, {
              optionsToSelect: optionsToSelect2,
              force
            }]) => {
              return injected.waitForElementStatesAndPerformAction(node, ["visible", "enabled"], force, injected.selectOptions.bind(injected, optionsToSelect2));
            }, {
              optionsToSelect,
              force: options.force
            });
            yield this._page._doSlowMo();
            return result;
          }));
        });
      }
      fill(_0, _1) {
        return __async(this, arguments, function* (metadata, value, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._fill(progress, value, options);
            assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _fill(progress, value, options) {
        return __async(this, null, function* () {
          progress.log(`elementHandle.fill("${value}")`);
          yield progress.beforeInputAction(this);
          return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, () => __async(this, null, function* () {
            progress.log("  waiting for element to be visible, enabled and editable");
            const filled = yield this.evaluatePoll(progress, ([injected, node, {
              value: value2,
              force
            }]) => {
              return injected.waitForElementStatesAndPerformAction(node, ["visible", "enabled", "editable"], force, injected.fill.bind(injected, value2));
            }, {
              value,
              force: options.force
            });
            progress.throwIfAborted();
            if (filled === "error:notconnected")
              return filled;
            progress.log("  element is visible, enabled and editable");
            if (filled === "needsinput") {
              progress.throwIfAborted();
              if (value)
                yield this._page.keyboard.insertText(value);
              else
                yield this._page.keyboard.press("Delete");
            } else {
              assertDone(filled);
            }
            return "done";
          }), "input");
        });
      }
      selectText(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            progress.throwIfAborted();
            const result = yield this.evaluatePoll(progress, ([injected, node, force]) => {
              return injected.waitForElementStatesAndPerformAction(node, ["visible"], force, injected.selectText.bind(injected));
            }, options.force);
            assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      setInputFiles(metadata, items, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._setInputFiles(progress, items, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _setInputFiles(progress, items, options) {
        return __async(this, null, function* () {
          const {
            files,
            localPaths
          } = items;
          if (files) {
            for (const payload of files) {
              if (!payload.mimeType)
                payload.mimeType = mime.getType(payload.name) || "application/octet-stream";
            }
          }
          const multiple = files && files.length > 1 || localPaths && localPaths.length > 1;
          const result = yield this.evaluateHandleInUtility(([injected, node, multiple2]) => {
            const element = injected.retarget(node, "follow-label");
            if (!element)
              return;
            if (element.tagName !== "INPUT")
              throw injected.createStacklessError("Node is not an HTMLInputElement");
            if (multiple2 && !element.multiple)
              throw injected.createStacklessError("Non-multiple file input can only accept single file");
            return element;
          }, multiple);
          if (result === "error:notconnected" || !result.asElement())
            return "error:notconnected";
          const retargeted = result.asElement();
          yield progress.beforeInputAction(this);
          yield this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, () => __async(this, null, function* () {
            progress.throwIfAborted();
            if (localPaths)
              yield this._page._delegate.setInputFilePaths(retargeted, localPaths);
            else
              yield this._page._delegate.setInputFiles(retargeted, files);
          }));
          yield this._page._doSlowMo();
          return "done";
        });
      }
      focus(metadata) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          yield controller.run((progress) => __async(this, null, function* () {
            const result = yield this._focus(progress);
            yield this._page._doSlowMo();
            return assertDone(throwRetargetableDOMError(result));
          }), 0);
        });
      }
      _focus(progress, resetSelectionIfNotFocused) {
        return __async(this, null, function* () {
          progress.throwIfAborted();
          return yield this.evaluateInUtility(([injected, node, resetSelectionIfNotFocused2]) => injected.focusNode(node, resetSelectionIfNotFocused2), resetSelectionIfNotFocused);
        });
      }
      type(metadata, text, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._type(progress, text, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _type(progress, text, options) {
        return __async(this, null, function* () {
          progress.log(`elementHandle.type("${text}")`);
          yield progress.beforeInputAction(this);
          return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, () => __async(this, null, function* () {
            const result = yield this._focus(progress, true);
            if (result !== "done")
              return result;
            progress.throwIfAborted();
            yield this._page.keyboard.type(text, options);
            return "done";
          }), "input");
        });
      }
      press(metadata, key, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._press(progress, key, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _press(progress, key, options) {
        return __async(this, null, function* () {
          progress.log(`elementHandle.press("${key}")`);
          yield progress.beforeInputAction(this);
          return this._page._frameManager.waitForSignalsCreatedBy(progress, options.noWaitAfter, () => __async(this, null, function* () {
            const result = yield this._focus(progress, true);
            if (result !== "done")
              return result;
            progress.throwIfAborted();
            yield this._page.keyboard.press(key, options);
            return "done";
          }), "input");
        });
      }
      check(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._setChecked(progress, true, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      uncheck(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            const result = yield this._setChecked(progress, false, options);
            return assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _setChecked(progress, state, options) {
        return __async(this, null, function* () {
          const isChecked = () => __async(this, null, function* () {
            const result2 = yield this.evaluateInUtility(([injected, node]) => injected.elementState(node, "checked"), {});
            return throwRetargetableDOMError(result2);
          });
          if ((yield isChecked()) === state)
            return "done";
          const result = yield this._click(progress, options);
          if (result !== "done")
            return result;
          if (options.trial)
            return "done";
          if ((yield isChecked()) !== state)
            throw new NonRecoverableDOMError("Clicking the checkbox did not change its state");
          return "done";
        });
      }
      boundingBox() {
        return __async(this, null, function* () {
          return this._page._delegate.getBoundingBox(this);
        });
      }
      screenshot(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => this._page._screenshotter.screenshotElement(progress, this, options), this._page._timeoutSettings.timeout(options));
        });
      }
      querySelector(selector, options) {
        return __async(this, null, function* () {
          const pair = yield this._frame.resolveFrameForSelectorNoWait(selector, options, this);
          if (!pair)
            return null;
          const {
            frame,
            info
          } = pair;
          return this._page.selectors.query(frame, info, this._frame === frame ? this : void 0);
        });
      }
      querySelectorAll(selector) {
        return __async(this, null, function* () {
          const pair = yield this._frame.resolveFrameForSelectorNoWait(selector, {}, this);
          if (!pair)
            return [];
          const {
            frame,
            info
          } = pair;
          return this._page.selectors._queryAll(frame, info, this._frame === frame ? this : void 0, true);
        });
      }
      evalOnSelectorAndWaitForSignals(selector, strict, expression, isFunction, arg) {
        return __async(this, null, function* () {
          const pair = yield this._frame.resolveFrameForSelectorNoWait(selector, {
            strict
          }, this);
          const handle = pair ? yield this._page.selectors.query(pair.frame, pair.info, this._frame === pair.frame ? this : void 0) : null;
          if (!handle)
            throw new Error(`Error: failed to find element matching selector "${selector}"`);
          const result = yield handle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
          handle.dispose();
          return result;
        });
      }
      evalOnSelectorAllAndWaitForSignals(selector, expression, isFunction, arg) {
        return __async(this, null, function* () {
          const pair = yield this._frame.resolveFrameForSelectorNoWait(selector, {}, this);
          if (!pair)
            throw new Error(`Error: failed to find frame for selector "${selector}"`);
          const {
            frame,
            info
          } = pair;
          const arrayHandle = yield this._page.selectors._queryArrayInMainWorld(frame, info, this._frame === frame ? this : void 0);
          const result = yield arrayHandle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
          arrayHandle.dispose();
          return result;
        });
      }
      isVisible() {
        return __async(this, null, function* () {
          const result = yield this.evaluateInUtility(([injected, node]) => injected.elementState(node, "visible"), {});
          if (result === "error:notconnected")
            return false;
          return result;
        });
      }
      isHidden() {
        return __async(this, null, function* () {
          const result = yield this.evaluateInUtility(([injected, node]) => injected.elementState(node, "hidden"), {});
          return throwRetargetableDOMError(result);
        });
      }
      isEnabled() {
        return __async(this, null, function* () {
          const result = yield this.evaluateInUtility(([injected, node]) => injected.elementState(node, "enabled"), {});
          return throwRetargetableDOMError(result);
        });
      }
      isDisabled() {
        return __async(this, null, function* () {
          const result = yield this.evaluateInUtility(([injected, node]) => injected.elementState(node, "disabled"), {});
          return throwRetargetableDOMError(result);
        });
      }
      isEditable() {
        return __async(this, null, function* () {
          const result = yield this.evaluateInUtility(([injected, node]) => injected.elementState(node, "editable"), {});
          return throwRetargetableDOMError(result);
        });
      }
      isChecked() {
        return __async(this, null, function* () {
          const result = yield this.evaluateInUtility(([injected, node]) => injected.elementState(node, "checked"), {});
          return throwRetargetableDOMError(result);
        });
      }
      waitForElementState(_0, _1) {
        return __async(this, arguments, function* (metadata, state, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            progress.log(`  waiting for element to be ${state}`);
            const result = yield this.evaluatePoll(progress, ([injected, node, state2]) => {
              return injected.waitForElementStatesAndPerformAction(node, [state2], false, () => "done");
            }, state);
            assertDone(throwRetargetableDOMError(result));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      waitForSelector(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._frame.waitForSelector(metadata, selector, options, this);
        });
      }
      _adoptTo(context) {
        return __async(this, null, function* () {
          if (this._context !== context) {
            const adopted = yield this._page._delegate.adoptElementHandle(this, context);
            this.dispose();
            return adopted;
          }
          return this;
        });
      }
      _waitForDisplayedAtStablePosition(progress, force, waitForEnabled) {
        return __async(this, null, function* () {
          if (waitForEnabled)
            progress.log(`  waiting for element to be visible, enabled and stable`);
          else
            progress.log(`  waiting for element to be visible and stable`);
          const result = yield this.evaluatePoll(progress, ([injected, node, {
            waitForEnabled: waitForEnabled2,
            force: force2
          }]) => {
            return injected.waitForElementStatesAndPerformAction(node, waitForEnabled2 ? ["visible", "stable", "enabled"] : ["visible", "stable"], force2, () => "done");
          }, {
            waitForEnabled,
            force
          });
          if (result === "error:notconnected")
            return result;
          if (waitForEnabled)
            progress.log("  element is visible, enabled and stable");
          else
            progress.log("  element is visible and stable");
          return result;
        });
      }
      _checkHitTargetAt(point) {
        return __async(this, null, function* () {
          const frame = yield this.ownerFrame();
          if (frame && frame.parentFrame()) {
            const element = yield frame.frameElement();
            const box = yield element.boundingBox();
            if (!box)
              return "error:notconnected";
            point = {
              x: point.x - box.x,
              y: point.y - box.y
            };
          }
          return this.evaluateInUtility(([injected, node, point2]) => injected.checkHitTargetAt(node, point2), point);
        });
      }
    };
    exports2.ElementHandle = ElementHandle;
    var InjectedScriptPollHandler = class {
      constructor(progress, poll) {
        this._progress = void 0;
        this._poll = void 0;
        this._progress = progress;
        this._poll = poll;
        this._progress.cleanupWhenAborted(() => this.cancel());
        this._streamLogs();
      }
      _streamLogs() {
        return __async(this, null, function* () {
          while (this._poll && this._progress.isRunning()) {
            const log = yield this._poll.evaluate((poll) => poll.takeNextLogs()).catch((e) => []);
            if (!this._poll || !this._progress.isRunning())
              return;
            for (const entry of log)
              this._progress.logEntry(entry);
          }
        });
      }
      finishHandle() {
        return __async(this, null, function* () {
          try {
            const result = yield this._poll.evaluateHandle((poll) => poll.run());
            yield this._finishInternal();
            return result;
          } finally {
            yield this.cancel();
          }
        });
      }
      finish() {
        return __async(this, null, function* () {
          try {
            const result = yield this._poll.evaluate((poll) => poll.run());
            yield this._finishInternal();
            return result;
          } finally {
            yield this.cancel();
          }
        });
      }
      _finishInternal() {
        return __async(this, null, function* () {
          if (!this._poll)
            return;
          const log = yield this._poll.evaluate((poll) => poll.takeLastLogs()).catch((e) => []);
          for (const entry of log)
            this._progress.logEntry(entry);
        });
      }
      cancel() {
        return __async(this, null, function* () {
          if (!this._poll)
            return;
          const copy = this._poll;
          this._poll = null;
          yield copy.evaluate((p) => p.cancel()).catch((e) => {
          });
          copy.dispose();
        });
      }
    };
    exports2.InjectedScriptPollHandler = InjectedScriptPollHandler;
    function throwRetargetableDOMError(result) {
      if (result === "error:notconnected")
        throw new Error("Element is not attached to the DOM");
      return result;
    }
    function assertDone(result) {
    }
    function roundPoint(point) {
      return {
        x: (point.x * 100 | 0) / 100,
        y: (point.y * 100 | 0) / 100
      };
    }
    function compensateHalfIntegerRoundingError(point) {
      const remainderX = point.x - Math.floor(point.x);
      if (remainderX > 0.49 && remainderX < 0.51)
        point.x -= 0.02;
      const remainderY = point.y - Math.floor(point.y);
      if (remainderY > 0.49 && remainderY < 0.51)
        point.y -= 0.02;
    }
    function waitForSelectorTask(selector, state, omitReturnValue, root) {
      return (injectedScript) => injectedScript.evaluateHandle((injected, {
        parsed,
        strict,
        state: state2,
        omitReturnValue: omitReturnValue2,
        root: root2
      }) => {
        let lastElement;
        return injected.pollRaf((progress) => {
          const elements = injected.querySelectorAll(parsed, root2 || document);
          let element = elements[0];
          const visible = element ? injected.isVisible(element) : false;
          if (lastElement !== element) {
            lastElement = element;
            if (!element) {
              progress.log(`  selector did not resolve to any element`);
            } else {
              if (elements.length > 1) {
                if (strict)
                  throw injected.strictModeViolationError(parsed, elements);
                progress.log(`  selector resolved to ${elements.length} elements. Proceeding with the first one.`);
              }
              progress.log(`  selector resolved to ${visible ? "visible" : "hidden"} ${injected.previewNode(element)}`);
            }
          }
          const hasElement = !!element;
          if (omitReturnValue2)
            element = void 0;
          switch (state2) {
            case "attached":
              return hasElement ? element : progress.continuePolling;
            case "detached":
              return !hasElement ? void 0 : progress.continuePolling;
            case "visible":
              return visible ? element : progress.continuePolling;
            case "hidden":
              return !visible ? void 0 : progress.continuePolling;
          }
        });
      }, {
        parsed: selector.parsed,
        strict: selector.strict,
        state,
        omitReturnValue,
        root
      });
    }
    var kUnableToAdoptErrorMessage = "Unable to adopt element handle from a different document";
    exports2.kUnableToAdoptErrorMessage = kUnableToAdoptErrorMessage;
  }
});

// node_modules/playwright-core/lib/server/types.js
var require_types = __commonJS({
  "node_modules/playwright-core/lib/server/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.reducedMotions = exports2.mediaTypes = exports2.kLifecycleEvents = exports2.forcedColors = exports2.colorSchemes = void 0;
    var kLifecycleEvents = /* @__PURE__ */ new Set(["load", "domcontentloaded", "networkidle", "commit"]);
    exports2.kLifecycleEvents = kLifecycleEvents;
    var mediaTypes = /* @__PURE__ */ new Set(["screen", "print"]);
    exports2.mediaTypes = mediaTypes;
    var colorSchemes = /* @__PURE__ */ new Set(["dark", "light", "no-preference"]);
    exports2.colorSchemes = colorSchemes;
    var reducedMotions = /* @__PURE__ */ new Set(["no-preference", "reduce"]);
    exports2.reducedMotions = reducedMotions;
    var forcedColors = /* @__PURE__ */ new Set(["active", "none"]);
    exports2.forcedColors = forcedColors;
  }
});

// node_modules/playwright-core/lib/server/isomorphic/cssTokenizer.js
var require_cssTokenizer = __commonJS({
  "node_modules/playwright-core/lib/server/isomorphic/cssTokenizer.js"(exports2) {
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        define(["exports"], factory);
      } else if (typeof exports2 !== "undefined") {
        factory(exports2);
      } else {
        factory(root);
      }
    })(exports2, function(exports3) {
      var between = function(num, first, last) {
        return num >= first && num <= last;
      };
      function digit(code) {
        return between(code, 48, 57);
      }
      function hexdigit(code) {
        return digit(code) || between(code, 65, 70) || between(code, 97, 102);
      }
      function uppercaseletter(code) {
        return between(code, 65, 90);
      }
      function lowercaseletter(code) {
        return between(code, 97, 122);
      }
      function letter(code) {
        return uppercaseletter(code) || lowercaseletter(code);
      }
      function nonascii(code) {
        return code >= 128;
      }
      function namestartchar(code) {
        return letter(code) || nonascii(code) || code == 95;
      }
      function namechar(code) {
        return namestartchar(code) || digit(code) || code == 45;
      }
      function nonprintable(code) {
        return between(code, 0, 8) || code == 11 || between(code, 14, 31) || code == 127;
      }
      function newline(code) {
        return code == 10;
      }
      function whitespace(code) {
        return newline(code) || code == 9 || code == 32;
      }
      function badescape(code) {
        return newline(code) || isNaN(code);
      }
      var maximumallowedcodepoint = 1114111;
      var InvalidCharacterError = function(message) {
        this.message = message;
      };
      InvalidCharacterError.prototype = new Error();
      InvalidCharacterError.prototype.name = "InvalidCharacterError";
      function preprocess(str) {
        var codepoints = [];
        for (var i = 0; i < str.length; i++) {
          var code = str.charCodeAt(i);
          if (code == 13 && str.charCodeAt(i + 1) == 10) {
            code = 10;
            i++;
          }
          if (code == 13 || code == 12)
            code = 10;
          if (code == 0)
            code = 65533;
          if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {
            var lead = code - 55296;
            var trail = str.charCodeAt(i + 1) - 56320;
            code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;
            i++;
          }
          codepoints.push(code);
        }
        return codepoints;
      }
      function stringFromCode(code) {
        if (code <= 65535)
          return String.fromCharCode(code);
        code -= Math.pow(2, 16);
        var lead = Math.floor(code / Math.pow(2, 10)) + 55296;
        var trail = code % Math.pow(2, 10) + 56320;
        return String.fromCharCode(lead) + String.fromCharCode(trail);
      }
      function tokenize(str) {
        str = preprocess(str);
        var i = -1;
        var tokens = [];
        var code;
        var line = 0;
        var column = 0;
        var lastLineLength = 0;
        var incrLineno = function() {
          line += 1;
          lastLineLength = column;
          column = 0;
        };
        var locStart = { line, column };
        var codepoint = function(i2) {
          if (i2 >= str.length) {
            return -1;
          }
          return str[i2];
        };
        var next = function(num) {
          if (num === void 0)
            num = 1;
          if (num > 3)
            throw "Spec Error: no more than three codepoints of lookahead.";
          return codepoint(i + num);
        };
        var consume = function(num) {
          if (num === void 0)
            num = 1;
          i += num;
          code = codepoint(i);
          if (newline(code))
            incrLineno();
          else
            column += num;
          return true;
        };
        var reconsume = function() {
          i -= 1;
          if (newline(code)) {
            line -= 1;
            column = lastLineLength;
          } else {
            column -= 1;
          }
          locStart.line = line;
          locStart.column = column;
          return true;
        };
        var eof = function(codepoint2) {
          if (codepoint2 === void 0)
            codepoint2 = code;
          return codepoint2 == -1;
        };
        var donothing = function() {
        };
        var parseerror = function() {
          console.log("Parse error at index " + i + ", processing codepoint 0x" + code.toString(16) + ".");
          return true;
        };
        var consumeAToken = function() {
          consumeComments();
          consume();
          if (whitespace(code)) {
            while (whitespace(next()))
              consume();
            return new WhitespaceToken();
          } else if (code == 34)
            return consumeAStringToken();
          else if (code == 35) {
            if (namechar(next()) || areAValidEscape(next(1), next(2))) {
              var token = new HashToken();
              if (wouldStartAnIdentifier(next(1), next(2), next(3)))
                token.type = "id";
              token.value = consumeAName();
              return token;
            } else {
              return new DelimToken(code);
            }
          } else if (code == 36) {
            if (next() == 61) {
              consume();
              return new SuffixMatchToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 39)
            return consumeAStringToken();
          else if (code == 40)
            return new OpenParenToken();
          else if (code == 41)
            return new CloseParenToken();
          else if (code == 42) {
            if (next() == 61) {
              consume();
              return new SubstringMatchToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 43) {
            if (startsWithANumber()) {
              reconsume();
              return consumeANumericToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 44)
            return new CommaToken();
          else if (code == 45) {
            if (startsWithANumber()) {
              reconsume();
              return consumeANumericToken();
            } else if (next(1) == 45 && next(2) == 62) {
              consume(2);
              return new CDCToken();
            } else if (startsWithAnIdentifier()) {
              reconsume();
              return consumeAnIdentlikeToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 46) {
            if (startsWithANumber()) {
              reconsume();
              return consumeANumericToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 58)
            return new ColonToken();
          else if (code == 59)
            return new SemicolonToken();
          else if (code == 60) {
            if (next(1) == 33 && next(2) == 45 && next(3) == 45) {
              consume(3);
              return new CDOToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 64) {
            if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
              return new AtKeywordToken(consumeAName());
            } else {
              return new DelimToken(code);
            }
          } else if (code == 91)
            return new OpenSquareToken();
          else if (code == 92) {
            if (startsWithAValidEscape()) {
              reconsume();
              return consumeAnIdentlikeToken();
            } else {
              parseerror();
              return new DelimToken(code);
            }
          } else if (code == 93)
            return new CloseSquareToken();
          else if (code == 94) {
            if (next() == 61) {
              consume();
              return new PrefixMatchToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 123)
            return new OpenCurlyToken();
          else if (code == 124) {
            if (next() == 61) {
              consume();
              return new DashMatchToken();
            } else if (next() == 124) {
              consume();
              return new ColumnToken();
            } else {
              return new DelimToken(code);
            }
          } else if (code == 125)
            return new CloseCurlyToken();
          else if (code == 126) {
            if (next() == 61) {
              consume();
              return new IncludeMatchToken();
            } else {
              return new DelimToken(code);
            }
          } else if (digit(code)) {
            reconsume();
            return consumeANumericToken();
          } else if (namestartchar(code)) {
            reconsume();
            return consumeAnIdentlikeToken();
          } else if (eof())
            return new EOFToken();
          else
            return new DelimToken(code);
        };
        var consumeComments = function() {
          while (next(1) == 47 && next(2) == 42) {
            consume(2);
            while (true) {
              consume();
              if (code == 42 && next() == 47) {
                consume();
                break;
              } else if (eof()) {
                parseerror();
                return;
              }
            }
          }
        };
        var consumeANumericToken = function() {
          var num = consumeANumber();
          if (wouldStartAnIdentifier(next(1), next(2), next(3))) {
            var token = new DimensionToken();
            token.value = num.value;
            token.repr = num.repr;
            token.type = num.type;
            token.unit = consumeAName();
            return token;
          } else if (next() == 37) {
            consume();
            var token = new PercentageToken();
            token.value = num.value;
            token.repr = num.repr;
            return token;
          } else {
            var token = new NumberToken();
            token.value = num.value;
            token.repr = num.repr;
            token.type = num.type;
            return token;
          }
        };
        var consumeAnIdentlikeToken = function() {
          var str2 = consumeAName();
          if (str2.toLowerCase() == "url" && next() == 40) {
            consume();
            while (whitespace(next(1)) && whitespace(next(2)))
              consume();
            if (next() == 34 || next() == 39) {
              return new FunctionToken(str2);
            } else if (whitespace(next()) && (next(2) == 34 || next(2) == 39)) {
              return new FunctionToken(str2);
            } else {
              return consumeAURLToken();
            }
          } else if (next() == 40) {
            consume();
            return new FunctionToken(str2);
          } else {
            return new IdentToken(str2);
          }
        };
        var consumeAStringToken = function(endingCodePoint) {
          if (endingCodePoint === void 0)
            endingCodePoint = code;
          var string = "";
          while (consume()) {
            if (code == endingCodePoint || eof()) {
              return new StringToken(string);
            } else if (newline(code)) {
              parseerror();
              reconsume();
              return new BadStringToken();
            } else if (code == 92) {
              if (eof(next())) {
                donothing();
              } else if (newline(next())) {
                consume();
              } else {
                string += stringFromCode(consumeEscape());
              }
            } else {
              string += stringFromCode(code);
            }
          }
        };
        var consumeAURLToken = function() {
          var token = new URLToken("");
          while (whitespace(next()))
            consume();
          if (eof(next()))
            return token;
          while (consume()) {
            if (code == 41 || eof()) {
              return token;
            } else if (whitespace(code)) {
              while (whitespace(next()))
                consume();
              if (next() == 41 || eof(next())) {
                consume();
                return token;
              } else {
                consumeTheRemnantsOfABadURL();
                return new BadURLToken();
              }
            } else if (code == 34 || code == 39 || code == 40 || nonprintable(code)) {
              parseerror();
              consumeTheRemnantsOfABadURL();
              return new BadURLToken();
            } else if (code == 92) {
              if (startsWithAValidEscape()) {
                token.value += stringFromCode(consumeEscape());
              } else {
                parseerror();
                consumeTheRemnantsOfABadURL();
                return new BadURLToken();
              }
            } else {
              token.value += stringFromCode(code);
            }
          }
        };
        var consumeEscape = function() {
          consume();
          if (hexdigit(code)) {
            var digits = [code];
            for (var total = 0; total < 5; total++) {
              if (hexdigit(next())) {
                consume();
                digits.push(code);
              } else {
                break;
              }
            }
            if (whitespace(next()))
              consume();
            var value = parseInt(digits.map(function(x) {
              return String.fromCharCode(x);
            }).join(""), 16);
            if (value > maximumallowedcodepoint)
              value = 65533;
            return value;
          } else if (eof()) {
            return 65533;
          } else {
            return code;
          }
        };
        var areAValidEscape = function(c1, c2) {
          if (c1 != 92)
            return false;
          if (newline(c2))
            return false;
          return true;
        };
        var startsWithAValidEscape = function() {
          return areAValidEscape(code, next());
        };
        var wouldStartAnIdentifier = function(c1, c2, c3) {
          if (c1 == 45) {
            return namestartchar(c2) || c2 == 45 || areAValidEscape(c2, c3);
          } else if (namestartchar(c1)) {
            return true;
          } else if (c1 == 92) {
            return areAValidEscape(c1, c2);
          } else {
            return false;
          }
        };
        var startsWithAnIdentifier = function() {
          return wouldStartAnIdentifier(code, next(1), next(2));
        };
        var wouldStartANumber = function(c1, c2, c3) {
          if (c1 == 43 || c1 == 45) {
            if (digit(c2))
              return true;
            if (c2 == 46 && digit(c3))
              return true;
            return false;
          } else if (c1 == 46) {
            if (digit(c2))
              return true;
            return false;
          } else if (digit(c1)) {
            return true;
          } else {
            return false;
          }
        };
        var startsWithANumber = function() {
          return wouldStartANumber(code, next(1), next(2));
        };
        var consumeAName = function() {
          var result = "";
          while (consume()) {
            if (namechar(code)) {
              result += stringFromCode(code);
            } else if (startsWithAValidEscape()) {
              result += stringFromCode(consumeEscape());
            } else {
              reconsume();
              return result;
            }
          }
        };
        var consumeANumber = function() {
          var repr = [];
          var type = "integer";
          if (next() == 43 || next() == 45) {
            consume();
            repr += stringFromCode(code);
          }
          while (digit(next())) {
            consume();
            repr += stringFromCode(code);
          }
          if (next(1) == 46 && digit(next(2))) {
            consume();
            repr += stringFromCode(code);
            consume();
            repr += stringFromCode(code);
            type = "number";
            while (digit(next())) {
              consume();
              repr += stringFromCode(code);
            }
          }
          var c1 = next(1), c2 = next(2), c3 = next(3);
          if ((c1 == 69 || c1 == 101) && digit(c2)) {
            consume();
            repr += stringFromCode(code);
            consume();
            repr += stringFromCode(code);
            type = "number";
            while (digit(next())) {
              consume();
              repr += stringFromCode(code);
            }
          } else if ((c1 == 69 || c1 == 101) && (c2 == 43 || c2 == 45) && digit(c3)) {
            consume();
            repr += stringFromCode(code);
            consume();
            repr += stringFromCode(code);
            consume();
            repr += stringFromCode(code);
            type = "number";
            while (digit(next())) {
              consume();
              repr += stringFromCode(code);
            }
          }
          var value = convertAStringToANumber(repr);
          return { type, value, repr };
        };
        var convertAStringToANumber = function(string) {
          return +string;
        };
        var consumeTheRemnantsOfABadURL = function() {
          while (consume()) {
            if (code == 41 || eof()) {
              return;
            } else if (startsWithAValidEscape()) {
              consumeEscape();
              donothing();
            } else {
              donothing();
            }
          }
        };
        var iterationCount = 0;
        while (!eof(next())) {
          tokens.push(consumeAToken());
          iterationCount++;
          if (iterationCount > str.length * 2)
            return "I'm infinite-looping!";
        }
        return tokens;
      }
      function CSSParserToken() {
        throw "Abstract Base Class";
      }
      CSSParserToken.prototype.toJSON = function() {
        return { token: this.tokenType };
      };
      CSSParserToken.prototype.toString = function() {
        return this.tokenType;
      };
      CSSParserToken.prototype.toSource = function() {
        return "" + this;
      };
      function BadStringToken() {
        return this;
      }
      BadStringToken.prototype = Object.create(CSSParserToken.prototype);
      BadStringToken.prototype.tokenType = "BADSTRING";
      function BadURLToken() {
        return this;
      }
      BadURLToken.prototype = Object.create(CSSParserToken.prototype);
      BadURLToken.prototype.tokenType = "BADURL";
      function WhitespaceToken() {
        return this;
      }
      WhitespaceToken.prototype = Object.create(CSSParserToken.prototype);
      WhitespaceToken.prototype.tokenType = "WHITESPACE";
      WhitespaceToken.prototype.toString = function() {
        return "WS";
      };
      WhitespaceToken.prototype.toSource = function() {
        return " ";
      };
      function CDOToken() {
        return this;
      }
      CDOToken.prototype = Object.create(CSSParserToken.prototype);
      CDOToken.prototype.tokenType = "CDO";
      CDOToken.prototype.toSource = function() {
        return "<!--";
      };
      function CDCToken() {
        return this;
      }
      CDCToken.prototype = Object.create(CSSParserToken.prototype);
      CDCToken.prototype.tokenType = "CDC";
      CDCToken.prototype.toSource = function() {
        return "-->";
      };
      function ColonToken() {
        return this;
      }
      ColonToken.prototype = Object.create(CSSParserToken.prototype);
      ColonToken.prototype.tokenType = ":";
      function SemicolonToken() {
        return this;
      }
      SemicolonToken.prototype = Object.create(CSSParserToken.prototype);
      SemicolonToken.prototype.tokenType = ";";
      function CommaToken() {
        return this;
      }
      CommaToken.prototype = Object.create(CSSParserToken.prototype);
      CommaToken.prototype.tokenType = ",";
      function GroupingToken() {
        throw "Abstract Base Class";
      }
      GroupingToken.prototype = Object.create(CSSParserToken.prototype);
      function OpenCurlyToken() {
        this.value = "{";
        this.mirror = "}";
        return this;
      }
      OpenCurlyToken.prototype = Object.create(GroupingToken.prototype);
      OpenCurlyToken.prototype.tokenType = "{";
      function CloseCurlyToken() {
        this.value = "}";
        this.mirror = "{";
        return this;
      }
      CloseCurlyToken.prototype = Object.create(GroupingToken.prototype);
      CloseCurlyToken.prototype.tokenType = "}";
      function OpenSquareToken() {
        this.value = "[";
        this.mirror = "]";
        return this;
      }
      OpenSquareToken.prototype = Object.create(GroupingToken.prototype);
      OpenSquareToken.prototype.tokenType = "[";
      function CloseSquareToken() {
        this.value = "]";
        this.mirror = "[";
        return this;
      }
      CloseSquareToken.prototype = Object.create(GroupingToken.prototype);
      CloseSquareToken.prototype.tokenType = "]";
      function OpenParenToken() {
        this.value = "(";
        this.mirror = ")";
        return this;
      }
      OpenParenToken.prototype = Object.create(GroupingToken.prototype);
      OpenParenToken.prototype.tokenType = "(";
      function CloseParenToken() {
        this.value = ")";
        this.mirror = "(";
        return this;
      }
      CloseParenToken.prototype = Object.create(GroupingToken.prototype);
      CloseParenToken.prototype.tokenType = ")";
      function IncludeMatchToken() {
        return this;
      }
      IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);
      IncludeMatchToken.prototype.tokenType = "~=";
      function DashMatchToken() {
        return this;
      }
      DashMatchToken.prototype = Object.create(CSSParserToken.prototype);
      DashMatchToken.prototype.tokenType = "|=";
      function PrefixMatchToken() {
        return this;
      }
      PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);
      PrefixMatchToken.prototype.tokenType = "^=";
      function SuffixMatchToken() {
        return this;
      }
      SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);
      SuffixMatchToken.prototype.tokenType = "$=";
      function SubstringMatchToken() {
        return this;
      }
      SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);
      SubstringMatchToken.prototype.tokenType = "*=";
      function ColumnToken() {
        return this;
      }
      ColumnToken.prototype = Object.create(CSSParserToken.prototype);
      ColumnToken.prototype.tokenType = "||";
      function EOFToken() {
        return this;
      }
      EOFToken.prototype = Object.create(CSSParserToken.prototype);
      EOFToken.prototype.tokenType = "EOF";
      EOFToken.prototype.toSource = function() {
        return "";
      };
      function DelimToken(code) {
        this.value = stringFromCode(code);
        return this;
      }
      DelimToken.prototype = Object.create(CSSParserToken.prototype);
      DelimToken.prototype.tokenType = "DELIM";
      DelimToken.prototype.toString = function() {
        return "DELIM(" + this.value + ")";
      };
      DelimToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        return json;
      };
      DelimToken.prototype.toSource = function() {
        if (this.value == "\\")
          return "\\\n";
        else
          return this.value;
      };
      function StringValuedToken() {
        throw "Abstract Base Class";
      }
      StringValuedToken.prototype = Object.create(CSSParserToken.prototype);
      StringValuedToken.prototype.ASCIIMatch = function(str) {
        return this.value.toLowerCase() == str.toLowerCase();
      };
      StringValuedToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        return json;
      };
      function IdentToken(val) {
        this.value = val;
      }
      IdentToken.prototype = Object.create(StringValuedToken.prototype);
      IdentToken.prototype.tokenType = "IDENT";
      IdentToken.prototype.toString = function() {
        return "IDENT(" + this.value + ")";
      };
      IdentToken.prototype.toSource = function() {
        return escapeIdent(this.value);
      };
      function FunctionToken(val) {
        this.value = val;
        this.mirror = ")";
      }
      FunctionToken.prototype = Object.create(StringValuedToken.prototype);
      FunctionToken.prototype.tokenType = "FUNCTION";
      FunctionToken.prototype.toString = function() {
        return "FUNCTION(" + this.value + ")";
      };
      FunctionToken.prototype.toSource = function() {
        return escapeIdent(this.value) + "(";
      };
      function AtKeywordToken(val) {
        this.value = val;
      }
      AtKeywordToken.prototype = Object.create(StringValuedToken.prototype);
      AtKeywordToken.prototype.tokenType = "AT-KEYWORD";
      AtKeywordToken.prototype.toString = function() {
        return "AT(" + this.value + ")";
      };
      AtKeywordToken.prototype.toSource = function() {
        return "@" + escapeIdent(this.value);
      };
      function HashToken(val) {
        this.value = val;
        this.type = "unrestricted";
      }
      HashToken.prototype = Object.create(StringValuedToken.prototype);
      HashToken.prototype.tokenType = "HASH";
      HashToken.prototype.toString = function() {
        return "HASH(" + this.value + ")";
      };
      HashToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        return json;
      };
      HashToken.prototype.toSource = function() {
        if (this.type == "id") {
          return "#" + escapeIdent(this.value);
        } else {
          return "#" + escapeHash(this.value);
        }
      };
      function StringToken(val) {
        this.value = val;
      }
      StringToken.prototype = Object.create(StringValuedToken.prototype);
      StringToken.prototype.tokenType = "STRING";
      StringToken.prototype.toString = function() {
        return '"' + escapeString(this.value) + '"';
      };
      function URLToken(val) {
        this.value = val;
      }
      URLToken.prototype = Object.create(StringValuedToken.prototype);
      URLToken.prototype.tokenType = "URL";
      URLToken.prototype.toString = function() {
        return "URL(" + this.value + ")";
      };
      URLToken.prototype.toSource = function() {
        return 'url("' + escapeString(this.value) + '")';
      };
      function NumberToken() {
        this.value = null;
        this.type = "integer";
        this.repr = "";
      }
      NumberToken.prototype = Object.create(CSSParserToken.prototype);
      NumberToken.prototype.tokenType = "NUMBER";
      NumberToken.prototype.toString = function() {
        if (this.type == "integer")
          return "INT(" + this.value + ")";
        return "NUMBER(" + this.value + ")";
      };
      NumberToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        json.repr = this.repr;
        return json;
      };
      NumberToken.prototype.toSource = function() {
        return this.repr;
      };
      function PercentageToken() {
        this.value = null;
        this.repr = "";
      }
      PercentageToken.prototype = Object.create(CSSParserToken.prototype);
      PercentageToken.prototype.tokenType = "PERCENTAGE";
      PercentageToken.prototype.toString = function() {
        return "PERCENTAGE(" + this.value + ")";
      };
      PercentageToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.repr = this.repr;
        return json;
      };
      PercentageToken.prototype.toSource = function() {
        return this.repr + "%";
      };
      function DimensionToken() {
        this.value = null;
        this.type = "integer";
        this.repr = "";
        this.unit = "";
      }
      DimensionToken.prototype = Object.create(CSSParserToken.prototype);
      DimensionToken.prototype.tokenType = "DIMENSION";
      DimensionToken.prototype.toString = function() {
        return "DIM(" + this.value + "," + this.unit + ")";
      };
      DimensionToken.prototype.toJSON = function() {
        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);
        json.value = this.value;
        json.type = this.type;
        json.repr = this.repr;
        json.unit = this.unit;
        return json;
      };
      DimensionToken.prototype.toSource = function() {
        var source = this.repr;
        var unit = escapeIdent(this.unit);
        if (unit[0].toLowerCase() == "e" && (unit[1] == "-" || between(unit.charCodeAt(1), 48, 57))) {
          unit = "\\65 " + unit.slice(1, unit.length);
        }
        return source + unit;
      };
      function escapeIdent(string) {
        string = "" + string;
        var result = "";
        var firstcode = string.charCodeAt(0);
        for (var i = 0; i < string.length; i++) {
          var code = string.charCodeAt(i);
          if (code == 0) {
            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
          }
          if (between(code, 1, 31) || code == 127 || i == 0 && between(code, 48, 57) || i == 1 && between(code, 48, 57) && firstcode == 45) {
            result += "\\" + code.toString(16) + " ";
          } else if (code >= 128 || code == 45 || code == 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122)) {
            result += string[i];
          } else {
            result += "\\" + string[i];
          }
        }
        return result;
      }
      function escapeHash(string) {
        string = "" + string;
        var result = "";
        var firstcode = string.charCodeAt(0);
        for (var i = 0; i < string.length; i++) {
          var code = string.charCodeAt(i);
          if (code == 0) {
            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
          }
          if (code >= 128 || code == 45 || code == 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122)) {
            result += string[i];
          } else {
            result += "\\" + code.toString(16) + " ";
          }
        }
        return result;
      }
      function escapeString(string) {
        string = "" + string;
        var result = "";
        for (var i = 0; i < string.length; i++) {
          var code = string.charCodeAt(i);
          if (code == 0) {
            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");
          }
          if (between(code, 1, 31) || code == 127) {
            result += "\\" + code.toString(16) + " ";
          } else if (code == 34 || code == 92) {
            result += "\\" + string[i];
          } else {
            result += string[i];
          }
        }
        return result;
      }
      exports3.tokenize = tokenize;
      exports3.IdentToken = IdentToken;
      exports3.FunctionToken = FunctionToken;
      exports3.AtKeywordToken = AtKeywordToken;
      exports3.HashToken = HashToken;
      exports3.StringToken = StringToken;
      exports3.BadStringToken = BadStringToken;
      exports3.URLToken = URLToken;
      exports3.BadURLToken = BadURLToken;
      exports3.DelimToken = DelimToken;
      exports3.NumberToken = NumberToken;
      exports3.PercentageToken = PercentageToken;
      exports3.DimensionToken = DimensionToken;
      exports3.IncludeMatchToken = IncludeMatchToken;
      exports3.DashMatchToken = DashMatchToken;
      exports3.PrefixMatchToken = PrefixMatchToken;
      exports3.SuffixMatchToken = SuffixMatchToken;
      exports3.SubstringMatchToken = SubstringMatchToken;
      exports3.ColumnToken = ColumnToken;
      exports3.WhitespaceToken = WhitespaceToken;
      exports3.CDOToken = CDOToken;
      exports3.CDCToken = CDCToken;
      exports3.ColonToken = ColonToken;
      exports3.SemicolonToken = SemicolonToken;
      exports3.CommaToken = CommaToken;
      exports3.OpenParenToken = OpenParenToken;
      exports3.CloseParenToken = CloseParenToken;
      exports3.OpenSquareToken = OpenSquareToken;
      exports3.CloseSquareToken = CloseSquareToken;
      exports3.OpenCurlyToken = OpenCurlyToken;
      exports3.CloseCurlyToken = CloseCurlyToken;
      exports3.EOFToken = EOFToken;
      exports3.CSSParserToken = CSSParserToken;
      exports3.GroupingToken = GroupingToken;
    });
  }
});

// node_modules/playwright-core/lib/server/isomorphic/cssParser.js
var require_cssParser = __commonJS({
  "node_modules/playwright-core/lib/server/isomorphic/cssParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.InvalidSelectorError = void 0;
    exports2.isInvalidSelectorError = isInvalidSelectorError;
    exports2.parseCSS = parseCSS;
    exports2.serializeSelector = serializeSelector;
    var css = _interopRequireWildcard(require_cssTokenizer());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var InvalidSelectorError = class extends Error {
    };
    exports2.InvalidSelectorError = InvalidSelectorError;
    function isInvalidSelectorError(error) {
      return error instanceof InvalidSelectorError;
    }
    function parseCSS(selector, customNames) {
      let tokens;
      try {
        tokens = css.tokenize(selector);
        if (!(tokens[tokens.length - 1] instanceof css.EOFToken))
          tokens.push(new css.EOFToken());
      } catch (e) {
        const newMessage = e.message + ` while parsing selector "${selector}"`;
        const index = (e.stack || "").indexOf(e.message);
        if (index !== -1)
          e.stack = e.stack.substring(0, index) + newMessage + e.stack.substring(index + e.message.length);
        e.message = newMessage;
        throw e;
      }
      const unsupportedToken = tokens.find((token) => {
        return token instanceof css.AtKeywordToken || token instanceof css.BadStringToken || token instanceof css.BadURLToken || token instanceof css.ColumnToken || token instanceof css.CDOToken || token instanceof css.CDCToken || token instanceof css.SemicolonToken || token instanceof css.OpenCurlyToken || token instanceof css.CloseCurlyToken || token instanceof css.URLToken || token instanceof css.PercentageToken;
      });
      if (unsupportedToken)
        throw new InvalidSelectorError(`Unsupported token "${unsupportedToken.toSource()}" while parsing selector "${selector}"`);
      let pos = 0;
      const names = /* @__PURE__ */ new Set();
      function unexpected() {
        return new InvalidSelectorError(`Unexpected token "${tokens[pos].toSource()}" while parsing selector "${selector}"`);
      }
      function skipWhitespace() {
        while (tokens[pos] instanceof css.WhitespaceToken)
          pos++;
      }
      function isIdent(p = pos) {
        return tokens[p] instanceof css.IdentToken;
      }
      function isString(p = pos) {
        return tokens[p] instanceof css.StringToken;
      }
      function isNumber(p = pos) {
        return tokens[p] instanceof css.NumberToken;
      }
      function isComma(p = pos) {
        return tokens[p] instanceof css.CommaToken;
      }
      function isCloseParen(p = pos) {
        return tokens[p] instanceof css.CloseParenToken;
      }
      function isStar(p = pos) {
        return tokens[p] instanceof css.DelimToken && tokens[p].value === "*";
      }
      function isEOF(p = pos) {
        return tokens[p] instanceof css.EOFToken;
      }
      function isClauseCombinator(p = pos) {
        return tokens[p] instanceof css.DelimToken && [">", "+", "~"].includes(tokens[p].value);
      }
      function isSelectorClauseEnd(p = pos) {
        return isComma(p) || isCloseParen(p) || isEOF(p) || isClauseCombinator(p) || tokens[p] instanceof css.WhitespaceToken;
      }
      function consumeFunctionArguments() {
        const result2 = [consumeArgument()];
        while (true) {
          skipWhitespace();
          if (!isComma())
            break;
          pos++;
          result2.push(consumeArgument());
        }
        return result2;
      }
      function consumeArgument() {
        skipWhitespace();
        if (isNumber())
          return tokens[pos++].value;
        if (isString())
          return tokens[pos++].value;
        return consumeComplexSelector();
      }
      function consumeComplexSelector() {
        const result2 = {
          simples: []
        };
        skipWhitespace();
        if (isClauseCombinator()) {
          result2.simples.push({
            selector: {
              functions: [{
                name: "scope",
                args: []
              }]
            },
            combinator: ""
          });
        } else {
          result2.simples.push({
            selector: consumeSimpleSelector(),
            combinator: ""
          });
        }
        while (true) {
          skipWhitespace();
          if (isClauseCombinator()) {
            result2.simples[result2.simples.length - 1].combinator = tokens[pos++].value;
            skipWhitespace();
          } else if (isSelectorClauseEnd()) {
            break;
          }
          result2.simples.push({
            combinator: "",
            selector: consumeSimpleSelector()
          });
        }
        return result2;
      }
      function consumeSimpleSelector() {
        let rawCSSString = "";
        const functions = [];
        while (!isSelectorClauseEnd()) {
          if (isIdent() || isStar()) {
            rawCSSString += tokens[pos++].toSource();
          } else if (tokens[pos] instanceof css.HashToken) {
            rawCSSString += tokens[pos++].toSource();
          } else if (tokens[pos] instanceof css.DelimToken && tokens[pos].value === ".") {
            pos++;
            if (isIdent())
              rawCSSString += "." + tokens[pos++].toSource();
            else
              throw unexpected();
          } else if (tokens[pos] instanceof css.ColonToken) {
            pos++;
            if (isIdent()) {
              if (!customNames.has(tokens[pos].value.toLowerCase())) {
                rawCSSString += ":" + tokens[pos++].toSource();
              } else {
                const name = tokens[pos++].value.toLowerCase();
                functions.push({
                  name,
                  args: []
                });
                names.add(name);
              }
            } else if (tokens[pos] instanceof css.FunctionToken) {
              const name = tokens[pos++].value.toLowerCase();
              if (!customNames.has(name)) {
                rawCSSString += `:${name}(${consumeBuiltinFunctionArguments()})`;
              } else {
                functions.push({
                  name,
                  args: consumeFunctionArguments()
                });
                names.add(name);
              }
              skipWhitespace();
              if (!isCloseParen())
                throw unexpected();
              pos++;
            } else {
              throw unexpected();
            }
          } else if (tokens[pos] instanceof css.OpenSquareToken) {
            rawCSSString += "[";
            pos++;
            while (!(tokens[pos] instanceof css.CloseSquareToken) && !isEOF())
              rawCSSString += tokens[pos++].toSource();
            if (!(tokens[pos] instanceof css.CloseSquareToken))
              throw unexpected();
            rawCSSString += "]";
            pos++;
          } else {
            throw unexpected();
          }
        }
        if (!rawCSSString && !functions.length)
          throw unexpected();
        return {
          css: rawCSSString || void 0,
          functions
        };
      }
      function consumeBuiltinFunctionArguments() {
        let s = "";
        while (!isCloseParen() && !isEOF())
          s += tokens[pos++].toSource();
        return s;
      }
      const result = consumeFunctionArguments();
      if (!isEOF())
        throw new InvalidSelectorError(`Error while parsing selector "${selector}"`);
      if (result.some((arg) => typeof arg !== "object" || !("simples" in arg)))
        throw new InvalidSelectorError(`Error while parsing selector "${selector}"`);
      return {
        selector: result,
        names: Array.from(names)
      };
    }
    function serializeSelector(args) {
      return args.map((arg) => {
        if (typeof arg === "string")
          return `"${arg}"`;
        if (typeof arg === "number")
          return String(arg);
        return arg.simples.map(({
          selector,
          combinator
        }) => {
          let s = selector.css || "";
          s = s + selector.functions.map((func) => `:${func.name}(${serializeSelector(func.args)})`).join("");
          if (combinator)
            s += " " + combinator;
          return s;
        }).join(" ");
      }).join(", ");
    }
  }
});

// node_modules/playwright-core/lib/server/isomorphic/selectorParser.js
var require_selectorParser = __commonJS({
  "node_modules/playwright-core/lib/server/isomorphic/selectorParser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "InvalidSelectorError", {
      enumerable: true,
      get: function() {
        return _cssParser.InvalidSelectorError;
      }
    });
    exports2.allEngineNames = allEngineNames;
    exports2.customCSSNames = void 0;
    Object.defineProperty(exports2, "isInvalidSelectorError", {
      enumerable: true,
      get: function() {
        return _cssParser.isInvalidSelectorError;
      }
    });
    exports2.parseSelector = parseSelector;
    exports2.splitSelectorByFrame = splitSelectorByFrame;
    exports2.stringifySelector = stringifySelector;
    var _cssParser = require_cssParser();
    var customCSSNames = /* @__PURE__ */ new Set(["not", "is", "where", "has", "scope", "light", "visible", "text", "text-matches", "text-is", "has-text", "above", "below", "right-of", "left-of", "near", "nth-match"]);
    exports2.customCSSNames = customCSSNames;
    var kNestedSelectorNames = /* @__PURE__ */ new Set(["has"]);
    function parseSelector(selector) {
      const result = parseSelectorString(selector);
      const parts = result.parts.map((part) => {
        if (part.name === "css" || part.name === "css:light") {
          if (part.name === "css:light")
            part.body = ":light(" + part.body + ")";
          const parsedCSS = (0, _cssParser.parseCSS)(part.body, customCSSNames);
          return {
            name: "css",
            body: parsedCSS.selector,
            source: part.body
          };
        }
        if (kNestedSelectorNames.has(part.name)) {
          let innerSelector;
          try {
            const unescaped = JSON.parse(part.body);
            if (typeof unescaped !== "string")
              throw new Error(`Malformed selector: ${part.name}=` + part.body);
            innerSelector = unescaped;
          } catch (e) {
            throw new Error(`Malformed selector: ${part.name}=` + part.body);
          }
          const result2 = {
            name: part.name,
            source: part.body,
            body: parseSelector(innerSelector)
          };
          if (result2.body.parts.some((part2) => part2.name === "control" && part2.body === "enter-frame"))
            throw new Error(`Frames are not allowed inside "${part.name}" selectors`);
          return result2;
        }
        return __spreadProps(__spreadValues({}, part), {
          source: part.body
        });
      });
      if (kNestedSelectorNames.has(parts[0].name))
        throw new Error(`"${parts[0].name}" selector cannot be first`);
      return {
        capture: result.capture,
        parts
      };
    }
    function splitSelectorByFrame(selectorText) {
      const selector = parseSelector(selectorText);
      const result = [];
      let chunk = {
        parts: []
      };
      let chunkStartIndex = 0;
      for (let i = 0; i < selector.parts.length; ++i) {
        const part = selector.parts[i];
        if (part.name === "control" && part.body === "enter-frame") {
          if (!chunk.parts.length)
            throw new _cssParser.InvalidSelectorError("Selector cannot start with entering frame, select the iframe first");
          result.push(chunk);
          chunk = {
            parts: []
          };
          chunkStartIndex = i + 1;
          continue;
        }
        if (selector.capture === i)
          chunk.capture = i - chunkStartIndex;
        chunk.parts.push(part);
      }
      if (!chunk.parts.length)
        throw new _cssParser.InvalidSelectorError(`Selector cannot end with entering frame, while parsing selector ${selectorText}`);
      result.push(chunk);
      if (typeof selector.capture === "number" && typeof result[result.length - 1].capture !== "number")
        throw new _cssParser.InvalidSelectorError(`Can not capture the selector before diving into the frame. Only use * after the last frame has been selected`);
      return result;
    }
    function stringifySelector(selector) {
      if (typeof selector === "string")
        return selector;
      return selector.parts.map((p, i) => {
        const prefix = p.name === "css" ? "" : p.name + "=";
        return `${i === selector.capture ? "*" : ""}${prefix}${p.source}`;
      }).join(" >> ");
    }
    function allEngineNames(selector) {
      const result = /* @__PURE__ */ new Set();
      const visit = (selector2) => {
        for (const part of selector2.parts) {
          result.add(part.name);
          if (kNestedSelectorNames.has(part.name))
            visit(part.body);
        }
      };
      visit(selector);
      return result;
    }
    function parseSelectorString(selector) {
      let index = 0;
      let quote;
      let start = 0;
      const result = {
        parts: []
      };
      const append = () => {
        const part = selector.substring(start, index).trim();
        const eqIndex = part.indexOf("=");
        let name;
        let body;
        if (eqIndex !== -1 && part.substring(0, eqIndex).trim().match(/^[a-zA-Z_0-9-+:*]+$/)) {
          name = part.substring(0, eqIndex).trim();
          body = part.substring(eqIndex + 1);
        } else if (part.length > 1 && part[0] === '"' && part[part.length - 1] === '"') {
          name = "text";
          body = part;
        } else if (part.length > 1 && part[0] === "'" && part[part.length - 1] === "'") {
          name = "text";
          body = part;
        } else if (/^\(*\/\//.test(part) || part.startsWith("..")) {
          name = "xpath";
          body = part;
        } else {
          name = "css";
          body = part;
        }
        let capture = false;
        if (name[0] === "*") {
          capture = true;
          name = name.substring(1);
        }
        result.parts.push({
          name,
          body
        });
        if (capture) {
          if (result.capture !== void 0)
            throw new _cssParser.InvalidSelectorError(`Only one of the selectors can capture using * modifier`);
          result.capture = result.parts.length - 1;
        }
      };
      if (!selector.includes(">>")) {
        index = selector.length;
        append();
        return result;
      }
      const shouldIgnoreTextSelectorQuote = () => {
        const prefix = selector.substring(start, index);
        const match = prefix.match(/^\s*text\s*=(.*)$/);
        return !!match && !!match[1];
      };
      while (index < selector.length) {
        const c = selector[index];
        if (c === "\\" && index + 1 < selector.length) {
          index += 2;
        } else if (c === quote) {
          quote = void 0;
          index++;
        } else if (!quote && (c === '"' || c === "'" || c === "`") && !shouldIgnoreTextSelectorQuote()) {
          quote = c;
          index++;
        } else if (!quote && c === ">" && selector[index + 1] === ">") {
          append();
          index += 2;
          start = index;
        } else {
          index++;
        }
      }
      append();
      return result;
    }
  }
});

// node_modules/playwright-core/lib/server/frames.js
var require_frames = __commonJS({
  "node_modules/playwright-core/lib/server/frames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FrameManager = exports2.Frame = void 0;
    var dom = _interopRequireWildcard(require_dom());
    var _helper = require_helper();
    var _eventsHelper = require_eventsHelper();
    var js = _interopRequireWildcard(require_javascript());
    var network = _interopRequireWildcard(require_network());
    var _page = require_page();
    var types = _interopRequireWildcard(require_types());
    var _browserContext = require_browserContext();
    var _progress = require_progress2();
    var _utils = require_utils();
    var _manualPromise = require_manualPromise();
    var _debugLogger = require_debugLogger();
    var _instrumentation = require_instrumentation();
    var _protocolError = require_protocolError();
    var _selectorParser = require_selectorParser();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FrameManager = class {
      constructor(page) {
        this._page = void 0;
        this._frames = /* @__PURE__ */ new Map();
        this._mainFrame = void 0;
        this._consoleMessageTags = /* @__PURE__ */ new Map();
        this._signalBarriers = /* @__PURE__ */ new Set();
        this._webSockets = /* @__PURE__ */ new Map();
        this._openedDialogs = /* @__PURE__ */ new Set();
        this._page = page;
        this._mainFrame = void 0;
      }
      dispose() {
        for (const frame of this._frames.values())
          frame._stopNetworkIdleTimer();
      }
      mainFrame() {
        return this._mainFrame;
      }
      frames() {
        const frames = [];
        collect(this._mainFrame);
        return frames;
        function collect(frame) {
          frames.push(frame);
          for (const subframe of frame.childFrames())
            collect(subframe);
        }
      }
      frame(frameId) {
        return this._frames.get(frameId) || null;
      }
      frameAttached(frameId, parentFrameId) {
        const parentFrame = parentFrameId ? this._frames.get(parentFrameId) : null;
        if (!parentFrame) {
          if (this._mainFrame) {
            this._frames.delete(this._mainFrame._id);
            this._mainFrame._id = frameId;
          } else {
            (0, _utils.assert)(!this._frames.has(frameId));
            this._mainFrame = new Frame(this._page, frameId, parentFrame);
          }
          this._frames.set(frameId, this._mainFrame);
          return this._mainFrame;
        } else {
          (0, _utils.assert)(!this._frames.has(frameId));
          const frame = new Frame(this._page, frameId, parentFrame);
          this._frames.set(frameId, frame);
          this._page.emit(_page.Page.Events.FrameAttached, frame);
          return frame;
        }
      }
      waitForSignalsCreatedBy(progress, noWaitAfter, action, source) {
        return __async(this, null, function* () {
          if (noWaitAfter)
            return action();
          const barrier = new SignalBarrier(progress);
          this._signalBarriers.add(barrier);
          if (progress)
            progress.cleanupWhenAborted(() => this._signalBarriers.delete(barrier));
          const result = yield action();
          if (source === "input")
            yield this._page._delegate.inputActionEpilogue();
          yield barrier.waitFor();
          this._signalBarriers.delete(barrier);
          yield new Promise((0, _utils.makeWaitForNextTask)());
          return result;
        });
      }
      frameWillPotentiallyRequestNavigation() {
        for (const barrier of this._signalBarriers)
          barrier.retain();
      }
      frameDidPotentiallyRequestNavigation() {
        for (const barrier of this._signalBarriers)
          barrier.release();
      }
      frameRequestedNavigation(frameId, documentId) {
        const frame = this._frames.get(frameId);
        if (!frame)
          return;
        for (const barrier of this._signalBarriers)
          barrier.addFrameNavigation(frame);
        if (frame.pendingDocument() && frame.pendingDocument().documentId === documentId) {
          return;
        }
        frame.setPendingDocument({
          documentId,
          request: void 0
        });
      }
      frameCommittedNewDocumentNavigation(frameId, url, name, documentId, initial) {
        const frame = this._frames.get(frameId);
        this.removeChildFramesRecursively(frame);
        this.clearWebSockets(frame);
        frame._url = url;
        frame._name = name;
        let keepPending;
        const pendingDocument = frame.pendingDocument();
        if (pendingDocument) {
          if (pendingDocument.documentId === void 0) {
            pendingDocument.documentId = documentId;
          }
          if (pendingDocument.documentId === documentId) {
            frame._currentDocument = pendingDocument;
          } else {
            keepPending = pendingDocument;
            frame._currentDocument = {
              documentId,
              request: void 0
            };
          }
          frame.setPendingDocument(void 0);
        } else {
          frame._currentDocument = {
            documentId,
            request: void 0
          };
        }
        frame._onClearLifecycle();
        const navigationEvent = {
          url,
          name,
          newDocument: frame._currentDocument
        };
        frame.emit(Frame.Events.Navigation, navigationEvent);
        if (!initial) {
          _debugLogger.debugLogger.log("api", `  navigated to "${url}"`);
          this._page.frameNavigatedToNewDocument(frame);
        }
        frame.setPendingDocument(keepPending);
      }
      frameCommittedSameDocumentNavigation(frameId, url) {
        const frame = this._frames.get(frameId);
        if (!frame)
          return;
        frame._url = url;
        const navigationEvent = {
          url,
          name: frame._name
        };
        frame.emit(Frame.Events.Navigation, navigationEvent);
        _debugLogger.debugLogger.log("api", `  navigated to "${url}"`);
      }
      frameAbortedNavigation(frameId, errorText, documentId) {
        const frame = this._frames.get(frameId);
        if (!frame || !frame.pendingDocument())
          return;
        if (documentId !== void 0 && frame.pendingDocument().documentId !== documentId)
          return;
        const navigationEvent = {
          url: frame._url,
          name: frame._name,
          newDocument: frame.pendingDocument(),
          error: new Error(errorText)
        };
        frame.setPendingDocument(void 0);
        frame.emit(Frame.Events.Navigation, navigationEvent);
      }
      frameDetached(frameId) {
        const frame = this._frames.get(frameId);
        if (frame)
          this._removeFramesRecursively(frame);
      }
      frameStoppedLoading(frameId) {
        this.frameLifecycleEvent(frameId, "domcontentloaded");
        this.frameLifecycleEvent(frameId, "load");
      }
      frameLifecycleEvent(frameId, event) {
        const frame = this._frames.get(frameId);
        if (frame)
          frame._onLifecycleEvent(event);
      }
      requestStarted(request, route) {
        const frame = request.frame();
        this._inflightRequestStarted(request);
        if (request._documentId)
          frame.setPendingDocument({
            documentId: request._documentId,
            request
          });
        if (request._isFavicon) {
          if (route)
            route.continue(request, {});
          return;
        }
        this._page.emitOnContext(_browserContext.BrowserContext.Events.Request, request);
        if (route)
          this._page._requestStarted(request, route);
      }
      requestReceivedResponse(response) {
        if (response.request()._isFavicon)
          return;
        this._page.emitOnContext(_browserContext.BrowserContext.Events.Response, response);
      }
      reportRequestFinished(request, response) {
        this._inflightRequestFinished(request);
        if (request._isFavicon)
          return;
        this._page.emitOnContext(_browserContext.BrowserContext.Events.RequestFinished, {
          request,
          response
        });
      }
      requestFailed(request, canceled) {
        const frame = request.frame();
        this._inflightRequestFinished(request);
        if (frame.pendingDocument() && frame.pendingDocument().request === request) {
          let errorText = request.failure().errorText;
          if (canceled)
            errorText += "; maybe frame was detached?";
          this.frameAbortedNavigation(frame._id, errorText, frame.pendingDocument().documentId);
        }
        if (request._isFavicon)
          return;
        this._page.emitOnContext(_browserContext.BrowserContext.Events.RequestFailed, request);
      }
      dialogDidOpen(dialog) {
        for (const frame of this._frames.values())
          frame._invalidateNonStallingEvaluations("JavaScript dialog interrupted evaluation");
        this._openedDialogs.add(dialog);
      }
      dialogWillClose(dialog) {
        this._openedDialogs.delete(dialog);
      }
      removeChildFramesRecursively(frame) {
        for (const child of frame.childFrames())
          this._removeFramesRecursively(child);
      }
      _removeFramesRecursively(frame) {
        this.removeChildFramesRecursively(frame);
        frame._onDetached();
        this._frames.delete(frame._id);
        if (!this._page.isClosed())
          this._page.emit(_page.Page.Events.FrameDetached, frame);
      }
      _inflightRequestFinished(request) {
        const frame = request.frame();
        if (request._isFavicon)
          return;
        if (!frame._inflightRequests.has(request))
          return;
        frame._inflightRequests.delete(request);
        if (frame._inflightRequests.size === 0)
          frame._startNetworkIdleTimer();
      }
      _inflightRequestStarted(request) {
        const frame = request.frame();
        if (request._isFavicon)
          return;
        frame._inflightRequests.add(request);
        if (frame._inflightRequests.size === 1)
          frame._stopNetworkIdleTimer();
      }
      interceptConsoleMessage(message) {
        if (message.type() !== "debug")
          return false;
        const tag = message.text();
        const handler = this._consoleMessageTags.get(tag);
        if (!handler)
          return false;
        this._consoleMessageTags.delete(tag);
        handler();
        return true;
      }
      clearWebSockets(frame) {
        if (frame.parentFrame())
          return;
        this._webSockets.clear();
      }
      onWebSocketCreated(requestId, url) {
        const ws = new network.WebSocket(this._page, url);
        this._webSockets.set(requestId, ws);
      }
      onWebSocketRequest(requestId) {
        const ws = this._webSockets.get(requestId);
        if (ws && ws.markAsNotified())
          this._page.emit(_page.Page.Events.WebSocket, ws);
      }
      onWebSocketResponse(requestId, status, statusText) {
        const ws = this._webSockets.get(requestId);
        if (status < 400)
          return;
        if (ws)
          ws.error(`${statusText}: ${status}`);
      }
      onWebSocketFrameSent(requestId, opcode, data) {
        const ws = this._webSockets.get(requestId);
        if (ws)
          ws.frameSent(opcode, data);
      }
      webSocketFrameReceived(requestId, opcode, data) {
        const ws = this._webSockets.get(requestId);
        if (ws)
          ws.frameReceived(opcode, data);
      }
      webSocketClosed(requestId) {
        const ws = this._webSockets.get(requestId);
        if (ws)
          ws.closed();
        this._webSockets.delete(requestId);
      }
      webSocketError(requestId, errorMessage) {
        const ws = this._webSockets.get(requestId);
        if (ws)
          ws.error(errorMessage);
      }
    };
    exports2.FrameManager = FrameManager;
    var Frame = class extends _instrumentation.SdkObject {
      constructor(page, id, parentFrame) {
        super(page, "frame");
        this._id = void 0;
        this._firedLifecycleEvents = /* @__PURE__ */ new Set();
        this._subtreeLifecycleEvents = /* @__PURE__ */ new Set();
        this._currentDocument = void 0;
        this._pendingDocument = void 0;
        this._page = void 0;
        this._parentFrame = void 0;
        this._url = "";
        this._detached = false;
        this._contextData = /* @__PURE__ */ new Map();
        this._childFrames = /* @__PURE__ */ new Set();
        this._name = "";
        this._inflightRequests = /* @__PURE__ */ new Set();
        this._networkIdleTimer = void 0;
        this._setContentCounter = 0;
        this._detachedPromise = void 0;
        this._detachedCallback = () => {
        };
        this._raceAgainstEvaluationStallingEventsPromises = /* @__PURE__ */ new Set();
        this.attribution.frame = this;
        this._id = id;
        this._page = page;
        this._parentFrame = parentFrame;
        this._currentDocument = {
          documentId: void 0,
          request: void 0
        };
        this._detachedPromise = new Promise((x) => this._detachedCallback = x);
        this._contextData.set("main", {
          contextPromise: new _manualPromise.ManualPromise(),
          context: null,
          rerunnableTasks: /* @__PURE__ */ new Set()
        });
        this._contextData.set("utility", {
          contextPromise: new _manualPromise.ManualPromise(),
          context: null,
          rerunnableTasks: /* @__PURE__ */ new Set()
        });
        this._setContext("main", null);
        this._setContext("utility", null);
        if (this._parentFrame)
          this._parentFrame._childFrames.add(this);
        this._firedLifecycleEvents.add("commit");
        this._subtreeLifecycleEvents.add("commit");
      }
      isDetached() {
        return this._detached;
      }
      _onLifecycleEvent(event) {
        if (this._firedLifecycleEvents.has(event))
          return;
        this._firedLifecycleEvents.add(event);
        this._page.mainFrame()._recalculateLifecycle();
      }
      _onClearLifecycle() {
        this._firedLifecycleEvents.clear();
        this._page.mainFrame()._recalculateLifecycle();
        this._inflightRequests = new Set(Array.from(this._inflightRequests).filter((request) => request === this._currentDocument.request));
        this._stopNetworkIdleTimer();
        if (this._inflightRequests.size === 0)
          this._startNetworkIdleTimer();
        this._onLifecycleEvent("commit");
      }
      setPendingDocument(documentInfo) {
        this._pendingDocument = documentInfo;
        if (documentInfo)
          this._invalidateNonStallingEvaluations("Navigation interrupted the evaluation");
      }
      pendingDocument() {
        return this._pendingDocument;
      }
      _invalidateNonStallingEvaluations(message) {
        if (!this._raceAgainstEvaluationStallingEventsPromises.size)
          return;
        const error = new Error(message);
        for (const promise of this._raceAgainstEvaluationStallingEventsPromises)
          promise.reject(error);
      }
      raceAgainstEvaluationStallingEvents(cb) {
        return __async(this, null, function* () {
          if (this._pendingDocument)
            throw new Error("Frame is currently attempting a navigation");
          if (this._page._frameManager._openedDialogs.size)
            throw new Error("Open JavaScript dialog prevents evaluation");
          const promise = new _manualPromise.ManualPromise();
          this._raceAgainstEvaluationStallingEventsPromises.add(promise);
          try {
            return yield Promise.race([cb(), promise]);
          } finally {
            this._raceAgainstEvaluationStallingEventsPromises.delete(promise);
          }
        });
      }
      nonStallingRawEvaluateInExistingMainContext(expression) {
        return this.raceAgainstEvaluationStallingEvents(() => {
          const context = this._existingMainContext();
          if (!context)
            throw new Error("Frame does not yet have a main execution context");
          return context.rawEvaluateJSON(expression);
        });
      }
      nonStallingEvaluateInExistingContext(expression, isFunction, world) {
        return this.raceAgainstEvaluationStallingEvents(() => {
          var _this$_contextData$ge;
          const context = (_this$_contextData$ge = this._contextData.get(world)) === null || _this$_contextData$ge === void 0 ? void 0 : _this$_contextData$ge.context;
          if (!context)
            throw new Error("Frame does not yet have the execution context");
          return context.evaluateExpression(expression, isFunction);
        });
      }
      _recalculateLifecycle() {
        const events = new Set(this._firedLifecycleEvents);
        for (const child of this._childFrames) {
          child._recalculateLifecycle();
          for (const event of events) {
            if (!child._subtreeLifecycleEvents.has(event))
              events.delete(event);
          }
        }
        const mainFrame = this._page.mainFrame();
        for (const event of events) {
          if (!this._subtreeLifecycleEvents.has(event)) {
            this.emit(Frame.Events.AddLifecycle, event);
            if (this === mainFrame && this._url !== "about:blank")
              _debugLogger.debugLogger.log("api", `  "${event}" event fired`);
            if (this === mainFrame && event === "load")
              this._page.emit(_page.Page.Events.Load);
            if (this === mainFrame && event === "domcontentloaded")
              this._page.emit(_page.Page.Events.DOMContentLoaded);
          }
        }
        for (const event of this._subtreeLifecycleEvents) {
          if (!events.has(event))
            this.emit(Frame.Events.RemoveLifecycle, event);
        }
        this._subtreeLifecycleEvents = events;
      }
      raceNavigationAction(action) {
        return __async(this, null, function* () {
          return Promise.race([this._page._disconnectedPromise.then(() => {
            throw new Error("Navigation failed because page was closed!");
          }), this._page._crashedPromise.then(() => {
            throw new Error("Navigation failed because page crashed!");
          }), this._detachedPromise.then(() => {
            throw new Error("Navigating frame was detached!");
          }), action()]);
        });
      }
      goto(_0, _1) {
        return __async(this, arguments, function* (metadata, url, options = {}) {
          const constructedNavigationURL = (0, _utils.constructURLBasedOnBaseURL)(this._page._browserContext._options.baseURL, url);
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => this._goto(progress, constructedNavigationURL, options), this._page._timeoutSettings.navigationTimeout(options));
        });
      }
      _goto(progress, url, options) {
        return __async(this, null, function* () {
          return this.raceNavigationAction(() => __async(this, null, function* () {
            const waitUntil = verifyLifecycle("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
            progress.log(`navigating to "${url}", waiting until "${waitUntil}"`);
            const headers = this._page._state.extraHTTPHeaders || [];
            const refererHeader = headers.find((h) => h.name.toLowerCase() === "referer");
            let referer = refererHeader ? refererHeader.value : void 0;
            if (options.referer !== void 0) {
              if (referer !== void 0 && referer !== options.referer)
                throw new Error('"referer" is already specified as extra HTTP header');
              referer = options.referer;
            }
            url = _helper.helper.completeUserURL(url);
            const sameDocument = _helper.helper.waitForEvent(progress, this, Frame.Events.Navigation, (e) => !e.newDocument);
            const navigateResult = yield this._page._delegate.navigateFrame(this, url, referer);
            let event;
            if (navigateResult.newDocumentId) {
              sameDocument.dispose();
              event = yield _helper.helper.waitForEvent(progress, this, Frame.Events.Navigation, (event2) => {
                return event2.newDocument && (event2.newDocument.documentId === navigateResult.newDocumentId || !event2.error);
              }).promise;
              if (event.newDocument.documentId !== navigateResult.newDocumentId) {
                throw new Error("Navigation interrupted by another one");
              }
              if (event.error)
                throw event.error;
            } else {
              event = yield sameDocument.promise;
            }
            if (!this._subtreeLifecycleEvents.has(waitUntil))
              yield _helper.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
            const request = event.newDocument ? event.newDocument.request : void 0;
            const response = request ? request._finalRequest().response() : null;
            yield this._page._doSlowMo();
            return response;
          }));
        });
      }
      _waitForNavigation(progress, options) {
        return __async(this, null, function* () {
          const waitUntil = verifyLifecycle("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          progress.log(`waiting for navigation until "${waitUntil}"`);
          const navigationEvent = yield _helper.helper.waitForEvent(progress, this, Frame.Events.Navigation, (event) => {
            if (event.error)
              return true;
            progress.log(`  navigated to "${this._url}"`);
            return true;
          }).promise;
          if (navigationEvent.error)
            throw navigationEvent.error;
          if (!this._subtreeLifecycleEvents.has(waitUntil))
            yield _helper.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
          const request = navigationEvent.newDocument ? navigationEvent.newDocument.request : void 0;
          return request ? request._finalRequest().response() : null;
        });
      }
      _waitForLoadState(progress, state) {
        return __async(this, null, function* () {
          const waitUntil = verifyLifecycle("state", state);
          if (!this._subtreeLifecycleEvents.has(waitUntil))
            yield _helper.helper.waitForEvent(progress, this, Frame.Events.AddLifecycle, (e) => e === waitUntil).promise;
        });
      }
      frameElement() {
        return __async(this, null, function* () {
          return this._page._delegate.getFrameElement(this);
        });
      }
      _context(world) {
        return this._contextData.get(world).contextPromise.then((contextOrError) => {
          if (contextOrError instanceof js.ExecutionContext)
            return contextOrError;
          throw contextOrError;
        });
      }
      _mainContext() {
        return this._context("main");
      }
      _existingMainContext() {
        var _this$_contextData$ge2;
        return ((_this$_contextData$ge2 = this._contextData.get("main")) === null || _this$_contextData$ge2 === void 0 ? void 0 : _this$_contextData$ge2.context) || null;
      }
      _utilityContext() {
        return this._context("utility");
      }
      evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg, world = "main") {
        return __async(this, null, function* () {
          const context = yield this._context(world);
          const handle = yield context.evaluateExpressionHandleAndWaitForSignals(expression, isFunction, arg);
          if (world === "main")
            yield this._page._doSlowMo();
          return handle;
        });
      }
      evaluateExpression(expression, isFunction, arg, world = "main") {
        return __async(this, null, function* () {
          const context = yield this._context(world);
          const value = yield context.evaluateExpression(expression, isFunction, arg);
          if (world === "main")
            yield this._page._doSlowMo();
          return value;
        });
      }
      evaluateExpressionAndWaitForSignals(expression, isFunction, arg, world = "main") {
        return __async(this, null, function* () {
          const context = yield this._context(world);
          const value = yield context.evaluateExpressionAndWaitForSignals(expression, isFunction, arg);
          if (world === "main")
            yield this._page._doSlowMo();
          return value;
        });
      }
      querySelector(selector, options) {
        return __async(this, null, function* () {
          _debugLogger.debugLogger.log("api", `    finding element using the selector "${selector}"`);
          const result = yield this.resolveFrameForSelectorNoWait(selector, options);
          if (!result)
            return null;
          return this._page.selectors.query(result.frame, result.info);
        });
      }
      waitForSelector(metadata, selector, options, scope) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          if (options.visibility)
            throw new Error("options.visibility is not supported, did you mean options.state?");
          if (options.waitFor && options.waitFor !== "visible")
            throw new Error("options.waitFor is not supported, did you mean options.state?");
          const {
            state = "visible"
          } = options;
          if (!["attached", "detached", "visible", "hidden"].includes(state))
            throw new Error(`state: expected one of (attached|detached|visible|hidden)`);
          return controller.run((progress) => __async(this, null, function* () {
            progress.log(`waiting for selector "${selector}"${state === "attached" ? "" : " to be " + state}`);
            return this.retryWithProgress(progress, selector, options, (selectorInFrame, continuePolling) => __async(this, null, function* () {
              const {
                frame,
                info
              } = selectorInFrame;
              const actualScope = this === frame ? scope : void 0;
              const task = dom.waitForSelectorTask(info, state, options.omitReturnValue, actualScope);
              const result = actualScope ? yield frame._runWaitForSelectorTaskOnce(progress, (0, _selectorParser.stringifySelector)(info.parsed), info.world, task) : yield frame._scheduleRerunnableHandleTask(progress, info.world, task);
              if (!result.asElement()) {
                result.dispose();
                return null;
              }
              if (options.__testHookBeforeAdoptNode)
                yield options.__testHookBeforeAdoptNode();
              const handle = result.asElement();
              try {
                return yield handle._adoptTo(yield frame._mainContext());
              } catch (e) {
                return continuePolling;
              }
            }), scope);
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      dispatchEvent(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, selector, type, eventInit = {}, options = {}) {
          yield this._scheduleRerunnableTask(metadata, selector, (progress, element, data) => {
            progress.injectedScript.dispatchEvent(element, data.type, data.eventInit);
          }, {
            type,
            eventInit
          }, __spreadValues({
            mainWorld: true
          }, options));
          yield this._page._doSlowMo();
        });
      }
      evalOnSelectorAndWaitForSignals(selector, strict, expression, isFunction, arg) {
        return __async(this, null, function* () {
          const pair = yield this.resolveFrameForSelectorNoWait(selector, {
            strict
          });
          const handle = pair ? yield this._page.selectors.query(pair.frame, pair.info) : null;
          if (!handle)
            throw new Error(`Error: failed to find element matching selector "${selector}"`);
          const result = yield handle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
          handle.dispose();
          return result;
        });
      }
      evalOnSelectorAllAndWaitForSignals(selector, expression, isFunction, arg) {
        return __async(this, null, function* () {
          const pair = yield this.resolveFrameForSelectorNoWait(selector, {});
          if (!pair)
            throw new Error(`Error: failed to find frame for selector "${selector}"`);
          const arrayHandle = yield this._page.selectors._queryArrayInMainWorld(pair.frame, pair.info);
          const result = yield arrayHandle.evaluateExpressionAndWaitForSignals(expression, isFunction, true, arg);
          arrayHandle.dispose();
          return result;
        });
      }
      maskSelectors(selectors) {
        return __async(this, null, function* () {
          const context = yield this._utilityContext();
          const injectedScript = yield context.injectedScript();
          yield injectedScript.evaluate((injected, {
            parsed
          }) => {
            injected.maskSelectors(parsed);
          }, {
            parsed: selectors
          });
        });
      }
      querySelectorAll(selector) {
        return __async(this, null, function* () {
          const pair = yield this.resolveFrameForSelectorNoWait(selector, {});
          if (!pair)
            return [];
          return this._page.selectors._queryAll(pair.frame, pair.info, void 0, true);
        });
      }
      queryCount(selector) {
        return __async(this, null, function* () {
          const pair = yield this.resolveFrameForSelectorNoWait(selector);
          if (!pair)
            throw new Error(`Error: failed to find frame for selector "${selector}"`);
          return yield this._page.selectors._queryCount(pair.frame, pair.info);
        });
      }
      content() {
        return __async(this, null, function* () {
          try {
            const context = yield this._utilityContext();
            return yield context.evaluate(() => {
              let retVal = "";
              if (document.doctype)
                retVal = new XMLSerializer().serializeToString(document.doctype);
              if (document.documentElement)
                retVal += document.documentElement.outerHTML;
              return retVal;
            });
          } catch (e) {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
              throw e;
            throw new Error(`Unable to retrieve content because the page is navigating and changing the content.`);
          }
        });
      }
      setContent(_0, _1) {
        return __async(this, arguments, function* (metadata, html, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => this.raceNavigationAction(() => __async(this, null, function* () {
            const waitUntil = options.waitUntil === void 0 ? "load" : options.waitUntil;
            progress.log(`setting frame content, waiting until "${waitUntil}"`);
            const tag = `--playwright--set--content--${this._id}--${++this._setContentCounter}--`;
            const context = yield this._utilityContext();
            const lifecyclePromise = new Promise((resolve, reject) => {
              this._page._frameManager._consoleMessageTags.set(tag, () => {
                this._onClearLifecycle();
                this._waitForLoadState(progress, waitUntil).then(resolve).catch(reject);
              });
            });
            const contentPromise = context.evaluate(({
              html: html2,
              tag: tag2
            }) => {
              window.stop();
              document.open();
              console.debug(tag2);
              document.write(html2);
              document.close();
            }, {
              html,
              tag
            });
            yield Promise.all([contentPromise, lifecyclePromise]);
            yield this._page._doSlowMo();
          })), this._page._timeoutSettings.navigationTimeout(options));
        });
      }
      name() {
        return this._name || "";
      }
      url() {
        return this._url;
      }
      parentFrame() {
        return this._parentFrame;
      }
      childFrames() {
        return Array.from(this._childFrames);
      }
      addScriptTag(params) {
        return __async(this, null, function* () {
          const {
            url = null,
            content = null,
            type = ""
          } = params;
          if (!url && !content)
            throw new Error("Provide an object with a `url`, `path` or `content` property");
          const context = yield this._mainContext();
          return this._raceWithCSPError(() => __async(this, null, function* () {
            if (url !== null)
              return (yield context.evaluateHandle(addScriptUrl, {
                url,
                type
              })).asElement();
            const result = (yield context.evaluateHandle(addScriptContent, {
              content,
              type
            })).asElement();
            if (this._page._delegate.cspErrorsAsynchronousForInlineScipts)
              yield context.evaluate(() => true);
            return result;
          }));
          function addScriptUrl(params2) {
            return __async(this, null, function* () {
              const script = document.createElement("script");
              script.src = params2.url;
              if (params2.type)
                script.type = params2.type;
              const promise = new Promise((res, rej) => {
                script.onload = res;
                script.onerror = (e) => rej(typeof e === "string" ? new Error(e) : new Error(`Failed to load script at ${script.src}`));
              });
              document.head.appendChild(script);
              yield promise;
              return script;
            });
          }
          function addScriptContent(params2) {
            const script = document.createElement("script");
            script.type = params2.type || "text/javascript";
            script.text = params2.content;
            let error = null;
            script.onerror = (e) => error = e;
            document.head.appendChild(script);
            if (error)
              throw error;
            return script;
          }
        });
      }
      addStyleTag(params) {
        return __async(this, null, function* () {
          const {
            url = null,
            content = null
          } = params;
          if (!url && !content)
            throw new Error("Provide an object with a `url`, `path` or `content` property");
          const context = yield this._mainContext();
          return this._raceWithCSPError(() => __async(this, null, function* () {
            if (url !== null)
              return (yield context.evaluateHandle(addStyleUrl, url)).asElement();
            return (yield context.evaluateHandle(addStyleContent, content)).asElement();
          }));
          function addStyleUrl(url2) {
            return __async(this, null, function* () {
              const link = document.createElement("link");
              link.rel = "stylesheet";
              link.href = url2;
              const promise = new Promise((res, rej) => {
                link.onload = res;
                link.onerror = rej;
              });
              document.head.appendChild(link);
              yield promise;
              return link;
            });
          }
          function addStyleContent(content2) {
            return __async(this, null, function* () {
              const style = document.createElement("style");
              style.type = "text/css";
              style.appendChild(document.createTextNode(content2));
              const promise = new Promise((res, rej) => {
                style.onload = res;
                style.onerror = rej;
              });
              document.head.appendChild(style);
              yield promise;
              return style;
            });
          }
        });
      }
      _raceWithCSPError(func) {
        return __async(this, null, function* () {
          const listeners = [];
          let result;
          let error;
          let cspMessage;
          const actionPromise = func().then((r) => result = r).catch((e) => error = e);
          const errorPromise = new Promise((resolve) => {
            listeners.push(_eventsHelper.eventsHelper.addEventListener(this._page, _page.Page.Events.Console, (message) => {
              if (message.type() === "error" && message.text().includes("Content Security Policy")) {
                cspMessage = message;
                resolve();
              }
            }));
          });
          yield Promise.race([actionPromise, errorPromise]);
          _eventsHelper.eventsHelper.removeEventListeners(listeners);
          if (cspMessage)
            throw new Error(cspMessage.text());
          if (error)
            throw error;
          return result;
        });
      }
      retryWithProgress(progress, selector, options, action, scope) {
        return __async(this, null, function* () {
          const continuePolling = Symbol("continuePolling");
          while (progress.isRunning()) {
            let selectorInFrame;
            if (options.omitAttached) {
              selectorInFrame = yield this.resolveFrameForSelectorNoWait(selector, options, scope);
            } else {
              selectorInFrame = yield this._resolveFrameForSelector(progress, selector, options, scope);
              if (!selectorInFrame) {
                yield new Promise((f) => setTimeout(f, 100));
                continue;
              }
            }
            try {
              const result = yield action(selectorInFrame, continuePolling);
              if (result === continuePolling)
                continue;
              return result;
            } catch (e) {
              var _selectorInFrame;
              if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e))
                throw e;
              if (dom.isNonRecoverableDOMError(e))
                throw e;
              if (this.isDetached())
                throw e;
              if (scope && scope._context.frame === ((_selectorInFrame = selectorInFrame) === null || _selectorInFrame === void 0 ? void 0 : _selectorInFrame.frame))
                throw e;
              continue;
            }
          }
          progress.throwIfAborted();
          return void 0;
        });
      }
      _retryWithProgressIfNotConnected(progress, selector, strict, action) {
        return __async(this, null, function* () {
          return this.retryWithProgress(progress, selector, {
            strict
          }, (selectorInFrame, continuePolling) => __async(this, null, function* () {
            const {
              frame,
              info
            } = selectorInFrame;
            const task = dom.waitForSelectorTask(info, "attached");
            progress.log(`waiting for selector "${selector}"`);
            const handle = yield frame._scheduleRerunnableHandleTask(progress, info.world, task);
            const element = handle.asElement();
            try {
              const result = yield action(element);
              if (result === "error:notconnected") {
                progress.log("element was detached from the DOM, retrying");
                return continuePolling;
              }
              return result;
            } finally {
              element === null || element === void 0 ? void 0 : element.dispose();
            }
          }));
        });
      }
      rafrafTimeoutScreenshotElementWithProgress(progress, selector, timeout, options) {
        return __async(this, null, function* () {
          return yield this._retryWithProgressIfNotConnected(progress, selector, true, (handle) => __async(this, null, function* () {
            yield handle._frame.rafrafTimeout(timeout);
            return yield this._page._screenshotter.screenshotElement(progress, handle, options);
          }));
        });
      }
      click(metadata, selector, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._click(progress, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      dblclick(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._dblclick(progress, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      dragAndDrop(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, source, target, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          yield controller.run((progress) => __async(this, null, function* () {
            dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, source, options.strict, (handle) => __async(this, null, function* () {
              return handle._retryPointerAction(progress, "move and down", false, (point) => __async(this, null, function* () {
                yield this._page.mouse.move(point.x, point.y);
                yield this._page.mouse.down();
              }), __spreadProps(__spreadValues({}, options), {
                position: options.sourcePosition,
                timeout: progress.timeUntilDeadline()
              }));
            })));
            dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, target, options.strict, (handle) => __async(this, null, function* () {
              return handle._retryPointerAction(progress, "move and up", false, (point) => __async(this, null, function* () {
                yield this._page.mouse.move(point.x, point.y);
                yield this._page.mouse.up();
              }), __spreadProps(__spreadValues({}, options), {
                position: options.targetPosition,
                timeout: progress.timeUntilDeadline()
              }));
            })));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      tap(metadata, selector, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._tap(progress, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      fill(metadata, selector, value, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._fill(progress, value, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      focus(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          yield controller.run((progress) => __async(this, null, function* () {
            dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._focus(progress)));
            yield this._page._doSlowMo();
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      textContent(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._scheduleRerunnableTask(metadata, selector, (progress, element) => element.textContent, void 0, options);
        });
      }
      innerText(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._scheduleRerunnableTask(metadata, selector, (progress, element) => {
            if (element.namespaceURI !== "http://www.w3.org/1999/xhtml")
              throw progress.injectedScript.createStacklessError("Node is not an HTMLElement");
            return element.innerText;
          }, void 0, options);
        });
      }
      innerHTML(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._scheduleRerunnableTask(metadata, selector, (progress, element) => element.innerHTML, void 0, options);
        });
      }
      getAttribute(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, selector, name, options = {}) {
          return this._scheduleRerunnableTask(metadata, selector, (progress, element, data) => element.getAttribute(data.name), {
            name
          }, options);
        });
      }
      inputValue(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._scheduleRerunnableTask(metadata, selector, (progress, node) => {
            const element = progress.injectedScript.retarget(node, "follow-label");
            if (!element || element.nodeName !== "INPUT" && element.nodeName !== "TEXTAREA" && element.nodeName !== "SELECT")
              throw progress.injectedScript.createStacklessError("Node is not an <input>, <textarea> or <select> element");
            return element.value;
          }, void 0, options);
        });
      }
      highlight(selector) {
        return __async(this, null, function* () {
          const pair = yield this.resolveFrameForSelectorNoWait(selector);
          if (!pair)
            return;
          const context = yield pair.frame._utilityContext();
          const injectedScript = yield context.injectedScript();
          return yield injectedScript.evaluate((injected, {
            parsed
          }) => {
            return injected.highlight(parsed);
          }, {
            parsed: pair.info.parsed
          });
        });
      }
      hideHighlight() {
        return __async(this, null, function* () {
          return this.raceAgainstEvaluationStallingEvents(() => __async(this, null, function* () {
            const context = yield this._utilityContext();
            const injectedScript = yield context.injectedScript();
            return yield injectedScript.evaluate((injected) => {
              return injected.hideHighlight();
            });
          }));
        });
      }
      _elementState(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, selector, state, options = {}) {
          const result = yield this._scheduleRerunnableTask(metadata, selector, (progress, element, data) => {
            const injected = progress.injectedScript;
            return injected.elementState(element, data.state);
          }, {
            state
          }, options);
          return dom.throwRetargetableDOMError(result);
        });
      }
      isVisible(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            progress.log(`  checking visibility of "${selector}"`);
            const pair = yield this.resolveFrameForSelectorNoWait(selector, options);
            if (!pair)
              return false;
            const element = yield this._page.selectors.query(pair.frame, pair.info);
            return element ? yield element.isVisible() : false;
          }), this._page._timeoutSettings.timeout({}));
        });
      }
      isHidden(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return !(yield this.isVisible(metadata, selector, options));
        });
      }
      isDisabled(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._elementState(metadata, selector, "disabled", options);
        });
      }
      isEnabled(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._elementState(metadata, selector, "enabled", options);
        });
      }
      isEditable(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._elementState(metadata, selector, "editable", options);
        });
      }
      isChecked(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          return this._elementState(metadata, selector, "checked", options);
        });
      }
      hover(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._hover(progress, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      selectOption(_0, _1, _2, _3) {
        return __async(this, arguments, function* (metadata, selector, elements, values, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._selectOption(progress, elements, values, options));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      setInputFiles(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, selector, items, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._setInputFiles(progress, items, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      type(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, selector, text, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._type(progress, text, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      press(_0, _1, _2) {
        return __async(this, arguments, function* (metadata, selector, key, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._press(progress, key, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      check(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._setChecked(progress, true, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      uncheck(_0, _1) {
        return __async(this, arguments, function* (metadata, selector, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return dom.assertDone(yield this._retryWithProgressIfNotConnected(progress, selector, options.strict, (handle) => handle._setChecked(progress, false, options)));
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      waitForTimeout(metadata, timeout) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run(() => __async(this, null, function* () {
            yield new Promise((resolve) => setTimeout(resolve, timeout));
          }));
        });
      }
      expect(metadata, selector, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          const isArray = options.expression === "to.have.count" || options.expression.endsWith(".array");
          const mainWorld = options.expression === "to.have.property";
          const timeout = this._page._timeoutSettings.timeout(options);
          let omitAttached = false;
          if (!options.isNot && options.expression === "to.be.hidden")
            omitAttached = true;
          else if (options.isNot && options.expression === "to.be.visible")
            omitAttached = true;
          else if (!options.isNot && options.expression === "to.have.count" && options.expectedNumber === 0)
            omitAttached = true;
          else if (options.isNot && options.expression === "to.have.count" && options.expectedNumber !== 0)
            omitAttached = true;
          else if (!options.isNot && options.expression.endsWith(".array") && options.expectedText.length === 0)
            omitAttached = true;
          else if (options.isNot && options.expression.endsWith(".array") && options.expectedText.length > 0)
            omitAttached = true;
          return controller.run((outerProgress) => __async(this, null, function* () {
            outerProgress.log(`${metadata.apiName}${timeout ? ` with timeout ${timeout}ms` : ""}`);
            return yield this._scheduleRerunnableTaskWithProgress(outerProgress, selector, (progress, element, options2, elements) => {
              let result;
              if (options2.isArray) {
                result = progress.injectedScript.expectArray(elements, options2);
              } else {
                if (!element) {
                  if (!options2.isNot && options2.expression === "to.be.hidden")
                    return {
                      matches: true
                    };
                  if (options2.isNot && options2.expression === "to.be.visible")
                    return {
                      matches: false
                    };
                  return progress.continuePolling;
                }
                result = progress.injectedScript.expectSingleElement(progress, element, options2);
              }
              if (result.matches === options2.isNot) {
                progress.setIntermediateResult(result.received);
                if (!Array.isArray(result.received))
                  progress.log(`  unexpected value "${result.received}"`);
                return progress.continuePolling;
              }
              return result;
            }, __spreadProps(__spreadValues({}, options), {
              isArray
            }), __spreadValues({
              strict: true,
              querySelectorAll: isArray,
              mainWorld,
              omitAttached,
              logScale: true
            }, options));
          }), timeout).catch((e) => {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _selectorParser.isInvalidSelectorError)(e))
              throw e;
            return {
              received: controller.lastIntermediateResult(),
              matches: options.isNot,
              log: metadata.log
            };
          });
        });
      }
      _waitForFunctionExpression(metadata, expression, isFunction, arg, options, world = "main") {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          if (typeof options.pollingInterval === "number")
            (0, _utils.assert)(options.pollingInterval > 0, "Cannot poll with non-positive interval: " + options.pollingInterval);
          expression = js.normalizeEvaluationExpression(expression, isFunction);
          const task = (injectedScript) => injectedScript.evaluateHandle((injectedScript2, {
            expression: expression2,
            isFunction: isFunction2,
            polling,
            arg: arg2
          }) => {
            const predicate = (arg3) => {
              let result = self.eval(expression2);
              if (isFunction2 === true) {
                result = result(arg3);
              } else if (isFunction2 === false) {
                result = result;
              } else {
                if (typeof result === "function")
                  result = result(arg3);
              }
              return result;
            };
            if (typeof polling !== "number")
              return injectedScript2.pollRaf((progress) => predicate(arg2) || progress.continuePolling);
            return injectedScript2.pollInterval(polling, (progress) => predicate(arg2) || progress.continuePolling);
          }, {
            expression,
            isFunction,
            polling: options.pollingInterval,
            arg
          });
          return controller.run((progress) => this._scheduleRerunnableHandleTask(progress, world, task), this._page._timeoutSettings.timeout(options));
        });
      }
      waitForFunctionValueInUtility(progress, pageFunction) {
        return __async(this, null, function* () {
          const expression = `() => {
      const result = (${pageFunction})();
      if (!result)
        return result;
      return JSON.stringify(result);
    }`;
          const handle = yield this._waitForFunctionExpression((0, _instrumentation.serverSideCallMetadata)(), expression, true, void 0, {
            timeout: progress.timeUntilDeadline()
          }, "utility");
          return JSON.parse(handle.rawValue());
        });
      }
      title() {
        return __async(this, null, function* () {
          const context = yield this._utilityContext();
          return context.evaluate(() => document.title);
        });
      }
      rafrafTimeout(timeout) {
        return __async(this, null, function* () {
          if (timeout === 0)
            return;
          const context = yield this._utilityContext();
          yield Promise.all([
            context.evaluate(() => new Promise((x) => {
              requestAnimationFrame(() => {
                requestAnimationFrame(x);
              });
            })),
            new Promise((fulfill) => setTimeout(fulfill, timeout))
          ]);
        });
      }
      _onDetached() {
        this._stopNetworkIdleTimer();
        this._detached = true;
        this._detachedCallback();
        const error = new Error("Frame was detached");
        for (const data of this._contextData.values()) {
          if (data.context)
            data.context.contextDestroyed(error);
          data.contextPromise.resolve(error);
          for (const rerunnableTask of data.rerunnableTasks)
            rerunnableTask.terminate(error);
        }
        if (this._parentFrame)
          this._parentFrame._childFrames.delete(this);
        this._parentFrame = null;
      }
      _scheduleRerunnableTask(_0, _1, _2, _3) {
        return __async(this, arguments, function* (metadata, selector, body, taskData, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => __async(this, null, function* () {
            return yield this._scheduleRerunnableTaskWithProgress(progress, selector, body, taskData, options);
          }), this._page._timeoutSettings.timeout(options));
        });
      }
      _scheduleRerunnableTaskWithProgress(_0, _1, _2, _3) {
        return __async(this, arguments, function* (progress, selector, body, taskData, options = {}) {
          const callbackText = body.toString();
          return this.retryWithProgress(progress, selector, options, (selectorInFrame) => __async(this, null, function* () {
            progress.log(`waiting for selector "${selector}"`);
            const {
              frame,
              info
            } = selectorInFrame || {
              frame: this,
              info: {
                parsed: {
                  parts: [{
                    name: "control",
                    body: "return-empty",
                    source: "control=return-empty"
                  }]
                },
                world: "utility",
                strict: !!options.strict
              }
            };
            return yield frame._scheduleRerunnableTaskInFrame(progress, info, callbackText, taskData, options);
          }));
        });
      }
      _scheduleRerunnableTaskInFrame(progress, info, callbackText, taskData, options) {
        return __async(this, null, function* () {
          progress.throwIfAborted();
          const data = this._contextData.get(options.mainWorld ? "main" : info.world);
          {
            const rerunnableTask = new RerunnableTask(data, progress, (injectedScript) => {
              return injectedScript.evaluateHandle((injected, {
                info: info2,
                taskData: taskData2,
                callbackText: callbackText2,
                querySelectorAll,
                logScale,
                omitAttached,
                snapshotName
              }) => {
                const callback = injected.eval(callbackText2);
                const poller = logScale ? injected.pollLogScale.bind(injected) : injected.pollRaf.bind(injected);
                let markedElements = /* @__PURE__ */ new Set();
                return poller((progress2) => {
                  let element;
                  let elements = [];
                  if (querySelectorAll) {
                    elements = injected.querySelectorAll(info2.parsed, document);
                    element = elements[0];
                    progress2.logRepeating(`  selector resolved to ${elements.length} element${elements.length === 1 ? "" : "s"}`);
                  } else {
                    element = injected.querySelector(info2.parsed, document, info2.strict);
                    elements = element ? [element] : [];
                    if (element)
                      progress2.logRepeating(`  selector resolved to ${injected.previewNode(element)}`);
                  }
                  if (!element && !omitAttached)
                    return progress2.continuePolling;
                  if (snapshotName) {
                    const previouslyMarkedElements = markedElements;
                    markedElements = new Set(elements);
                    for (const e of previouslyMarkedElements) {
                      if (!markedElements.has(e))
                        e.removeAttribute("__playwright_target__");
                    }
                    for (const e of markedElements) {
                      if (!previouslyMarkedElements.has(e))
                        e.setAttribute("__playwright_target__", snapshotName);
                    }
                  }
                  return callback(progress2, element, taskData2, elements);
                });
              }, {
                info,
                taskData,
                callbackText,
                querySelectorAll: options.querySelectorAll,
                logScale: options.logScale,
                omitAttached: options.omitAttached,
                snapshotName: progress.metadata.afterSnapshot
              });
            }, true);
            if (this._detached)
              rerunnableTask.terminate(new Error("Frame got detached."));
            if (data.context)
              rerunnableTask.rerun(data.context);
            return yield rerunnableTask.promise;
          }
        });
      }
      _scheduleRerunnableHandleTask(progress, world, task) {
        const data = this._contextData.get(world);
        const rerunnableTask = new RerunnableTask(data, progress, task, false);
        if (this._detached)
          rerunnableTask.terminate(new Error("waitForFunction failed: frame got detached."));
        if (data.context)
          rerunnableTask.rerun(data.context);
        return rerunnableTask.handlePromise;
      }
      _setContext(world, context) {
        const data = this._contextData.get(world);
        data.context = context;
        if (context) {
          data.contextPromise.resolve(context);
          for (const rerunnableTask of data.rerunnableTasks)
            rerunnableTask.rerun(context);
        } else {
          data.contextPromise = new _manualPromise.ManualPromise();
        }
      }
      _contextCreated(world, context) {
        const data = this._contextData.get(world);
        if (data.context) {
          data.context.contextDestroyed(new Error("Execution context was destroyed, most likely because of a navigation"));
          this._setContext(world, null);
        }
        this._setContext(world, context);
      }
      _contextDestroyed(context) {
        if (this._detached)
          return;
        context.contextDestroyed(new Error("Execution context was destroyed, most likely because of a navigation"));
        for (const [world, data] of this._contextData) {
          if (data.context === context)
            this._setContext(world, null);
        }
      }
      _startNetworkIdleTimer() {
        (0, _utils.assert)(!this._networkIdleTimer);
        if (this._firedLifecycleEvents.has("networkidle") || this._detached)
          return;
        this._networkIdleTimer = setTimeout(() => this._onLifecycleEvent("networkidle"), 500);
      }
      _stopNetworkIdleTimer() {
        if (this._networkIdleTimer)
          clearTimeout(this._networkIdleTimer);
        this._networkIdleTimer = void 0;
      }
      extendInjectedScript(source, arg) {
        return __async(this, null, function* () {
          const context = yield this._context("main");
          const injectedScriptHandle = yield context.injectedScript();
          return injectedScriptHandle.evaluateHandle((injectedScript, {
            source: source2,
            arg: arg2
          }) => {
            return injectedScript.extend(source2, arg2);
          }, {
            source,
            arg
          });
        });
      }
      _resolveFrameForSelector(progress, selector, options, scope) {
        return __async(this, null, function* () {
          const elementPath = [];
          progress.cleanupWhenAborted(() => {
            for (const element of elementPath)
              element.dispose();
          });
          let frame = this;
          const frameChunks = (0, _selectorParser.splitSelectorByFrame)(selector);
          for (let i = 0; i < frameChunks.length - 1 && progress.isRunning(); ++i) {
            const info = this._page.parseSelector(frameChunks[i], options);
            const task = dom.waitForSelectorTask(info, "attached", false, i === 0 ? scope : void 0);
            progress.log(`  waiting for frame "${(0, _selectorParser.stringifySelector)(frameChunks[i])}"`);
            const handle = i === 0 && scope ? yield frame._runWaitForSelectorTaskOnce(progress, (0, _selectorParser.stringifySelector)(info.parsed), info.world, task) : yield frame._scheduleRerunnableHandleTask(progress, info.world, task);
            const element = handle.asElement();
            const isIframe = yield element.isIframeElement();
            if (isIframe === "error:notconnected")
              return null;
            if (!isIframe)
              throw new Error(`Selector "${(0, _selectorParser.stringifySelector)(info.parsed)}" resolved to ${element.preview()}, <iframe> was expected`);
            frame = yield element.contentFrame();
            element.dispose();
            if (!frame)
              return null;
          }
          return {
            frame,
            info: this._page.parseSelector(frameChunks[frameChunks.length - 1], options)
          };
        });
      }
      resolveFrameForSelectorNoWait(_0) {
        return __async(this, arguments, function* (selector, options = {}, scope) {
          let frame = this;
          const frameChunks = (0, _selectorParser.splitSelectorByFrame)(selector);
          for (let i = 0; i < frameChunks.length - 1; ++i) {
            const info = this._page.parseSelector(frameChunks[i], options);
            const element = yield this._page.selectors.query(frame, info, i === 0 ? scope : void 0);
            if (!element)
              return null;
            frame = yield element.contentFrame();
            element.dispose();
            if (!frame)
              throw new Error(`Selector "${(0, _selectorParser.stringifySelector)(info.parsed)}" resolved to ${element.preview()}, <iframe> was expected`);
          }
          return {
            frame,
            info: this._page.parseSelector(frameChunks[frameChunks.length - 1], options)
          };
        });
      }
      _runWaitForSelectorTaskOnce(progress, selector, world, task) {
        return __async(this, null, function* () {
          const context = yield this._context(world);
          const injected = yield context.injectedScript();
          try {
            const pollHandler = new dom.InjectedScriptPollHandler(progress, yield task(injected));
            const result = yield pollHandler.finishHandle();
            progress.cleanupWhenAborted(() => result.dispose());
            return result;
          } catch (e) {
            throw new Error(`Error: frame navigated while waiting for selector "${selector}"`);
          }
        });
      }
    };
    exports2.Frame = Frame;
    Frame.Events = {
      Navigation: "navigation",
      AddLifecycle: "addlifecycle",
      RemoveLifecycle: "removelifecycle"
    };
    var RerunnableTask = class {
      constructor(data, progress, task, returnByValue) {
        this.promise = void 0;
        this.handlePromise = void 0;
        this._task = void 0;
        this._progress = void 0;
        this._returnByValue = void 0;
        this._contextData = void 0;
        this._task = task;
        this._progress = progress;
        this._returnByValue = returnByValue;
        if (returnByValue)
          this.promise = new _manualPromise.ManualPromise();
        else
          this.handlePromise = new _manualPromise.ManualPromise();
        this._contextData = data;
        this._contextData.rerunnableTasks.add(this);
      }
      terminate(error) {
        this._reject(error);
      }
      _resolve(value) {
        if (this.promise)
          this.promise.resolve(value);
        if (this.handlePromise)
          this.handlePromise.resolve(value);
      }
      _reject(error) {
        if (this.promise)
          this.promise.reject(error);
        if (this.handlePromise)
          this.handlePromise.reject(error);
      }
      rerun(context) {
        return __async(this, null, function* () {
          try {
            const injectedScript = yield context.injectedScript();
            const pollHandler = new dom.InjectedScriptPollHandler(this._progress, yield this._task(injectedScript));
            const result = this._returnByValue ? yield pollHandler.finish() : yield pollHandler.finishHandle();
            this._contextData.rerunnableTasks.delete(this);
            this._resolve(result);
          } catch (e) {
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _protocolError.isSessionClosedError)(e)) {
              this._contextData.rerunnableTasks.delete(this);
              this._reject(e);
            }
          }
        });
      }
    };
    var SignalBarrier = class {
      constructor(progress) {
        this._progress = void 0;
        this._protectCount = 0;
        this._promise = new _manualPromise.ManualPromise();
        this._progress = progress;
        this.retain();
      }
      waitFor() {
        this.release();
        return this._promise;
      }
      addFrameNavigation(frame) {
        return __async(this, null, function* () {
          if (frame.parentFrame())
            return;
          this.retain();
          const waiter = _helper.helper.waitForEvent(null, frame, Frame.Events.Navigation, (e) => {
            if (!e.error && this._progress)
              this._progress.log(`  navigated to "${frame._url}"`);
            return true;
          });
          yield Promise.race([frame._page._disconnectedPromise, frame._page._crashedPromise, frame._detachedPromise, waiter.promise]).catch((e) => {
          });
          waiter.dispose();
          this.release();
        });
      }
      retain() {
        ++this._protectCount;
      }
      release() {
        --this._protectCount;
        if (!this._protectCount)
          this._promise.resolve();
      }
    };
    function verifyLifecycle(name, waitUntil) {
      if (waitUntil === "networkidle0")
        waitUntil = "networkidle";
      if (!types.kLifecycleEvents.has(waitUntil))
        throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle|commit)`);
      return waitUntil;
    }
  }
});

// node_modules/playwright-core/lib/server/usKeyboardLayout.js
var require_usKeyboardLayout = __commonJS({
  "node_modules/playwright-core/lib/server/usKeyboardLayout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.keypadLocation = exports2.USKeyboardLayout = void 0;
    var keypadLocation = 3;
    exports2.keypadLocation = keypadLocation;
    var USKeyboardLayout = {
      "Escape": {
        "keyCode": 27,
        "key": "Escape"
      },
      "F1": {
        "keyCode": 112,
        "key": "F1"
      },
      "F2": {
        "keyCode": 113,
        "key": "F2"
      },
      "F3": {
        "keyCode": 114,
        "key": "F3"
      },
      "F4": {
        "keyCode": 115,
        "key": "F4"
      },
      "F5": {
        "keyCode": 116,
        "key": "F5"
      },
      "F6": {
        "keyCode": 117,
        "key": "F6"
      },
      "F7": {
        "keyCode": 118,
        "key": "F7"
      },
      "F8": {
        "keyCode": 119,
        "key": "F8"
      },
      "F9": {
        "keyCode": 120,
        "key": "F9"
      },
      "F10": {
        "keyCode": 121,
        "key": "F10"
      },
      "F11": {
        "keyCode": 122,
        "key": "F11"
      },
      "F12": {
        "keyCode": 123,
        "key": "F12"
      },
      "Backquote": {
        "keyCode": 192,
        "shiftKey": "~",
        "key": "`"
      },
      "Digit1": {
        "keyCode": 49,
        "shiftKey": "!",
        "key": "1"
      },
      "Digit2": {
        "keyCode": 50,
        "shiftKey": "@",
        "key": "2"
      },
      "Digit3": {
        "keyCode": 51,
        "shiftKey": "#",
        "key": "3"
      },
      "Digit4": {
        "keyCode": 52,
        "shiftKey": "$",
        "key": "4"
      },
      "Digit5": {
        "keyCode": 53,
        "shiftKey": "%",
        "key": "5"
      },
      "Digit6": {
        "keyCode": 54,
        "shiftKey": "^",
        "key": "6"
      },
      "Digit7": {
        "keyCode": 55,
        "shiftKey": "&",
        "key": "7"
      },
      "Digit8": {
        "keyCode": 56,
        "shiftKey": "*",
        "key": "8"
      },
      "Digit9": {
        "keyCode": 57,
        "shiftKey": "(",
        "key": "9"
      },
      "Digit0": {
        "keyCode": 48,
        "shiftKey": ")",
        "key": "0"
      },
      "Minus": {
        "keyCode": 189,
        "shiftKey": "_",
        "key": "-"
      },
      "Equal": {
        "keyCode": 187,
        "shiftKey": "+",
        "key": "="
      },
      "Backslash": {
        "keyCode": 220,
        "shiftKey": "|",
        "key": "\\"
      },
      "Backspace": {
        "keyCode": 8,
        "key": "Backspace"
      },
      "Tab": {
        "keyCode": 9,
        "key": "Tab"
      },
      "KeyQ": {
        "keyCode": 81,
        "shiftKey": "Q",
        "key": "q"
      },
      "KeyW": {
        "keyCode": 87,
        "shiftKey": "W",
        "key": "w"
      },
      "KeyE": {
        "keyCode": 69,
        "shiftKey": "E",
        "key": "e"
      },
      "KeyR": {
        "keyCode": 82,
        "shiftKey": "R",
        "key": "r"
      },
      "KeyT": {
        "keyCode": 84,
        "shiftKey": "T",
        "key": "t"
      },
      "KeyY": {
        "keyCode": 89,
        "shiftKey": "Y",
        "key": "y"
      },
      "KeyU": {
        "keyCode": 85,
        "shiftKey": "U",
        "key": "u"
      },
      "KeyI": {
        "keyCode": 73,
        "shiftKey": "I",
        "key": "i"
      },
      "KeyO": {
        "keyCode": 79,
        "shiftKey": "O",
        "key": "o"
      },
      "KeyP": {
        "keyCode": 80,
        "shiftKey": "P",
        "key": "p"
      },
      "BracketLeft": {
        "keyCode": 219,
        "shiftKey": "{",
        "key": "["
      },
      "BracketRight": {
        "keyCode": 221,
        "shiftKey": "}",
        "key": "]"
      },
      "CapsLock": {
        "keyCode": 20,
        "key": "CapsLock"
      },
      "KeyA": {
        "keyCode": 65,
        "shiftKey": "A",
        "key": "a"
      },
      "KeyS": {
        "keyCode": 83,
        "shiftKey": "S",
        "key": "s"
      },
      "KeyD": {
        "keyCode": 68,
        "shiftKey": "D",
        "key": "d"
      },
      "KeyF": {
        "keyCode": 70,
        "shiftKey": "F",
        "key": "f"
      },
      "KeyG": {
        "keyCode": 71,
        "shiftKey": "G",
        "key": "g"
      },
      "KeyH": {
        "keyCode": 72,
        "shiftKey": "H",
        "key": "h"
      },
      "KeyJ": {
        "keyCode": 74,
        "shiftKey": "J",
        "key": "j"
      },
      "KeyK": {
        "keyCode": 75,
        "shiftKey": "K",
        "key": "k"
      },
      "KeyL": {
        "keyCode": 76,
        "shiftKey": "L",
        "key": "l"
      },
      "Semicolon": {
        "keyCode": 186,
        "shiftKey": ":",
        "key": ";"
      },
      "Quote": {
        "keyCode": 222,
        "shiftKey": '"',
        "key": "'"
      },
      "Enter": {
        "keyCode": 13,
        "key": "Enter",
        "text": "\r"
      },
      "ShiftLeft": {
        "keyCode": 160,
        "keyCodeWithoutLocation": 16,
        "key": "Shift",
        "location": 1
      },
      "KeyZ": {
        "keyCode": 90,
        "shiftKey": "Z",
        "key": "z"
      },
      "KeyX": {
        "keyCode": 88,
        "shiftKey": "X",
        "key": "x"
      },
      "KeyC": {
        "keyCode": 67,
        "shiftKey": "C",
        "key": "c"
      },
      "KeyV": {
        "keyCode": 86,
        "shiftKey": "V",
        "key": "v"
      },
      "KeyB": {
        "keyCode": 66,
        "shiftKey": "B",
        "key": "b"
      },
      "KeyN": {
        "keyCode": 78,
        "shiftKey": "N",
        "key": "n"
      },
      "KeyM": {
        "keyCode": 77,
        "shiftKey": "M",
        "key": "m"
      },
      "Comma": {
        "keyCode": 188,
        "shiftKey": "<",
        "key": ","
      },
      "Period": {
        "keyCode": 190,
        "shiftKey": ">",
        "key": "."
      },
      "Slash": {
        "keyCode": 191,
        "shiftKey": "?",
        "key": "/"
      },
      "ShiftRight": {
        "keyCode": 161,
        "keyCodeWithoutLocation": 16,
        "key": "Shift",
        "location": 2
      },
      "ControlLeft": {
        "keyCode": 162,
        "keyCodeWithoutLocation": 17,
        "key": "Control",
        "location": 1
      },
      "MetaLeft": {
        "keyCode": 91,
        "key": "Meta",
        "location": 1
      },
      "AltLeft": {
        "keyCode": 164,
        "keyCodeWithoutLocation": 18,
        "key": "Alt",
        "location": 1
      },
      "Space": {
        "keyCode": 32,
        "key": " "
      },
      "AltRight": {
        "keyCode": 165,
        "keyCodeWithoutLocation": 18,
        "key": "Alt",
        "location": 2
      },
      "AltGraph": {
        "keyCode": 225,
        "key": "AltGraph"
      },
      "MetaRight": {
        "keyCode": 92,
        "key": "Meta",
        "location": 2
      },
      "ContextMenu": {
        "keyCode": 93,
        "key": "ContextMenu"
      },
      "ControlRight": {
        "keyCode": 163,
        "keyCodeWithoutLocation": 17,
        "key": "Control",
        "location": 2
      },
      "PrintScreen": {
        "keyCode": 44,
        "key": "PrintScreen"
      },
      "ScrollLock": {
        "keyCode": 145,
        "key": "ScrollLock"
      },
      "Pause": {
        "keyCode": 19,
        "key": "Pause"
      },
      "PageUp": {
        "keyCode": 33,
        "key": "PageUp"
      },
      "PageDown": {
        "keyCode": 34,
        "key": "PageDown"
      },
      "Insert": {
        "keyCode": 45,
        "key": "Insert"
      },
      "Delete": {
        "keyCode": 46,
        "key": "Delete"
      },
      "Home": {
        "keyCode": 36,
        "key": "Home"
      },
      "End": {
        "keyCode": 35,
        "key": "End"
      },
      "ArrowLeft": {
        "keyCode": 37,
        "key": "ArrowLeft"
      },
      "ArrowUp": {
        "keyCode": 38,
        "key": "ArrowUp"
      },
      "ArrowRight": {
        "keyCode": 39,
        "key": "ArrowRight"
      },
      "ArrowDown": {
        "keyCode": 40,
        "key": "ArrowDown"
      },
      "NumLock": {
        "keyCode": 144,
        "key": "NumLock"
      },
      "NumpadDivide": {
        "keyCode": 111,
        "key": "/",
        "location": 3
      },
      "NumpadMultiply": {
        "keyCode": 106,
        "key": "*",
        "location": 3
      },
      "NumpadSubtract": {
        "keyCode": 109,
        "key": "-",
        "location": 3
      },
      "Numpad7": {
        "keyCode": 36,
        "shiftKeyCode": 103,
        "key": "Home",
        "shiftKey": "7",
        "location": 3
      },
      "Numpad8": {
        "keyCode": 38,
        "shiftKeyCode": 104,
        "key": "ArrowUp",
        "shiftKey": "8",
        "location": 3
      },
      "Numpad9": {
        "keyCode": 33,
        "shiftKeyCode": 105,
        "key": "PageUp",
        "shiftKey": "9",
        "location": 3
      },
      "Numpad4": {
        "keyCode": 37,
        "shiftKeyCode": 100,
        "key": "ArrowLeft",
        "shiftKey": "4",
        "location": 3
      },
      "Numpad5": {
        "keyCode": 12,
        "shiftKeyCode": 101,
        "key": "Clear",
        "shiftKey": "5",
        "location": 3
      },
      "Numpad6": {
        "keyCode": 39,
        "shiftKeyCode": 102,
        "key": "ArrowRight",
        "shiftKey": "6",
        "location": 3
      },
      "NumpadAdd": {
        "keyCode": 107,
        "key": "+",
        "location": 3
      },
      "Numpad1": {
        "keyCode": 35,
        "shiftKeyCode": 97,
        "key": "End",
        "shiftKey": "1",
        "location": 3
      },
      "Numpad2": {
        "keyCode": 40,
        "shiftKeyCode": 98,
        "key": "ArrowDown",
        "shiftKey": "2",
        "location": 3
      },
      "Numpad3": {
        "keyCode": 34,
        "shiftKeyCode": 99,
        "key": "PageDown",
        "shiftKey": "3",
        "location": 3
      },
      "Numpad0": {
        "keyCode": 45,
        "shiftKeyCode": 96,
        "key": "Insert",
        "shiftKey": "0",
        "location": 3
      },
      "NumpadDecimal": {
        "keyCode": 46,
        "shiftKeyCode": 110,
        "key": "\0",
        "shiftKey": ".",
        "location": 3
      },
      "NumpadEnter": {
        "keyCode": 13,
        "key": "Enter",
        "text": "\r",
        "location": 3
      }
    };
    exports2.USKeyboardLayout = USKeyboardLayout;
  }
});

// node_modules/playwright-core/lib/server/input.js
var require_input = __commonJS({
  "node_modules/playwright-core/lib/server/input.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.keypadLocation = exports2.Touchscreen = exports2.Mouse = exports2.Keyboard = void 0;
    var _utils = require_utils();
    var keyboardLayout = _interopRequireWildcard(require_usKeyboardLayout());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var keypadLocation = keyboardLayout.keypadLocation;
    exports2.keypadLocation = keypadLocation;
    var kModifiers = ["Alt", "Control", "Meta", "Shift"];
    var Keyboard = class {
      constructor(raw, page) {
        this._pressedModifiers = /* @__PURE__ */ new Set();
        this._pressedKeys = /* @__PURE__ */ new Set();
        this._raw = void 0;
        this._page = void 0;
        this._raw = raw;
        this._page = page;
      }
      down(key) {
        return __async(this, null, function* () {
          const description = this._keyDescriptionForString(key);
          const autoRepeat = this._pressedKeys.has(description.code);
          this._pressedKeys.add(description.code);
          if (kModifiers.includes(description.key))
            this._pressedModifiers.add(description.key);
          const text = description.text;
          yield this._raw.keydown(this._pressedModifiers, description.code, description.keyCode, description.keyCodeWithoutLocation, description.key, description.location, autoRepeat, text);
          yield this._page._doSlowMo();
        });
      }
      _keyDescriptionForString(keyString) {
        let description = usKeyboardLayout.get(keyString);
        (0, _utils.assert)(description, `Unknown key: "${keyString}"`);
        const shift = this._pressedModifiers.has("Shift");
        description = shift && description.shifted ? description.shifted : description;
        if (this._pressedModifiers.size > 1 || !this._pressedModifiers.has("Shift") && this._pressedModifiers.size === 1)
          return __spreadProps(__spreadValues({}, description), {
            text: ""
          });
        return description;
      }
      up(key) {
        return __async(this, null, function* () {
          const description = this._keyDescriptionForString(key);
          if (kModifiers.includes(description.key))
            this._pressedModifiers.delete(description.key);
          this._pressedKeys.delete(description.code);
          yield this._raw.keyup(this._pressedModifiers, description.code, description.keyCode, description.keyCodeWithoutLocation, description.key, description.location);
          yield this._page._doSlowMo();
        });
      }
      insertText(text) {
        return __async(this, null, function* () {
          yield this._raw.sendText(text);
          yield this._page._doSlowMo();
        });
      }
      type(text, options) {
        return __async(this, null, function* () {
          const delay = options && options.delay || void 0;
          for (const char of text) {
            if (usKeyboardLayout.has(char)) {
              yield this.press(char, {
                delay
              });
            } else {
              if (delay)
                yield new Promise((f) => setTimeout(f, delay));
              yield this.insertText(char);
            }
          }
        });
      }
      press(_0) {
        return __async(this, arguments, function* (key, options = {}) {
          function split(keyString) {
            const keys = [];
            let building = "";
            for (const char of keyString) {
              if (char === "+" && building) {
                keys.push(building);
                building = "";
              } else {
                building += char;
              }
            }
            keys.push(building);
            return keys;
          }
          const tokens = split(key);
          const promises = [];
          key = tokens[tokens.length - 1];
          for (let i = 0; i < tokens.length - 1; ++i)
            promises.push(this.down(tokens[i]));
          promises.push(this.down(key));
          if (options.delay) {
            yield Promise.all(promises);
            yield new Promise((f) => setTimeout(f, options.delay));
          }
          promises.push(this.up(key));
          for (let i = tokens.length - 2; i >= 0; --i)
            promises.push(this.up(tokens[i]));
          yield Promise.all(promises);
        });
      }
      _ensureModifiers(modifiers) {
        return __async(this, null, function* () {
          for (const modifier of modifiers) {
            if (!kModifiers.includes(modifier))
              throw new Error("Unknown modifier " + modifier);
          }
          const restore = Array.from(this._pressedModifiers);
          const promises = [];
          for (const key of kModifiers) {
            const needDown = modifiers.includes(key);
            const isDown = this._pressedModifiers.has(key);
            if (needDown && !isDown)
              promises.push(this.down(key));
            else if (!needDown && isDown)
              promises.push(this.up(key));
          }
          yield Promise.all(promises);
          return restore;
        });
      }
      _modifiers() {
        return this._pressedModifiers;
      }
    };
    exports2.Keyboard = Keyboard;
    var Mouse = class {
      constructor(raw, page) {
        this._keyboard = void 0;
        this._x = 0;
        this._y = 0;
        this._lastButton = "none";
        this._buttons = /* @__PURE__ */ new Set();
        this._raw = void 0;
        this._page = void 0;
        this._raw = raw;
        this._page = page;
        this._keyboard = this._page.keyboard;
      }
      move(_0, _1) {
        return __async(this, arguments, function* (x, y, options = {}) {
          const {
            steps = 1
          } = options;
          const fromX = this._x;
          const fromY = this._y;
          this._x = x;
          this._y = y;
          for (let i = 1; i <= steps; i++) {
            const middleX = fromX + (x - fromX) * (i / steps);
            const middleY = fromY + (y - fromY) * (i / steps);
            yield this._raw.move(middleX, middleY, this._lastButton, this._buttons, this._keyboard._modifiers(), !!options.forClick);
            yield this._page._doSlowMo();
          }
        });
      }
      down() {
        return __async(this, arguments, function* (options = {}) {
          const {
            button = "left",
            clickCount = 1
          } = options;
          this._lastButton = button;
          this._buttons.add(button);
          yield this._raw.down(this._x, this._y, this._lastButton, this._buttons, this._keyboard._modifiers(), clickCount);
          yield this._page._doSlowMo();
        });
      }
      up() {
        return __async(this, arguments, function* (options = {}) {
          const {
            button = "left",
            clickCount = 1
          } = options;
          this._lastButton = "none";
          this._buttons.delete(button);
          yield this._raw.up(this._x, this._y, button, this._buttons, this._keyboard._modifiers(), clickCount);
          yield this._page._doSlowMo();
        });
      }
      click(_0, _1) {
        return __async(this, arguments, function* (x, y, options = {}) {
          const {
            delay = null,
            clickCount = 1
          } = options;
          if (delay) {
            this.move(x, y, {
              forClick: true
            });
            for (let cc = 1; cc <= clickCount; ++cc) {
              yield this.down(__spreadProps(__spreadValues({}, options), {
                clickCount: cc
              }));
              yield new Promise((f) => setTimeout(f, delay));
              yield this.up(__spreadProps(__spreadValues({}, options), {
                clickCount: cc
              }));
              if (cc < clickCount)
                yield new Promise((f) => setTimeout(f, delay));
            }
          } else {
            const promises = [];
            promises.push(this.move(x, y, {
              forClick: true
            }));
            for (let cc = 1; cc <= clickCount; ++cc) {
              promises.push(this.down(__spreadProps(__spreadValues({}, options), {
                clickCount: cc
              })));
              promises.push(this.up(__spreadProps(__spreadValues({}, options), {
                clickCount: cc
              })));
            }
            yield Promise.all(promises);
          }
        });
      }
      dblclick(_0, _1) {
        return __async(this, arguments, function* (x, y, options = {}) {
          yield this.click(x, y, __spreadProps(__spreadValues({}, options), {
            clickCount: 2
          }));
        });
      }
      wheel(deltaX, deltaY) {
        return __async(this, null, function* () {
          yield this._raw.wheel(this._x, this._y, this._buttons, this._keyboard._modifiers(), deltaX, deltaY);
          yield this._page._doSlowMo();
        });
      }
    };
    exports2.Mouse = Mouse;
    var aliases = /* @__PURE__ */ new Map([["ShiftLeft", ["Shift"]], ["ControlLeft", ["Control"]], ["AltLeft", ["Alt"]], ["MetaLeft", ["Meta"]], ["Enter", ["\n", "\r"]]]);
    var usKeyboardLayout = buildLayoutClosure(keyboardLayout.USKeyboardLayout);
    function buildLayoutClosure(layout) {
      const result = /* @__PURE__ */ new Map();
      for (const code in layout) {
        const definition = layout[code];
        const description = {
          key: definition.key || "",
          keyCode: definition.keyCode || 0,
          keyCodeWithoutLocation: definition.keyCodeWithoutLocation || definition.keyCode || 0,
          code,
          text: definition.text || "",
          location: definition.location || 0
        };
        if (definition.key.length === 1)
          description.text = description.key;
        let shiftedDescription;
        if (definition.shiftKey) {
          (0, _utils.assert)(definition.shiftKey.length === 1);
          shiftedDescription = __spreadValues({}, description);
          shiftedDescription.key = definition.shiftKey;
          shiftedDescription.text = definition.shiftKey;
          if (definition.shiftKeyCode)
            shiftedDescription.keyCode = definition.shiftKeyCode;
        }
        result.set(code, __spreadProps(__spreadValues({}, description), {
          shifted: shiftedDescription
        }));
        if (aliases.has(code)) {
          for (const alias of aliases.get(code))
            result.set(alias, description);
        }
        if (definition.location)
          continue;
        if (description.key.length === 1)
          result.set(description.key, description);
        if (shiftedDescription)
          result.set(shiftedDescription.key, __spreadProps(__spreadValues({}, shiftedDescription), {
            shifted: void 0
          }));
      }
      return result;
    }
    var Touchscreen = class {
      constructor(raw, page) {
        this._raw = void 0;
        this._page = void 0;
        this._raw = raw;
        this._page = page;
      }
      tap(x, y) {
        return __async(this, null, function* () {
          if (!this._page._browserContext._options.hasTouch)
            throw new Error("hasTouch must be enabled on the browser context before using the touchscreen.");
          yield this._raw.tap(x, y, this._page.keyboard._modifiers());
          yield this._page._doSlowMo();
        });
      }
    };
    exports2.Touchscreen = Touchscreen;
  }
});

// node_modules/playwright-core/lib/utils/multimap.js
var require_multimap = __commonJS({
  "node_modules/playwright-core/lib/utils/multimap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.MultiMap = void 0;
    var MultiMap = class {
      constructor() {
        this._map = void 0;
        this._map = /* @__PURE__ */ new Map();
      }
      set(key, value) {
        let values = this._map.get(key);
        if (!values) {
          values = [];
          this._map.set(key, values);
        }
        values.push(value);
      }
      get(key) {
        return this._map.get(key) || [];
      }
      has(key) {
        return this._map.has(key);
      }
      hasValue(key, value) {
        const values = this._map.get(key);
        if (!values)
          return false;
        return values.includes(value);
      }
      get size() {
        return this._map.size;
      }
      keys() {
        return this._map.keys();
      }
      values() {
        const result = [];
        for (const key of this.keys())
          result.push(...this.get(key));
        return result;
      }
      clear() {
        this._map.clear();
      }
    };
    exports2.MultiMap = MultiMap;
  }
});

// node_modules/playwright-core/lib/server/screenshotter.js
var require_screenshotter = __commonJS({
  "node_modules/playwright-core/lib/server/screenshotter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Screenshotter = void 0;
    var _helper = require_helper();
    var _utils = require_utils();
    var _multimap = require_multimap();
    var Screenshotter = class {
      constructor(page) {
        this._queue = new TaskQueue();
        this._page = void 0;
        this._page = page;
        this._queue = new TaskQueue();
      }
      _originalViewportSize(progress) {
        return __async(this, null, function* () {
          const originalViewportSize = this._page.viewportSize();
          let viewportSize = originalViewportSize;
          if (!viewportSize)
            viewportSize = yield this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({
              width: window.innerWidth,
              height: window.innerHeight
            }));
          return {
            viewportSize,
            originalViewportSize
          };
        });
      }
      _fullPageSize(progress) {
        return __async(this, null, function* () {
          const fullPageSize = yield this._page.mainFrame().waitForFunctionValueInUtility(progress, () => {
            if (!document.body || !document.documentElement)
              return null;
            return {
              width: Math.max(document.body.scrollWidth, document.documentElement.scrollWidth, document.body.offsetWidth, document.documentElement.offsetWidth, document.body.clientWidth, document.documentElement.clientWidth),
              height: Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight)
            };
          });
          return fullPageSize;
        });
      }
      screenshotPage(progress, options) {
        return __async(this, null, function* () {
          const format = validateScreenshotOptions(options);
          return this._queue.postTask(() => __async(this, null, function* () {
            progress.log("taking page screenshot");
            const {
              viewportSize
            } = yield this._originalViewportSize(progress);
            yield this._preparePageForScreenshot(progress, options.caret !== "initial", options.animations === "disabled", options.fonts === "ready");
            progress.throwIfAborted();
            if (options.fullPage) {
              const fullPageSize = yield this._fullPageSize(progress);
              let documentRect = {
                x: 0,
                y: 0,
                width: fullPageSize.width,
                height: fullPageSize.height
              };
              const fitsViewport = fullPageSize.width <= viewportSize.width && fullPageSize.height <= viewportSize.height;
              if (options.clip)
                documentRect = trimClipToSize(options.clip, documentRect);
              const buffer2 = yield this._screenshot(progress, format, documentRect, void 0, fitsViewport, options);
              progress.throwIfAborted();
              yield this._restorePageAfterScreenshot();
              return buffer2;
            }
            const viewportRect = options.clip ? trimClipToSize(options.clip, viewportSize) : __spreadValues({
              x: 0,
              y: 0
            }, viewportSize);
            const buffer = yield this._screenshot(progress, format, void 0, viewportRect, true, options);
            progress.throwIfAborted();
            yield this._restorePageAfterScreenshot();
            return buffer;
          }));
        });
      }
      screenshotElement(progress, handle, options) {
        return __async(this, null, function* () {
          const format = validateScreenshotOptions(options);
          return this._queue.postTask(() => __async(this, null, function* () {
            progress.log("taking element screenshot");
            const {
              viewportSize
            } = yield this._originalViewportSize(progress);
            yield this._preparePageForScreenshot(progress, options.caret !== "initial", options.animations === "disabled", options.fonts === "ready");
            progress.throwIfAborted();
            yield handle._waitAndScrollIntoViewIfNeeded(progress);
            progress.throwIfAborted();
            const boundingBox = yield handle.boundingBox();
            (0, _utils.assert)(boundingBox, "Node is either not visible or not an HTMLElement");
            (0, _utils.assert)(boundingBox.width !== 0, "Node has 0 width.");
            (0, _utils.assert)(boundingBox.height !== 0, "Node has 0 height.");
            const fitsViewport = boundingBox.width <= viewportSize.width && boundingBox.height <= viewportSize.height;
            progress.throwIfAborted();
            const scrollOffset = yield this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({
              x: window.scrollX,
              y: window.scrollY
            }));
            const documentRect = __spreadValues({}, boundingBox);
            documentRect.x += scrollOffset.x;
            documentRect.y += scrollOffset.y;
            const buffer = yield this._screenshot(progress, format, _helper.helper.enclosingIntRect(documentRect), void 0, fitsViewport, options);
            progress.throwIfAborted();
            yield this._restorePageAfterScreenshot();
            return buffer;
          }));
        });
      }
      _preparePageForScreenshot(progress, hideCaret, disableAnimations, waitForFonts) {
        return __async(this, null, function* () {
          if (disableAnimations)
            progress.log("  disabled all CSS animations");
          if (waitForFonts)
            progress.log("  waiting for fonts to load...");
          yield Promise.all(this._page.frames().map((frame) => __async(this, null, function* () {
            yield frame.nonStallingEvaluateInExistingContext("(" + function(hideCaret2, disableAnimations2, waitForFonts2) {
              return __async(this, null, function* () {
                const styleTag = document.createElement("style");
                if (hideCaret2) {
                  styleTag.textContent = `
            *:not(#playwright-aaaaaaaaaa.playwright-bbbbbbbbbbb.playwright-cccccccccc.playwright-dddddddddd.playwright-eeeeeeeee) {
              caret-color: transparent !important;
            }
          `;
                  document.documentElement.append(styleTag);
                }
                const infiniteAnimationsToResume = /* @__PURE__ */ new Set();
                const cleanupCallbacks = [];
                if (disableAnimations2) {
                  const collectRoots = (root, roots = []) => {
                    roots.push(root);
                    const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
                    do {
                      const node = walker.currentNode;
                      const shadowRoot = node instanceof Element ? node.shadowRoot : null;
                      if (shadowRoot)
                        collectRoots(shadowRoot, roots);
                    } while (walker.nextNode());
                    return roots;
                  };
                  const handleAnimations = (root) => {
                    for (const animation of root.getAnimations()) {
                      if (!animation.effect || animation.playbackRate === 0 || infiniteAnimationsToResume.has(animation))
                        continue;
                      const endTime = animation.effect.getComputedTiming().endTime;
                      if (Number.isFinite(endTime)) {
                        try {
                          animation.finish();
                        } catch (e) {
                        }
                      } else {
                        try {
                          animation.cancel();
                          infiniteAnimationsToResume.add(animation);
                        } catch (e) {
                        }
                      }
                    }
                  };
                  for (const root of collectRoots(document)) {
                    const handleRootAnimations = handleAnimations.bind(null, root);
                    handleRootAnimations();
                    root.addEventListener("transitionrun", handleRootAnimations);
                    root.addEventListener("animationstart", handleRootAnimations);
                    cleanupCallbacks.push(() => {
                      root.removeEventListener("transitionrun", handleRootAnimations);
                      root.removeEventListener("animationstart", handleRootAnimations);
                    });
                  }
                }
                window.__cleanupScreenshot = () => {
                  styleTag.remove();
                  for (const animation of infiniteAnimationsToResume) {
                    try {
                      animation.play();
                    } catch (e) {
                    }
                  }
                  for (const cleanupCallback of cleanupCallbacks)
                    cleanupCallback();
                  delete window.__cleanupScreenshot;
                };
                if (waitForFonts2)
                  yield document.fonts.ready;
              });
            }.toString() + `)(${hideCaret}, ${disableAnimations}, ${waitForFonts})`, false, "utility").catch(() => {
            });
          })));
          if (waitForFonts)
            progress.log("  fonts in all frames are loaded");
          progress.cleanupWhenAborted(() => this._restorePageAfterScreenshot());
        });
      }
      _restorePageAfterScreenshot() {
        return __async(this, null, function* () {
          yield Promise.all(this._page.frames().map((frame) => __async(this, null, function* () {
            frame.nonStallingEvaluateInExistingContext("window.__cleanupScreenshot && window.__cleanupScreenshot()", false, "utility").catch(() => {
            });
          })));
        });
      }
      _maskElements(progress, options) {
        return __async(this, null, function* () {
          const framesToParsedSelectors = new _multimap.MultiMap();
          const cleanup = () => __async(this, null, function* () {
            yield Promise.all([...framesToParsedSelectors.keys()].map((frame) => __async(this, null, function* () {
              yield frame.hideHighlight();
            })));
          });
          if (!options.mask || !options.mask.length)
            return cleanup;
          yield Promise.all((options.mask || []).map((_0) => __async(this, [_0], function* ({
            frame,
            selector
          }) {
            const pair = yield frame.resolveFrameForSelectorNoWait(selector);
            if (pair)
              framesToParsedSelectors.set(pair.frame, pair.info.parsed);
          })));
          progress.throwIfAborted();
          yield Promise.all([...framesToParsedSelectors.keys()].map((frame) => __async(this, null, function* () {
            yield frame.maskSelectors(framesToParsedSelectors.get(frame));
          })));
          progress.cleanupWhenAborted(cleanup);
          return cleanup;
        });
      }
      _screenshot(progress, format, documentRect, viewportRect, fitsViewport, options) {
        return __async(this, null, function* () {
          if (options.__testHookBeforeScreenshot)
            yield options.__testHookBeforeScreenshot();
          progress.throwIfAborted();
          const shouldSetDefaultBackground = options.omitBackground && format === "png";
          if (shouldSetDefaultBackground) {
            yield this._page._delegate.setBackgroundColor({
              r: 0,
              g: 0,
              b: 0,
              a: 0
            });
            progress.cleanupWhenAborted(() => this._page._delegate.setBackgroundColor());
          }
          progress.throwIfAborted();
          const cleanupHighlight = yield this._maskElements(progress, options);
          progress.throwIfAborted();
          const buffer = yield this._page._delegate.takeScreenshot(progress, format, documentRect, viewportRect, options.quality, fitsViewport, options.scale || "device");
          progress.throwIfAborted();
          yield cleanupHighlight();
          progress.throwIfAborted();
          if (shouldSetDefaultBackground)
            yield this._page._delegate.setBackgroundColor();
          progress.throwIfAborted();
          if (options.__testHookAfterScreenshot)
            yield options.__testHookAfterScreenshot();
          return buffer;
        });
      }
    };
    exports2.Screenshotter = Screenshotter;
    var TaskQueue = class {
      constructor() {
        this._chain = void 0;
        this._chain = Promise.resolve();
      }
      postTask(task) {
        const result = this._chain.then(task);
        this._chain = result.catch(() => {
        });
        return result;
      }
    };
    function trimClipToSize(clip, size) {
      const p1 = {
        x: Math.max(0, Math.min(clip.x, size.width)),
        y: Math.max(0, Math.min(clip.y, size.height))
      };
      const p2 = {
        x: Math.max(0, Math.min(clip.x + clip.width, size.width)),
        y: Math.max(0, Math.min(clip.y + clip.height, size.height))
      };
      const result = {
        x: p1.x,
        y: p1.y,
        width: p2.x - p1.x,
        height: p2.y - p1.y
      };
      (0, _utils.assert)(result.width && result.height, "Clipped area is either empty or outside the resulting image");
      return result;
    }
    function validateScreenshotOptions(options) {
      let format = null;
      if (options.type) {
        (0, _utils.assert)(options.type === "png" || options.type === "jpeg", "Unknown options.type value: " + options.type);
        format = options.type;
      }
      if (!format)
        format = "png";
      if (options.quality !== void 0) {
        (0, _utils.assert)(format === "jpeg", "options.quality is unsupported for the " + format + " screenshots");
        (0, _utils.assert)(typeof options.quality === "number", "Expected options.quality to be a number but found " + typeof options.quality);
        (0, _utils.assert)(Number.isInteger(options.quality), "Expected options.quality to be an integer");
        (0, _utils.assert)(options.quality >= 0 && options.quality <= 100, "Expected options.quality to be between 0 and 100 (inclusive), got " + options.quality);
      }
      if (options.clip) {
        (0, _utils.assert)(typeof options.clip.x === "number", "Expected options.clip.x to be a number but found " + typeof options.clip.x);
        (0, _utils.assert)(typeof options.clip.y === "number", "Expected options.clip.y to be a number but found " + typeof options.clip.y);
        (0, _utils.assert)(typeof options.clip.width === "number", "Expected options.clip.width to be a number but found " + typeof options.clip.width);
        (0, _utils.assert)(typeof options.clip.height === "number", "Expected options.clip.height to be a number but found " + typeof options.clip.height);
        (0, _utils.assert)(options.clip.width !== 0, "Expected options.clip.width not to be 0.");
        (0, _utils.assert)(options.clip.height !== 0, "Expected options.clip.height not to be 0.");
      }
      return format;
    }
  }
});

// node_modules/playwright-core/lib/server/console.js
var require_console = __commonJS({
  "node_modules/playwright-core/lib/server/console.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ConsoleMessage = void 0;
    var _instrumentation = require_instrumentation();
    var ConsoleMessage = class extends _instrumentation.SdkObject {
      constructor(parent, type, text, args, location2) {
        super(parent, "console-message");
        this._type = void 0;
        this._text = void 0;
        this._args = void 0;
        this._location = void 0;
        this._type = type;
        this._text = text;
        this._args = args;
        this._location = location2 || {
          url: "",
          lineNumber: 0,
          columnNumber: 0
        };
      }
      type() {
        return this._type;
      }
      text() {
        if (this._text === void 0)
          this._text = this._args.map((arg) => arg.preview()).join(" ");
        return this._text;
      }
      args() {
        return this._args;
      }
      location() {
        return this._location;
      }
    };
    exports2.ConsoleMessage = ConsoleMessage;
  }
});

// node_modules/playwright-core/lib/server/accessibility.js
var require_accessibility = __commonJS({
  "node_modules/playwright-core/lib/server/accessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Accessibility = void 0;
    var Accessibility = class {
      constructor(getAXTree) {
        this._getAXTree = void 0;
        this._getAXTree = getAXTree;
      }
      snapshot() {
        return __async(this, arguments, function* (options = {}) {
          const {
            interestingOnly = true,
            root = null
          } = options;
          const {
            tree,
            needle
          } = yield this._getAXTree(root || void 0);
          if (!interestingOnly) {
            if (root)
              return needle && serializeTree(needle)[0];
            return serializeTree(tree)[0];
          }
          const interestingNodes = /* @__PURE__ */ new Set();
          collectInterestingNodes(interestingNodes, tree, false);
          if (root && (!needle || !interestingNodes.has(needle)))
            return null;
          return serializeTree(needle || tree, interestingNodes)[0];
        });
      }
    };
    exports2.Accessibility = Accessibility;
    function collectInterestingNodes(collection, node, insideControl) {
      if (node.isInteresting(insideControl))
        collection.add(node);
      if (node.isLeafNode())
        return;
      insideControl = insideControl || node.isControl();
      for (const child of node.children())
        collectInterestingNodes(collection, child, insideControl);
    }
    function serializeTree(node, whitelistedNodes) {
      const children = [];
      for (const child of node.children())
        children.push(...serializeTree(child, whitelistedNodes));
      if (whitelistedNodes && !whitelistedNodes.has(node))
        return children;
      const serializedNode = node.serialize();
      if (children.length)
        serializedNode.children = children;
      return [serializedNode];
    }
  }
});

// node_modules/playwright-core/lib/server/fileChooser.js
var require_fileChooser = __commonJS({
  "node_modules/playwright-core/lib/server/fileChooser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FileChooser = void 0;
    var FileChooser = class {
      constructor(page, elementHandle, isMultiple) {
        this._page = void 0;
        this._elementHandle = void 0;
        this._isMultiple = void 0;
        this._page = page;
        this._elementHandle = elementHandle;
        this._isMultiple = isMultiple;
      }
      element() {
        return this._elementHandle;
      }
      isMultiple() {
        return this._isMultiple;
      }
      page() {
        return this._page;
      }
    };
    exports2.FileChooser = FileChooser;
  }
});

// node_modules/colors/lib/styles.js
var require_styles = __commonJS({
  "node_modules/colors/lib/styles.js"(exports2, module2) {
    var styles = {};
    module2["exports"] = styles;
    var codes = {
      reset: [0, 0],
      bold: [1, 22],
      dim: [2, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      hidden: [8, 28],
      strikethrough: [9, 29],
      black: [30, 39],
      red: [31, 39],
      green: [32, 39],
      yellow: [33, 39],
      blue: [34, 39],
      magenta: [35, 39],
      cyan: [36, 39],
      white: [37, 39],
      gray: [90, 39],
      grey: [90, 39],
      brightRed: [91, 39],
      brightGreen: [92, 39],
      brightYellow: [93, 39],
      brightBlue: [94, 39],
      brightMagenta: [95, 39],
      brightCyan: [96, 39],
      brightWhite: [97, 39],
      bgBlack: [40, 49],
      bgRed: [41, 49],
      bgGreen: [42, 49],
      bgYellow: [43, 49],
      bgBlue: [44, 49],
      bgMagenta: [45, 49],
      bgCyan: [46, 49],
      bgWhite: [47, 49],
      bgGray: [100, 49],
      bgGrey: [100, 49],
      bgBrightRed: [101, 49],
      bgBrightGreen: [102, 49],
      bgBrightYellow: [103, 49],
      bgBrightBlue: [104, 49],
      bgBrightMagenta: [105, 49],
      bgBrightCyan: [106, 49],
      bgBrightWhite: [107, 49],
      blackBG: [40, 49],
      redBG: [41, 49],
      greenBG: [42, 49],
      yellowBG: [43, 49],
      blueBG: [44, 49],
      magentaBG: [45, 49],
      cyanBG: [46, 49],
      whiteBG: [47, 49]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = "[" + val[0] + "m";
      style.close = "[" + val[1] + "m";
    });
  }
});

// node_modules/colors/lib/system/has-flag.js
var require_has_flag = __commonJS({
  "node_modules/colors/lib/system/has-flag.js"(exports2, module2) {
    "use strict";
    module2.exports = function(flag, argv) {
      argv = argv || process.argv;
      var terminatorPos = argv.indexOf("--");
      var prefix = /^-{1,2}/.test(flag) ? "" : "--";
      var pos = argv.indexOf(prefix + flag);
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "node_modules/colors/lib/system/supports-colors.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env = process.env;
    var forceColor = void 0;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env) {
      forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      var min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        var osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function(sign) {
          return sign in env;
        }) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("TERM_PROGRAM" in env) {
        var version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Hyper":
            return 3;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      if (env.TERM === "dumb") {
        return min;
      }
      return min;
    }
    function getSupportLevel(stream) {
      var level = supportsColor(stream);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "node_modules/colors/lib/custom/trap.js"(exports2, module2) {
    module2["exports"] = function runTheTrap(text, options) {
      var result = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: ["@", "\u0104", "\u023A", "\u0245", "\u0394", "\u039B", "\u0414"],
        b: ["\xDF", "\u0181", "\u0243", "\u026E", "\u03B2", "\u0E3F"],
        c: ["\xA9", "\u023B", "\u03FE"],
        d: ["\xD0", "\u018A", "\u0500", "\u0501", "\u0502", "\u0503"],
        e: [
          "\xCB",
          "\u0115",
          "\u018E",
          "\u0258",
          "\u03A3",
          "\u03BE",
          "\u04BC",
          "\u0A6C"
        ],
        f: ["\u04FA"],
        g: ["\u0262"],
        h: ["\u0126", "\u0195", "\u04A2", "\u04BA", "\u04C7", "\u050A"],
        i: ["\u0F0F"],
        j: ["\u0134"],
        k: ["\u0138", "\u04A0", "\u04C3", "\u051E"],
        l: ["\u0139"],
        m: ["\u028D", "\u04CD", "\u04CE", "\u0520", "\u0521", "\u0D69"],
        n: ["\xD1", "\u014B", "\u019D", "\u0376", "\u03A0", "\u048A"],
        o: [
          "\xD8",
          "\xF5",
          "\xF8",
          "\u01FE",
          "\u0298",
          "\u047A",
          "\u05DD",
          "\u06DD",
          "\u0E4F"
        ],
        p: ["\u01F7", "\u048E"],
        q: ["\u09CD"],
        r: ["\xAE", "\u01A6", "\u0210", "\u024C", "\u0280", "\u042F"],
        s: ["\xA7", "\u03DE", "\u03DF", "\u03E8"],
        t: ["\u0141", "\u0166", "\u0373"],
        u: ["\u01B1", "\u054D"],
        v: ["\u05D8"],
        w: ["\u0428", "\u0460", "\u047C", "\u0D70"],
        x: ["\u04B2", "\u04FE", "\u04FC", "\u04FD"],
        y: ["\xA5", "\u04B0", "\u04CB"],
        z: ["\u01B5", "\u0240"]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [" "];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result += trap[c][rand];
        } else {
          result += c;
        }
      });
      return result;
    };
  }
});

// node_modules/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "node_modules/colors/lib/custom/zalgo.js"(exports2, module2) {
    module2["exports"] = function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      };
      var all = [].concat(soul.up, soul.down, soul.mid);
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      function isChar(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      function heComes(text2, options2) {
        var result = "";
        var counts;
        var l;
        options2 = options2 || {};
        options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
        options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
        options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
        options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (isChar(l)) {
            continue;
          }
          result = result + text2[l];
          counts = { "up": 0, "down": 0, "mid": 0 };
          switch (options2.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.mid = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.mid = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = ["up", "mid", "down"];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options2[index]) {
                result = result + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result;
      }
      return heComes(text, options);
    };
  }
});

// node_modules/colors/lib/maps/america.js
var require_america = __commonJS({
  "node_modules/colors/lib/maps/america.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        if (letter === " ")
          return letter;
        switch (i % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    };
  }
});

// node_modules/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "node_modules/colors/lib/maps/zebra.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        return i % 2 === 0 ? letter : colors.inverse(letter);
      };
    };
  }
});

// node_modules/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "node_modules/colors/lib/maps/rainbow.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var rainbowColors = ["red", "yellow", "green", "blue", "magenta"];
      return function(letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    };
  }
});

// node_modules/colors/lib/maps/random.js
var require_random = __commonJS({
  "node_modules/colors/lib/maps/random.js"(exports2, module2) {
    module2["exports"] = function(colors) {
      var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
      ];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
      };
    };
  }
});

// node_modules/colors/lib/colors.js
var require_colors = __commonJS({
  "node_modules/colors/lib/colors.js"(exports2, module2) {
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var util = require("util");
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);
    colors.supportsColor = require_supports_colors().supportsColor;
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor() !== false;
    }
    colors.enable = function() {
      colors.enabled = true;
    };
    colors.disable = function() {
      colors.enabled = false;
    };
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = function stylize2(str, style) {
      if (!colors.enabled) {
        return str + "";
      }
      var styleMap = ansiStyles[style];
      if (!styleMap && style in colors) {
        return colors[style](str);
      }
      return styleMap.open + str + styleMap.close;
    };
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    };
    function build(_styles) {
      var builder = function builder2() {
        return applyStyle.apply(builder2, arguments);
      };
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    var styles = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: function() {
            return build(this._styles.concat(key));
          }
        };
      });
      return ret;
    }();
    var proto = defineProps(function colors2() {
    }, styles);
    function applyStyle() {
      var args = Array.prototype.slice.call(arguments);
      var str = args.map(function(arg) {
        if (arg != null && arg.constructor === String) {
          return arg;
        } else {
          return util.inspect(arg);
        }
      }).join(" ");
      if (!colors.enabled || !str) {
        return str;
      }
      var newLinesPresent = str.indexOf("\n") != -1;
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, function(match) {
            return code.close + match + code.open;
          });
        }
      }
      return str;
    }
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            if (typeof theme[style2] === "object") {
              var out = str;
              for (var i in theme[style2]) {
                out = colors[theme[style2][i]](out);
              }
              return out;
            }
            return colors[theme[style2]](str);
          };
        })(style);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function(name) {
        ret[name] = {
          get: function() {
            return build([name]);
          }
        };
      });
      return ret;
    }
    var sequencer = function sequencer2(map2, str) {
      var exploded = str.split("");
      exploded = exploded.map(map2);
      return exploded.join("");
    };
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america()(colors);
    colors.maps.zebra = require_zebra()(colors);
    colors.maps.rainbow = require_rainbow()(colors);
    colors.maps.random = require_random()(colors);
    for (map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    var map;
    defineProps(colors, init());
  }
});

// node_modules/colors/safe.js
var require_safe = __commonJS({
  "node_modules/colors/safe.js"(exports2, module2) {
    var colors = require_colors();
    module2["exports"] = colors;
  }
});

// node_modules/jpeg-js/lib/encoder.js
var require_encoder = __commonJS({
  "node_modules/jpeg-js/lib/encoder.js"(exports2, module2) {
    var btoa = btoa || function(buf) {
      return Buffer.from(buf).toString("base64");
    };
    function JPEGEncoder(quality) {
      var self2 = this;
      var fround = Math.round;
      var ffloor = Math.floor;
      var YTable = new Array(64);
      var UVTable = new Array(64);
      var fdtbl_Y = new Array(64);
      var fdtbl_UV = new Array(64);
      var YDC_HT;
      var UVDC_HT;
      var YAC_HT;
      var UVAC_HT;
      var bitcode = new Array(65535);
      var category = new Array(65535);
      var outputfDCTQuant = new Array(64);
      var DU = new Array(64);
      var byteout = [];
      var bytenew = 0;
      var bytepos = 7;
      var YDU = new Array(64);
      var UDU = new Array(64);
      var VDU = new Array(64);
      var clt = new Array(256);
      var RGB_YUV_TABLE = new Array(2048);
      var currentQuality;
      var ZigZag = [
        0,
        1,
        5,
        6,
        14,
        15,
        27,
        28,
        2,
        4,
        7,
        13,
        16,
        26,
        29,
        42,
        3,
        8,
        12,
        17,
        25,
        30,
        41,
        43,
        9,
        11,
        18,
        24,
        31,
        40,
        44,
        53,
        10,
        19,
        23,
        32,
        39,
        45,
        52,
        54,
        20,
        22,
        33,
        38,
        46,
        51,
        55,
        60,
        21,
        34,
        37,
        47,
        50,
        56,
        59,
        61,
        35,
        36,
        48,
        49,
        57,
        58,
        62,
        63
      ];
      var std_dc_luminance_nrcodes = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0];
      var std_dc_luminance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_luminance_nrcodes = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125];
      var std_ac_luminance_values = [
        1,
        2,
        3,
        0,
        4,
        17,
        5,
        18,
        33,
        49,
        65,
        6,
        19,
        81,
        97,
        7,
        34,
        113,
        20,
        50,
        129,
        145,
        161,
        8,
        35,
        66,
        177,
        193,
        21,
        82,
        209,
        240,
        36,
        51,
        98,
        114,
        130,
        9,
        10,
        22,
        23,
        24,
        25,
        26,
        37,
        38,
        39,
        40,
        41,
        42,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        225,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        241,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      var std_dc_chrominance_nrcodes = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
      var std_dc_chrominance_values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
      var std_ac_chrominance_nrcodes = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119];
      var std_ac_chrominance_values = [
        0,
        1,
        2,
        3,
        17,
        4,
        5,
        33,
        49,
        6,
        18,
        65,
        81,
        7,
        97,
        113,
        19,
        34,
        50,
        129,
        8,
        20,
        66,
        145,
        161,
        177,
        193,
        9,
        35,
        51,
        82,
        240,
        21,
        98,
        114,
        209,
        10,
        22,
        36,
        52,
        225,
        37,
        241,
        23,
        24,
        25,
        26,
        38,
        39,
        40,
        41,
        42,
        53,
        54,
        55,
        56,
        57,
        58,
        67,
        68,
        69,
        70,
        71,
        72,
        73,
        74,
        83,
        84,
        85,
        86,
        87,
        88,
        89,
        90,
        99,
        100,
        101,
        102,
        103,
        104,
        105,
        106,
        115,
        116,
        117,
        118,
        119,
        120,
        121,
        122,
        130,
        131,
        132,
        133,
        134,
        135,
        136,
        137,
        138,
        146,
        147,
        148,
        149,
        150,
        151,
        152,
        153,
        154,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        178,
        179,
        180,
        181,
        182,
        183,
        184,
        185,
        186,
        194,
        195,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        210,
        211,
        212,
        213,
        214,
        215,
        216,
        217,
        218,
        226,
        227,
        228,
        229,
        230,
        231,
        232,
        233,
        234,
        242,
        243,
        244,
        245,
        246,
        247,
        248,
        249,
        250
      ];
      function initQuantTables(sf) {
        var YQT = [
          16,
          11,
          10,
          16,
          24,
          40,
          51,
          61,
          12,
          12,
          14,
          19,
          26,
          58,
          60,
          55,
          14,
          13,
          16,
          24,
          40,
          57,
          69,
          56,
          14,
          17,
          22,
          29,
          51,
          87,
          80,
          62,
          18,
          22,
          37,
          56,
          68,
          109,
          103,
          77,
          24,
          35,
          55,
          64,
          81,
          104,
          113,
          92,
          49,
          64,
          78,
          87,
          103,
          121,
          120,
          101,
          72,
          92,
          95,
          98,
          112,
          100,
          103,
          99
        ];
        for (var i = 0; i < 64; i++) {
          var t = ffloor((YQT[i] * sf + 50) / 100);
          if (t < 1) {
            t = 1;
          } else if (t > 255) {
            t = 255;
          }
          YTable[ZigZag[i]] = t;
        }
        var UVQT = [
          17,
          18,
          24,
          47,
          99,
          99,
          99,
          99,
          18,
          21,
          26,
          66,
          99,
          99,
          99,
          99,
          24,
          26,
          56,
          99,
          99,
          99,
          99,
          99,
          47,
          66,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99,
          99
        ];
        for (var j = 0; j < 64; j++) {
          var u = ffloor((UVQT[j] * sf + 50) / 100);
          if (u < 1) {
            u = 1;
          } else if (u > 255) {
            u = 255;
          }
          UVTable[ZigZag[j]] = u;
        }
        var aasf = [
          1,
          1.387039845,
          1.306562965,
          1.175875602,
          1,
          0.785694958,
          0.5411961,
          0.275899379
        ];
        var k = 0;
        for (var row = 0; row < 8; row++) {
          for (var col = 0; col < 8; col++) {
            fdtbl_Y[k] = 1 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            fdtbl_UV[k] = 1 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8);
            k++;
          }
        }
      }
      function computeHuffmanTbl(nrcodes, std_table) {
        var codevalue = 0;
        var pos_in_table = 0;
        var HT = new Array();
        for (var k = 1; k <= 16; k++) {
          for (var j = 1; j <= nrcodes[k]; j++) {
            HT[std_table[pos_in_table]] = [];
            HT[std_table[pos_in_table]][0] = codevalue;
            HT[std_table[pos_in_table]][1] = k;
            pos_in_table++;
            codevalue++;
          }
          codevalue *= 2;
        }
        return HT;
      }
      function initHuffmanTbl() {
        YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values);
        UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values);
        YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values);
        UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
      }
      function initCategoryNumber() {
        var nrlower = 1;
        var nrupper = 2;
        for (var cat = 1; cat <= 15; cat++) {
          for (var nr = nrlower; nr < nrupper; nr++) {
            category[32767 + nr] = cat;
            bitcode[32767 + nr] = [];
            bitcode[32767 + nr][1] = cat;
            bitcode[32767 + nr][0] = nr;
          }
          for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) {
            category[32767 + nrneg] = cat;
            bitcode[32767 + nrneg] = [];
            bitcode[32767 + nrneg][1] = cat;
            bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
          }
          nrlower <<= 1;
          nrupper <<= 1;
        }
      }
      function initRGBYUVTable() {
        for (var i = 0; i < 256; i++) {
          RGB_YUV_TABLE[i] = 19595 * i;
          RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i;
          RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 32768;
          RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i;
          RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i;
          RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 8421375;
          RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i;
          RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
        }
      }
      function writeBits(bs) {
        var value = bs[0];
        var posval = bs[1] - 1;
        while (posval >= 0) {
          if (value & 1 << posval) {
            bytenew |= 1 << bytepos;
          }
          posval--;
          bytepos--;
          if (bytepos < 0) {
            if (bytenew == 255) {
              writeByte(255);
              writeByte(0);
            } else {
              writeByte(bytenew);
            }
            bytepos = 7;
            bytenew = 0;
          }
        }
      }
      function writeByte(value) {
        byteout.push(value);
      }
      function writeWord(value) {
        writeByte(value >> 8 & 255);
        writeByte(value & 255);
      }
      function fDCTQuant(data, fdtbl) {
        var d0, d1, d2, d3, d4, d5, d6, d7;
        var dataOff = 0;
        var i;
        var I8 = 8;
        var I64 = 64;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 1];
          d2 = data[dataOff + 2];
          d3 = data[dataOff + 3];
          d4 = data[dataOff + 4];
          d5 = data[dataOff + 5];
          d6 = data[dataOff + 6];
          d7 = data[dataOff + 7];
          var tmp0 = d0 + d7;
          var tmp7 = d0 - d7;
          var tmp1 = d1 + d6;
          var tmp6 = d1 - d6;
          var tmp2 = d2 + d5;
          var tmp5 = d2 - d5;
          var tmp3 = d3 + d4;
          var tmp4 = d3 - d4;
          var tmp10 = tmp0 + tmp3;
          var tmp13 = tmp0 - tmp3;
          var tmp11 = tmp1 + tmp2;
          var tmp12 = tmp1 - tmp2;
          data[dataOff] = tmp10 + tmp11;
          data[dataOff + 4] = tmp10 - tmp11;
          var z1 = (tmp12 + tmp13) * 0.707106781;
          data[dataOff + 2] = tmp13 + z1;
          data[dataOff + 6] = tmp13 - z1;
          tmp10 = tmp4 + tmp5;
          tmp11 = tmp5 + tmp6;
          tmp12 = tmp6 + tmp7;
          var z5 = (tmp10 - tmp12) * 0.382683433;
          var z2 = 0.5411961 * tmp10 + z5;
          var z4 = 1.306562965 * tmp12 + z5;
          var z3 = tmp11 * 0.707106781;
          var z11 = tmp7 + z3;
          var z13 = tmp7 - z3;
          data[dataOff + 5] = z13 + z2;
          data[dataOff + 3] = z13 - z2;
          data[dataOff + 1] = z11 + z4;
          data[dataOff + 7] = z11 - z4;
          dataOff += 8;
        }
        dataOff = 0;
        for (i = 0; i < I8; ++i) {
          d0 = data[dataOff];
          d1 = data[dataOff + 8];
          d2 = data[dataOff + 16];
          d3 = data[dataOff + 24];
          d4 = data[dataOff + 32];
          d5 = data[dataOff + 40];
          d6 = data[dataOff + 48];
          d7 = data[dataOff + 56];
          var tmp0p2 = d0 + d7;
          var tmp7p2 = d0 - d7;
          var tmp1p2 = d1 + d6;
          var tmp6p2 = d1 - d6;
          var tmp2p2 = d2 + d5;
          var tmp5p2 = d2 - d5;
          var tmp3p2 = d3 + d4;
          var tmp4p2 = d3 - d4;
          var tmp10p2 = tmp0p2 + tmp3p2;
          var tmp13p2 = tmp0p2 - tmp3p2;
          var tmp11p2 = tmp1p2 + tmp2p2;
          var tmp12p2 = tmp1p2 - tmp2p2;
          data[dataOff] = tmp10p2 + tmp11p2;
          data[dataOff + 32] = tmp10p2 - tmp11p2;
          var z1p2 = (tmp12p2 + tmp13p2) * 0.707106781;
          data[dataOff + 16] = tmp13p2 + z1p2;
          data[dataOff + 48] = tmp13p2 - z1p2;
          tmp10p2 = tmp4p2 + tmp5p2;
          tmp11p2 = tmp5p2 + tmp6p2;
          tmp12p2 = tmp6p2 + tmp7p2;
          var z5p2 = (tmp10p2 - tmp12p2) * 0.382683433;
          var z2p2 = 0.5411961 * tmp10p2 + z5p2;
          var z4p2 = 1.306562965 * tmp12p2 + z5p2;
          var z3p2 = tmp11p2 * 0.707106781;
          var z11p2 = tmp7p2 + z3p2;
          var z13p2 = tmp7p2 - z3p2;
          data[dataOff + 40] = z13p2 + z2p2;
          data[dataOff + 24] = z13p2 - z2p2;
          data[dataOff + 8] = z11p2 + z4p2;
          data[dataOff + 56] = z11p2 - z4p2;
          dataOff++;
        }
        var fDCTQuant2;
        for (i = 0; i < I64; ++i) {
          fDCTQuant2 = data[i] * fdtbl[i];
          outputfDCTQuant[i] = fDCTQuant2 > 0 ? fDCTQuant2 + 0.5 | 0 : fDCTQuant2 - 0.5 | 0;
        }
        return outputfDCTQuant;
      }
      function writeAPP0() {
        writeWord(65504);
        writeWord(16);
        writeByte(74);
        writeByte(70);
        writeByte(73);
        writeByte(70);
        writeByte(0);
        writeByte(1);
        writeByte(1);
        writeByte(0);
        writeWord(1);
        writeWord(1);
        writeByte(0);
        writeByte(0);
      }
      function writeAPP1(exifBuffer) {
        if (!exifBuffer)
          return;
        writeWord(65505);
        if (exifBuffer[0] === 69 && exifBuffer[1] === 120 && exifBuffer[2] === 105 && exifBuffer[3] === 102) {
          writeWord(exifBuffer.length + 2);
        } else {
          writeWord(exifBuffer.length + 5 + 2);
          writeByte(69);
          writeByte(120);
          writeByte(105);
          writeByte(102);
          writeByte(0);
        }
        for (var i = 0; i < exifBuffer.length; i++) {
          writeByte(exifBuffer[i]);
        }
      }
      function writeSOF0(width, height) {
        writeWord(65472);
        writeWord(17);
        writeByte(8);
        writeWord(height);
        writeWord(width);
        writeByte(3);
        writeByte(1);
        writeByte(17);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(1);
        writeByte(3);
        writeByte(17);
        writeByte(1);
      }
      function writeDQT() {
        writeWord(65499);
        writeWord(132);
        writeByte(0);
        for (var i = 0; i < 64; i++) {
          writeByte(YTable[i]);
        }
        writeByte(1);
        for (var j = 0; j < 64; j++) {
          writeByte(UVTable[j]);
        }
      }
      function writeDHT() {
        writeWord(65476);
        writeWord(418);
        writeByte(0);
        for (var i = 0; i < 16; i++) {
          writeByte(std_dc_luminance_nrcodes[i + 1]);
        }
        for (var j = 0; j <= 11; j++) {
          writeByte(std_dc_luminance_values[j]);
        }
        writeByte(16);
        for (var k = 0; k < 16; k++) {
          writeByte(std_ac_luminance_nrcodes[k + 1]);
        }
        for (var l = 0; l <= 161; l++) {
          writeByte(std_ac_luminance_values[l]);
        }
        writeByte(1);
        for (var m = 0; m < 16; m++) {
          writeByte(std_dc_chrominance_nrcodes[m + 1]);
        }
        for (var n = 0; n <= 11; n++) {
          writeByte(std_dc_chrominance_values[n]);
        }
        writeByte(17);
        for (var o = 0; o < 16; o++) {
          writeByte(std_ac_chrominance_nrcodes[o + 1]);
        }
        for (var p = 0; p <= 161; p++) {
          writeByte(std_ac_chrominance_values[p]);
        }
      }
      function writeSOS() {
        writeWord(65498);
        writeWord(12);
        writeByte(3);
        writeByte(1);
        writeByte(0);
        writeByte(2);
        writeByte(17);
        writeByte(3);
        writeByte(17);
        writeByte(0);
        writeByte(63);
        writeByte(0);
      }
      function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
        var EOB = HTAC[0];
        var M16zeroes = HTAC[240];
        var pos;
        var I16 = 16;
        var I63 = 63;
        var I64 = 64;
        var DU_DCT = fDCTQuant(CDU, fdtbl);
        for (var j = 0; j < I64; ++j) {
          DU[ZigZag[j]] = DU_DCT[j];
        }
        var Diff = DU[0] - DC;
        DC = DU[0];
        if (Diff == 0) {
          writeBits(HTDC[0]);
        } else {
          pos = 32767 + Diff;
          writeBits(HTDC[category[pos]]);
          writeBits(bitcode[pos]);
        }
        var end0pos = 63;
        for (; end0pos > 0 && DU[end0pos] == 0; end0pos--) {
        }
        ;
        if (end0pos == 0) {
          writeBits(EOB);
          return DC;
        }
        var i = 1;
        var lng;
        while (i <= end0pos) {
          var startpos = i;
          for (; DU[i] == 0 && i <= end0pos; ++i) {
          }
          var nrzeroes = i - startpos;
          if (nrzeroes >= I16) {
            lng = nrzeroes >> 4;
            for (var nrmarker = 1; nrmarker <= lng; ++nrmarker)
              writeBits(M16zeroes);
            nrzeroes = nrzeroes & 15;
          }
          pos = 32767 + DU[i];
          writeBits(HTAC[(nrzeroes << 4) + category[pos]]);
          writeBits(bitcode[pos]);
          i++;
        }
        if (end0pos != I63) {
          writeBits(EOB);
        }
        return DC;
      }
      function initCharLookupTable() {
        var sfcc = String.fromCharCode;
        for (var i = 0; i < 256; i++) {
          clt[i] = sfcc(i);
        }
      }
      this.encode = function(image, quality2) {
        var time_start = new Date().getTime();
        if (quality2)
          setQuality(quality2);
        byteout = new Array();
        bytenew = 0;
        bytepos = 7;
        writeWord(65496);
        writeAPP0();
        writeAPP1(image.exifBuffer);
        writeDQT();
        writeSOF0(image.width, image.height);
        writeDHT();
        writeSOS();
        var DCY = 0;
        var DCU = 0;
        var DCV = 0;
        bytenew = 0;
        bytepos = 7;
        this.encode.displayName = "_encode_";
        var imageData = image.data;
        var width = image.width;
        var height = image.height;
        var quadWidth = width * 4;
        var tripleWidth = width * 3;
        var x, y = 0;
        var r, g, b;
        var start, p, col, row, pos;
        while (y < height) {
          x = 0;
          while (x < quadWidth) {
            start = quadWidth * y + x;
            p = start;
            col = -1;
            row = 0;
            for (pos = 0; pos < 64; pos++) {
              row = pos >> 3;
              col = (pos & 7) * 4;
              p = start + row * quadWidth + col;
              if (y + row >= height) {
                p -= quadWidth * (y + 1 + row - height);
              }
              if (x + col >= quadWidth) {
                p -= x + col - quadWidth + 4;
              }
              r = imageData[p++];
              g = imageData[p++];
              b = imageData[p++];
              YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128;
              UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128;
              VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
            }
            DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
            DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
            DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
            x += 32;
          }
          y += 8;
        }
        if (bytepos >= 0) {
          var fillbits = [];
          fillbits[1] = bytepos + 1;
          fillbits[0] = (1 << bytepos + 1) - 1;
          writeBits(fillbits);
        }
        writeWord(65497);
        if (typeof module2 === "undefined")
          return new Uint8Array(byteout);
        return Buffer.from(byteout);
        var jpegDataUri = "data:image/jpeg;base64," + btoa(byteout.join(""));
        byteout = [];
        var duration = new Date().getTime() - time_start;
        return jpegDataUri;
      };
      function setQuality(quality2) {
        if (quality2 <= 0) {
          quality2 = 1;
        }
        if (quality2 > 100) {
          quality2 = 100;
        }
        if (currentQuality == quality2)
          return;
        var sf = 0;
        if (quality2 < 50) {
          sf = Math.floor(5e3 / quality2);
        } else {
          sf = Math.floor(200 - quality2 * 2);
        }
        initQuantTables(sf);
        currentQuality = quality2;
      }
      function init() {
        var time_start = new Date().getTime();
        if (!quality)
          quality = 50;
        initCharLookupTable();
        initHuffmanTbl();
        initCategoryNumber();
        initRGBYUVTable();
        setQuality(quality);
        var duration = new Date().getTime() - time_start;
      }
      init();
    }
    if (typeof module2 !== "undefined") {
      module2.exports = encode;
    } else if (typeof window !== "undefined") {
      window["jpeg-js"] = window["jpeg-js"] || {};
      window["jpeg-js"].encode = encode;
    }
    function encode(imgData, qu) {
      if (typeof qu === "undefined")
        qu = 50;
      var encoder = new JPEGEncoder(qu);
      var data = encoder.encode(imgData, qu);
      return {
        data,
        width: imgData.width,
        height: imgData.height
      };
    }
  }
});

// node_modules/jpeg-js/lib/decoder.js
var require_decoder = __commonJS({
  "node_modules/jpeg-js/lib/decoder.js"(exports2, module2) {
    var JpegImage = function jpegImage() {
      "use strict";
      var dctZigZag = new Int32Array([
        0,
        1,
        8,
        16,
        9,
        2,
        3,
        10,
        17,
        24,
        32,
        25,
        18,
        11,
        4,
        5,
        12,
        19,
        26,
        33,
        40,
        48,
        41,
        34,
        27,
        20,
        13,
        6,
        7,
        14,
        21,
        28,
        35,
        42,
        49,
        56,
        57,
        50,
        43,
        36,
        29,
        22,
        15,
        23,
        30,
        37,
        44,
        51,
        58,
        59,
        52,
        45,
        38,
        31,
        39,
        46,
        53,
        60,
        61,
        54,
        47,
        55,
        62,
        63
      ]);
      var dctCos1 = 4017;
      var dctSin1 = 799;
      var dctCos3 = 3406;
      var dctSin3 = 2276;
      var dctCos6 = 1567;
      var dctSin6 = 3784;
      var dctSqrt2 = 5793;
      var dctSqrt1d2 = 2896;
      function constructor() {
      }
      function buildHuffmanTable(codeLengths, values) {
        var k = 0, code = [], i, j, length = 16;
        while (length > 0 && !codeLengths[length - 1])
          length--;
        code.push({ children: [], index: 0 });
        var p = code[0], q;
        for (i = 0; i < length; i++) {
          for (j = 0; j < codeLengths[i]; j++) {
            p = code.pop();
            p.children[p.index] = values[k];
            while (p.index > 0) {
              if (code.length === 0)
                throw new Error("Could not recreate Huffman Table");
              p = code.pop();
            }
            p.index++;
            code.push(p);
            while (code.length <= i) {
              code.push(q = { children: [], index: 0 });
              p.children[p.index] = q.children;
              p = q;
            }
            k++;
          }
          if (i + 1 < length) {
            code.push(q = { children: [], index: 0 });
            p.children[p.index] = q.children;
            p = q;
          }
        }
        return code[0].children;
      }
      function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
        var precision = frame.precision;
        var samplesPerLine = frame.samplesPerLine;
        var scanLines = frame.scanLines;
        var mcusPerLine = frame.mcusPerLine;
        var progressive = frame.progressive;
        var maxH = frame.maxH, maxV = frame.maxV;
        var startOffset = offset, bitsData = 0, bitsCount = 0;
        function readBit() {
          if (bitsCount > 0) {
            bitsCount--;
            return bitsData >> bitsCount & 1;
          }
          bitsData = data[offset++];
          if (bitsData == 255) {
            var nextByte = data[offset++];
            if (nextByte) {
              throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
            }
          }
          bitsCount = 7;
          return bitsData >>> 7;
        }
        function decodeHuffman(tree) {
          var node = tree, bit;
          while ((bit = readBit()) !== null) {
            node = node[bit];
            if (typeof node === "number")
              return node;
            if (typeof node !== "object")
              throw new Error("invalid huffman sequence");
          }
          return null;
        }
        function receive(length) {
          var n2 = 0;
          while (length > 0) {
            var bit = readBit();
            if (bit === null)
              return;
            n2 = n2 << 1 | bit;
            length--;
          }
          return n2;
        }
        function receiveAndExtend(length) {
          var n2 = receive(length);
          if (n2 >= 1 << length - 1)
            return n2;
          return n2 + (-1 << length) + 1;
        }
        function decodeBaseline(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t);
          zz[0] = component2.pred += diff;
          var k2 = 1;
          while (k2 < 64) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15)
                break;
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s);
            k2++;
          }
        }
        function decodeDCFirst(component2, zz) {
          var t = decodeHuffman(component2.huffmanTableDC);
          var diff = t === 0 ? 0 : receiveAndExtend(t) << successive;
          zz[0] = component2.pred += diff;
        }
        function decodeDCSuccessive(component2, zz) {
          zz[0] |= readBit() << successive;
        }
        var eobrun = 0;
        function decodeACFirst(component2, zz) {
          if (eobrun > 0) {
            eobrun--;
            return;
          }
          var k2 = spectralStart, e = spectralEnd;
          while (k2 <= e) {
            var rs = decodeHuffman(component2.huffmanTableAC);
            var s = rs & 15, r = rs >> 4;
            if (s === 0) {
              if (r < 15) {
                eobrun = receive(r) + (1 << r) - 1;
                break;
              }
              k2 += 16;
              continue;
            }
            k2 += r;
            var z = dctZigZag[k2];
            zz[z] = receiveAndExtend(s) * (1 << successive);
            k2++;
          }
        }
        var successiveACState = 0, successiveACNextValue;
        function decodeACSuccessive(component2, zz) {
          var k2 = spectralStart, e = spectralEnd, r = 0;
          while (k2 <= e) {
            var z = dctZigZag[k2];
            var direction = zz[z] < 0 ? -1 : 1;
            switch (successiveACState) {
              case 0:
                var rs = decodeHuffman(component2.huffmanTableAC);
                var s = rs & 15, r = rs >> 4;
                if (s === 0) {
                  if (r < 15) {
                    eobrun = receive(r) + (1 << r);
                    successiveACState = 4;
                  } else {
                    r = 16;
                    successiveACState = 1;
                  }
                } else {
                  if (s !== 1)
                    throw new Error("invalid ACn encoding");
                  successiveACNextValue = receiveAndExtend(s);
                  successiveACState = r ? 2 : 3;
                }
                continue;
              case 1:
              case 2:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  r--;
                  if (r === 0)
                    successiveACState = successiveACState == 2 ? 3 : 0;
                }
                break;
              case 3:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                else {
                  zz[z] = successiveACNextValue << successive;
                  successiveACState = 0;
                }
                break;
              case 4:
                if (zz[z])
                  zz[z] += (readBit() << successive) * direction;
                break;
            }
            k2++;
          }
          if (successiveACState === 4) {
            eobrun--;
            if (eobrun === 0)
              successiveACState = 0;
          }
        }
        function decodeMcu(component2, decode2, mcu2, row, col) {
          var mcuRow = mcu2 / mcusPerLine | 0;
          var mcuCol = mcu2 % mcusPerLine;
          var blockRow = mcuRow * component2.v + row;
          var blockCol = mcuCol * component2.h + col;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        function decodeBlock(component2, decode2, mcu2) {
          var blockRow = mcu2 / component2.blocksPerLine | 0;
          var blockCol = mcu2 % component2.blocksPerLine;
          if (component2.blocks[blockRow] === void 0 && opts.tolerantDecoding)
            return;
          decode2(component2, component2.blocks[blockRow][blockCol]);
        }
        var componentsLength = components.length;
        var component, i, j, k, n;
        var decodeFn;
        if (progressive) {
          if (spectralStart === 0)
            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;
          else
            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;
        } else {
          decodeFn = decodeBaseline;
        }
        var mcu = 0, marker;
        var mcuExpected;
        if (componentsLength == 1) {
          mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;
        } else {
          mcuExpected = mcusPerLine * frame.mcusPerColumn;
        }
        if (!resetInterval)
          resetInterval = mcuExpected;
        var h, v;
        while (mcu < mcuExpected) {
          for (i = 0; i < componentsLength; i++)
            components[i].pred = 0;
          eobrun = 0;
          if (componentsLength == 1) {
            component = components[0];
            for (n = 0; n < resetInterval; n++) {
              decodeBlock(component, decodeFn, mcu);
              mcu++;
            }
          } else {
            for (n = 0; n < resetInterval; n++) {
              for (i = 0; i < componentsLength; i++) {
                component = components[i];
                h = component.h;
                v = component.v;
                for (j = 0; j < v; j++) {
                  for (k = 0; k < h; k++) {
                    decodeMcu(component, decodeFn, mcu, j, k);
                  }
                }
              }
              mcu++;
              if (mcu === mcuExpected)
                break;
            }
          }
          if (mcu === mcuExpected) {
            do {
              if (data[offset] === 255) {
                if (data[offset + 1] !== 0) {
                  break;
                }
              }
              offset += 1;
            } while (offset < data.length - 2);
          }
          bitsCount = 0;
          marker = data[offset] << 8 | data[offset + 1];
          if (marker < 65280) {
            throw new Error("marker was not found");
          }
          if (marker >= 65488 && marker <= 65495) {
            offset += 2;
          } else
            break;
        }
        return offset - startOffset;
      }
      function buildComponentData(frame, component) {
        var lines = [];
        var blocksPerLine = component.blocksPerLine;
        var blocksPerColumn = component.blocksPerColumn;
        var samplesPerLine = blocksPerLine << 3;
        var R = new Int32Array(64), r = new Uint8Array(64);
        function quantizeAndInverse(zz, dataOut, dataIn) {
          var qt = component.quantizationTable;
          var v0, v1, v2, v3, v4, v5, v6, v7, t;
          var p = dataIn;
          var i2;
          for (i2 = 0; i2 < 64; i2++)
            p[i2] = zz[i2] * qt[i2];
          for (i2 = 0; i2 < 8; ++i2) {
            var row = 8 * i2;
            if (p[1 + row] == 0 && p[2 + row] == 0 && p[3 + row] == 0 && p[4 + row] == 0 && p[5 + row] == 0 && p[6 + row] == 0 && p[7 + row] == 0) {
              t = dctSqrt2 * p[0 + row] + 512 >> 10;
              p[0 + row] = t;
              p[1 + row] = t;
              p[2 + row] = t;
              p[3 + row] = t;
              p[4 + row] = t;
              p[5 + row] = t;
              p[6 + row] = t;
              p[7 + row] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 + row] + 128 >> 8;
            v1 = dctSqrt2 * p[4 + row] + 128 >> 8;
            v2 = p[2 + row];
            v3 = p[6 + row];
            v4 = dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128 >> 8;
            v7 = dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128 >> 8;
            v5 = p[3 + row] << 4;
            v6 = p[5 + row] << 4;
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 128 >> 8;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 128 >> 8;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 + row] = v0 + v7;
            p[7 + row] = v0 - v7;
            p[1 + row] = v1 + v6;
            p[6 + row] = v1 - v6;
            p[2 + row] = v2 + v5;
            p[5 + row] = v2 - v5;
            p[3 + row] = v3 + v4;
            p[4 + row] = v3 - v4;
          }
          for (i2 = 0; i2 < 8; ++i2) {
            var col = i2;
            if (p[1 * 8 + col] == 0 && p[2 * 8 + col] == 0 && p[3 * 8 + col] == 0 && p[4 * 8 + col] == 0 && p[5 * 8 + col] == 0 && p[6 * 8 + col] == 0 && p[7 * 8 + col] == 0) {
              t = dctSqrt2 * dataIn[i2 + 0] + 8192 >> 14;
              p[0 * 8 + col] = t;
              p[1 * 8 + col] = t;
              p[2 * 8 + col] = t;
              p[3 * 8 + col] = t;
              p[4 * 8 + col] = t;
              p[5 * 8 + col] = t;
              p[6 * 8 + col] = t;
              p[7 * 8 + col] = t;
              continue;
            }
            v0 = dctSqrt2 * p[0 * 8 + col] + 2048 >> 12;
            v1 = dctSqrt2 * p[4 * 8 + col] + 2048 >> 12;
            v2 = p[2 * 8 + col];
            v3 = p[6 * 8 + col];
            v4 = dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048 >> 12;
            v7 = dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048 >> 12;
            v5 = p[3 * 8 + col];
            v6 = p[5 * 8 + col];
            t = v0 - v1 + 1 >> 1;
            v0 = v0 + v1 + 1 >> 1;
            v1 = t;
            t = v2 * dctSin6 + v3 * dctCos6 + 2048 >> 12;
            v2 = v2 * dctCos6 - v3 * dctSin6 + 2048 >> 12;
            v3 = t;
            t = v4 - v6 + 1 >> 1;
            v4 = v4 + v6 + 1 >> 1;
            v6 = t;
            t = v7 + v5 + 1 >> 1;
            v5 = v7 - v5 + 1 >> 1;
            v7 = t;
            t = v0 - v3 + 1 >> 1;
            v0 = v0 + v3 + 1 >> 1;
            v3 = t;
            t = v1 - v2 + 1 >> 1;
            v1 = v1 + v2 + 1 >> 1;
            v2 = t;
            t = v4 * dctSin3 + v7 * dctCos3 + 2048 >> 12;
            v4 = v4 * dctCos3 - v7 * dctSin3 + 2048 >> 12;
            v7 = t;
            t = v5 * dctSin1 + v6 * dctCos1 + 2048 >> 12;
            v5 = v5 * dctCos1 - v6 * dctSin1 + 2048 >> 12;
            v6 = t;
            p[0 * 8 + col] = v0 + v7;
            p[7 * 8 + col] = v0 - v7;
            p[1 * 8 + col] = v1 + v6;
            p[6 * 8 + col] = v1 - v6;
            p[2 * 8 + col] = v2 + v5;
            p[5 * 8 + col] = v2 - v5;
            p[3 * 8 + col] = v3 + v4;
            p[4 * 8 + col] = v3 - v4;
          }
          for (i2 = 0; i2 < 64; ++i2) {
            var sample2 = 128 + (p[i2] + 8 >> 4);
            dataOut[i2] = sample2 < 0 ? 0 : sample2 > 255 ? 255 : sample2;
          }
        }
        requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
        var i, j;
        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
          var scanLine = blockRow << 3;
          for (i = 0; i < 8; i++)
            lines.push(new Uint8Array(samplesPerLine));
          for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
            quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
            var offset = 0, sample = blockCol << 3;
            for (j = 0; j < 8; j++) {
              var line = lines[scanLine + j];
              for (i = 0; i < 8; i++)
                line[sample + i] = r[offset++];
            }
          }
        }
        return lines;
      }
      function clampTo8bit(a) {
        return a < 0 ? 0 : a > 255 ? 255 : a;
      }
      constructor.prototype = {
        load: function load(path) {
          var xhr = new XMLHttpRequest();
          xhr.open("GET", path, true);
          xhr.responseType = "arraybuffer";
          xhr.onload = function() {
            var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
            this.parse(data);
            if (this.onload)
              this.onload();
          }.bind(this);
          xhr.send(null);
        },
        parse: function parse(data) {
          var maxResolutionInPixels = this.opts.maxResolutionInMP * 1e3 * 1e3;
          var offset = 0, length = data.length;
          function readUint16() {
            var value = data[offset] << 8 | data[offset + 1];
            offset += 2;
            return value;
          }
          function readDataBlock() {
            var length2 = readUint16();
            var array = data.subarray(offset, offset + length2 - 2);
            offset += array.length;
            return array;
          }
          function prepareComponents(frame2) {
            var maxH2 = 0, maxV2 = 0;
            var component2, componentId2;
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                if (maxH2 < component2.h)
                  maxH2 = component2.h;
                if (maxV2 < component2.v)
                  maxV2 = component2.v;
              }
            }
            var mcusPerLine = Math.ceil(frame2.samplesPerLine / 8 / maxH2);
            var mcusPerColumn = Math.ceil(frame2.scanLines / 8 / maxV2);
            for (componentId2 in frame2.components) {
              if (frame2.components.hasOwnProperty(componentId2)) {
                component2 = frame2.components[componentId2];
                var blocksPerLine = Math.ceil(Math.ceil(frame2.samplesPerLine / 8) * component2.h / maxH2);
                var blocksPerColumn = Math.ceil(Math.ceil(frame2.scanLines / 8) * component2.v / maxV2);
                var blocksPerLineForMcu = mcusPerLine * component2.h;
                var blocksPerColumnForMcu = mcusPerColumn * component2.v;
                var blocksToAllocate = blocksPerColumnForMcu * blocksPerLineForMcu;
                var blocks = [];
                requestMemoryAllocation(blocksToAllocate * 256);
                for (var i2 = 0; i2 < blocksPerColumnForMcu; i2++) {
                  var row = [];
                  for (var j2 = 0; j2 < blocksPerLineForMcu; j2++)
                    row.push(new Int32Array(64));
                  blocks.push(row);
                }
                component2.blocksPerLine = blocksPerLine;
                component2.blocksPerColumn = blocksPerColumn;
                component2.blocks = blocks;
              }
            }
            frame2.maxH = maxH2;
            frame2.maxV = maxV2;
            frame2.mcusPerLine = mcusPerLine;
            frame2.mcusPerColumn = mcusPerColumn;
          }
          var jfif = null;
          var adobe = null;
          var pixels = null;
          var frame, resetInterval;
          var quantizationTables = [], frames = [];
          var huffmanTablesAC = [], huffmanTablesDC = [];
          var fileMarker = readUint16();
          var malformedDataOffset = -1;
          this.comments = [];
          if (fileMarker != 65496) {
            throw new Error("SOI not found");
          }
          fileMarker = readUint16();
          while (fileMarker != 65497) {
            var i, j, l;
            switch (fileMarker) {
              case 65280:
                break;
              case 65504:
              case 65505:
              case 65506:
              case 65507:
              case 65508:
              case 65509:
              case 65510:
              case 65511:
              case 65512:
              case 65513:
              case 65514:
              case 65515:
              case 65516:
              case 65517:
              case 65518:
              case 65519:
              case 65534:
                var appData = readDataBlock();
                if (fileMarker === 65534) {
                  var comment = String.fromCharCode.apply(null, appData);
                  this.comments.push(comment);
                }
                if (fileMarker === 65504) {
                  if (appData[0] === 74 && appData[1] === 70 && appData[2] === 73 && appData[3] === 70 && appData[4] === 0) {
                    jfif = {
                      version: { major: appData[5], minor: appData[6] },
                      densityUnits: appData[7],
                      xDensity: appData[8] << 8 | appData[9],
                      yDensity: appData[10] << 8 | appData[11],
                      thumbWidth: appData[12],
                      thumbHeight: appData[13],
                      thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                    };
                  }
                }
                if (fileMarker === 65505) {
                  if (appData[0] === 69 && appData[1] === 120 && appData[2] === 105 && appData[3] === 102 && appData[4] === 0) {
                    this.exifBuffer = appData.subarray(5, appData.length);
                  }
                }
                if (fileMarker === 65518) {
                  if (appData[0] === 65 && appData[1] === 100 && appData[2] === 111 && appData[3] === 98 && appData[4] === 101 && appData[5] === 0) {
                    adobe = {
                      version: appData[6],
                      flags0: appData[7] << 8 | appData[8],
                      flags1: appData[9] << 8 | appData[10],
                      transformCode: appData[11]
                    };
                  }
                }
                break;
              case 65499:
                var quantizationTablesLength = readUint16();
                var quantizationTablesEnd = quantizationTablesLength + offset - 2;
                while (offset < quantizationTablesEnd) {
                  var quantizationTableSpec = data[offset++];
                  requestMemoryAllocation(64 * 4);
                  var tableData = new Int32Array(64);
                  if (quantizationTableSpec >> 4 === 0) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = data[offset++];
                    }
                  } else if (quantizationTableSpec >> 4 === 1) {
                    for (j = 0; j < 64; j++) {
                      var z = dctZigZag[j];
                      tableData[z] = readUint16();
                    }
                  } else
                    throw new Error("DQT: invalid table spec");
                  quantizationTables[quantizationTableSpec & 15] = tableData;
                }
                break;
              case 65472:
              case 65473:
              case 65474:
                readUint16();
                frame = {};
                frame.extended = fileMarker === 65473;
                frame.progressive = fileMarker === 65474;
                frame.precision = data[offset++];
                frame.scanLines = readUint16();
                frame.samplesPerLine = readUint16();
                frame.components = {};
                frame.componentsOrder = [];
                var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
                if (pixelsInFrame > maxResolutionInPixels) {
                  var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                  throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
                }
                var componentsCount = data[offset++], componentId;
                var maxH = 0, maxV = 0;
                for (i = 0; i < componentsCount; i++) {
                  componentId = data[offset];
                  var h = data[offset + 1] >> 4;
                  var v = data[offset + 1] & 15;
                  var qId = data[offset + 2];
                  frame.componentsOrder.push(componentId);
                  frame.components[componentId] = {
                    h,
                    v,
                    quantizationIdx: qId
                  };
                  offset += 3;
                }
                prepareComponents(frame);
                frames.push(frame);
                break;
              case 65476:
                var huffmanLength = readUint16();
                for (i = 2; i < huffmanLength; ) {
                  var huffmanTableSpec = data[offset++];
                  var codeLengths = new Uint8Array(16);
                  var codeLengthSum = 0;
                  for (j = 0; j < 16; j++, offset++) {
                    codeLengthSum += codeLengths[j] = data[offset];
                  }
                  requestMemoryAllocation(16 + codeLengthSum);
                  var huffmanValues = new Uint8Array(codeLengthSum);
                  for (j = 0; j < codeLengthSum; j++, offset++)
                    huffmanValues[j] = data[offset];
                  i += 17 + codeLengthSum;
                  (huffmanTableSpec >> 4 === 0 ? huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);
                }
                break;
              case 65501:
                readUint16();
                resetInterval = readUint16();
                break;
              case 65500:
                readUint16();
                readUint16();
                break;
              case 65498:
                var scanLength = readUint16();
                var selectorsCount = data[offset++];
                var components = [], component;
                for (i = 0; i < selectorsCount; i++) {
                  component = frame.components[data[offset++]];
                  var tableSpec = data[offset++];
                  component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];
                  component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];
                  components.push(component);
                }
                var spectralStart = data[offset++];
                var spectralEnd = data[offset++];
                var successiveApproximation = data[offset++];
                var processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15, this.opts);
                offset += processed;
                break;
              case 65535:
                if (data[offset] !== 255) {
                  offset--;
                }
                break;
              default:
                if (data[offset - 3] == 255 && data[offset - 2] >= 192 && data[offset - 2] <= 254) {
                  offset -= 3;
                  break;
                } else if (fileMarker === 224 || fileMarker == 225) {
                  if (malformedDataOffset !== -1) {
                    throw new Error(`first unknown JPEG marker at offset ${malformedDataOffset.toString(16)}, second unknown JPEG marker ${fileMarker.toString(16)} at offset ${(offset - 1).toString(16)}`);
                  }
                  malformedDataOffset = offset - 1;
                  const nextOffset = readUint16();
                  if (data[offset + nextOffset - 2] === 255) {
                    offset += nextOffset - 2;
                    break;
                  }
                }
                throw new Error("unknown JPEG marker " + fileMarker.toString(16));
            }
            fileMarker = readUint16();
          }
          if (frames.length != 1)
            throw new Error("only single frame JPEGs supported");
          for (var i = 0; i < frames.length; i++) {
            var cp = frames[i].components;
            for (var j in cp) {
              cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx];
              delete cp[j].quantizationIdx;
            }
          }
          this.width = frame.samplesPerLine;
          this.height = frame.scanLines;
          this.jfif = jfif;
          this.adobe = adobe;
          this.components = [];
          for (var i = 0; i < frame.componentsOrder.length; i++) {
            var component = frame.components[frame.componentsOrder[i]];
            this.components.push({
              lines: buildComponentData(frame, component),
              scaleX: component.h / frame.maxH,
              scaleY: component.v / frame.maxV
            });
          }
        },
        getData: function getData(width, height) {
          var scaleX = this.width / width, scaleY = this.height / height;
          var component1, component2, component3, component4;
          var component1Line, component2Line, component3Line, component4Line;
          var x, y;
          var offset = 0;
          var Y, Cb, Cr, K, C, M, Ye, R, G, B;
          var colorTransform;
          var dataLength = width * height * this.components.length;
          requestMemoryAllocation(dataLength);
          var data = new Uint8Array(dataLength);
          switch (this.components.length) {
            case 1:
              component1 = this.components[0];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 2:
              component1 = this.components[0];
              component2 = this.components[1];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  Y = component1Line[0 | x * component1.scaleX * scaleX];
                  data[offset++] = Y;
                  Y = component2Line[0 | x * component2.scaleX * scaleX];
                  data[offset++] = Y;
                }
              }
              break;
            case 3:
              colorTransform = true;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    R = component1Line[0 | x * component1.scaleX * scaleX];
                    G = component2Line[0 | x * component2.scaleX * scaleX];
                    B = component3Line[0 | x * component3.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    R = clampTo8bit(Y + 1.402 * (Cr - 128));
                    G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    B = clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = R;
                  data[offset++] = G;
                  data[offset++] = B;
                }
              }
              break;
            case 4:
              if (!this.adobe)
                throw new Error("Unsupported color mode (4 components)");
              colorTransform = false;
              if (this.adobe && this.adobe.transformCode)
                colorTransform = true;
              else if (typeof this.opts.colorTransform !== "undefined")
                colorTransform = !!this.opts.colorTransform;
              component1 = this.components[0];
              component2 = this.components[1];
              component3 = this.components[2];
              component4 = this.components[3];
              for (y = 0; y < height; y++) {
                component1Line = component1.lines[0 | y * component1.scaleY * scaleY];
                component2Line = component2.lines[0 | y * component2.scaleY * scaleY];
                component3Line = component3.lines[0 | y * component3.scaleY * scaleY];
                component4Line = component4.lines[0 | y * component4.scaleY * scaleY];
                for (x = 0; x < width; x++) {
                  if (!colorTransform) {
                    C = component1Line[0 | x * component1.scaleX * scaleX];
                    M = component2Line[0 | x * component2.scaleX * scaleX];
                    Ye = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                  } else {
                    Y = component1Line[0 | x * component1.scaleX * scaleX];
                    Cb = component2Line[0 | x * component2.scaleX * scaleX];
                    Cr = component3Line[0 | x * component3.scaleX * scaleX];
                    K = component4Line[0 | x * component4.scaleX * scaleX];
                    C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128));
                    M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128));
                    Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128));
                  }
                  data[offset++] = 255 - C;
                  data[offset++] = 255 - M;
                  data[offset++] = 255 - Ye;
                  data[offset++] = 255 - K;
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
          return data;
        },
        copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
          var width = imageData.width, height = imageData.height;
          var imageDataArray = imageData.data;
          var data = this.getData(width, height);
          var i = 0, j = 0, x, y;
          var Y, K, C, M, R, G, B;
          switch (this.components.length) {
            case 1:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  Y = data[i++];
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  imageDataArray[j++] = Y;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 3:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  R = data[i++];
                  G = data[i++];
                  B = data[i++];
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            case 4:
              for (y = 0; y < height; y++) {
                for (x = 0; x < width; x++) {
                  C = data[i++];
                  M = data[i++];
                  Y = data[i++];
                  K = data[i++];
                  R = 255 - clampTo8bit(C * (1 - K / 255) + K);
                  G = 255 - clampTo8bit(M * (1 - K / 255) + K);
                  B = 255 - clampTo8bit(Y * (1 - K / 255) + K);
                  imageDataArray[j++] = R;
                  imageDataArray[j++] = G;
                  imageDataArray[j++] = B;
                  if (formatAsRGBA) {
                    imageDataArray[j++] = 255;
                  }
                }
              }
              break;
            default:
              throw new Error("Unsupported color mode");
          }
        }
      };
      var totalBytesAllocated = 0;
      var maxMemoryUsageBytes = 0;
      function requestMemoryAllocation(increaseAmount = 0) {
        var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
        if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
          var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
          throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
        }
        totalBytesAllocated = totalMemoryImpactBytes;
      }
      constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
        totalBytesAllocated = 0;
        maxMemoryUsageBytes = maxMemoryUsageBytes_;
      };
      constructor.getBytesAllocated = function() {
        return totalBytesAllocated;
      };
      constructor.requestMemoryAllocation = requestMemoryAllocation;
      return constructor;
    }();
    if (typeof module2 !== "undefined") {
      module2.exports = decode;
    } else if (typeof window !== "undefined") {
      window["jpeg-js"] = window["jpeg-js"] || {};
      window["jpeg-js"].decode = decode;
    }
    function decode(jpegData, userOpts = {}) {
      var defaultOpts = {
        colorTransform: void 0,
        useTArray: false,
        formatAsRGBA: true,
        tolerantDecoding: true,
        maxResolutionInMP: 100,
        maxMemoryUsageInMB: 512
      };
      var opts = __spreadValues(__spreadValues({}, defaultOpts), userOpts);
      var arr = new Uint8Array(jpegData);
      var decoder = new JpegImage();
      decoder.opts = opts;
      JpegImage.resetMaxMemoryUsage(opts.maxMemoryUsageInMB * 1024 * 1024);
      decoder.parse(arr);
      var channels = opts.formatAsRGBA ? 4 : 3;
      var bytesNeeded = decoder.width * decoder.height * channels;
      try {
        JpegImage.requestMemoryAllocation(bytesNeeded);
        var image = {
          width: decoder.width,
          height: decoder.height,
          exifBuffer: decoder.exifBuffer,
          data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)
        };
        if (decoder.comments.length > 0) {
          image["comments"] = decoder.comments;
        }
      } catch (err) {
        if (err instanceof RangeError) {
          throw new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded);
        } else {
          throw err;
        }
      }
      decoder.copyToImageData(image, opts.formatAsRGBA);
      return image;
    }
  }
});

// node_modules/jpeg-js/index.js
var require_jpeg_js = __commonJS({
  "node_modules/jpeg-js/index.js"(exports2, module2) {
    var encode = require_encoder();
    var decode = require_decoder();
    module2.exports = {
      encode,
      decode
    };
  }
});

// node_modules/playwright-core/lib/third_party/diff_match_patch.js
var require_diff_match_patch = __commonJS({
  "node_modules/playwright-core/lib/third_party/diff_match_patch.js"(exports2, module2) {
    var diff_match_patch = function() {
      this.Diff_Timeout = 1;
      this.Diff_EditCost = 4;
      this.Match_Threshold = 0.5;
      this.Match_Distance = 1e3;
      this.Patch_DeleteThreshold = 0.5;
      this.Patch_Margin = 4;
      this.Match_MaxBits = 32;
    };
    var DIFF_DELETE = -1;
    var DIFF_INSERT = 1;
    var DIFF_EQUAL = 0;
    diff_match_patch.Diff = function(op, text) {
      this[0] = op;
      this[1] = text;
    };
    diff_match_patch.Diff.prototype.length = 2;
    diff_match_patch.Diff.prototype.toString = function() {
      return this[0] + "," + this[1];
    };
    diff_match_patch.prototype.diff_main = function(text1, text2, opt_checklines, opt_deadline) {
      if (typeof opt_deadline == "undefined") {
        if (this.Diff_Timeout <= 0) {
          opt_deadline = Number.MAX_VALUE;
        } else {
          opt_deadline = new Date().getTime() + this.Diff_Timeout * 1e3;
        }
      }
      var deadline = opt_deadline;
      if (text1 == null || text2 == null) {
        throw new Error("Null input. (diff_main)");
      }
      if (text1 == text2) {
        if (text1) {
          return [new diff_match_patch.Diff(DIFF_EQUAL, text1)];
        }
        return [];
      }
      if (typeof opt_checklines == "undefined") {
        opt_checklines = true;
      }
      var checklines = opt_checklines;
      var commonlength = this.diff_commonPrefix(text1, text2);
      var commonprefix = text1.substring(0, commonlength);
      text1 = text1.substring(commonlength);
      text2 = text2.substring(commonlength);
      commonlength = this.diff_commonSuffix(text1, text2);
      var commonsuffix = text1.substring(text1.length - commonlength);
      text1 = text1.substring(0, text1.length - commonlength);
      text2 = text2.substring(0, text2.length - commonlength);
      var diffs = this.diff_compute_(text1, text2, checklines, deadline);
      if (commonprefix) {
        diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, commonprefix));
      }
      if (commonsuffix) {
        diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, commonsuffix));
      }
      this.diff_cleanupMerge(diffs);
      return diffs;
    };
    diff_match_patch.prototype.diff_compute_ = function(text1, text2, checklines, deadline) {
      var diffs;
      if (!text1) {
        return [new diff_match_patch.Diff(DIFF_INSERT, text2)];
      }
      if (!text2) {
        return [new diff_match_patch.Diff(DIFF_DELETE, text1)];
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      var i = longtext.indexOf(shorttext);
      if (i != -1) {
        diffs = [
          new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(0, i)),
          new diff_match_patch.Diff(DIFF_EQUAL, shorttext),
          new diff_match_patch.Diff(DIFF_INSERT, longtext.substring(i + shorttext.length))
        ];
        if (text1.length > text2.length) {
          diffs[0][0] = diffs[2][0] = DIFF_DELETE;
        }
        return diffs;
      }
      if (shorttext.length == 1) {
        return [
          new diff_match_patch.Diff(DIFF_DELETE, text1),
          new diff_match_patch.Diff(DIFF_INSERT, text2)
        ];
      }
      var hm = this.diff_halfMatch_(text1, text2);
      if (hm) {
        var text1_a = hm[0];
        var text1_b = hm[1];
        var text2_a = hm[2];
        var text2_b = hm[3];
        var mid_common = hm[4];
        var diffs_a = this.diff_main(text1_a, text2_a, checklines, deadline);
        var diffs_b = this.diff_main(text1_b, text2_b, checklines, deadline);
        return diffs_a.concat([new diff_match_patch.Diff(DIFF_EQUAL, mid_common)], diffs_b);
      }
      if (checklines && text1.length > 100 && text2.length > 100) {
        return this.diff_lineMode_(text1, text2, deadline);
      }
      return this.diff_bisect_(text1, text2, deadline);
    };
    diff_match_patch.prototype.diff_lineMode_ = function(text1, text2, deadline) {
      var a = this.diff_linesToChars_(text1, text2);
      text1 = a.chars1;
      text2 = a.chars2;
      var linearray = a.lineArray;
      var diffs = this.diff_main(text1, text2, false, deadline);
      this.diff_charsToLines_(diffs, linearray);
      this.diff_cleanupSemantic(diffs);
      diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ""));
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            break;
          case DIFF_EQUAL:
            if (count_delete >= 1 && count_insert >= 1) {
              diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert);
              pointer = pointer - count_delete - count_insert;
              var subDiff = this.diff_main(text_delete, text_insert, false, deadline);
              for (var j = subDiff.length - 1; j >= 0; j--) {
                diffs.splice(pointer, 0, subDiff[j]);
              }
              pointer = pointer + subDiff.length;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
        pointer++;
      }
      diffs.pop();
      return diffs;
    };
    diff_match_patch.prototype.diff_bisect_ = function(text1, text2, deadline) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      var max_d = Math.ceil((text1_length + text2_length) / 2);
      var v_offset = max_d;
      var v_length = 2 * max_d;
      var v1 = new Array(v_length);
      var v2 = new Array(v_length);
      for (var x = 0; x < v_length; x++) {
        v1[x] = -1;
        v2[x] = -1;
      }
      v1[v_offset + 1] = 0;
      v2[v_offset + 1] = 0;
      var delta = text1_length - text2_length;
      var front = delta % 2 != 0;
      var k1start = 0;
      var k1end = 0;
      var k2start = 0;
      var k2end = 0;
      for (var d = 0; d < max_d; d++) {
        if (new Date().getTime() > deadline) {
          break;
        }
        for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
          var k1_offset = v_offset + k1;
          var x1;
          if (k1 == -d || k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1]) {
            x1 = v1[k1_offset + 1];
          } else {
            x1 = v1[k1_offset - 1] + 1;
          }
          var y1 = x1 - k1;
          while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) == text2.charAt(y1)) {
            x1++;
            y1++;
          }
          v1[k1_offset] = x1;
          if (x1 > text1_length) {
            k1end += 2;
          } else if (y1 > text2_length) {
            k1start += 2;
          } else if (front) {
            var k2_offset = v_offset + delta - k1;
            if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
              var x2 = text1_length - v2[k2_offset];
              if (x1 >= x2) {
                return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
              }
            }
          }
        }
        for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
          var k2_offset = v_offset + k2;
          var x2;
          if (k2 == -d || k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1]) {
            x2 = v2[k2_offset + 1];
          } else {
            x2 = v2[k2_offset - 1] + 1;
          }
          var y2 = x2 - k2;
          while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) == text2.charAt(text2_length - y2 - 1)) {
            x2++;
            y2++;
          }
          v2[k2_offset] = x2;
          if (x2 > text1_length) {
            k2end += 2;
          } else if (y2 > text2_length) {
            k2start += 2;
          } else if (!front) {
            var k1_offset = v_offset + delta - k2;
            if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
              var x1 = v1[k1_offset];
              var y1 = v_offset + x1 - k1_offset;
              x2 = text1_length - x2;
              if (x1 >= x2) {
                return this.diff_bisectSplit_(text1, text2, x1, y1, deadline);
              }
            }
          }
        }
      }
      return [
        new diff_match_patch.Diff(DIFF_DELETE, text1),
        new diff_match_patch.Diff(DIFF_INSERT, text2)
      ];
    };
    diff_match_patch.prototype.diff_bisectSplit_ = function(text1, text2, x, y, deadline) {
      var text1a = text1.substring(0, x);
      var text2a = text2.substring(0, y);
      var text1b = text1.substring(x);
      var text2b = text2.substring(y);
      var diffs = this.diff_main(text1a, text2a, false, deadline);
      var diffsb = this.diff_main(text1b, text2b, false, deadline);
      return diffs.concat(diffsb);
    };
    diff_match_patch.prototype.diff_linesToChars_ = function(text1, text2) {
      var lineArray = [];
      var lineHash = {};
      lineArray[0] = "";
      function diff_linesToCharsMunge_(text) {
        var chars = "";
        var lineStart = 0;
        var lineEnd = -1;
        var lineArrayLength = lineArray.length;
        while (lineEnd < text.length - 1) {
          lineEnd = text.indexOf("\n", lineStart);
          if (lineEnd == -1) {
            lineEnd = text.length - 1;
          }
          var line = text.substring(lineStart, lineEnd + 1);
          if (lineHash.hasOwnProperty ? lineHash.hasOwnProperty(line) : lineHash[line] !== void 0) {
            chars += String.fromCharCode(lineHash[line]);
          } else {
            if (lineArrayLength == maxLines) {
              line = text.substring(lineStart);
              lineEnd = text.length;
            }
            chars += String.fromCharCode(lineArrayLength);
            lineHash[line] = lineArrayLength;
            lineArray[lineArrayLength++] = line;
          }
          lineStart = lineEnd + 1;
        }
        return chars;
      }
      var maxLines = 4e4;
      var chars1 = diff_linesToCharsMunge_(text1);
      maxLines = 65535;
      var chars2 = diff_linesToCharsMunge_(text2);
      return { chars1, chars2, lineArray };
    };
    diff_match_patch.prototype.diff_charsToLines_ = function(diffs, lineArray) {
      for (var i = 0; i < diffs.length; i++) {
        var chars = diffs[i][1];
        var text = [];
        for (var j = 0; j < chars.length; j++) {
          text[j] = lineArray[chars.charCodeAt(j)];
        }
        diffs[i][1] = text.join("");
      }
    };
    diff_match_patch.prototype.diff_commonPrefix = function(text1, text2) {
      if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerstart = 0;
      while (pointermin < pointermid) {
        if (text1.substring(pointerstart, pointermid) == text2.substring(pointerstart, pointermid)) {
          pointermin = pointermid;
          pointerstart = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    };
    diff_match_patch.prototype.diff_commonSuffix = function(text1, text2) {
      if (!text1 || !text2 || text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
        return 0;
      }
      var pointermin = 0;
      var pointermax = Math.min(text1.length, text2.length);
      var pointermid = pointermax;
      var pointerend = 0;
      while (pointermin < pointermid) {
        if (text1.substring(text1.length - pointermid, text1.length - pointerend) == text2.substring(text2.length - pointermid, text2.length - pointerend)) {
          pointermin = pointermid;
          pointerend = pointermin;
        } else {
          pointermax = pointermid;
        }
        pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
      }
      return pointermid;
    };
    diff_match_patch.prototype.diff_commonOverlap_ = function(text1, text2) {
      var text1_length = text1.length;
      var text2_length = text2.length;
      if (text1_length == 0 || text2_length == 0) {
        return 0;
      }
      if (text1_length > text2_length) {
        text1 = text1.substring(text1_length - text2_length);
      } else if (text1_length < text2_length) {
        text2 = text2.substring(0, text1_length);
      }
      var text_length = Math.min(text1_length, text2_length);
      if (text1 == text2) {
        return text_length;
      }
      var best = 0;
      var length = 1;
      while (true) {
        var pattern = text1.substring(text_length - length);
        var found = text2.indexOf(pattern);
        if (found == -1) {
          return best;
        }
        length += found;
        if (found == 0 || text1.substring(text_length - length) == text2.substring(0, length)) {
          best = length;
          length++;
        }
      }
    };
    diff_match_patch.prototype.diff_halfMatch_ = function(text1, text2) {
      if (this.Diff_Timeout <= 0) {
        return null;
      }
      var longtext = text1.length > text2.length ? text1 : text2;
      var shorttext = text1.length > text2.length ? text2 : text1;
      if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
        return null;
      }
      var dmp = this;
      function diff_halfMatchI_(longtext2, shorttext2, i) {
        var seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
        var j = -1;
        var best_common = "";
        var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
        while ((j = shorttext2.indexOf(seed, j + 1)) != -1) {
          var prefixLength = dmp.diff_commonPrefix(longtext2.substring(i), shorttext2.substring(j));
          var suffixLength = dmp.diff_commonSuffix(longtext2.substring(0, i), shorttext2.substring(0, j));
          if (best_common.length < suffixLength + prefixLength) {
            best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
            best_longtext_a = longtext2.substring(0, i - suffixLength);
            best_longtext_b = longtext2.substring(i + prefixLength);
            best_shorttext_a = shorttext2.substring(0, j - suffixLength);
            best_shorttext_b = shorttext2.substring(j + prefixLength);
          }
        }
        if (best_common.length * 2 >= longtext2.length) {
          return [
            best_longtext_a,
            best_longtext_b,
            best_shorttext_a,
            best_shorttext_b,
            best_common
          ];
        } else {
          return null;
        }
      }
      var hm1 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 4));
      var hm2 = diff_halfMatchI_(longtext, shorttext, Math.ceil(longtext.length / 2));
      var hm;
      if (!hm1 && !hm2) {
        return null;
      } else if (!hm2) {
        hm = hm1;
      } else if (!hm1) {
        hm = hm2;
      } else {
        hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
      }
      var text1_a, text1_b, text2_a, text2_b;
      if (text1.length > text2.length) {
        text1_a = hm[0];
        text1_b = hm[1];
        text2_a = hm[2];
        text2_b = hm[3];
      } else {
        text2_a = hm[0];
        text2_b = hm[1];
        text1_a = hm[2];
        text1_b = hm[3];
      }
      var mid_common = hm[4];
      return [text1_a, text1_b, text2_a, text2_b, mid_common];
    };
    diff_match_patch.prototype.diff_cleanupSemantic = function(diffs) {
      var changes = false;
      var equalities = [];
      var equalitiesLength = 0;
      var lastEquality = null;
      var pointer = 0;
      var length_insertions1 = 0;
      var length_deletions1 = 0;
      var length_insertions2 = 0;
      var length_deletions2 = 0;
      while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL) {
          equalities[equalitiesLength++] = pointer;
          length_insertions1 = length_insertions2;
          length_deletions1 = length_deletions2;
          length_insertions2 = 0;
          length_deletions2 = 0;
          lastEquality = diffs[pointer][1];
        } else {
          if (diffs[pointer][0] == DIFF_INSERT) {
            length_insertions2 += diffs[pointer][1].length;
          } else {
            length_deletions2 += diffs[pointer][1].length;
          }
          if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
            diffs.splice(equalities[equalitiesLength - 1], 0, new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
            equalitiesLength--;
            equalitiesLength--;
            pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
            length_insertions1 = 0;
            length_deletions1 = 0;
            length_insertions2 = 0;
            length_deletions2 = 0;
            lastEquality = null;
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        this.diff_cleanupMerge(diffs);
      }
      this.diff_cleanupSemanticLossless(diffs);
      pointer = 1;
      while (pointer < diffs.length) {
        if (diffs[pointer - 1][0] == DIFF_DELETE && diffs[pointer][0] == DIFF_INSERT) {
          var deletion = diffs[pointer - 1][1];
          var insertion = diffs[pointer][1];
          var overlap_length1 = this.diff_commonOverlap_(deletion, insertion);
          var overlap_length2 = this.diff_commonOverlap_(insertion, deletion);
          if (overlap_length1 >= overlap_length2) {
            if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
              diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));
              diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
              diffs[pointer + 1][1] = insertion.substring(overlap_length1);
              pointer++;
            }
          } else {
            if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
              diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));
              diffs[pointer - 1][0] = DIFF_INSERT;
              diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
              diffs[pointer + 1][0] = DIFF_DELETE;
              diffs[pointer + 1][1] = deletion.substring(overlap_length2);
              pointer++;
            }
          }
          pointer++;
        }
        pointer++;
      }
    };
    diff_match_patch.prototype.diff_cleanupSemanticLossless = function(diffs) {
      function diff_cleanupSemanticScore_(one, two) {
        if (!one || !two) {
          return 6;
        }
        var char1 = one.charAt(one.length - 1);
        var char2 = two.charAt(0);
        var nonAlphaNumeric1 = char1.match(diff_match_patch.nonAlphaNumericRegex_);
        var nonAlphaNumeric2 = char2.match(diff_match_patch.nonAlphaNumericRegex_);
        var whitespace1 = nonAlphaNumeric1 && char1.match(diff_match_patch.whitespaceRegex_);
        var whitespace2 = nonAlphaNumeric2 && char2.match(diff_match_patch.whitespaceRegex_);
        var lineBreak1 = whitespace1 && char1.match(diff_match_patch.linebreakRegex_);
        var lineBreak2 = whitespace2 && char2.match(diff_match_patch.linebreakRegex_);
        var blankLine1 = lineBreak1 && one.match(diff_match_patch.blanklineEndRegex_);
        var blankLine2 = lineBreak2 && two.match(diff_match_patch.blanklineStartRegex_);
        if (blankLine1 || blankLine2) {
          return 5;
        } else if (lineBreak1 || lineBreak2) {
          return 4;
        } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
          return 3;
        } else if (whitespace1 || whitespace2) {
          return 2;
        } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
          return 1;
        }
        return 0;
      }
      var pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
          var equality1 = diffs[pointer - 1][1];
          var edit = diffs[pointer][1];
          var equality2 = diffs[pointer + 1][1];
          var commonOffset = this.diff_commonSuffix(equality1, edit);
          if (commonOffset) {
            var commonString = edit.substring(edit.length - commonOffset);
            equality1 = equality1.substring(0, equality1.length - commonOffset);
            edit = commonString + edit.substring(0, edit.length - commonOffset);
            equality2 = commonString + equality2;
          }
          var bestEquality1 = equality1;
          var bestEdit = edit;
          var bestEquality2 = equality2;
          var bestScore = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
          while (edit.charAt(0) === equality2.charAt(0)) {
            equality1 += edit.charAt(0);
            edit = edit.substring(1) + equality2.charAt(0);
            equality2 = equality2.substring(1);
            var score = diff_cleanupSemanticScore_(equality1, edit) + diff_cleanupSemanticScore_(edit, equality2);
            if (score >= bestScore) {
              bestScore = score;
              bestEquality1 = equality1;
              bestEdit = edit;
              bestEquality2 = equality2;
            }
          }
          if (diffs[pointer - 1][1] != bestEquality1) {
            if (bestEquality1) {
              diffs[pointer - 1][1] = bestEquality1;
            } else {
              diffs.splice(pointer - 1, 1);
              pointer--;
            }
            diffs[pointer][1] = bestEdit;
            if (bestEquality2) {
              diffs[pointer + 1][1] = bestEquality2;
            } else {
              diffs.splice(pointer + 1, 1);
              pointer--;
            }
          }
        }
        pointer++;
      }
    };
    diff_match_patch.nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
    diff_match_patch.whitespaceRegex_ = /\s/;
    diff_match_patch.linebreakRegex_ = /[\r\n]/;
    diff_match_patch.blanklineEndRegex_ = /\n\r?\n$/;
    diff_match_patch.blanklineStartRegex_ = /^\r?\n\r?\n/;
    diff_match_patch.prototype.diff_cleanupEfficiency = function(diffs) {
      var changes = false;
      var equalities = [];
      var equalitiesLength = 0;
      var lastEquality = null;
      var pointer = 0;
      var pre_ins = false;
      var pre_del = false;
      var post_ins = false;
      var post_del = false;
      while (pointer < diffs.length) {
        if (diffs[pointer][0] == DIFF_EQUAL) {
          if (diffs[pointer][1].length < this.Diff_EditCost && (post_ins || post_del)) {
            equalities[equalitiesLength++] = pointer;
            pre_ins = post_ins;
            pre_del = post_del;
            lastEquality = diffs[pointer][1];
          } else {
            equalitiesLength = 0;
            lastEquality = null;
          }
          post_ins = post_del = false;
        } else {
          if (diffs[pointer][0] == DIFF_DELETE) {
            post_del = true;
          } else {
            post_ins = true;
          }
          if (lastEquality && (pre_ins && pre_del && post_ins && post_del || lastEquality.length < this.Diff_EditCost / 2 && pre_ins + pre_del + post_ins + post_del == 3)) {
            diffs.splice(equalities[equalitiesLength - 1], 0, new diff_match_patch.Diff(DIFF_DELETE, lastEquality));
            diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
            equalitiesLength--;
            lastEquality = null;
            if (pre_ins && pre_del) {
              post_ins = post_del = true;
              equalitiesLength = 0;
            } else {
              equalitiesLength--;
              pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
              post_ins = post_del = false;
            }
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        this.diff_cleanupMerge(diffs);
      }
    };
    diff_match_patch.prototype.diff_cleanupMerge = function(diffs) {
      diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, ""));
      var pointer = 0;
      var count_delete = 0;
      var count_insert = 0;
      var text_delete = "";
      var text_insert = "";
      var commonlength;
      while (pointer < diffs.length) {
        switch (diffs[pointer][0]) {
          case DIFF_INSERT:
            count_insert++;
            text_insert += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_DELETE:
            count_delete++;
            text_delete += diffs[pointer][1];
            pointer++;
            break;
          case DIFF_EQUAL:
            if (count_delete + count_insert > 1) {
              if (count_delete !== 0 && count_insert !== 0) {
                commonlength = this.diff_commonPrefix(text_insert, text_delete);
                if (commonlength !== 0) {
                  if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] == DIFF_EQUAL) {
                    diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
                  } else {
                    diffs.splice(0, 0, new diff_match_patch.Diff(DIFF_EQUAL, text_insert.substring(0, commonlength)));
                    pointer++;
                  }
                  text_insert = text_insert.substring(commonlength);
                  text_delete = text_delete.substring(commonlength);
                }
                commonlength = this.diff_commonSuffix(text_insert, text_delete);
                if (commonlength !== 0) {
                  diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
                  text_insert = text_insert.substring(0, text_insert.length - commonlength);
                  text_delete = text_delete.substring(0, text_delete.length - commonlength);
                }
              }
              pointer -= count_delete + count_insert;
              diffs.splice(pointer, count_delete + count_insert);
              if (text_delete.length) {
                diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_DELETE, text_delete));
                pointer++;
              }
              if (text_insert.length) {
                diffs.splice(pointer, 0, new diff_match_patch.Diff(DIFF_INSERT, text_insert));
                pointer++;
              }
              pointer++;
            } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
              diffs[pointer - 1][1] += diffs[pointer][1];
              diffs.splice(pointer, 1);
            } else {
              pointer++;
            }
            count_insert = 0;
            count_delete = 0;
            text_delete = "";
            text_insert = "";
            break;
        }
      }
      if (diffs[diffs.length - 1][1] === "") {
        diffs.pop();
      }
      var changes = false;
      pointer = 1;
      while (pointer < diffs.length - 1) {
        if (diffs[pointer - 1][0] == DIFF_EQUAL && diffs[pointer + 1][0] == DIFF_EQUAL) {
          if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
            diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
            diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
            diffs.splice(pointer - 1, 1);
            changes = true;
          } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) == diffs[pointer + 1][1]) {
            diffs[pointer - 1][1] += diffs[pointer + 1][1];
            diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
            diffs.splice(pointer + 1, 1);
            changes = true;
          }
        }
        pointer++;
      }
      if (changes) {
        this.diff_cleanupMerge(diffs);
      }
    };
    diff_match_patch.prototype.diff_xIndex = function(diffs, loc) {
      var chars1 = 0;
      var chars2 = 0;
      var last_chars1 = 0;
      var last_chars2 = 0;
      var x;
      for (x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_INSERT) {
          chars1 += diffs[x][1].length;
        }
        if (diffs[x][0] !== DIFF_DELETE) {
          chars2 += diffs[x][1].length;
        }
        if (chars1 > loc) {
          break;
        }
        last_chars1 = chars1;
        last_chars2 = chars2;
      }
      if (diffs.length != x && diffs[x][0] === DIFF_DELETE) {
        return last_chars2;
      }
      return last_chars2 + (loc - last_chars1);
    };
    diff_match_patch.prototype.diff_prettyHtml = function(diffs) {
      var html = [];
      var pattern_amp = /&/g;
      var pattern_lt = /</g;
      var pattern_gt = />/g;
      var pattern_para = /\n/g;
      for (var x = 0; x < diffs.length; x++) {
        var op = diffs[x][0];
        var data = diffs[x][1];
        var text = data.replace(pattern_amp, "&amp;").replace(pattern_lt, "&lt;").replace(pattern_gt, "&gt;").replace(pattern_para, "&para;<br>");
        switch (op) {
          case DIFF_INSERT:
            html[x] = '<ins style="background:#e6ffe6;">' + text + "</ins>";
            break;
          case DIFF_DELETE:
            html[x] = '<del style="background:#ffe6e6;">' + text + "</del>";
            break;
          case DIFF_EQUAL:
            html[x] = "<span>" + text + "</span>";
            break;
        }
      }
      return html.join("");
    };
    diff_match_patch.prototype.diff_text1 = function(diffs) {
      var text = [];
      for (var x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_INSERT) {
          text[x] = diffs[x][1];
        }
      }
      return text.join("");
    };
    diff_match_patch.prototype.diff_text2 = function(diffs) {
      var text = [];
      for (var x = 0; x < diffs.length; x++) {
        if (diffs[x][0] !== DIFF_DELETE) {
          text[x] = diffs[x][1];
        }
      }
      return text.join("");
    };
    diff_match_patch.prototype.diff_levenshtein = function(diffs) {
      var levenshtein = 0;
      var insertions = 0;
      var deletions = 0;
      for (var x = 0; x < diffs.length; x++) {
        var op = diffs[x][0];
        var data = diffs[x][1];
        switch (op) {
          case DIFF_INSERT:
            insertions += data.length;
            break;
          case DIFF_DELETE:
            deletions += data.length;
            break;
          case DIFF_EQUAL:
            levenshtein += Math.max(insertions, deletions);
            insertions = 0;
            deletions = 0;
            break;
        }
      }
      levenshtein += Math.max(insertions, deletions);
      return levenshtein;
    };
    diff_match_patch.prototype.diff_toDelta = function(diffs) {
      var text = [];
      for (var x = 0; x < diffs.length; x++) {
        switch (diffs[x][0]) {
          case DIFF_INSERT:
            text[x] = "+" + encodeURI(diffs[x][1]);
            break;
          case DIFF_DELETE:
            text[x] = "-" + diffs[x][1].length;
            break;
          case DIFF_EQUAL:
            text[x] = "=" + diffs[x][1].length;
            break;
        }
      }
      return text.join("	").replace(/%20/g, " ");
    };
    diff_match_patch.prototype.diff_fromDelta = function(text1, delta) {
      var diffs = [];
      var diffsLength = 0;
      var pointer = 0;
      var tokens = delta.split(/\t/g);
      for (var x = 0; x < tokens.length; x++) {
        var param = tokens[x].substring(1);
        switch (tokens[x].charAt(0)) {
          case "+":
            try {
              diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_INSERT, decodeURI(param));
            } catch (ex) {
              throw new Error("Illegal escape in diff_fromDelta: " + param);
            }
            break;
          case "-":
          case "=":
            var n = parseInt(param, 10);
            if (isNaN(n) || n < 0) {
              throw new Error("Invalid number in diff_fromDelta: " + param);
            }
            var text = text1.substring(pointer, pointer += n);
            if (tokens[x].charAt(0) == "=") {
              diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_EQUAL, text);
            } else {
              diffs[diffsLength++] = new diff_match_patch.Diff(DIFF_DELETE, text);
            }
            break;
          default:
            if (tokens[x]) {
              throw new Error("Invalid diff operation in diff_fromDelta: " + tokens[x]);
            }
        }
      }
      if (pointer != text1.length) {
        throw new Error("Delta length (" + pointer + ") does not equal source text length (" + text1.length + ").");
      }
      return diffs;
    };
    diff_match_patch.prototype.match_main = function(text, pattern, loc) {
      if (text == null || pattern == null || loc == null) {
        throw new Error("Null input. (match_main)");
      }
      loc = Math.max(0, Math.min(loc, text.length));
      if (text == pattern) {
        return 0;
      } else if (!text.length) {
        return -1;
      } else if (text.substring(loc, loc + pattern.length) == pattern) {
        return loc;
      } else {
        return this.match_bitap_(text, pattern, loc);
      }
    };
    diff_match_patch.prototype.match_bitap_ = function(text, pattern, loc) {
      if (pattern.length > this.Match_MaxBits) {
        throw new Error("Pattern too long for this browser.");
      }
      var s = this.match_alphabet_(pattern);
      var dmp = this;
      function match_bitapScore_(e, x) {
        var accuracy = e / pattern.length;
        var proximity = Math.abs(loc - x);
        if (!dmp.Match_Distance) {
          return proximity ? 1 : accuracy;
        }
        return accuracy + proximity / dmp.Match_Distance;
      }
      var score_threshold = this.Match_Threshold;
      var best_loc = text.indexOf(pattern, loc);
      if (best_loc != -1) {
        score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
        best_loc = text.lastIndexOf(pattern, loc + pattern.length);
        if (best_loc != -1) {
          score_threshold = Math.min(match_bitapScore_(0, best_loc), score_threshold);
        }
      }
      var matchmask = 1 << pattern.length - 1;
      best_loc = -1;
      var bin_min, bin_mid;
      var bin_max = pattern.length + text.length;
      var last_rd;
      for (var d = 0; d < pattern.length; d++) {
        bin_min = 0;
        bin_mid = bin_max;
        while (bin_min < bin_mid) {
          if (match_bitapScore_(d, loc + bin_mid) <= score_threshold) {
            bin_min = bin_mid;
          } else {
            bin_max = bin_mid;
          }
          bin_mid = Math.floor((bin_max - bin_min) / 2 + bin_min);
        }
        bin_max = bin_mid;
        var start = Math.max(1, loc - bin_mid + 1);
        var finish = Math.min(loc + bin_mid, text.length) + pattern.length;
        var rd = Array(finish + 2);
        rd[finish + 1] = (1 << d) - 1;
        for (var j = finish; j >= start; j--) {
          var charMatch = s[text.charAt(j - 1)];
          if (d === 0) {
            rd[j] = (rd[j + 1] << 1 | 1) & charMatch;
          } else {
            rd[j] = (rd[j + 1] << 1 | 1) & charMatch | ((last_rd[j + 1] | last_rd[j]) << 1 | 1) | last_rd[j + 1];
          }
          if (rd[j] & matchmask) {
            var score = match_bitapScore_(d, j - 1);
            if (score <= score_threshold) {
              score_threshold = score;
              best_loc = j - 1;
              if (best_loc > loc) {
                start = Math.max(1, 2 * loc - best_loc);
              } else {
                break;
              }
            }
          }
        }
        if (match_bitapScore_(d + 1, loc) > score_threshold) {
          break;
        }
        last_rd = rd;
      }
      return best_loc;
    };
    diff_match_patch.prototype.match_alphabet_ = function(pattern) {
      var s = {};
      for (var i = 0; i < pattern.length; i++) {
        s[pattern.charAt(i)] = 0;
      }
      for (var i = 0; i < pattern.length; i++) {
        s[pattern.charAt(i)] |= 1 << pattern.length - i - 1;
      }
      return s;
    };
    diff_match_patch.prototype.patch_addContext_ = function(patch, text) {
      if (text.length == 0) {
        return;
      }
      if (patch.start2 === null) {
        throw Error("patch not initialized");
      }
      var pattern = text.substring(patch.start2, patch.start2 + patch.length1);
      var padding = 0;
      while (text.indexOf(pattern) != text.lastIndexOf(pattern) && pattern.length < this.Match_MaxBits - this.Patch_Margin - this.Patch_Margin) {
        padding += this.Patch_Margin;
        pattern = text.substring(patch.start2 - padding, patch.start2 + patch.length1 + padding);
      }
      padding += this.Patch_Margin;
      var prefix = text.substring(patch.start2 - padding, patch.start2);
      if (prefix) {
        patch.diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, prefix));
      }
      var suffix = text.substring(patch.start2 + patch.length1, patch.start2 + patch.length1 + padding);
      if (suffix) {
        patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, suffix));
      }
      patch.start1 -= prefix.length;
      patch.start2 -= prefix.length;
      patch.length1 += prefix.length + suffix.length;
      patch.length2 += prefix.length + suffix.length;
    };
    diff_match_patch.prototype.patch_make = function(a, opt_b, opt_c) {
      var text1, diffs;
      if (typeof a == "string" && typeof opt_b == "string" && typeof opt_c == "undefined") {
        text1 = a;
        diffs = this.diff_main(text1, opt_b, true);
        if (diffs.length > 2) {
          this.diff_cleanupSemantic(diffs);
          this.diff_cleanupEfficiency(diffs);
        }
      } else if (a && typeof a == "object" && typeof opt_b == "undefined" && typeof opt_c == "undefined") {
        diffs = a;
        text1 = this.diff_text1(diffs);
      } else if (typeof a == "string" && opt_b && typeof opt_b == "object" && typeof opt_c == "undefined") {
        text1 = a;
        diffs = opt_b;
      } else if (typeof a == "string" && typeof opt_b == "string" && opt_c && typeof opt_c == "object") {
        text1 = a;
        diffs = opt_c;
      } else {
        throw new Error("Unknown call format to patch_make.");
      }
      if (diffs.length === 0) {
        return [];
      }
      var patches = [];
      var patch = new diff_match_patch.patch_obj();
      var patchDiffLength = 0;
      var char_count1 = 0;
      var char_count2 = 0;
      var prepatch_text = text1;
      var postpatch_text = text1;
      for (var x = 0; x < diffs.length; x++) {
        var diff_type = diffs[x][0];
        var diff_text = diffs[x][1];
        if (!patchDiffLength && diff_type !== DIFF_EQUAL) {
          patch.start1 = char_count1;
          patch.start2 = char_count2;
        }
        switch (diff_type) {
          case DIFF_INSERT:
            patch.diffs[patchDiffLength++] = diffs[x];
            patch.length2 += diff_text.length;
            postpatch_text = postpatch_text.substring(0, char_count2) + diff_text + postpatch_text.substring(char_count2);
            break;
          case DIFF_DELETE:
            patch.length1 += diff_text.length;
            patch.diffs[patchDiffLength++] = diffs[x];
            postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + diff_text.length);
            break;
          case DIFF_EQUAL:
            if (diff_text.length <= 2 * this.Patch_Margin && patchDiffLength && diffs.length != x + 1) {
              patch.diffs[patchDiffLength++] = diffs[x];
              patch.length1 += diff_text.length;
              patch.length2 += diff_text.length;
            } else if (diff_text.length >= 2 * this.Patch_Margin) {
              if (patchDiffLength) {
                this.patch_addContext_(patch, prepatch_text);
                patches.push(patch);
                patch = new diff_match_patch.patch_obj();
                patchDiffLength = 0;
                prepatch_text = postpatch_text;
                char_count1 = char_count2;
              }
            }
            break;
        }
        if (diff_type !== DIFF_INSERT) {
          char_count1 += diff_text.length;
        }
        if (diff_type !== DIFF_DELETE) {
          char_count2 += diff_text.length;
        }
      }
      if (patchDiffLength) {
        this.patch_addContext_(patch, prepatch_text);
        patches.push(patch);
      }
      return patches;
    };
    diff_match_patch.prototype.patch_deepCopy = function(patches) {
      var patchesCopy = [];
      for (var x = 0; x < patches.length; x++) {
        var patch = patches[x];
        var patchCopy = new diff_match_patch.patch_obj();
        patchCopy.diffs = [];
        for (var y = 0; y < patch.diffs.length; y++) {
          patchCopy.diffs[y] = new diff_match_patch.Diff(patch.diffs[y][0], patch.diffs[y][1]);
        }
        patchCopy.start1 = patch.start1;
        patchCopy.start2 = patch.start2;
        patchCopy.length1 = patch.length1;
        patchCopy.length2 = patch.length2;
        patchesCopy[x] = patchCopy;
      }
      return patchesCopy;
    };
    diff_match_patch.prototype.patch_apply = function(patches, text) {
      if (patches.length == 0) {
        return [text, []];
      }
      patches = this.patch_deepCopy(patches);
      var nullPadding = this.patch_addPadding(patches);
      text = nullPadding + text + nullPadding;
      this.patch_splitMax(patches);
      var delta = 0;
      var results = [];
      for (var x = 0; x < patches.length; x++) {
        var expected_loc = patches[x].start2 + delta;
        var text1 = this.diff_text1(patches[x].diffs);
        var start_loc;
        var end_loc = -1;
        if (text1.length > this.Match_MaxBits) {
          start_loc = this.match_main(text, text1.substring(0, this.Match_MaxBits), expected_loc);
          if (start_loc != -1) {
            end_loc = this.match_main(text, text1.substring(text1.length - this.Match_MaxBits), expected_loc + text1.length - this.Match_MaxBits);
            if (end_loc == -1 || start_loc >= end_loc) {
              start_loc = -1;
            }
          }
        } else {
          start_loc = this.match_main(text, text1, expected_loc);
        }
        if (start_loc == -1) {
          results[x] = false;
          delta -= patches[x].length2 - patches[x].length1;
        } else {
          results[x] = true;
          delta = start_loc - expected_loc;
          var text2;
          if (end_loc == -1) {
            text2 = text.substring(start_loc, start_loc + text1.length);
          } else {
            text2 = text.substring(start_loc, end_loc + this.Match_MaxBits);
          }
          if (text1 == text2) {
            text = text.substring(0, start_loc) + this.diff_text2(patches[x].diffs) + text.substring(start_loc + text1.length);
          } else {
            var diffs = this.diff_main(text1, text2, false);
            if (text1.length > this.Match_MaxBits && this.diff_levenshtein(diffs) / text1.length > this.Patch_DeleteThreshold) {
              results[x] = false;
            } else {
              this.diff_cleanupSemanticLossless(diffs);
              var index1 = 0;
              var index2;
              for (var y = 0; y < patches[x].diffs.length; y++) {
                var mod = patches[x].diffs[y];
                if (mod[0] !== DIFF_EQUAL) {
                  index2 = this.diff_xIndex(diffs, index1);
                }
                if (mod[0] === DIFF_INSERT) {
                  text = text.substring(0, start_loc + index2) + mod[1] + text.substring(start_loc + index2);
                } else if (mod[0] === DIFF_DELETE) {
                  text = text.substring(0, start_loc + index2) + text.substring(start_loc + this.diff_xIndex(diffs, index1 + mod[1].length));
                }
                if (mod[0] !== DIFF_DELETE) {
                  index1 += mod[1].length;
                }
              }
            }
          }
        }
      }
      text = text.substring(nullPadding.length, text.length - nullPadding.length);
      return [text, results];
    };
    diff_match_patch.prototype.patch_addPadding = function(patches) {
      var paddingLength = this.Patch_Margin;
      var nullPadding = "";
      for (var x = 1; x <= paddingLength; x++) {
        nullPadding += String.fromCharCode(x);
      }
      for (var x = 0; x < patches.length; x++) {
        patches[x].start1 += paddingLength;
        patches[x].start2 += paddingLength;
      }
      var patch = patches[0];
      var diffs = patch.diffs;
      if (diffs.length == 0 || diffs[0][0] != DIFF_EQUAL) {
        diffs.unshift(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
        patch.start1 -= paddingLength;
        patch.start2 -= paddingLength;
        patch.length1 += paddingLength;
        patch.length2 += paddingLength;
      } else if (paddingLength > diffs[0][1].length) {
        var extraLength = paddingLength - diffs[0][1].length;
        diffs[0][1] = nullPadding.substring(diffs[0][1].length) + diffs[0][1];
        patch.start1 -= extraLength;
        patch.start2 -= extraLength;
        patch.length1 += extraLength;
        patch.length2 += extraLength;
      }
      patch = patches[patches.length - 1];
      diffs = patch.diffs;
      if (diffs.length == 0 || diffs[diffs.length - 1][0] != DIFF_EQUAL) {
        diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, nullPadding));
        patch.length1 += paddingLength;
        patch.length2 += paddingLength;
      } else if (paddingLength > diffs[diffs.length - 1][1].length) {
        var extraLength = paddingLength - diffs[diffs.length - 1][1].length;
        diffs[diffs.length - 1][1] += nullPadding.substring(0, extraLength);
        patch.length1 += extraLength;
        patch.length2 += extraLength;
      }
      return nullPadding;
    };
    diff_match_patch.prototype.patch_splitMax = function(patches) {
      var patch_size = this.Match_MaxBits;
      for (var x = 0; x < patches.length; x++) {
        if (patches[x].length1 <= patch_size) {
          continue;
        }
        var bigpatch = patches[x];
        patches.splice(x--, 1);
        var start1 = bigpatch.start1;
        var start2 = bigpatch.start2;
        var precontext = "";
        while (bigpatch.diffs.length !== 0) {
          var patch = new diff_match_patch.patch_obj();
          var empty = true;
          patch.start1 = start1 - precontext.length;
          patch.start2 = start2 - precontext.length;
          if (precontext !== "") {
            patch.length1 = patch.length2 = precontext.length;
            patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, precontext));
          }
          while (bigpatch.diffs.length !== 0 && patch.length1 < patch_size - this.Patch_Margin) {
            var diff_type = bigpatch.diffs[0][0];
            var diff_text = bigpatch.diffs[0][1];
            if (diff_type === DIFF_INSERT) {
              patch.length2 += diff_text.length;
              start2 += diff_text.length;
              patch.diffs.push(bigpatch.diffs.shift());
              empty = false;
            } else if (diff_type === DIFF_DELETE && patch.diffs.length == 1 && patch.diffs[0][0] == DIFF_EQUAL && diff_text.length > 2 * patch_size) {
              patch.length1 += diff_text.length;
              start1 += diff_text.length;
              empty = false;
              patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
              bigpatch.diffs.shift();
            } else {
              diff_text = diff_text.substring(0, patch_size - patch.length1 - this.Patch_Margin);
              patch.length1 += diff_text.length;
              start1 += diff_text.length;
              if (diff_type === DIFF_EQUAL) {
                patch.length2 += diff_text.length;
                start2 += diff_text.length;
              } else {
                empty = false;
              }
              patch.diffs.push(new diff_match_patch.Diff(diff_type, diff_text));
              if (diff_text == bigpatch.diffs[0][1]) {
                bigpatch.diffs.shift();
              } else {
                bigpatch.diffs[0][1] = bigpatch.diffs[0][1].substring(diff_text.length);
              }
            }
          }
          precontext = this.diff_text2(patch.diffs);
          precontext = precontext.substring(precontext.length - this.Patch_Margin);
          var postcontext = this.diff_text1(bigpatch.diffs).substring(0, this.Patch_Margin);
          if (postcontext !== "") {
            patch.length1 += postcontext.length;
            patch.length2 += postcontext.length;
            if (patch.diffs.length !== 0 && patch.diffs[patch.diffs.length - 1][0] === DIFF_EQUAL) {
              patch.diffs[patch.diffs.length - 1][1] += postcontext;
            } else {
              patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, postcontext));
            }
          }
          if (!empty) {
            patches.splice(++x, 0, patch);
          }
        }
      }
    };
    diff_match_patch.prototype.patch_toText = function(patches) {
      var text = [];
      for (var x = 0; x < patches.length; x++) {
        text[x] = patches[x];
      }
      return text.join("");
    };
    diff_match_patch.prototype.patch_fromText = function(textline) {
      var patches = [];
      if (!textline) {
        return patches;
      }
      var text = textline.split("\n");
      var textPointer = 0;
      var patchHeader = /^@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@$/;
      while (textPointer < text.length) {
        var m = text[textPointer].match(patchHeader);
        if (!m) {
          throw new Error("Invalid patch string: " + text[textPointer]);
        }
        var patch = new diff_match_patch.patch_obj();
        patches.push(patch);
        patch.start1 = parseInt(m[1], 10);
        if (m[2] === "") {
          patch.start1--;
          patch.length1 = 1;
        } else if (m[2] == "0") {
          patch.length1 = 0;
        } else {
          patch.start1--;
          patch.length1 = parseInt(m[2], 10);
        }
        patch.start2 = parseInt(m[3], 10);
        if (m[4] === "") {
          patch.start2--;
          patch.length2 = 1;
        } else if (m[4] == "0") {
          patch.length2 = 0;
        } else {
          patch.start2--;
          patch.length2 = parseInt(m[4], 10);
        }
        textPointer++;
        while (textPointer < text.length) {
          var sign = text[textPointer].charAt(0);
          try {
            var line = decodeURI(text[textPointer].substring(1));
          } catch (ex) {
            throw new Error("Illegal escape in patch_fromText: " + line);
          }
          if (sign == "-") {
            patch.diffs.push(new diff_match_patch.Diff(DIFF_DELETE, line));
          } else if (sign == "+") {
            patch.diffs.push(new diff_match_patch.Diff(DIFF_INSERT, line));
          } else if (sign == " ") {
            patch.diffs.push(new diff_match_patch.Diff(DIFF_EQUAL, line));
          } else if (sign == "@") {
            break;
          } else if (sign === "") {
          } else {
            throw new Error('Invalid patch mode "' + sign + '" in: ' + line);
          }
          textPointer++;
        }
      }
      return patches;
    };
    diff_match_patch.patch_obj = function() {
      this.diffs = [];
      this.start1 = null;
      this.start2 = null;
      this.length1 = 0;
      this.length2 = 0;
    };
    diff_match_patch.patch_obj.prototype.toString = function() {
      var coords1, coords2;
      if (this.length1 === 0) {
        coords1 = this.start1 + ",0";
      } else if (this.length1 == 1) {
        coords1 = this.start1 + 1;
      } else {
        coords1 = this.start1 + 1 + "," + this.length1;
      }
      if (this.length2 === 0) {
        coords2 = this.start2 + ",0";
      } else if (this.length2 == 1) {
        coords2 = this.start2 + 1;
      } else {
        coords2 = this.start2 + 1 + "," + this.length2;
      }
      var text = ["@@ -" + coords1 + " +" + coords2 + " @@\n"];
      var op;
      for (var x = 0; x < this.diffs.length; x++) {
        switch (this.diffs[x][0]) {
          case DIFF_INSERT:
            op = "+";
            break;
          case DIFF_DELETE:
            op = "-";
            break;
          case DIFF_EQUAL:
            op = " ";
            break;
        }
        text[x + 1] = op + encodeURI(this.diffs[x][1]) + "\n";
      }
      return text.join("").replace(/%20/g, " ");
    };
    module2.exports = { diff_match_patch, DIFF_INSERT, DIFF_DELETE, DIFF_EQUAL };
  }
});

// node_modules/playwright-core/lib/utils/comparators.js
var require_comparators = __commonJS({
  "node_modules/playwright-core/lib/utils/comparators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getComparator = getComparator;
    var _safe = _interopRequireDefault(require_safe());
    var _jpegJs = _interopRequireDefault(require_jpeg_js());
    var _pixelmatch = _interopRequireDefault(require("pixelmatch"));
    var _diff_match_patch = require_diff_match_patch();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var {
      PNG
    } = require(require.resolve("pngjs", {
      paths: [require.resolve("pixelmatch")]
    }));
    function getComparator(mimeType) {
      if (mimeType === "image/png")
        return compareImages.bind(null, "image/png");
      if (mimeType === "image/jpeg")
        return compareImages.bind(null, "image/jpeg");
      if (mimeType === "text/plain")
        return compareText;
      return compareBuffersOrStrings;
    }
    function compareBuffersOrStrings(actualBuffer, expectedBuffer) {
      if (typeof actualBuffer === "string")
        return compareText(actualBuffer, expectedBuffer);
      if (!actualBuffer || !(actualBuffer instanceof Buffer))
        return {
          errorMessage: "Actual result should be a Buffer or a string."
        };
      if (Buffer.compare(actualBuffer, expectedBuffer))
        return {
          errorMessage: "Buffers differ"
        };
      return null;
    }
    function compareImages(mimeType, actualBuffer, expectedBuffer, options = {}) {
      var _options$threshold, _ref;
      if (!actualBuffer || !(actualBuffer instanceof Buffer))
        return {
          errorMessage: "Actual result should be a Buffer."
        };
      const actual = mimeType === "image/png" ? PNG.sync.read(actualBuffer) : _jpegJs.default.decode(actualBuffer);
      const expected = mimeType === "image/png" ? PNG.sync.read(expectedBuffer) : _jpegJs.default.decode(expectedBuffer);
      if (expected.width !== actual.width || expected.height !== actual.height) {
        return {
          errorMessage: `Expected an image ${expected.width}px by ${expected.height}px, received ${actual.width}px by ${actual.height}px. `
        };
      }
      const diff = new PNG({
        width: expected.width,
        height: expected.height
      });
      const count = (0, _pixelmatch.default)(expected.data, actual.data, diff.data, expected.width, expected.height, {
        threshold: (_options$threshold = options.threshold) !== null && _options$threshold !== void 0 ? _options$threshold : 0.2
      });
      const maxDiffPixels1 = options.maxDiffPixels;
      const maxDiffPixels2 = options.maxDiffPixelRatio !== void 0 ? expected.width * expected.height * options.maxDiffPixelRatio : void 0;
      let maxDiffPixels;
      if (maxDiffPixels1 !== void 0 && maxDiffPixels2 !== void 0)
        maxDiffPixels = Math.min(maxDiffPixels1, maxDiffPixels2);
      else
        maxDiffPixels = (_ref = maxDiffPixels1 !== null && maxDiffPixels1 !== void 0 ? maxDiffPixels1 : maxDiffPixels2) !== null && _ref !== void 0 ? _ref : 0;
      const ratio = Math.ceil(count / (expected.width * expected.height) * 100) / 100;
      return count > maxDiffPixels ? {
        errorMessage: `${count} pixels (ratio ${ratio.toFixed(2)} of all image pixels) are different`,
        diff: PNG.sync.write(diff)
      } : null;
    }
    function compareText(actual, expectedBuffer) {
      if (typeof actual !== "string")
        return {
          errorMessage: "Actual result should be a string"
        };
      const expected = expectedBuffer.toString("utf-8");
      if (expected === actual)
        return null;
      const dmp = new _diff_match_patch.diff_match_patch();
      const d = dmp.diff_main(expected, actual);
      dmp.diff_cleanupSemantic(d);
      return {
        errorMessage: diff_prettyTerminal(d)
      };
    }
    function diff_prettyTerminal(diffs) {
      const html = [];
      for (let x = 0; x < diffs.length; x++) {
        const op = diffs[x][0];
        const data = diffs[x][1];
        const text = data;
        switch (op) {
          case _diff_match_patch.DIFF_INSERT:
            html[x] = _safe.default.green(text);
            break;
          case _diff_match_patch.DIFF_DELETE:
            html[x] = _safe.default.reset(_safe.default.strikethrough(_safe.default.red(text)));
            break;
          case _diff_match_patch.DIFF_EQUAL:
            html[x] = text;
            break;
        }
      }
      return html.join("");
    }
  }
});

// node_modules/playwright-core/lib/server/page.js
var require_page = __commonJS({
  "node_modules/playwright-core/lib/server/page.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Worker = exports2.PageBinding = exports2.Page = void 0;
    var frames = _interopRequireWildcard(require_frames());
    var input = _interopRequireWildcard(require_input());
    var js = _interopRequireWildcard(require_javascript());
    var network = _interopRequireWildcard(require_network());
    var _screenshotter = require_screenshotter();
    var _timeoutSettings = require_timeoutSettings();
    var _browserContext = require_browserContext();
    var _console = require_console();
    var accessibility = _interopRequireWildcard(require_accessibility());
    var _fileChooser = require_fileChooser();
    var _progress = require_progress2();
    var _utils = require_utils();
    var _manualPromise = require_manualPromise();
    var _debugLogger = require_debugLogger();
    var _comparators = require_comparators();
    var _instrumentation = require_instrumentation();
    var _selectorParser = require_selectorParser();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Page = class extends _instrumentation.SdkObject {
      constructor(delegate, browserContext) {
        super(browserContext, "page");
        this._closedState = "open";
        this._closedPromise = new _manualPromise.ManualPromise();
        this._disconnected = false;
        this._initialized = false;
        this._disconnectedPromise = new _manualPromise.ManualPromise();
        this._crashedPromise = new _manualPromise.ManualPromise();
        this._browserContext = void 0;
        this.keyboard = void 0;
        this.mouse = void 0;
        this.touchscreen = void 0;
        this._timeoutSettings = void 0;
        this._delegate = void 0;
        this._state = void 0;
        this._pageBindings = /* @__PURE__ */ new Map();
        this.initScripts = [];
        this._screenshotter = void 0;
        this._frameManager = void 0;
        this.accessibility = void 0;
        this._workers = /* @__PURE__ */ new Map();
        this.pdf = void 0;
        this.coverage = void 0;
        this._clientRequestInterceptor = void 0;
        this._serverRequestInterceptor = void 0;
        this._ownedContext = void 0;
        this.selectors = void 0;
        this._pageIsError = void 0;
        this._video = null;
        this._opener = void 0;
        this._frameThrottler = new FrameThrottler(10, 200);
        this._isServerSideOnly = false;
        this.attribution.page = this;
        this._delegate = delegate;
        this._browserContext = browserContext;
        this._state = {
          emulatedSize: browserContext._options.viewport ? {
            viewport: browserContext._options.viewport,
            screen: browserContext._options.screen || browserContext._options.viewport
          } : null,
          mediaType: null,
          colorScheme: browserContext._options.colorScheme !== void 0 ? browserContext._options.colorScheme : "light",
          reducedMotion: browserContext._options.reducedMotion !== void 0 ? browserContext._options.reducedMotion : "no-preference",
          forcedColors: browserContext._options.forcedColors !== void 0 ? browserContext._options.forcedColors : "none",
          extraHTTPHeaders: null
        };
        this.accessibility = new accessibility.Accessibility(delegate.getAccessibilityTree.bind(delegate));
        this.keyboard = new input.Keyboard(delegate.rawKeyboard, this);
        this.mouse = new input.Mouse(delegate.rawMouse, this);
        this.touchscreen = new input.Touchscreen(delegate.rawTouchscreen, this);
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings(browserContext._timeoutSettings);
        this._screenshotter = new _screenshotter.Screenshotter(this);
        this._frameManager = new frames.FrameManager(this);
        if (delegate.pdf)
          this.pdf = delegate.pdf.bind(delegate);
        this.coverage = delegate.coverage ? delegate.coverage() : null;
        this.selectors = browserContext.selectors();
        this.instrumentation.onPageOpen(this);
      }
      initOpener(opener) {
        return __async(this, null, function* () {
          if (!opener)
            return;
          const openerPage = yield opener.pageOrError();
          if (openerPage instanceof Page && !openerPage.isClosed())
            this._opener = openerPage;
        });
      }
      reportAsNew(error) {
        if (error) {
          if (this._browserContext.isClosingOrClosed())
            return;
          this._setIsError(error);
        }
        this._initialized = true;
        this.emitOnContext(_browserContext.BrowserContext.Events.Page, this);
        if (this.isClosed())
          this.emit(Page.Events.Close);
      }
      initializedOrUndefined() {
        return this._initialized ? this : void 0;
      }
      emitOnContext(event, ...args) {
        if (this._isServerSideOnly)
          return;
        this._browserContext.emit(event, ...args);
      }
      _doSlowMo() {
        return __async(this, null, function* () {
          const slowMo = this._browserContext._browser.options.slowMo;
          if (!slowMo)
            return;
          yield new Promise((x) => setTimeout(x, slowMo));
        });
      }
      _didClose() {
        this.instrumentation.onPageClose(this);
        this._frameManager.dispose();
        this._frameThrottler.setEnabled(false);
        (0, _utils.assert)(this._closedState !== "closed", "Page closed twice");
        this._closedState = "closed";
        this.emit(Page.Events.Close);
        this._closedPromise.resolve();
      }
      _didCrash() {
        this.instrumentation.onPageClose(this);
        this._frameManager.dispose();
        this._frameThrottler.setEnabled(false);
        this.emit(Page.Events.Crash);
        this._crashedPromise.resolve(new Error("Page crashed"));
      }
      _didDisconnect() {
        this.instrumentation.onPageClose(this);
        this._frameManager.dispose();
        this._frameThrottler.setEnabled(false);
        (0, _utils.assert)(!this._disconnected, "Page disconnected twice");
        this._disconnected = true;
        this._disconnectedPromise.resolve(new Error("Page closed"));
      }
      _onFileChooserOpened(handle) {
        return __async(this, null, function* () {
          let multiple;
          try {
            multiple = yield handle.evaluate((element) => !!element.multiple);
          } catch (e) {
            return;
          }
          if (!this.listenerCount(Page.Events.FileChooser)) {
            handle.dispose();
            return;
          }
          const fileChooser = new _fileChooser.FileChooser(this, handle, multiple);
          this.emit(Page.Events.FileChooser, fileChooser);
        });
      }
      context() {
        return this._browserContext;
      }
      opener() {
        return this._opener;
      }
      mainFrame() {
        return this._frameManager.mainFrame();
      }
      frames() {
        return this._frameManager.frames();
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      exposeBinding(name, needsHandle, playwrightBinding) {
        return __async(this, null, function* () {
          if (this._pageBindings.has(name))
            throw new Error(`Function "${name}" has been already registered`);
          if (this._browserContext._pageBindings.has(name))
            throw new Error(`Function "${name}" has been already registered in the browser context`);
          const binding = new PageBinding(name, playwrightBinding, needsHandle);
          this._pageBindings.set(name, binding);
          yield this._delegate.exposeBinding(binding);
        });
      }
      removeExposedBindings() {
        return __async(this, null, function* () {
          this._pageBindings.clear();
          yield this._delegate.removeExposedBindings();
        });
      }
      setExtraHTTPHeaders(headers) {
        this._state.extraHTTPHeaders = headers;
        return this._delegate.updateExtraHTTPHeaders();
      }
      _onBindingCalled(payload, context) {
        return __async(this, null, function* () {
          if (this._disconnected || this._closedState === "closed")
            return;
          yield PageBinding.dispatch(this, payload, context);
        });
      }
      _addConsoleMessage(type, args, location2, text) {
        const message = new _console.ConsoleMessage(this, type, text, args, location2);
        const intercepted = this._frameManager.interceptConsoleMessage(message);
        if (intercepted || !this.listenerCount(Page.Events.Console))
          args.forEach((arg) => arg.dispose());
        else
          this.emit(Page.Events.Console, message);
      }
      reload(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => this.mainFrame().raceNavigationAction(() => __async(this, null, function* () {
            const [response] = yield Promise.all([this.mainFrame()._waitForNavigation(progress, options), this._delegate.reload()]);
            yield this._doSlowMo();
            return response;
          })), this._timeoutSettings.navigationTimeout(options));
        });
      }
      goBack(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => this.mainFrame().raceNavigationAction(() => __async(this, null, function* () {
            let error;
            const waitPromise = this.mainFrame()._waitForNavigation(progress, options).catch((e) => {
              error = e;
              return null;
            });
            const result = yield this._delegate.goBack();
            if (!result)
              return null;
            const response = yield waitPromise;
            if (error)
              throw error;
            yield this._doSlowMo();
            return response;
          })), this._timeoutSettings.navigationTimeout(options));
        });
      }
      goForward(metadata, options) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => this.mainFrame().raceNavigationAction(() => __async(this, null, function* () {
            let error;
            const waitPromise = this.mainFrame()._waitForNavigation(progress, options).catch((e) => {
              error = e;
              return null;
            });
            const result = yield this._delegate.goForward();
            if (!result)
              return null;
            const response = yield waitPromise;
            if (error)
              throw error;
            yield this._doSlowMo();
            return response;
          })), this._timeoutSettings.navigationTimeout(options));
        });
      }
      emulateMedia(options) {
        return __async(this, null, function* () {
          if (options.media !== void 0)
            this._state.mediaType = options.media;
          if (options.colorScheme !== void 0)
            this._state.colorScheme = options.colorScheme;
          if (options.reducedMotion !== void 0)
            this._state.reducedMotion = options.reducedMotion;
          if (options.forcedColors !== void 0)
            this._state.forcedColors = options.forcedColors;
          yield this._delegate.updateEmulateMedia();
          yield this._doSlowMo();
        });
      }
      setViewportSize(viewportSize) {
        return __async(this, null, function* () {
          this._state.emulatedSize = {
            viewport: __spreadValues({}, viewportSize),
            screen: __spreadValues({}, viewportSize)
          };
          yield this._delegate.setEmulatedSize(this._state.emulatedSize);
          yield this._doSlowMo();
        });
      }
      viewportSize() {
        var _this$_state$emulated;
        return ((_this$_state$emulated = this._state.emulatedSize) === null || _this$_state$emulated === void 0 ? void 0 : _this$_state$emulated.viewport) || null;
      }
      bringToFront() {
        return __async(this, null, function* () {
          yield this._delegate.bringToFront();
        });
      }
      addInitScript(source) {
        return __async(this, null, function* () {
          this.initScripts.push(source);
          yield this._delegate.addInitScript(source);
        });
      }
      removeInitScripts() {
        return __async(this, null, function* () {
          this.initScripts.splice(0, this.initScripts.length);
          yield this._delegate.removeInitScripts();
        });
      }
      _needsRequestInterception() {
        return !!this._clientRequestInterceptor || !!this._serverRequestInterceptor || !!this._browserContext._requestInterceptor;
      }
      setClientRequestInterceptor(handler) {
        return __async(this, null, function* () {
          this._clientRequestInterceptor = handler;
          yield this._delegate.updateRequestInterception();
        });
      }
      _setServerRequestInterceptor(handler) {
        return __async(this, null, function* () {
          this._serverRequestInterceptor = handler;
          yield this._delegate.updateRequestInterception();
        });
      }
      _requestStarted(request, routeDelegate) {
        const route = new network.Route(request, routeDelegate);
        if (this._serverRequestInterceptor) {
          this._serverRequestInterceptor(route, request);
          return;
        }
        if (this._clientRequestInterceptor) {
          this._clientRequestInterceptor(route, request);
          return;
        }
        if (this._browserContext._requestInterceptor) {
          this._browserContext._requestInterceptor(route, request);
          return;
        }
        route.continue();
      }
      expectScreenshot(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const locator = options.locator;
          const rafrafScreenshot = locator ? (progress, timeout) => __async(this, null, function* () {
            return yield locator.frame.rafrafTimeoutScreenshotElementWithProgress(progress, locator.selector, timeout, options.screenshotOptions || {});
          }) : (progress, timeout) => __async(this, null, function* () {
            yield this.mainFrame().rafrafTimeout(timeout);
            return yield this._screenshotter.screenshotPage(progress, options.screenshotOptions || {});
          });
          const comparator = (0, _comparators.getComparator)("image/png");
          const controller = new _progress.ProgressController(metadata, this);
          if (!options.expected && options.isNot)
            return {
              errorMessage: '"not" matcher requires expected result'
            };
          let intermediateResult = void 0;
          const areEqualScreenshots = (actual, expected, previous) => {
            const comparatorResult = actual && expected ? comparator(actual, expected, options.comparatorOptions) : void 0;
            if (comparatorResult !== void 0 && !!comparatorResult === !!options.isNot)
              return true;
            if (comparatorResult)
              intermediateResult = {
                errorMessage: comparatorResult.errorMessage,
                diff: comparatorResult.diff,
                actual,
                previous
              };
            return false;
          };
          const callTimeout = this._timeoutSettings.timeout(options);
          return controller.run((progress) => __async(this, null, function* () {
            let actual;
            let previous;
            const pollIntervals = [0, 100, 250, 500];
            progress.log(`${metadata.apiName}${callTimeout ? ` with timeout ${callTimeout}ms` : ""}`);
            if (options.expected)
              progress.log(`  verifying given screenshot expectation`);
            else
              progress.log(`  generating new stable screenshot expectation`);
            let isFirstIteration = true;
            while (true) {
              var _pollIntervals$shift;
              progress.throwIfAborted();
              if (this.isClosed())
                throw new Error("The page has closed");
              const screenshotTimeout = (_pollIntervals$shift = pollIntervals.shift()) !== null && _pollIntervals$shift !== void 0 ? _pollIntervals$shift : 1e3;
              if (screenshotTimeout)
                progress.log(`waiting ${screenshotTimeout}ms before taking screenshot`);
              previous = actual;
              actual = yield rafrafScreenshot(progress, screenshotTimeout).catch((e) => {
                progress.log(`failed to take screenshot - ` + e.message);
                return void 0;
              });
              if (!actual)
                continue;
              const expectation = options.expected && isFirstIteration ? options.expected : previous;
              if (areEqualScreenshots(actual, expectation, previous))
                break;
              if (intermediateResult)
                progress.log(intermediateResult.errorMessage);
              isFirstIteration = false;
            }
            if (!isFirstIteration)
              progress.log(`captured a stable screenshot`);
            if (!options.expected)
              return {
                actual
              };
            if (isFirstIteration) {
              progress.log(`screenshot matched expectation`);
              return {};
            }
            if (areEqualScreenshots(actual, options.expected, previous)) {
              progress.log(`screenshot matched expectation`);
              return {};
            }
            throw new Error(intermediateResult.errorMessage);
          }), callTimeout).catch((e) => {
            var _intermediateResult$e, _intermediateResult;
            if (js.isJavaScriptErrorInEvaluate(e) || (0, _selectorParser.isInvalidSelectorError)(e))
              throw e;
            return __spreadProps(__spreadValues({
              log: e.message ? [...metadata.log, e.message] : metadata.log
            }, intermediateResult), {
              errorMessage: (_intermediateResult$e = (_intermediateResult = intermediateResult) === null || _intermediateResult === void 0 ? void 0 : _intermediateResult.errorMessage) !== null && _intermediateResult$e !== void 0 ? _intermediateResult$e : e.message
            });
          });
        });
      }
      screenshot(_0) {
        return __async(this, arguments, function* (metadata, options = {}) {
          const controller = new _progress.ProgressController(metadata, this);
          return controller.run((progress) => this._screenshotter.screenshotPage(progress, options), this._timeoutSettings.timeout(options));
        });
      }
      close(metadata, options) {
        return __async(this, null, function* () {
          if (this._closedState === "closed")
            return;
          const runBeforeUnload = !!options && !!options.runBeforeUnload;
          if (this._closedState !== "closing") {
            this._closedState = "closing";
            (0, _utils.assert)(!this._disconnected, "Target closed");
            yield this._delegate.closePage(runBeforeUnload).catch((e) => _debugLogger.debugLogger.log("error", e));
          }
          if (!runBeforeUnload)
            yield this._closedPromise;
          if (this._ownedContext)
            yield this._ownedContext.close(metadata);
        });
      }
      _setIsError(error) {
        this._pageIsError = error;
        if (!this._frameManager.mainFrame())
          this._frameManager.frameAttached("<dummy>", null);
      }
      isClosed() {
        return this._closedState === "closed";
      }
      _addWorker(workerId, worker) {
        this._workers.set(workerId, worker);
        this.emit(Page.Events.Worker, worker);
      }
      _removeWorker(workerId) {
        const worker = this._workers.get(workerId);
        if (!worker)
          return;
        worker.didClose();
        this._workers.delete(workerId);
      }
      _clearWorkers() {
        for (const [workerId, worker] of this._workers) {
          worker.didClose();
          this._workers.delete(workerId);
        }
      }
      setFileChooserIntercepted(enabled) {
        return __async(this, null, function* () {
          yield this._delegate.setFileChooserIntercepted(enabled);
        });
      }
      frameNavigatedToNewDocument(frame) {
        this.emit(Page.Events.InternalFrameNavigatedToNewDocument, frame);
        const url = frame.url();
        if (!url.startsWith("http"))
          return;
        const purl = network.parsedURL(url);
        if (purl)
          this._browserContext.addVisitedOrigin(purl.origin);
      }
      allBindings() {
        return [...this._browserContext._pageBindings.values(), ...this._pageBindings.values()];
      }
      getBinding(name) {
        return this._pageBindings.get(name) || this._browserContext._pageBindings.get(name);
      }
      setScreencastOptions(options) {
        this._delegate.setScreencastOptions(options).catch((e) => _debugLogger.debugLogger.log("error", e));
        this._frameThrottler.setEnabled(!!options);
      }
      throttleScreencastFrameAck(ack) {
        this._frameThrottler.ack(ack);
      }
      temporarlyDisableTracingScreencastThrottling() {
        this._frameThrottler.recharge();
      }
      firePageError(error) {
        this.emit(Page.Events.PageError, error);
      }
      parseSelector(selector, options) {
        const strict = typeof (options === null || options === void 0 ? void 0 : options.strict) === "boolean" ? options.strict : !!this.context()._options.strictSelectors;
        return this.selectors.parseSelector(selector, strict);
      }
      hideHighlight() {
        return __async(this, null, function* () {
          yield Promise.all(this.frames().map((frame) => frame.hideHighlight().catch(() => {
          })));
        });
      }
      markAsServerSideOnly() {
        this._isServerSideOnly = true;
      }
    };
    exports2.Page = Page;
    Page.Events = {
      Close: "close",
      Crash: "crash",
      Console: "console",
      Dialog: "dialog",
      Download: "download",
      FileChooser: "filechooser",
      DOMContentLoaded: "domcontentloaded",
      PageError: "pageerror",
      FrameAttached: "frameattached",
      FrameDetached: "framedetached",
      InternalFrameNavigatedToNewDocument: "internalframenavigatedtonewdocument",
      Load: "load",
      ScreencastFrame: "screencastframe",
      Video: "video",
      WebSocket: "websocket",
      Worker: "worker"
    };
    var Worker = class extends _instrumentation.SdkObject {
      constructor(parent, url) {
        super(parent, "worker");
        this._url = void 0;
        this._executionContextPromise = void 0;
        this._executionContextCallback = void 0;
        this._existingExecutionContext = null;
        this._url = url;
        this._executionContextCallback = () => {
        };
        this._executionContextPromise = new Promise((x) => this._executionContextCallback = x);
      }
      _createExecutionContext(delegate) {
        this._existingExecutionContext = new js.ExecutionContext(this, delegate);
        this._executionContextCallback(this._existingExecutionContext);
      }
      url() {
        return this._url;
      }
      didClose() {
        if (this._existingExecutionContext)
          this._existingExecutionContext.contextDestroyed(new Error("Worker was closed"));
        this.emit(Worker.Events.Close, this);
      }
      evaluateExpression(expression, isFunction, arg) {
        return __async(this, null, function* () {
          return js.evaluateExpression(yield this._executionContextPromise, true, expression, isFunction, arg);
        });
      }
      evaluateExpressionHandle(expression, isFunction, arg) {
        return __async(this, null, function* () {
          return js.evaluateExpression(yield this._executionContextPromise, false, expression, isFunction, arg);
        });
      }
    };
    exports2.Worker = Worker;
    Worker.Events = {
      Close: "close"
    };
    var PageBinding = class {
      constructor(name, playwrightFunction, needsHandle) {
        this.name = void 0;
        this.playwrightFunction = void 0;
        this.source = void 0;
        this.needsHandle = void 0;
        this.name = name;
        this.playwrightFunction = playwrightFunction;
        this.source = `(${addPageBinding.toString()})(${JSON.stringify(name)}, ${needsHandle})`;
        this.needsHandle = needsHandle;
      }
      static dispatch(page, payload, context) {
        return __async(this, null, function* () {
          const {
            name,
            seq,
            args
          } = JSON.parse(payload);
          try {
            (0, _utils.assert)(context.world);
            const binding = page.getBinding(name);
            let result;
            if (binding.needsHandle) {
              const handle = yield context.evaluateHandle(takeHandle, {
                name,
                seq
              }).catch((e) => null);
              result = yield binding.playwrightFunction({
                frame: context.frame,
                page,
                context: page._browserContext
              }, handle);
            } else {
              result = yield binding.playwrightFunction({
                frame: context.frame,
                page,
                context: page._browserContext
              }, ...args);
            }
            context.evaluate(deliverResult, {
              name,
              seq,
              result
            }).catch((e) => _debugLogger.debugLogger.log("error", e));
          } catch (error) {
            if ((0, _utils.isError)(error))
              context.evaluate(deliverError, {
                name,
                seq,
                message: error.message,
                stack: error.stack
              }).catch((e) => _debugLogger.debugLogger.log("error", e));
            else
              context.evaluate(deliverErrorValue, {
                name,
                seq,
                error
              }).catch((e) => _debugLogger.debugLogger.log("error", e));
          }
          function takeHandle(arg) {
            const handle = globalThis[arg.name]["handles"].get(arg.seq);
            globalThis[arg.name]["handles"].delete(arg.seq);
            return handle;
          }
          function deliverResult(arg) {
            globalThis[arg.name]["callbacks"].get(arg.seq).resolve(arg.result);
            globalThis[arg.name]["callbacks"].delete(arg.seq);
          }
          function deliverError(arg) {
            const error = new Error(arg.message);
            error.stack = arg.stack;
            globalThis[arg.name]["callbacks"].get(arg.seq).reject(error);
            globalThis[arg.name]["callbacks"].delete(arg.seq);
          }
          function deliverErrorValue(arg) {
            globalThis[arg.name]["callbacks"].get(arg.seq).reject(arg.error);
            globalThis[arg.name]["callbacks"].delete(arg.seq);
          }
        });
      }
    };
    exports2.PageBinding = PageBinding;
    function addPageBinding(bindingName, needsHandle) {
      const binding = globalThis[bindingName];
      if (binding.__installed)
        return;
      globalThis[bindingName] = (...args) => {
        const me = globalThis[bindingName];
        if (needsHandle && args.slice(1).some((arg) => arg !== void 0))
          throw new Error(`exposeBindingHandle supports a single argument, ${args.length} received`);
        let callbacks = me["callbacks"];
        if (!callbacks) {
          callbacks = /* @__PURE__ */ new Map();
          me["callbacks"] = callbacks;
        }
        const seq = (me["lastSeq"] || 0) + 1;
        me["lastSeq"] = seq;
        let handles = me["handles"];
        if (!handles) {
          handles = /* @__PURE__ */ new Map();
          me["handles"] = handles;
        }
        const promise = new Promise((resolve, reject) => callbacks.set(seq, {
          resolve,
          reject
        }));
        if (needsHandle) {
          handles.set(seq, args[0]);
          binding(JSON.stringify({
            name: bindingName,
            seq
          }));
        } else {
          binding(JSON.stringify({
            name: bindingName,
            seq,
            args
          }));
        }
        return promise;
      };
      globalThis[bindingName].__installed = true;
    }
    var FrameThrottler = class {
      constructor(nonThrottledFrames, interval) {
        this._acks = [];
        this._interval = void 0;
        this._nonThrottledFrames = void 0;
        this._budget = void 0;
        this._intervalId = void 0;
        this._nonThrottledFrames = nonThrottledFrames;
        this._budget = nonThrottledFrames;
        this._interval = interval;
      }
      setEnabled(enabled) {
        if (enabled) {
          if (this._intervalId)
            clearInterval(this._intervalId);
          this._intervalId = setInterval(() => this._tick(), this._interval);
        } else if (this._intervalId) {
          clearInterval(this._intervalId);
          this._intervalId = void 0;
        }
      }
      recharge() {
        for (const ack of this._acks)
          ack();
        this._acks = [];
        this._budget = this._nonThrottledFrames;
      }
      ack(ack) {
        if (!this._intervalId) {
          ack();
          return;
        }
        if (--this._budget > 0) {
          ack();
          return;
        }
        this._acks.push(ack);
      }
      _tick() {
        var _this$_acks$shift;
        (_this$_acks$shift = this._acks.shift()) === null || _this$_acks$shift === void 0 ? void 0 : _this$_acks$shift();
      }
    };
  }
});

// node_modules/playwright-core/lib/protocol/channels.js
var require_channels = __commonJS({
  "node_modules/playwright-core/lib/protocol/channels.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.pausesBeforeInputActions = exports2.commandsWithTracingSnapshots = void 0;
    var commandsWithTracingSnapshots = /* @__PURE__ */ new Set(["EventTarget.waitForEventInfo", "BrowserContext.waitForEventInfo", "Page.waitForEventInfo", "WebSocket.waitForEventInfo", "ElectronApplication.waitForEventInfo", "AndroidDevice.waitForEventInfo", "Page.goBack", "Page.goForward", "Page.reload", "Page.expectScreenshot", "Page.screenshot", "Page.setViewportSize", "Page.keyboardDown", "Page.keyboardUp", "Page.keyboardInsertText", "Page.keyboardType", "Page.keyboardPress", "Page.mouseMove", "Page.mouseDown", "Page.mouseUp", "Page.mouseClick", "Page.mouseWheel", "Page.touchscreenTap", "Frame.evalOnSelector", "Frame.evalOnSelectorAll", "Frame.addScriptTag", "Frame.addStyleTag", "Frame.check", "Frame.click", "Frame.dragAndDrop", "Frame.dblclick", "Frame.dispatchEvent", "Frame.evaluateExpression", "Frame.evaluateExpressionHandle", "Frame.fill", "Frame.focus", "Frame.getAttribute", "Frame.goto", "Frame.hover", "Frame.innerHTML", "Frame.innerText", "Frame.inputValue", "Frame.isChecked", "Frame.isDisabled", "Frame.isEnabled", "Frame.isHidden", "Frame.isVisible", "Frame.isEditable", "Frame.press", "Frame.selectOption", "Frame.setContent", "Frame.setInputFiles", "Frame.setInputFilePaths", "Frame.tap", "Frame.textContent", "Frame.type", "Frame.uncheck", "Frame.waitForTimeout", "Frame.waitForFunction", "Frame.waitForSelector", "Frame.expect", "JSHandle.evaluateExpression", "ElementHandle.evaluateExpression", "JSHandle.evaluateExpressionHandle", "ElementHandle.evaluateExpressionHandle", "ElementHandle.evalOnSelector", "ElementHandle.evalOnSelectorAll", "ElementHandle.check", "ElementHandle.click", "ElementHandle.dblclick", "ElementHandle.dispatchEvent", "ElementHandle.fill", "ElementHandle.hover", "ElementHandle.innerHTML", "ElementHandle.innerText", "ElementHandle.inputValue", "ElementHandle.isChecked", "ElementHandle.isDisabled", "ElementHandle.isEditable", "ElementHandle.isEnabled", "ElementHandle.isHidden", "ElementHandle.isVisible", "ElementHandle.press", "ElementHandle.screenshot", "ElementHandle.scrollIntoViewIfNeeded", "ElementHandle.selectOption", "ElementHandle.selectText", "ElementHandle.setInputFiles", "ElementHandle.setInputFilePaths", "ElementHandle.tap", "ElementHandle.textContent", "ElementHandle.type", "ElementHandle.uncheck", "ElementHandle.waitForElementState", "ElementHandle.waitForSelector"]);
    exports2.commandsWithTracingSnapshots = commandsWithTracingSnapshots;
    var pausesBeforeInputActions = /* @__PURE__ */ new Set(["Frame.check", "Frame.click", "Frame.dragAndDrop", "Frame.dblclick", "Frame.fill", "Frame.hover", "Frame.press", "Frame.selectOption", "Frame.setInputFiles", "Frame.setInputFilePaths", "Frame.tap", "Frame.type", "Frame.uncheck", "ElementHandle.check", "ElementHandle.click", "ElementHandle.dblclick", "ElementHandle.fill", "ElementHandle.hover", "ElementHandle.press", "ElementHandle.selectOption", "ElementHandle.setInputFiles", "ElementHandle.setInputFilePaths", "ElementHandle.tap", "ElementHandle.type", "ElementHandle.uncheck"]);
    exports2.pausesBeforeInputActions = pausesBeforeInputActions;
  }
});

// node_modules/playwright-core/lib/server/debugger.js
var require_debugger = __commonJS({
  "node_modules/playwright-core/lib/server/debugger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Debugger = void 0;
    var _events = require("events");
    var _utils = require_utils();
    var _channels = require_channels();
    var symbol = Symbol("Debugger");
    var Debugger = class extends _events.EventEmitter {
      constructor(context) {
        super();
        this._pauseOnNextStatement = false;
        this._pausedCallsMetadata = /* @__PURE__ */ new Map();
        this._enabled = void 0;
        this._context = void 0;
        this._muted = false;
        this._context = context;
        this._context[symbol] = this;
        this._enabled = (0, _utils.debugMode)() === "inspector";
        if (this._enabled)
          this.pauseOnNextStatement();
      }
      static lookup(context) {
        if (!context)
          return;
        return context[symbol];
      }
      setMuted(muted) {
        return __async(this, null, function* () {
          this._muted = muted;
        });
      }
      onBeforeCall(sdkObject, metadata) {
        return __async(this, null, function* () {
          if (this._muted)
            return;
          if (shouldPauseOnCall(sdkObject, metadata) || this._pauseOnNextStatement && shouldPauseBeforeStep(metadata))
            yield this.pause(sdkObject, metadata);
        });
      }
      onBeforeInputAction(sdkObject, metadata) {
        return __async(this, null, function* () {
          if (this._muted)
            return;
          if (this._enabled && this._pauseOnNextStatement)
            yield this.pause(sdkObject, metadata);
        });
      }
      pause(sdkObject, metadata) {
        return __async(this, null, function* () {
          if (this._muted)
            return;
          this._enabled = true;
          metadata.pauseStartTime = (0, _utils.monotonicTime)();
          const result = new Promise((resolve) => {
            this._pausedCallsMetadata.set(metadata, {
              resolve,
              sdkObject
            });
          });
          this.emit(Debugger.Events.PausedStateChanged);
          return result;
        });
      }
      resume(step) {
        this._pauseOnNextStatement = step;
        const endTime = (0, _utils.monotonicTime)();
        for (const [metadata, {
          resolve
        }] of this._pausedCallsMetadata) {
          metadata.pauseEndTime = endTime;
          resolve();
        }
        this._pausedCallsMetadata.clear();
        this.emit(Debugger.Events.PausedStateChanged);
      }
      pauseOnNextStatement() {
        this._pauseOnNextStatement = true;
      }
      isPaused(metadata) {
        if (metadata)
          return this._pausedCallsMetadata.has(metadata);
        return !!this._pausedCallsMetadata.size;
      }
      pausedDetails() {
        const result = [];
        for (const [metadata, {
          sdkObject
        }] of this._pausedCallsMetadata)
          result.push({
            metadata,
            sdkObject
          });
        return result;
      }
    };
    exports2.Debugger = Debugger;
    Debugger.Events = {
      PausedStateChanged: "pausedstatechanged"
    };
    function shouldPauseOnCall(sdkObject, metadata) {
      var _sdkObject$attributio;
      if (!((_sdkObject$attributio = sdkObject.attribution.browser) !== null && _sdkObject$attributio !== void 0 && _sdkObject$attributio.options.headful) && !(0, _utils.isUnderTest)())
        return false;
      return metadata.method === "pause";
    }
    function shouldPauseBeforeStep(metadata) {
      if (metadata.method === "close")
        return true;
      if (metadata.method === "waitForSelector" || metadata.method === "waitForEventInfo")
        return false;
      const step = metadata.type + "." + metadata.method;
      return _channels.commandsWithTracingSnapshots.has(step) && !_channels.pausesBeforeInputActions.has(metadata.type + "." + metadata.method);
    }
  }
});

// node_modules/yazl/index.js
var require_yazl = __commonJS({
  "node_modules/yazl/index.js"(exports2) {
    var fs = require("fs");
    var Transform = require("stream").Transform;
    var PassThrough = require("stream").PassThrough;
    var zlib = require("zlib");
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var crc32 = require_buffer_crc32();
    exports2.ZipFile = ZipFile;
    exports2.dateToDosDateTime = dateToDosDateTime;
    util.inherits(ZipFile, EventEmitter);
    function ZipFile() {
      this.outputStream = new PassThrough();
      this.entries = [];
      this.outputStreamCursor = 0;
      this.ended = false;
      this.allDone = false;
      this.forceZip64Eocd = false;
    }
    ZipFile.prototype.addFile = function(realPath, metadataPath, options) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, false);
      if (options == null)
        options = {};
      var entry = new Entry(metadataPath, false, options);
      self2.entries.push(entry);
      fs.stat(realPath, function(err, stats) {
        if (err)
          return self2.emit("error", err);
        if (!stats.isFile())
          return self2.emit("error", new Error("not a file: " + realPath));
        entry.uncompressedSize = stats.size;
        if (options.mtime == null)
          entry.setLastModDate(stats.mtime);
        if (options.mode == null)
          entry.setFileAttributesMode(stats.mode);
        entry.setFileDataPumpFunction(function() {
          var readStream = fs.createReadStream(realPath);
          entry.state = Entry.FILE_DATA_IN_PROGRESS;
          readStream.on("error", function(err2) {
            self2.emit("error", err2);
          });
          pumpFileDataReadStream(self2, entry, readStream);
        });
        pumpEntries(self2);
      });
    };
    ZipFile.prototype.addReadStream = function(readStream, metadataPath, options) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, false);
      if (options == null)
        options = {};
      var entry = new Entry(metadataPath, false, options);
      self2.entries.push(entry);
      entry.setFileDataPumpFunction(function() {
        entry.state = Entry.FILE_DATA_IN_PROGRESS;
        pumpFileDataReadStream(self2, entry, readStream);
      });
      pumpEntries(self2);
    };
    ZipFile.prototype.addBuffer = function(buffer, metadataPath, options) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, false);
      if (buffer.length > 1073741823)
        throw new Error("buffer too large: " + buffer.length + " > " + 1073741823);
      if (options == null)
        options = {};
      if (options.size != null)
        throw new Error("options.size not allowed");
      var entry = new Entry(metadataPath, false, options);
      entry.uncompressedSize = buffer.length;
      entry.crc32 = crc32.unsigned(buffer);
      entry.crcAndFileSizeKnown = true;
      self2.entries.push(entry);
      if (!entry.compress) {
        setCompressedBuffer(buffer);
      } else {
        zlib.deflateRaw(buffer, function(err, compressedBuffer) {
          setCompressedBuffer(compressedBuffer);
        });
      }
      function setCompressedBuffer(compressedBuffer) {
        entry.compressedSize = compressedBuffer.length;
        entry.setFileDataPumpFunction(function() {
          writeToOutputStream(self2, compressedBuffer);
          writeToOutputStream(self2, entry.getDataDescriptor());
          entry.state = Entry.FILE_DATA_DONE;
          setImmediate(function() {
            pumpEntries(self2);
          });
        });
        pumpEntries(self2);
      }
    };
    ZipFile.prototype.addEmptyDirectory = function(metadataPath, options) {
      var self2 = this;
      metadataPath = validateMetadataPath(metadataPath, true);
      if (options == null)
        options = {};
      if (options.size != null)
        throw new Error("options.size not allowed");
      if (options.compress != null)
        throw new Error("options.compress not allowed");
      var entry = new Entry(metadataPath, true, options);
      self2.entries.push(entry);
      entry.setFileDataPumpFunction(function() {
        writeToOutputStream(self2, entry.getDataDescriptor());
        entry.state = Entry.FILE_DATA_DONE;
        pumpEntries(self2);
      });
      pumpEntries(self2);
    };
    var eocdrSignatureBuffer = bufferFrom([80, 75, 5, 6]);
    ZipFile.prototype.end = function(options, finalSizeCallback) {
      if (typeof options === "function") {
        finalSizeCallback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (this.ended)
        return;
      this.ended = true;
      this.finalSizeCallback = finalSizeCallback;
      this.forceZip64Eocd = !!options.forceZip64Format;
      if (options.comment) {
        if (typeof options.comment === "string") {
          this.comment = encodeCp437(options.comment);
        } else {
          this.comment = options.comment;
        }
        if (this.comment.length > 65535)
          throw new Error("comment is too large");
        if (bufferIncludes(this.comment, eocdrSignatureBuffer))
          throw new Error("comment contains end of central directory record signature");
      } else {
        this.comment = EMPTY_BUFFER;
      }
      pumpEntries(this);
    };
    function writeToOutputStream(self2, buffer) {
      self2.outputStream.write(buffer);
      self2.outputStreamCursor += buffer.length;
    }
    function pumpFileDataReadStream(self2, entry, readStream) {
      var crc32Watcher = new Crc32Watcher();
      var uncompressedSizeCounter = new ByteCounter();
      var compressor = entry.compress ? new zlib.DeflateRaw() : new PassThrough();
      var compressedSizeCounter = new ByteCounter();
      readStream.pipe(crc32Watcher).pipe(uncompressedSizeCounter).pipe(compressor).pipe(compressedSizeCounter).pipe(self2.outputStream, { end: false });
      compressedSizeCounter.on("end", function() {
        entry.crc32 = crc32Watcher.crc32;
        if (entry.uncompressedSize == null) {
          entry.uncompressedSize = uncompressedSizeCounter.byteCount;
        } else {
          if (entry.uncompressedSize !== uncompressedSizeCounter.byteCount)
            return self2.emit("error", new Error("file data stream has unexpected number of bytes"));
        }
        entry.compressedSize = compressedSizeCounter.byteCount;
        self2.outputStreamCursor += entry.compressedSize;
        writeToOutputStream(self2, entry.getDataDescriptor());
        entry.state = Entry.FILE_DATA_DONE;
        pumpEntries(self2);
      });
    }
    function pumpEntries(self2) {
      if (self2.allDone)
        return;
      if (self2.ended && self2.finalSizeCallback != null) {
        var finalSize = calculateFinalSize(self2);
        if (finalSize != null) {
          self2.finalSizeCallback(finalSize);
          self2.finalSizeCallback = null;
        }
      }
      var entry = getFirstNotDoneEntry();
      function getFirstNotDoneEntry() {
        for (var i = 0; i < self2.entries.length; i++) {
          var entry2 = self2.entries[i];
          if (entry2.state < Entry.FILE_DATA_DONE)
            return entry2;
        }
        return null;
      }
      if (entry != null) {
        if (entry.state < Entry.READY_TO_PUMP_FILE_DATA)
          return;
        if (entry.state === Entry.FILE_DATA_IN_PROGRESS)
          return;
        entry.relativeOffsetOfLocalHeader = self2.outputStreamCursor;
        var localFileHeader = entry.getLocalFileHeader();
        writeToOutputStream(self2, localFileHeader);
        entry.doFileDataPump();
      } else {
        if (self2.ended) {
          self2.offsetOfStartOfCentralDirectory = self2.outputStreamCursor;
          self2.entries.forEach(function(entry2) {
            var centralDirectoryRecord = entry2.getCentralDirectoryRecord();
            writeToOutputStream(self2, centralDirectoryRecord);
          });
          writeToOutputStream(self2, getEndOfCentralDirectoryRecord(self2));
          self2.outputStream.end();
          self2.allDone = true;
        }
      }
    }
    function calculateFinalSize(self2) {
      var pretendOutputCursor = 0;
      var centralDirectorySize = 0;
      for (var i = 0; i < self2.entries.length; i++) {
        var entry = self2.entries[i];
        if (entry.compress)
          return -1;
        if (entry.state >= Entry.READY_TO_PUMP_FILE_DATA) {
          if (entry.uncompressedSize == null)
            return -1;
        } else {
          if (entry.uncompressedSize == null)
            return null;
        }
        entry.relativeOffsetOfLocalHeader = pretendOutputCursor;
        var useZip64Format = entry.useZip64Format();
        pretendOutputCursor += LOCAL_FILE_HEADER_FIXED_SIZE + entry.utf8FileName.length;
        pretendOutputCursor += entry.uncompressedSize;
        if (!entry.crcAndFileSizeKnown) {
          if (useZip64Format) {
            pretendOutputCursor += ZIP64_DATA_DESCRIPTOR_SIZE;
          } else {
            pretendOutputCursor += DATA_DESCRIPTOR_SIZE;
          }
        }
        centralDirectorySize += CENTRAL_DIRECTORY_RECORD_FIXED_SIZE + entry.utf8FileName.length + entry.fileComment.length;
        if (useZip64Format) {
          centralDirectorySize += ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE;
        }
      }
      var endOfCentralDirectorySize = 0;
      if (self2.forceZip64Eocd || self2.entries.length >= 65535 || centralDirectorySize >= 65535 || pretendOutputCursor >= 4294967295) {
        endOfCentralDirectorySize += ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE;
      }
      endOfCentralDirectorySize += END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length;
      return pretendOutputCursor + centralDirectorySize + endOfCentralDirectorySize;
    }
    var ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 56;
    var ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE = 20;
    var END_OF_CENTRAL_DIRECTORY_RECORD_SIZE = 22;
    function getEndOfCentralDirectoryRecord(self2, actuallyJustTellMeHowLongItWouldBe) {
      var needZip64Format = false;
      var normalEntriesLength = self2.entries.length;
      if (self2.forceZip64Eocd || self2.entries.length >= 65535) {
        normalEntriesLength = 65535;
        needZip64Format = true;
      }
      var sizeOfCentralDirectory = self2.outputStreamCursor - self2.offsetOfStartOfCentralDirectory;
      var normalSizeOfCentralDirectory = sizeOfCentralDirectory;
      if (self2.forceZip64Eocd || sizeOfCentralDirectory >= 4294967295) {
        normalSizeOfCentralDirectory = 4294967295;
        needZip64Format = true;
      }
      var normalOffsetOfStartOfCentralDirectory = self2.offsetOfStartOfCentralDirectory;
      if (self2.forceZip64Eocd || self2.offsetOfStartOfCentralDirectory >= 4294967295) {
        normalOffsetOfStartOfCentralDirectory = 4294967295;
        needZip64Format = true;
      }
      if (actuallyJustTellMeHowLongItWouldBe) {
        if (needZip64Format) {
          return ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE + END_OF_CENTRAL_DIRECTORY_RECORD_SIZE;
        } else {
          return END_OF_CENTRAL_DIRECTORY_RECORD_SIZE;
        }
      }
      var eocdrBuffer = bufferAlloc(END_OF_CENTRAL_DIRECTORY_RECORD_SIZE + self2.comment.length);
      eocdrBuffer.writeUInt32LE(101010256, 0);
      eocdrBuffer.writeUInt16LE(0, 4);
      eocdrBuffer.writeUInt16LE(0, 6);
      eocdrBuffer.writeUInt16LE(normalEntriesLength, 8);
      eocdrBuffer.writeUInt16LE(normalEntriesLength, 10);
      eocdrBuffer.writeUInt32LE(normalSizeOfCentralDirectory, 12);
      eocdrBuffer.writeUInt32LE(normalOffsetOfStartOfCentralDirectory, 16);
      eocdrBuffer.writeUInt16LE(self2.comment.length, 20);
      self2.comment.copy(eocdrBuffer, 22);
      if (!needZip64Format)
        return eocdrBuffer;
      var zip64EocdrBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE);
      zip64EocdrBuffer.writeUInt32LE(101075792, 0);
      writeUInt64LE(zip64EocdrBuffer, ZIP64_END_OF_CENTRAL_DIRECTORY_RECORD_SIZE - 12, 4);
      zip64EocdrBuffer.writeUInt16LE(VERSION_MADE_BY, 12);
      zip64EocdrBuffer.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_ZIP64, 14);
      zip64EocdrBuffer.writeUInt32LE(0, 16);
      zip64EocdrBuffer.writeUInt32LE(0, 20);
      writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 24);
      writeUInt64LE(zip64EocdrBuffer, self2.entries.length, 32);
      writeUInt64LE(zip64EocdrBuffer, sizeOfCentralDirectory, 40);
      writeUInt64LE(zip64EocdrBuffer, self2.offsetOfStartOfCentralDirectory, 48);
      var zip64EocdlBuffer = bufferAlloc(ZIP64_END_OF_CENTRAL_DIRECTORY_LOCATOR_SIZE);
      zip64EocdlBuffer.writeUInt32LE(117853008, 0);
      zip64EocdlBuffer.writeUInt32LE(0, 4);
      writeUInt64LE(zip64EocdlBuffer, self2.outputStreamCursor, 8);
      zip64EocdlBuffer.writeUInt32LE(1, 16);
      return Buffer.concat([
        zip64EocdrBuffer,
        zip64EocdlBuffer,
        eocdrBuffer
      ]);
    }
    function validateMetadataPath(metadataPath, isDirectory) {
      if (metadataPath === "")
        throw new Error("empty metadataPath");
      metadataPath = metadataPath.replace(/\\/g, "/");
      if (/^[a-zA-Z]:/.test(metadataPath) || /^\//.test(metadataPath))
        throw new Error("absolute path: " + metadataPath);
      if (metadataPath.split("/").indexOf("..") !== -1)
        throw new Error("invalid relative path: " + metadataPath);
      var looksLikeDirectory = /\/$/.test(metadataPath);
      if (isDirectory) {
        if (!looksLikeDirectory)
          metadataPath += "/";
      } else {
        if (looksLikeDirectory)
          throw new Error("file path cannot end with '/': " + metadataPath);
      }
      return metadataPath;
    }
    var EMPTY_BUFFER = bufferAlloc(0);
    function Entry(metadataPath, isDirectory, options) {
      this.utf8FileName = bufferFrom(metadataPath);
      if (this.utf8FileName.length > 65535)
        throw new Error("utf8 file name too long. " + utf8FileName.length + " > " + 65535);
      this.isDirectory = isDirectory;
      this.state = Entry.WAITING_FOR_METADATA;
      this.setLastModDate(options.mtime != null ? options.mtime : new Date());
      if (options.mode != null) {
        this.setFileAttributesMode(options.mode);
      } else {
        this.setFileAttributesMode(isDirectory ? 16893 : 33204);
      }
      if (isDirectory) {
        this.crcAndFileSizeKnown = true;
        this.crc32 = 0;
        this.uncompressedSize = 0;
        this.compressedSize = 0;
      } else {
        this.crcAndFileSizeKnown = false;
        this.crc32 = null;
        this.uncompressedSize = null;
        this.compressedSize = null;
        if (options.size != null)
          this.uncompressedSize = options.size;
      }
      if (isDirectory) {
        this.compress = false;
      } else {
        this.compress = true;
        if (options.compress != null)
          this.compress = !!options.compress;
      }
      this.forceZip64Format = !!options.forceZip64Format;
      if (options.fileComment) {
        if (typeof options.fileComment === "string") {
          this.fileComment = bufferFrom(options.fileComment, "utf-8");
        } else {
          this.fileComment = options.fileComment;
        }
        if (this.fileComment.length > 65535)
          throw new Error("fileComment is too large");
      } else {
        this.fileComment = EMPTY_BUFFER;
      }
    }
    Entry.WAITING_FOR_METADATA = 0;
    Entry.READY_TO_PUMP_FILE_DATA = 1;
    Entry.FILE_DATA_IN_PROGRESS = 2;
    Entry.FILE_DATA_DONE = 3;
    Entry.prototype.setLastModDate = function(date) {
      var dosDateTime = dateToDosDateTime(date);
      this.lastModFileTime = dosDateTime.time;
      this.lastModFileDate = dosDateTime.date;
    };
    Entry.prototype.setFileAttributesMode = function(mode) {
      if ((mode & 65535) !== mode)
        throw new Error("invalid mode. expected: 0 <= " + mode + " <= " + 65535);
      this.externalFileAttributes = mode << 16 >>> 0;
    };
    Entry.prototype.setFileDataPumpFunction = function(doFileDataPump) {
      this.doFileDataPump = doFileDataPump;
      this.state = Entry.READY_TO_PUMP_FILE_DATA;
    };
    Entry.prototype.useZip64Format = function() {
      return this.forceZip64Format || this.uncompressedSize != null && this.uncompressedSize > 4294967294 || this.compressedSize != null && this.compressedSize > 4294967294 || this.relativeOffsetOfLocalHeader != null && this.relativeOffsetOfLocalHeader > 4294967294;
    };
    var LOCAL_FILE_HEADER_FIXED_SIZE = 30;
    var VERSION_NEEDED_TO_EXTRACT_UTF8 = 20;
    var VERSION_NEEDED_TO_EXTRACT_ZIP64 = 45;
    var VERSION_MADE_BY = 3 << 8 | 63;
    var FILE_NAME_IS_UTF8 = 1 << 11;
    var UNKNOWN_CRC32_AND_FILE_SIZES = 1 << 3;
    Entry.prototype.getLocalFileHeader = function() {
      var crc322 = 0;
      var compressedSize = 0;
      var uncompressedSize = 0;
      if (this.crcAndFileSizeKnown) {
        crc322 = this.crc32;
        compressedSize = this.compressedSize;
        uncompressedSize = this.uncompressedSize;
      }
      var fixedSizeStuff = bufferAlloc(LOCAL_FILE_HEADER_FIXED_SIZE);
      var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
      if (!this.crcAndFileSizeKnown)
        generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
      fixedSizeStuff.writeUInt32LE(67324752, 0);
      fixedSizeStuff.writeUInt16LE(VERSION_NEEDED_TO_EXTRACT_UTF8, 4);
      fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 6);
      fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 8);
      fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 10);
      fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 12);
      fixedSizeStuff.writeUInt32LE(crc322, 14);
      fixedSizeStuff.writeUInt32LE(compressedSize, 18);
      fixedSizeStuff.writeUInt32LE(uncompressedSize, 22);
      fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 26);
      fixedSizeStuff.writeUInt16LE(0, 28);
      return Buffer.concat([
        fixedSizeStuff,
        this.utf8FileName
      ]);
    };
    var DATA_DESCRIPTOR_SIZE = 16;
    var ZIP64_DATA_DESCRIPTOR_SIZE = 24;
    Entry.prototype.getDataDescriptor = function() {
      if (this.crcAndFileSizeKnown) {
        return EMPTY_BUFFER;
      }
      if (!this.useZip64Format()) {
        var buffer = bufferAlloc(DATA_DESCRIPTOR_SIZE);
        buffer.writeUInt32LE(134695760, 0);
        buffer.writeUInt32LE(this.crc32, 4);
        buffer.writeUInt32LE(this.compressedSize, 8);
        buffer.writeUInt32LE(this.uncompressedSize, 12);
        return buffer;
      } else {
        var buffer = bufferAlloc(ZIP64_DATA_DESCRIPTOR_SIZE);
        buffer.writeUInt32LE(134695760, 0);
        buffer.writeUInt32LE(this.crc32, 4);
        writeUInt64LE(buffer, this.compressedSize, 8);
        writeUInt64LE(buffer, this.uncompressedSize, 16);
        return buffer;
      }
    };
    var CENTRAL_DIRECTORY_RECORD_FIXED_SIZE = 46;
    var ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE = 28;
    Entry.prototype.getCentralDirectoryRecord = function() {
      var fixedSizeStuff = bufferAlloc(CENTRAL_DIRECTORY_RECORD_FIXED_SIZE);
      var generalPurposeBitFlag = FILE_NAME_IS_UTF8;
      if (!this.crcAndFileSizeKnown)
        generalPurposeBitFlag |= UNKNOWN_CRC32_AND_FILE_SIZES;
      var normalCompressedSize = this.compressedSize;
      var normalUncompressedSize = this.uncompressedSize;
      var normalRelativeOffsetOfLocalHeader = this.relativeOffsetOfLocalHeader;
      var versionNeededToExtract;
      var zeiefBuffer;
      if (this.useZip64Format()) {
        normalCompressedSize = 4294967295;
        normalUncompressedSize = 4294967295;
        normalRelativeOffsetOfLocalHeader = 4294967295;
        versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_ZIP64;
        zeiefBuffer = bufferAlloc(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE);
        zeiefBuffer.writeUInt16LE(1, 0);
        zeiefBuffer.writeUInt16LE(ZIP64_EXTENDED_INFORMATION_EXTRA_FIELD_SIZE - 4, 2);
        writeUInt64LE(zeiefBuffer, this.uncompressedSize, 4);
        writeUInt64LE(zeiefBuffer, this.compressedSize, 12);
        writeUInt64LE(zeiefBuffer, this.relativeOffsetOfLocalHeader, 20);
      } else {
        versionNeededToExtract = VERSION_NEEDED_TO_EXTRACT_UTF8;
        zeiefBuffer = EMPTY_BUFFER;
      }
      fixedSizeStuff.writeUInt32LE(33639248, 0);
      fixedSizeStuff.writeUInt16LE(VERSION_MADE_BY, 4);
      fixedSizeStuff.writeUInt16LE(versionNeededToExtract, 6);
      fixedSizeStuff.writeUInt16LE(generalPurposeBitFlag, 8);
      fixedSizeStuff.writeUInt16LE(this.getCompressionMethod(), 10);
      fixedSizeStuff.writeUInt16LE(this.lastModFileTime, 12);
      fixedSizeStuff.writeUInt16LE(this.lastModFileDate, 14);
      fixedSizeStuff.writeUInt32LE(this.crc32, 16);
      fixedSizeStuff.writeUInt32LE(normalCompressedSize, 20);
      fixedSizeStuff.writeUInt32LE(normalUncompressedSize, 24);
      fixedSizeStuff.writeUInt16LE(this.utf8FileName.length, 28);
      fixedSizeStuff.writeUInt16LE(zeiefBuffer.length, 30);
      fixedSizeStuff.writeUInt16LE(this.fileComment.length, 32);
      fixedSizeStuff.writeUInt16LE(0, 34);
      fixedSizeStuff.writeUInt16LE(0, 36);
      fixedSizeStuff.writeUInt32LE(this.externalFileAttributes, 38);
      fixedSizeStuff.writeUInt32LE(normalRelativeOffsetOfLocalHeader, 42);
      return Buffer.concat([
        fixedSizeStuff,
        this.utf8FileName,
        zeiefBuffer,
        this.fileComment
      ]);
    };
    Entry.prototype.getCompressionMethod = function() {
      var NO_COMPRESSION = 0;
      var DEFLATE_COMPRESSION = 8;
      return this.compress ? DEFLATE_COMPRESSION : NO_COMPRESSION;
    };
    function dateToDosDateTime(jsDate) {
      var date = 0;
      date |= jsDate.getDate() & 31;
      date |= (jsDate.getMonth() + 1 & 15) << 5;
      date |= (jsDate.getFullYear() - 1980 & 127) << 9;
      var time = 0;
      time |= Math.floor(jsDate.getSeconds() / 2);
      time |= (jsDate.getMinutes() & 63) << 5;
      time |= (jsDate.getHours() & 31) << 11;
      return { date, time };
    }
    function writeUInt64LE(buffer, n, offset) {
      var high = Math.floor(n / 4294967296);
      var low = n % 4294967296;
      buffer.writeUInt32LE(low, offset);
      buffer.writeUInt32LE(high, offset + 4);
    }
    util.inherits(ByteCounter, Transform);
    function ByteCounter(options) {
      Transform.call(this, options);
      this.byteCount = 0;
    }
    ByteCounter.prototype._transform = function(chunk, encoding, cb) {
      this.byteCount += chunk.length;
      cb(null, chunk);
    };
    util.inherits(Crc32Watcher, Transform);
    function Crc32Watcher(options) {
      Transform.call(this, options);
      this.crc32 = 0;
    }
    Crc32Watcher.prototype._transform = function(chunk, encoding, cb) {
      this.crc32 = crc32.unsigned(chunk, this.crc32);
      cb(null, chunk);
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    if (cp437.length !== 256)
      throw new Error("assertion failure");
    var reverseCp437 = null;
    function encodeCp437(string) {
      if (/^[\x20-\x7e]*$/.test(string)) {
        return bufferFrom(string, "utf-8");
      }
      if (reverseCp437 == null) {
        reverseCp437 = {};
        for (var i = 0; i < cp437.length; i++) {
          reverseCp437[cp437[i]] = i;
        }
      }
      var result = bufferAlloc(string.length);
      for (var i = 0; i < string.length; i++) {
        var b = reverseCp437[string[i]];
        if (b == null)
          throw new Error("character not encodable in CP437: " + JSON.stringify(string[i]));
        result[i] = b;
      }
      return result;
    }
    function bufferAlloc(size) {
      bufferAlloc = modern;
      try {
        return bufferAlloc(size);
      } catch (e) {
        bufferAlloc = legacy;
        return bufferAlloc(size);
      }
      function modern(size2) {
        return Buffer.allocUnsafe(size2);
      }
      function legacy(size2) {
        return new Buffer(size2);
      }
    }
    function bufferFrom(something, encoding) {
      bufferFrom = modern;
      try {
        return bufferFrom(something, encoding);
      } catch (e) {
        bufferFrom = legacy;
        return bufferFrom(something, encoding);
      }
      function modern(something2, encoding2) {
        return Buffer.from(something2, encoding2);
      }
      function legacy(something2, encoding2) {
        return new Buffer(something2, encoding2);
      }
    }
    function bufferIncludes(buffer, content) {
      bufferIncludes = modern;
      try {
        return bufferIncludes(buffer, content);
      } catch (e) {
        bufferIncludes = legacy;
        return bufferIncludes(buffer, content);
      }
      function modern(buffer2, content2) {
        return buffer2.includes(content2);
      }
      function legacy(buffer2, content2) {
        for (var i = 0; i <= buffer2.length - content2.length; i++) {
          for (var j = 0; ; j++) {
            if (j === content2.length)
              return true;
            if (buffer2[i + j] !== content2[j])
              break;
          }
        }
        return false;
      }
    }
  }
});

// node_modules/playwright-core/lib/server/artifact.js
var require_artifact = __commonJS({
  "node_modules/playwright-core/lib/server/artifact.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Artifact = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var _utils = require_utils();
    var _manualPromise = require_manualPromise();
    var _instrumentation = require_instrumentation();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Artifact = class extends _instrumentation.SdkObject {
      constructor(parent, localPath, unaccessibleErrorMessage, cancelCallback) {
        super(parent, "artifact");
        this._localPath = void 0;
        this._unaccessibleErrorMessage = void 0;
        this._cancelCallback = void 0;
        this._finishedPromise = new _manualPromise.ManualPromise();
        this._saveCallbacks = [];
        this._finished = false;
        this._deleted = false;
        this._failureError = null;
        this._localPath = localPath;
        this._unaccessibleErrorMessage = unaccessibleErrorMessage;
        this._cancelCallback = cancelCallback;
      }
      finishedPromise() {
        return this._finishedPromise;
      }
      localPath() {
        return this._localPath;
      }
      localPathAfterFinished() {
        return __async(this, null, function* () {
          if (this._unaccessibleErrorMessage)
            throw new Error(this._unaccessibleErrorMessage);
          yield this._finishedPromise;
          if (this._failureError)
            return null;
          return this._localPath;
        });
      }
      saveAs(saveCallback) {
        if (this._unaccessibleErrorMessage)
          throw new Error(this._unaccessibleErrorMessage);
        if (this._deleted)
          throw new Error(`File already deleted. Save before deleting.`);
        if (this._failureError)
          throw new Error(`File not found on disk. Check download.failure() for details.`);
        if (this._finished) {
          saveCallback(this._localPath).catch((e) => {
          });
          return;
        }
        this._saveCallbacks.push(saveCallback);
      }
      failureError() {
        return __async(this, null, function* () {
          if (this._unaccessibleErrorMessage)
            return this._unaccessibleErrorMessage;
          yield this._finishedPromise;
          return this._failureError;
        });
      }
      cancel() {
        return __async(this, null, function* () {
          (0, _utils.assert)(this._cancelCallback !== void 0);
          return this._cancelCallback();
        });
      }
      delete() {
        return __async(this, null, function* () {
          if (this._unaccessibleErrorMessage)
            return;
          const fileName = yield this.localPathAfterFinished();
          if (this._deleted)
            return;
          this._deleted = true;
          if (fileName)
            yield _fs.default.promises.unlink(fileName).catch((e) => {
            });
        });
      }
      deleteOnContextClose() {
        return __async(this, null, function* () {
          if (this._deleted)
            return;
          this._deleted = true;
          if (!this._unaccessibleErrorMessage)
            yield _fs.default.promises.unlink(this._localPath).catch((e) => {
            });
          yield this.reportFinished("File deleted upon browser context closure.");
        });
      }
      reportFinished(error) {
        return __async(this, null, function* () {
          if (this._finished)
            return;
          this._finished = true;
          this._failureError = error || null;
          if (error) {
            for (const callback of this._saveCallbacks)
              yield callback("", error);
          } else {
            for (const callback of this._saveCallbacks)
              yield callback(this._localPath);
          }
          this._saveCallbacks = [];
          this._finishedPromise.resolve();
        });
      }
    };
    exports2.Artifact = Artifact;
  }
});

// node_modules/playwright-core/lib/server/har/harTracer.js
var require_harTracer = __commonJS({
  "node_modules/playwright-core/lib/server/har/harTracer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.HarTracer = void 0;
    var _browserContext = require_browserContext();
    var _fetch = require_fetch();
    var _helper = require_helper();
    var network = _interopRequireWildcard(require_network());
    var _page = require_page();
    var _utils = require_utils();
    var _eventsHelper = require_eventsHelper();
    var mime = _interopRequireWildcard(require_mime());
    var _manualPromise = require_manualPromise();
    var _userAgent = require_userAgent();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FALLBACK_HTTP_VERSION = "HTTP/1.1";
    var HarTracer = class {
      constructor(context, delegate, options) {
        this._context = void 0;
        this._barrierPromises = /* @__PURE__ */ new Set();
        this._delegate = void 0;
        this._options = void 0;
        this._pageEntries = /* @__PURE__ */ new Map();
        this._eventListeners = [];
        this._started = false;
        this._entrySymbol = void 0;
        this._context = context;
        this._delegate = delegate;
        this._options = options;
        this._entrySymbol = Symbol("requestHarEntry");
      }
      start() {
        if (this._started)
          return;
        this._started = true;
        const apiRequest = this._context instanceof _fetch.APIRequestContext ? this._context : this._context.fetchRequest;
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(apiRequest, _fetch.APIRequestContext.Events.Request, (event) => this._onAPIRequest(event)), _eventsHelper.eventsHelper.addEventListener(apiRequest, _fetch.APIRequestContext.Events.RequestFinished, (event) => this._onAPIRequestFinished(event))];
        if (this._context instanceof _browserContext.BrowserContext) {
          this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Page, (page) => this._ensurePageEntry(page)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Request, (request) => this._onRequest(request)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.RequestFinished, ({
            request,
            response
          }) => this._onRequestFinished(request, response).catch(() => {
          })), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.RequestFailed, (request) => this._onRequestFailed(request)), _eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Response, (response) => this._onResponse(response)));
        }
      }
      _entryForRequest(request) {
        return request[this._entrySymbol];
      }
      _ensurePageEntry(page) {
        let pageEntry = this._pageEntries.get(page);
        if (!pageEntry) {
          page.on(_page.Page.Events.DOMContentLoaded, () => this._onDOMContentLoaded(page));
          page.on(_page.Page.Events.Load, () => this._onLoad(page));
          pageEntry = {
            startedDateTime: new Date(),
            id: page.guid,
            title: "",
            pageTimings: {
              onContentLoad: -1,
              onLoad: -1
            }
          };
          this._pageEntries.set(page, pageEntry);
        }
        return pageEntry;
      }
      _onDOMContentLoaded(page) {
        const pageEntry = this._ensurePageEntry(page);
        const promise = page.mainFrame().evaluateExpression(String(() => {
          return {
            title: document.title,
            domContentLoaded: performance.timing.domContentLoadedEventStart
          };
        }), true, void 0, "utility").then((result) => {
          pageEntry.title = result.title;
          pageEntry.pageTimings.onContentLoad = result.domContentLoaded;
        }).catch(() => {
        });
        this._addBarrier(page, promise);
      }
      _onLoad(page) {
        const pageEntry = this._ensurePageEntry(page);
        const promise = page.mainFrame().evaluateExpression(String(() => {
          return {
            title: document.title,
            loaded: performance.timing.loadEventStart
          };
        }), true, void 0, "utility").then((result) => {
          pageEntry.title = result.title;
          pageEntry.pageTimings.onLoad = result.loaded;
        }).catch(() => {
        });
        this._addBarrier(page, promise);
      }
      _addBarrier(page, promise) {
        if (!this._options.waitForContentOnStop)
          return;
        const race = Promise.race([new Promise((f) => page.on("close", () => {
          this._barrierPromises.delete(race);
          f();
        })), promise]);
        this._barrierPromises.add(race);
        race.then(() => this._barrierPromises.delete(race));
      }
      _onAPIRequest(event) {
        var _event$postData;
        const harEntry = createHarEntry(event.method, event.url, "", "");
        harEntry.request.cookies = event.cookies;
        harEntry.request.headers = Object.entries(event.headers).map(([name, value]) => ({
          name,
          value
        }));
        harEntry.request.postData = postDataForBuffer(event.postData || null, event.headers["content-type"], this._options.content);
        harEntry.request.bodySize = ((_event$postData = event.postData) === null || _event$postData === void 0 ? void 0 : _event$postData.length) || 0;
        event[this._entrySymbol] = harEntry;
        if (this._started)
          this._delegate.onEntryStarted(harEntry);
      }
      _onAPIRequestFinished(event) {
        const harEntry = this._entryForRequest(event.requestEvent);
        if (!harEntry)
          return;
        harEntry.response.status = event.statusCode;
        harEntry.response.statusText = event.statusMessage;
        harEntry.response.httpVersion = event.httpVersion;
        harEntry.response.redirectURL = event.headers.location || "";
        for (let i = 0; i < event.rawHeaders.length; i += 2) {
          harEntry.response.headers.push({
            name: event.rawHeaders[i],
            value: event.rawHeaders[i + 1]
          });
        }
        harEntry.response.cookies = event.cookies.map((c) => {
          return __spreadProps(__spreadValues({}, c), {
            expires: c.expires === -1 ? void 0 : new Date(c.expires)
          });
        });
        const content = harEntry.response.content;
        const contentType = event.headers["content-type"];
        if (contentType)
          content.mimeType = contentType;
        this._storeResponseContent(event.body, content);
        if (this._started)
          this._delegate.onEntryFinished(harEntry);
      }
      _onRequest(request) {
        const page = request.frame()._page;
        const url = network.parsedURL(request.url());
        if (!url)
          return;
        const pageEntry = this._ensurePageEntry(page);
        const harEntry = createHarEntry(request.method(), url, request.guid, request.frame().guid);
        harEntry.pageref = pageEntry.id;
        harEntry.request.postData = postDataForRequest(request, this._options.content);
        harEntry.request.bodySize = request.bodySize();
        if (request.redirectedFrom()) {
          const fromEntry = this._entryForRequest(request.redirectedFrom());
          if (fromEntry)
            fromEntry.response.redirectURL = request.url();
        }
        request[this._entrySymbol] = harEntry;
        if (this._started)
          this._delegate.onEntryStarted(harEntry);
      }
      _onRequestFinished(request, response) {
        return __async(this, null, function* () {
          if (!response)
            return;
          const page = request.frame()._page;
          const harEntry = this._entryForRequest(request);
          if (!harEntry)
            return;
          const httpVersion = response.httpVersion();
          harEntry.request.httpVersion = httpVersion;
          harEntry.response.httpVersion = httpVersion;
          const compressionCalculationBarrier = {
            _encodedBodySize: -1,
            _decodedBodySize: -1,
            barrier: new _manualPromise.ManualPromise(),
            _check: function() {
              if (this._encodedBodySize !== -1 && this._decodedBodySize !== -1) {
                harEntry.response.content.compression = Math.max(0, this._decodedBodySize - this._encodedBodySize);
                this.barrier.resolve();
              }
            },
            setEncodedBodySize: function(encodedBodySize) {
              this._encodedBodySize = encodedBodySize;
              this._check();
            },
            setDecodedBodySize: function(decodedBodySize) {
              this._decodedBodySize = decodedBodySize;
              this._check();
            }
          };
          this._addBarrier(page, compressionCalculationBarrier.barrier);
          const promise = response.body().then((buffer) => {
            if (this._options.skipScripts && request.resourceType() === "script") {
              compressionCalculationBarrier.setDecodedBodySize(0);
              return;
            }
            const content = harEntry.response.content;
            compressionCalculationBarrier.setDecodedBodySize(buffer.length);
            this._storeResponseContent(buffer, content);
          }).catch(() => {
            compressionCalculationBarrier.setDecodedBodySize(0);
          }).then(() => {
            const postData = response.request().postDataBuffer();
            if (postData && harEntry.request.postData && this._options.content === "sha1") {
              harEntry.request.postData._sha1 = (0, _utils.calculateSha1)(postData) + "." + (mime.getExtension(harEntry.request.postData.mimeType) || "dat");
              if (this._started)
                this._delegate.onContentBlob(harEntry.request.postData._sha1, postData);
            }
            if (this._started)
              this._delegate.onEntryFinished(harEntry);
          });
          this._addBarrier(page, promise);
          this._addBarrier(page, response.sizes().then((sizes) => {
            harEntry.response.bodySize = sizes.responseBodySize;
            harEntry.response.headersSize = sizes.responseHeadersSize;
            harEntry.response._transferSize = response.request().responseSize.transferSize || sizes.responseHeadersSize + sizes.responseBodySize;
            harEntry.request.headersSize = sizes.requestHeadersSize;
            compressionCalculationBarrier.setEncodedBodySize(sizes.responseBodySize);
          }));
        });
      }
      _onRequestFailed(request) {
        return __async(this, null, function* () {
          const harEntry = this._entryForRequest(request);
          if (!harEntry)
            return;
          if (request._failureText !== null)
            harEntry.response._failureText = request._failureText;
          if (this._started)
            this._delegate.onEntryFinished(harEntry);
        });
      }
      _storeResponseContent(buffer, content) {
        if (!buffer) {
          content.size = 0;
          return;
        }
        content.size = buffer.length;
        if (this._options.content === "embedded") {
          content.text = buffer.toString("base64");
          content.encoding = "base64";
        } else if (this._options.content === "sha1") {
          content._sha1 = (0, _utils.calculateSha1)(buffer) + "." + (mime.getExtension(content.mimeType) || "dat");
          if (this._started)
            this._delegate.onContentBlob(content._sha1, buffer);
        }
      }
      _onResponse(response) {
        const page = response.frame()._page;
        const pageEntry = this._ensurePageEntry(page);
        const harEntry = this._entryForRequest(response.request());
        if (!harEntry)
          return;
        const request = response.request();
        harEntry.request.postData = postDataForRequest(request, this._options.content);
        harEntry.response = {
          status: response.status(),
          statusText: response.statusText(),
          httpVersion: response.httpVersion(),
          cookies: [],
          headers: [],
          content: {
            size: -1,
            mimeType: "x-unknown"
          },
          headersSize: -1,
          bodySize: -1,
          redirectURL: "",
          _transferSize: -1
        };
        const timing = response.timing();
        if (pageEntry.startedDateTime.valueOf() > timing.startTime)
          pageEntry.startedDateTime = new Date(timing.startTime);
        const dns = timing.domainLookupEnd !== -1 ? _helper.helper.millisToRoundishMillis(timing.domainLookupEnd - timing.domainLookupStart) : -1;
        const connect = timing.connectEnd !== -1 ? _helper.helper.millisToRoundishMillis(timing.connectEnd - timing.connectStart) : -1;
        const ssl = timing.connectEnd !== -1 ? _helper.helper.millisToRoundishMillis(timing.connectEnd - timing.secureConnectionStart) : -1;
        const wait = timing.responseStart !== -1 ? _helper.helper.millisToRoundishMillis(timing.responseStart - timing.requestStart) : -1;
        const receive = response.request()._responseEndTiming !== -1 ? _helper.helper.millisToRoundishMillis(response.request()._responseEndTiming - timing.responseStart) : -1;
        harEntry.timings = {
          dns,
          connect,
          ssl,
          send: 0,
          wait,
          receive
        };
        harEntry.time = [dns, connect, ssl, wait, receive].reduce((pre, cur) => cur > 0 ? cur + pre : pre, 0);
        this._addBarrier(page, response.serverAddr().then((server) => {
          if (server !== null && server !== void 0 && server.ipAddress)
            harEntry.serverIPAddress = server.ipAddress;
          if (server !== null && server !== void 0 && server.port)
            harEntry._serverPort = server.port;
        }));
        this._addBarrier(page, response.securityDetails().then((details) => {
          if (details)
            harEntry._securityDetails = details;
        }));
        this._addBarrier(page, request.rawRequestHeaders().then((headers) => {
          for (const header of headers.filter((header2) => header2.name.toLowerCase() === "cookie"))
            harEntry.request.cookies.push(...header.value.split(";").map(parseCookie));
          harEntry.request.headers = headers;
        }));
        this._addBarrier(page, response.rawResponseHeaders().then((headers) => {
          for (const header of headers.filter((header2) => header2.name.toLowerCase() === "set-cookie"))
            harEntry.response.cookies.push(parseCookie(header.value));
          harEntry.response.headers = headers;
          const contentType = headers.find((header) => header.name.toLowerCase() === "content-type");
          if (contentType)
            harEntry.response.content.mimeType = contentType.value;
        }));
      }
      flush() {
        return __async(this, null, function* () {
          yield Promise.all(this._barrierPromises);
        });
      }
      stop() {
        this._started = false;
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        this._barrierPromises.clear();
        const context = this._context instanceof _browserContext.BrowserContext ? this._context : void 0;
        const log = {
          version: "1.2",
          creator: {
            name: "Playwright",
            version: (0, _userAgent.getPlaywrightVersion)()
          },
          browser: {
            name: (context === null || context === void 0 ? void 0 : context._browser.options.name) || "",
            version: (context === null || context === void 0 ? void 0 : context._browser.version()) || ""
          },
          pages: Array.from(this._pageEntries.values()),
          entries: []
        };
        for (const pageEntry of log.pages) {
          if (pageEntry.pageTimings.onContentLoad >= 0)
            pageEntry.pageTimings.onContentLoad -= pageEntry.startedDateTime.valueOf();
          else
            pageEntry.pageTimings.onContentLoad = -1;
          if (pageEntry.pageTimings.onLoad >= 0)
            pageEntry.pageTimings.onLoad -= pageEntry.startedDateTime.valueOf();
          else
            pageEntry.pageTimings.onLoad = -1;
        }
        this._pageEntries.clear();
        return log;
      }
    };
    exports2.HarTracer = HarTracer;
    function createHarEntry(method, url, requestref, frameref) {
      const harEntry = {
        _requestref: requestref,
        _frameref: frameref,
        _monotonicTime: (0, _utils.monotonicTime)(),
        startedDateTime: new Date(),
        time: -1,
        request: {
          method,
          url: url.toString(),
          httpVersion: FALLBACK_HTTP_VERSION,
          cookies: [],
          headers: [],
          queryString: [...url.searchParams].map((e) => ({
            name: e[0],
            value: e[1]
          })),
          headersSize: -1,
          bodySize: 0
        },
        response: {
          status: -1,
          statusText: "",
          httpVersion: FALLBACK_HTTP_VERSION,
          cookies: [],
          headers: [],
          content: {
            size: -1,
            mimeType: "x-unknown"
          },
          headersSize: -1,
          bodySize: -1,
          redirectURL: "",
          _transferSize: -1
        },
        cache: {
          beforeRequest: null,
          afterRequest: null
        },
        timings: {
          send: -1,
          wait: -1,
          receive: -1
        }
      };
      return harEntry;
    }
    function postDataForRequest(request, content) {
      const postData = request.postDataBuffer();
      if (!postData)
        return;
      const contentType = request.headerValue("content-type");
      return postDataForBuffer(postData, contentType, content);
    }
    function postDataForBuffer(postData, contentType, content) {
      var _contentType;
      if (!postData)
        return;
      (_contentType = contentType) !== null && _contentType !== void 0 ? _contentType : contentType = "application/octet-stream";
      const result = {
        mimeType: contentType,
        text: "",
        params: []
      };
      if (content === "embedded" && contentType !== "application/octet-stream")
        result.text = postData.toString();
      if (contentType === "application/x-www-form-urlencoded") {
        const parsed = new URLSearchParams(postData.toString());
        for (const [name, value] of parsed.entries())
          result.params.push({
            name,
            value
          });
      }
      return result;
    }
    function parseCookie(c) {
      const cookie = {
        name: "",
        value: ""
      };
      let first = true;
      for (const pair of c.split(/; */)) {
        const indexOfEquals = pair.indexOf("=");
        const name = indexOfEquals !== -1 ? pair.substr(0, indexOfEquals).trim() : pair.trim();
        const value = indexOfEquals !== -1 ? pair.substr(indexOfEquals + 1, pair.length).trim() : "";
        if (first) {
          first = false;
          cookie.name = name;
          cookie.value = value;
          continue;
        }
        if (name === "Domain")
          cookie.domain = value;
        if (name === "Expires")
          cookie.expires = new Date(value);
        if (name === "HttpOnly")
          cookie.httpOnly = true;
        if (name === "Max-Age")
          cookie.expires = new Date(Date.now() + +value * 1e3);
        if (name === "Path")
          cookie.path = value;
        if (name === "SameSite")
          cookie.sameSite = value;
        if (name === "Secure")
          cookie.secure = true;
      }
      return cookie;
    }
  }
});

// node_modules/playwright-core/lib/server/trace/common/traceEvents.js
var require_traceEvents = __commonJS({
  "node_modules/playwright-core/lib/server/trace/common/traceEvents.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VERSION = void 0;
    var VERSION = 3;
    exports2.VERSION = VERSION;
  }
});

// node_modules/playwright-core/lib/server/trace/recorder/snapshotterInjected.js
var require_snapshotterInjected = __commonJS({
  "node_modules/playwright-core/lib/server/trace/recorder/snapshotterInjected.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.frameSnapshotStreamer = frameSnapshotStreamer;
    function frameSnapshotStreamer(snapshotStreamer) {
      if (window[snapshotStreamer])
        return;
      const kShadowAttribute = "__playwright_shadow_root_";
      const kValueAttribute = "__playwright_value_";
      const kCheckedAttribute = "__playwright_checked_";
      const kSelectedAttribute = "__playwright_selected_";
      const kScrollTopAttribute = "__playwright_scroll_top_";
      const kScrollLeftAttribute = "__playwright_scroll_left_";
      const kStyleSheetAttribute = "__playwright_style_sheet_";
      const kSnapshotFrameId = Symbol("__playwright_snapshot_frameid_");
      const kCachedData = Symbol("__playwright_snapshot_cache_");
      const kEndOfList = Symbol("__playwright_end_of_list_");
      function resetCachedData(obj) {
        delete obj[kCachedData];
      }
      function ensureCachedData(obj) {
        if (!obj[kCachedData])
          obj[kCachedData] = {};
        return obj[kCachedData];
      }
      function removeHash(url) {
        try {
          const u = new URL(url);
          u.hash = "";
          return u.toString();
        } catch (e) {
          return url;
        }
      }
      class Streamer {
        constructor() {
          this._removeNoScript = true;
          this._lastSnapshotNumber = 0;
          this._staleStyleSheets = /* @__PURE__ */ new Set();
          this._readingStyleSheet = false;
          this._fakeBase = void 0;
          this._observer = void 0;
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "insertRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "deleteRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "addRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "removeRule", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeGetter(window.CSSStyleSheet.prototype, "rules", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeGetter(window.CSSStyleSheet.prototype, "cssRules", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeMethod(window.CSSStyleSheet.prototype, "replaceSync", (sheet) => this._invalidateStyleSheet(sheet));
          this._interceptNativeAsyncMethod(window.CSSStyleSheet.prototype, "replace", (sheet) => this._invalidateStyleSheet(sheet));
          this._fakeBase = document.createElement("base");
          this._observer = new MutationObserver((list) => this._handleMutations(list));
          const observerConfig = {
            attributes: true,
            subtree: true
          };
          this._observer.observe(document, observerConfig);
        }
        _interceptNativeMethod(obj, method, cb) {
          const native = obj[method];
          if (!native)
            return;
          obj[method] = function(...args) {
            const result = native.call(this, ...args);
            cb(this, result);
            return result;
          };
        }
        _interceptNativeAsyncMethod(obj, method, cb) {
          const native = obj[method];
          if (!native)
            return;
          obj[method] = function(...args) {
            return __async(this, null, function* () {
              const result = yield native.call(this, ...args);
              cb(this, result);
              return result;
            });
          };
        }
        _interceptNativeGetter(obj, prop, cb) {
          const descriptor = Object.getOwnPropertyDescriptor(obj, prop);
          Object.defineProperty(obj, prop, __spreadProps(__spreadValues({}, descriptor), {
            get: function() {
              const result = descriptor.get.call(this);
              cb(this, result);
              return result;
            }
          }));
        }
        _handleMutations(list) {
          for (const mutation of list)
            ensureCachedData(mutation.target).attributesCached = void 0;
        }
        _invalidateStyleSheet(sheet) {
          if (this._readingStyleSheet)
            return;
          this._staleStyleSheets.add(sheet);
        }
        _updateStyleElementStyleSheetTextIfNeeded(sheet, forceText) {
          const data = ensureCachedData(sheet);
          if (this._staleStyleSheets.has(sheet) || forceText && data.cssText === void 0) {
            this._staleStyleSheets.delete(sheet);
            try {
              data.cssText = this._getSheetText(sheet);
            } catch (e) {
              data.cssText = "";
            }
          }
          return data.cssText;
        }
        _updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber) {
          const data = ensureCachedData(sheet);
          if (this._staleStyleSheets.has(sheet)) {
            this._staleStyleSheets.delete(sheet);
            try {
              data.cssText = this._getSheetText(sheet);
              data.cssRef = snapshotNumber;
              return data.cssText;
            } catch (e) {
            }
          }
          return data.cssRef === void 0 ? void 0 : snapshotNumber - data.cssRef;
        }
        markIframe(iframeElement, frameId) {
          iframeElement[kSnapshotFrameId] = frameId;
        }
        reset() {
          this._staleStyleSheets.clear();
          const visitNode = (node) => {
            resetCachedData(node);
            if (node.nodeType === Node.ELEMENT_NODE) {
              const element = node;
              if (element.shadowRoot)
                visitNode(element.shadowRoot);
            }
            for (let child = node.firstChild; child; child = child.nextSibling)
              visitNode(child);
          };
          visitNode(document.documentElement);
          visitNode(this._fakeBase);
        }
        __sanitizeMetaAttribute(name, value, httpEquiv) {
          if (name === "charset")
            return "utf-8";
          if (httpEquiv.toLowerCase() !== "content-type" || name !== "content")
            return value;
          const [type, ...params] = value.split(";");
          if (type !== "text/html" || params.length <= 0)
            return value;
          const charsetParamIdx = params.findIndex((param) => param.trim().startsWith("charset="));
          if (charsetParamIdx > -1)
            params[charsetParamIdx] = "charset=utf-8";
          return `${type}; ${params.join("; ")}`;
        }
        _sanitizeUrl(url) {
          if (url.startsWith("javascript:"))
            return "";
          return url;
        }
        _sanitizeSrcSet(srcset) {
          return srcset.split(",").map((src) => {
            src = src.trim();
            const spaceIndex = src.lastIndexOf(" ");
            if (spaceIndex === -1)
              return this._sanitizeUrl(src);
            return this._sanitizeUrl(src.substring(0, spaceIndex).trim()) + src.substring(spaceIndex);
          }).join(", ");
        }
        _resolveUrl(base, url) {
          if (url === "")
            return "";
          try {
            return new URL(url, base).href;
          } catch (e) {
            return url;
          }
        }
        _getSheetBase(sheet) {
          let rootSheet = sheet;
          while (rootSheet.parentStyleSheet)
            rootSheet = rootSheet.parentStyleSheet;
          if (rootSheet.ownerNode)
            return rootSheet.ownerNode.baseURI;
          return document.baseURI;
        }
        _getSheetText(sheet) {
          this._readingStyleSheet = true;
          try {
            const rules = [];
            for (const rule of sheet.cssRules)
              rules.push(rule.cssText);
            return rules.join("\n");
          } finally {
            this._readingStyleSheet = false;
          }
        }
        captureSnapshot() {
          const timestamp = performance.now();
          const snapshotNumber = ++this._lastSnapshotNumber;
          let nodeCounter = 0;
          let shadowDomNesting = 0;
          let headNesting = 0;
          this._handleMutations(this._observer.takeRecords());
          const visitNode = (node) => {
            const nodeType = node.nodeType;
            const nodeName = nodeType === Node.DOCUMENT_FRAGMENT_NODE ? "template" : node.nodeName;
            if (nodeType !== Node.ELEMENT_NODE && nodeType !== Node.DOCUMENT_FRAGMENT_NODE && nodeType !== Node.TEXT_NODE)
              return;
            if (nodeName === "SCRIPT")
              return;
            if (nodeName === "LINK" && nodeType === Node.ELEMENT_NODE) {
              var _getAttribute;
              const rel = (_getAttribute = node.getAttribute("rel")) === null || _getAttribute === void 0 ? void 0 : _getAttribute.toLowerCase();
              if (rel === "preload" || rel === "prefetch")
                return;
            }
            if (this._removeNoScript && nodeName === "NOSCRIPT")
              return;
            if (nodeName === "META" && node.httpEquiv.toLowerCase() === "content-security-policy")
              return;
            if ((nodeName === "IFRAME" || nodeName === "FRAME") && headNesting)
              return;
            const data = ensureCachedData(node);
            const values = [];
            let equals = !!data.cached;
            let extraNodes = 0;
            const expectValue = (value) => {
              equals = equals && data.cached[values.length] === value;
              values.push(value);
            };
            const checkAndReturn = (n) => {
              data.attributesCached = true;
              if (equals)
                return {
                  equals: true,
                  n: [[snapshotNumber - data.ref[0], data.ref[1]]]
                };
              nodeCounter += extraNodes;
              data.ref = [snapshotNumber, nodeCounter++];
              data.cached = values;
              return {
                equals: false,
                n
              };
            };
            if (nodeType === Node.TEXT_NODE) {
              const value = node.nodeValue || "";
              expectValue(value);
              return checkAndReturn(value);
            }
            if (nodeName === "STYLE") {
              const sheet = node.sheet;
              let cssText;
              if (sheet)
                cssText = this._updateStyleElementStyleSheetTextIfNeeded(sheet);
              cssText = cssText || node.textContent || "";
              expectValue(cssText);
              extraNodes++;
              return checkAndReturn([nodeName, {}, cssText]);
            }
            const attrs = {};
            const result2 = [nodeName, attrs];
            const visitChild = (child) => {
              const snapshot = visitNode(child);
              if (snapshot) {
                result2.push(snapshot.n);
                expectValue(child);
                equals = equals && snapshot.equals;
              }
            };
            const visitChildStyleSheet = (child) => {
              const snapshot = visitStyleSheet(child);
              if (snapshot) {
                result2.push(snapshot.n);
                expectValue(child);
                equals = equals && snapshot.equals;
              }
            };
            if (nodeType === Node.DOCUMENT_FRAGMENT_NODE)
              attrs[kShadowAttribute] = "open";
            if (nodeType === Node.ELEMENT_NODE) {
              const element = node;
              if (nodeName === "INPUT" || nodeName === "TEXTAREA") {
                const value = element.value;
                expectValue(kValueAttribute);
                expectValue(value);
                attrs[kValueAttribute] = value;
              }
              if (nodeName === "INPUT" && ["checkbox", "radio"].includes(element.type)) {
                const value = element.checked ? "true" : "false";
                expectValue(kCheckedAttribute);
                expectValue(value);
                attrs[kCheckedAttribute] = value;
              }
              if (nodeName === "OPTION") {
                const value = element.selected ? "true" : "false";
                expectValue(kSelectedAttribute);
                expectValue(value);
                attrs[kSelectedAttribute] = value;
              }
              if (element.scrollTop) {
                expectValue(kScrollTopAttribute);
                expectValue(element.scrollTop);
                attrs[kScrollTopAttribute] = "" + element.scrollTop;
              }
              if (element.scrollLeft) {
                expectValue(kScrollLeftAttribute);
                expectValue(element.scrollLeft);
                attrs[kScrollLeftAttribute] = "" + element.scrollLeft;
              }
              if (element.shadowRoot) {
                ++shadowDomNesting;
                visitChild(element.shadowRoot);
                --shadowDomNesting;
              }
            }
            if (nodeName === "HEAD") {
              ++headNesting;
              this._fakeBase.setAttribute("href", document.baseURI);
              visitChild(this._fakeBase);
            }
            for (let child = node.firstChild; child; child = child.nextSibling)
              visitChild(child);
            if (nodeName === "HEAD")
              --headNesting;
            expectValue(kEndOfList);
            let documentOrShadowRoot = null;
            if (node.ownerDocument.documentElement === node)
              documentOrShadowRoot = node.ownerDocument;
            else if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE)
              documentOrShadowRoot = node;
            if (documentOrShadowRoot) {
              for (const sheet of documentOrShadowRoot.adoptedStyleSheets || [])
                visitChildStyleSheet(sheet);
              expectValue(kEndOfList);
            }
            if (nodeName === "IFRAME" || nodeName === "FRAME") {
              const element = node;
              const frameId = element[kSnapshotFrameId];
              const name = "src";
              const value = frameId ? `/snapshot/${frameId}` : "";
              expectValue(name);
              expectValue(value);
              attrs[name] = value;
            }
            if (equals && data.attributesCached && !shadowDomNesting)
              return checkAndReturn(result2);
            if (nodeType === Node.ELEMENT_NODE) {
              const element = node;
              for (let i = 0; i < element.attributes.length; i++) {
                const name = element.attributes[i].name;
                if (nodeName === "LINK" && name === "integrity")
                  continue;
                if (nodeName === "IFRAME" && (name === "src" || name === "sandbox"))
                  continue;
                if (nodeName === "FRAME" && name === "src")
                  continue;
                let value = element.attributes[i].value;
                if (nodeName === "META")
                  value = this.__sanitizeMetaAttribute(name, value, node.httpEquiv);
                else if (name === "src" && nodeName === "IMG")
                  value = this._sanitizeUrl(value);
                else if (name === "srcset" && nodeName === "IMG")
                  value = this._sanitizeSrcSet(value);
                else if (name === "srcset" && nodeName === "SOURCE")
                  value = this._sanitizeSrcSet(value);
                else if (name === "href" && nodeName === "LINK")
                  value = this._sanitizeUrl(value);
                else if (name.startsWith("on"))
                  value = "";
                expectValue(name);
                expectValue(value);
                attrs[name] = value;
              }
              expectValue(kEndOfList);
            }
            if (result2.length === 2 && !Object.keys(attrs).length)
              result2.pop();
            return checkAndReturn(result2);
          };
          const visitStyleSheet = (sheet) => {
            const data = ensureCachedData(sheet);
            const oldCSSText = data.cssText;
            const cssText = this._updateStyleElementStyleSheetTextIfNeeded(sheet, true);
            if (cssText === oldCSSText)
              return {
                equals: true,
                n: [[snapshotNumber - data.ref[0], data.ref[1]]]
              };
            data.ref = [snapshotNumber, nodeCounter++];
            return {
              equals: false,
              n: ["template", {
                [kStyleSheetAttribute]: cssText
              }]
            };
          };
          let html;
          if (document.documentElement) {
            const {
              n
            } = visitNode(document.documentElement);
            html = n;
          } else {
            html = ["html"];
          }
          const result = {
            html,
            doctype: document.doctype ? document.doctype.name : void 0,
            resourceOverrides: [],
            viewport: {
              width: window.innerWidth,
              height: window.innerHeight
            },
            url: location.href,
            timestamp,
            collectionTime: 0
          };
          for (const sheet of this._staleStyleSheets) {
            if (sheet.href === null)
              continue;
            const content = this._updateLinkStyleSheetTextIfNeeded(sheet, snapshotNumber);
            if (content === void 0) {
              continue;
            }
            const base = this._getSheetBase(sheet);
            const url = removeHash(this._resolveUrl(base, sheet.href));
            result.resourceOverrides.push({
              url,
              content,
              contentType: "text/css"
            });
          }
          result.collectionTime = performance.now() - result.timestamp;
          return result;
        }
      }
      window[snapshotStreamer] = new Streamer();
    }
  }
});

// node_modules/playwright-core/lib/server/trace/recorder/snapshotter.js
var require_snapshotter = __commonJS({
  "node_modules/playwright-core/lib/server/trace/recorder/snapshotter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Snapshotter = void 0;
    var _browserContext = require_browserContext();
    var _page = require_page();
    var _eventsHelper = require_eventsHelper();
    var _debugLogger = require_debugLogger();
    var _snapshotterInjected = require_snapshotterInjected();
    var _utils = require_utils();
    var mime = _interopRequireWildcard(require_mime());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Snapshotter = class {
      constructor(context, delegate) {
        this._context = void 0;
        this._delegate = void 0;
        this._eventListeners = [];
        this._snapshotStreamer = void 0;
        this._initialized = false;
        this._started = false;
        this._context = context;
        this._delegate = delegate;
        const guid = (0, _utils.createGuid)();
        this._snapshotStreamer = "__playwright_snapshot_streamer_" + guid;
      }
      started() {
        return this._started;
      }
      start() {
        return __async(this, null, function* () {
          this._started = true;
          if (!this._initialized) {
            this._initialized = true;
            yield this._initialize();
          }
          yield this.reset();
        });
      }
      reset() {
        return __async(this, null, function* () {
          if (this._started)
            yield this._runInAllFrames(`window["${this._snapshotStreamer}"].reset()`);
        });
      }
      stop() {
        return __async(this, null, function* () {
          this._started = false;
        });
      }
      _initialize() {
        return __async(this, null, function* () {
          for (const page of this._context.pages())
            this._onPage(page);
          this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Page, this._onPage.bind(this))];
          const initScript = `(${_snapshotterInjected.frameSnapshotStreamer})("${this._snapshotStreamer}")`;
          yield this._context.addInitScript(initScript);
          yield this._runInAllFrames(initScript);
        });
      }
      _runInAllFrames(expression) {
        return __async(this, null, function* () {
          const frames = [];
          for (const page of this._context.pages())
            frames.push(...page.frames());
          yield Promise.all(frames.map((frame) => {
            return frame.nonStallingRawEvaluateInExistingMainContext(expression).catch((e) => _debugLogger.debugLogger.log("error", e));
          }));
        });
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
      }
      captureSnapshot(page, snapshotName, element) {
        return __async(this, null, function* () {
          const expression = `window["${this._snapshotStreamer}"].captureSnapshot(${JSON.stringify(snapshotName)})`;
          element === null || element === void 0 ? void 0 : element.callFunctionNoReply((element2, snapshotName2) => {
            element2.setAttribute("__playwright_target__", snapshotName2);
          }, snapshotName);
          const snapshots = page.frames().map((frame) => __async(this, null, function* () {
            const data = yield frame.nonStallingRawEvaluateInExistingMainContext(expression).catch((e) => _debugLogger.debugLogger.log("error", e));
            if (!data || !this._started)
              return;
            const snapshot = {
              snapshotName,
              pageId: page.guid,
              frameId: frame.guid,
              frameUrl: data.url,
              doctype: data.doctype,
              html: data.html,
              viewport: data.viewport,
              timestamp: (0, _utils.monotonicTime)(),
              collectionTime: data.collectionTime,
              resourceOverrides: [],
              isMainFrame: page.mainFrame() === frame
            };
            for (const {
              url,
              content,
              contentType
            } of data.resourceOverrides) {
              if (typeof content === "string") {
                const buffer = Buffer.from(content);
                const sha1 = (0, _utils.calculateSha1)(buffer) + "." + (mime.getExtension(contentType) || "dat");
                this._delegate.onSnapshotterBlob({
                  sha1,
                  buffer
                });
                snapshot.resourceOverrides.push({
                  url,
                  sha1
                });
              } else {
                snapshot.resourceOverrides.push({
                  url,
                  ref: content
                });
              }
            }
            this._delegate.onFrameSnapshot(snapshot);
          }));
          yield Promise.all(snapshots);
        });
      }
      _onPage(page) {
        for (const frame of page.frames())
          this._annotateFrameHierarchy(frame);
        this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(page, _page.Page.Events.FrameAttached, (frame) => this._annotateFrameHierarchy(frame)));
      }
      _annotateFrameHierarchy(frame) {
        return __async(this, null, function* () {
          try {
            const frameElement = yield frame.frameElement();
            const parent = frame.parentFrame();
            if (!parent)
              return;
            const context = yield parent._mainContext();
            yield context === null || context === void 0 ? void 0 : context.evaluate(({
              snapshotStreamer,
              frameElement: frameElement2,
              frameId
            }) => {
              window[snapshotStreamer].markIframe(frameElement2, frameId);
            }, {
              snapshotStreamer: this._snapshotStreamer,
              frameElement,
              frameId: frame.guid
            });
            frameElement.dispose();
          } catch (e) {
          }
        });
      }
    };
    exports2.Snapshotter = Snapshotter;
  }
});

// node_modules/playwright-core/lib/server/trace/recorder/tracing.js
var require_tracing = __commonJS({
  "node_modules/playwright-core/lib/server/trace/recorder/tracing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Tracing = void 0;
    exports2.shouldCaptureSnapshot = shouldCaptureSnapshot;
    var _fs = _interopRequireDefault(require("fs"));
    var _os = _interopRequireDefault(require("os"));
    var _path = _interopRequireDefault(require("path"));
    var _yazl = _interopRequireDefault(require_yazl());
    var _channels = require_channels();
    var _manualPromise = require_manualPromise();
    var _eventsHelper = require_eventsHelper();
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _artifact = require_artifact();
    var _browserContext = require_browserContext();
    var _dom = require_dom();
    var _instrumentation = require_instrumentation();
    var _page = require_page();
    var _harTracer = require_harTracer();
    var _traceEvents = require_traceEvents();
    var _snapshotter = require_snapshotter();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var kScreencastOptions = {
      width: 800,
      height: 600,
      quality: 90
    };
    var Tracing = class extends _instrumentation.SdkObject {
      constructor(context, tracesDir) {
        super(context, "Tracing");
        this._writeChain = Promise.resolve();
        this._snapshotter = void 0;
        this._harTracer = void 0;
        this._screencastListeners = [];
        this._pendingCalls = /* @__PURE__ */ new Map();
        this._context = void 0;
        this._state = void 0;
        this._isStopping = false;
        this._precreatedTracesDir = void 0;
        this._tracesTmpDir = void 0;
        this._allResources = /* @__PURE__ */ new Set();
        this._contextCreatedEvent = void 0;
        this._context = context;
        this._precreatedTracesDir = tracesDir;
        this._harTracer = new _harTracer.HarTracer(context, this, {
          content: "sha1",
          waitForContentOnStop: false,
          skipScripts: true
        });
        this._contextCreatedEvent = {
          version: _traceEvents.VERSION,
          type: "context-options",
          browserName: "",
          options: {},
          platform: process.platform,
          wallTime: 0
        };
        if (context instanceof _browserContext.BrowserContext) {
          this._snapshotter = new _snapshotter.Snapshotter(context, this);
          (0, _utils.assert)(tracesDir, "tracesDir must be specified for BrowserContext");
          this._contextCreatedEvent.browserName = context._browser.options.name;
          this._contextCreatedEvent.options = context._options;
        }
      }
      start(options) {
        return __async(this, null, function* () {
          if (this._isStopping)
            throw new Error("Cannot start tracing while stopping");
          if (this._state) {
            const o = this._state.options;
            if (o.name !== options.name || !o.screenshots !== !options.screenshots || !o.snapshots !== !options.snapshots)
              throw new Error("Tracing has been already started with different options");
            return;
          }
          const traceName = options.name || (0, _utils.createGuid)();
          this._state = {
            options,
            traceName,
            traceFile: "",
            networkFile: "",
            tracesDir: "",
            resourcesDir: "",
            filesCount: 0,
            traceSha1s: /* @__PURE__ */ new Set(),
            networkSha1s: /* @__PURE__ */ new Set(),
            sources: /* @__PURE__ */ new Set(),
            recording: false
          };
          const state = this._state;
          state.tracesDir = yield this._createTracesDirIfNeeded();
          state.resourcesDir = _path.default.join(state.tracesDir, "resources");
          state.traceFile = _path.default.join(state.tracesDir, traceName + ".trace");
          state.networkFile = _path.default.join(state.tracesDir, traceName + ".network");
          this._writeChain = _fs.default.promises.mkdir(state.resourcesDir, {
            recursive: true
          }).then(() => _fs.default.promises.writeFile(state.networkFile, ""));
          if (options.snapshots)
            this._harTracer.start();
        });
      }
      startChunk() {
        return __async(this, arguments, function* (options = {}) {
          var _this$_snapshotter;
          if (this._state && this._state.recording)
            yield this.stopChunk({
              mode: "doNotSave"
            });
          if (!this._state)
            throw new Error("Must start tracing before starting a new chunk");
          if (this._isStopping)
            throw new Error("Cannot start a trace chunk while stopping");
          const state = this._state;
          const suffix = state.filesCount ? `-${state.filesCount}` : ``;
          state.filesCount++;
          state.traceFile = _path.default.join(state.tracesDir, `${state.traceName}${suffix}.trace`);
          state.recording = true;
          this._appendTraceOperation(() => __async(this, null, function* () {
            yield (0, _fileUtils.mkdirIfNeeded)(state.traceFile);
            yield _fs.default.promises.appendFile(state.traceFile, JSON.stringify(__spreadProps(__spreadValues({}, this._contextCreatedEvent), {
              title: options.title,
              wallTime: Date.now()
            })) + "\n");
          }));
          this._context.instrumentation.addListener(this, this._context);
          if (state.options.screenshots)
            this._startScreencast();
          if (state.options.snapshots)
            yield (_this$_snapshotter = this._snapshotter) === null || _this$_snapshotter === void 0 ? void 0 : _this$_snapshotter.start();
        });
      }
      _startScreencast() {
        if (!(this._context instanceof _browserContext.BrowserContext))
          return;
        for (const page of this._context.pages())
          this._startScreencastInPage(page);
        this._screencastListeners.push(_eventsHelper.eventsHelper.addEventListener(this._context, _browserContext.BrowserContext.Events.Page, this._startScreencastInPage.bind(this)));
      }
      _stopScreencast() {
        _eventsHelper.eventsHelper.removeEventListeners(this._screencastListeners);
        if (!(this._context instanceof _browserContext.BrowserContext))
          return;
        for (const page of this._context.pages())
          page.setScreencastOptions(null);
      }
      stop() {
        return __async(this, null, function* () {
          if (!this._state)
            return;
          if (this._isStopping)
            throw new Error(`Tracing is already stopping`);
          if (this._state.recording)
            throw new Error(`Must stop trace file before stopping tracing`);
          this._harTracer.stop();
          yield this._writeChain;
          this._state = void 0;
        });
      }
      deleteTmpTracesDir() {
        return __async(this, null, function* () {
          if (this._tracesTmpDir)
            yield (0, _fileUtils.removeFolders)([this._tracesTmpDir]);
        });
      }
      _createTracesDirIfNeeded() {
        return __async(this, null, function* () {
          if (this._precreatedTracesDir)
            return this._precreatedTracesDir;
          this._tracesTmpDir = yield _fs.default.promises.mkdtemp(_path.default.join(_os.default.tmpdir(), "playwright-tracing-"));
          return this._tracesTmpDir;
        });
      }
      flush() {
        return __async(this, null, function* () {
          var _this$_snapshotter2;
          (_this$_snapshotter2 = this._snapshotter) === null || _this$_snapshotter2 === void 0 ? void 0 : _this$_snapshotter2.dispose();
          yield this._writeChain;
        });
      }
      dispose() {
        return __async(this, null, function* () {
          var _this$_snapshotter3;
          (_this$_snapshotter3 = this._snapshotter) === null || _this$_snapshotter3 === void 0 ? void 0 : _this$_snapshotter3.dispose();
          this.emit(Tracing.Events.Dispose);
        });
      }
      stopChunk(params) {
        return __async(this, null, function* () {
          var _this$_state, _this$_snapshotter4;
          if (this._isStopping)
            throw new Error(`Tracing is already stopping`);
          this._isStopping = true;
          if (!this._state || !this._state.recording) {
            this._isStopping = false;
            if (params.mode !== "doNotSave")
              throw new Error(`Must start tracing before stopping`);
            return {
              artifact: null,
              sourceEntries: []
            };
          }
          const state = this._state;
          this._context.instrumentation.removeListener(this);
          if ((_this$_state = this._state) !== null && _this$_state !== void 0 && _this$_state.options.screenshots)
            this._stopScreencast();
          for (const {
            sdkObject,
            metadata,
            beforeSnapshot,
            actionSnapshot,
            afterSnapshot
          } of this._pendingCalls.values()) {
            yield Promise.all([beforeSnapshot, actionSnapshot, afterSnapshot]);
            let callMetadata = metadata;
            if (!afterSnapshot) {
              callMetadata = __spreadProps(__spreadValues({}, metadata), {
                error: {
                  error: {
                    name: "Error",
                    message: "Action was interrupted"
                  }
                }
              });
            }
            yield this.onAfterCall(sdkObject, callMetadata);
          }
          if (state.options.snapshots)
            yield (_this$_snapshotter4 = this._snapshotter) === null || _this$_snapshotter4 === void 0 ? void 0 : _this$_snapshotter4.stop();
          return (yield this._appendTraceOperation(() => __async(this, null, function* () {
            if (params.mode === "doNotSave")
              return {
                artifact: null,
                sourceEntries: void 0
              };
            const networkFile = _path.default.join(state.networkFile, "..", (0, _utils.createGuid)());
            yield _fs.default.promises.copyFile(state.networkFile, networkFile);
            const entries = [];
            entries.push({
              name: "trace.trace",
              value: state.traceFile
            });
            entries.push({
              name: "trace.network",
              value: networkFile
            });
            for (const sha1 of /* @__PURE__ */ new Set([...state.traceSha1s, ...state.networkSha1s]))
              entries.push({
                name: _path.default.join("resources", sha1),
                value: _path.default.join(state.resourcesDir, sha1)
              });
            let sourceEntries;
            if (state.sources.size) {
              sourceEntries = [];
              for (const value of state.sources) {
                const entry = {
                  name: "resources/src@" + (0, _utils.calculateSha1)(value) + ".txt",
                  value
                };
                if (params.mode === "compressTraceAndSources") {
                  if (_fs.default.existsSync(entry.value))
                    entries.push(entry);
                } else {
                  sourceEntries.push(entry);
                }
              }
            }
            const artifact = yield this._exportZip(entries, state).catch(() => null);
            return {
              artifact,
              sourceEntries
            };
          })).finally(() => {
            state.traceSha1s = /* @__PURE__ */ new Set();
            state.sources = /* @__PURE__ */ new Set();
            this._isStopping = false;
            state.recording = false;
          })) || {
            artifact: null,
            sourceEntries: void 0
          };
        });
      }
      _exportZip(entries, state) {
        return __async(this, null, function* () {
          const zipFile = new _yazl.default.ZipFile();
          const result = new _manualPromise.ManualPromise();
          zipFile.on("error", (error) => result.reject(error));
          for (const entry of entries)
            zipFile.addFile(entry.value, entry.name);
          zipFile.end();
          const zipFileName = state.traceFile + ".zip";
          zipFile.outputStream.pipe(_fs.default.createWriteStream(zipFileName)).on("close", () => {
            const artifact = new _artifact.Artifact(this._context, zipFileName);
            artifact.reportFinished();
            result.resolve(artifact);
          });
          return result;
        });
      }
      _captureSnapshot(name, sdkObject, metadata, element) {
        return __async(this, null, function* () {
          if (!this._snapshotter)
            return;
          if (!sdkObject.attribution.page)
            return;
          if (!this._snapshotter.started())
            return;
          if (!shouldCaptureSnapshot(metadata))
            return;
          const snapshotName = `${name}@${metadata.id}`;
          metadata.snapshots.push({
            title: name,
            snapshotName
          });
          if (!element && sdkObject instanceof _dom.ElementHandle)
            element = sdkObject;
          yield this._snapshotter.captureSnapshot(sdkObject.attribution.page, snapshotName, element).catch(() => {
          });
        });
      }
      onBeforeCall(sdkObject, metadata) {
        return __async(this, null, function* () {
          var _sdkObject$attributio, _this$_state2;
          (_sdkObject$attributio = sdkObject.attribution.page) === null || _sdkObject$attributio === void 0 ? void 0 : _sdkObject$attributio.temporarlyDisableTracingScreencastThrottling();
          metadata.afterSnapshot = `after@${metadata.id}`;
          const beforeSnapshot = this._captureSnapshot("before", sdkObject, metadata);
          this._pendingCalls.set(metadata.id, {
            sdkObject,
            metadata,
            beforeSnapshot
          });
          if ((_this$_state2 = this._state) !== null && _this$_state2 !== void 0 && _this$_state2.options.sources) {
            for (const frame of metadata.stack || [])
              this._state.sources.add(frame.file);
          }
          yield beforeSnapshot;
        });
      }
      onBeforeInputAction(sdkObject, metadata, element) {
        return __async(this, null, function* () {
          var _sdkObject$attributio2;
          (_sdkObject$attributio2 = sdkObject.attribution.page) === null || _sdkObject$attributio2 === void 0 ? void 0 : _sdkObject$attributio2.temporarlyDisableTracingScreencastThrottling();
          const actionSnapshot = this._captureSnapshot("action", sdkObject, metadata, element);
          this._pendingCalls.get(metadata.id).actionSnapshot = actionSnapshot;
          yield actionSnapshot;
        });
      }
      onAfterCall(sdkObject, metadata) {
        return __async(this, null, function* () {
          var _sdkObject$attributio3;
          (_sdkObject$attributio3 = sdkObject.attribution.page) === null || _sdkObject$attributio3 === void 0 ? void 0 : _sdkObject$attributio3.temporarlyDisableTracingScreencastThrottling();
          const pendingCall = this._pendingCalls.get(metadata.id);
          if (!pendingCall || pendingCall.afterSnapshot)
            return;
          if (!sdkObject.attribution.context) {
            this._pendingCalls.delete(metadata.id);
            return;
          }
          pendingCall.afterSnapshot = this._captureSnapshot("after", sdkObject, metadata);
          yield pendingCall.afterSnapshot;
          const event = {
            type: "action",
            metadata
          };
          this._appendTraceEvent(event);
          this._pendingCalls.delete(metadata.id);
        });
      }
      onEvent(sdkObject, metadata) {
        if (!sdkObject.attribution.context)
          return;
        const event = {
          type: "event",
          metadata
        };
        this._appendTraceEvent(event);
      }
      onEntryStarted(entry) {
      }
      onEntryFinished(entry) {
        const event = {
          type: "resource-snapshot",
          snapshot: entry
        };
        this._appendTraceOperation(() => __async(this, null, function* () {
          visitSha1s(event, this._state.networkSha1s);
          yield _fs.default.promises.appendFile(this._state.networkFile, JSON.stringify(event) + "\n");
        }));
      }
      onContentBlob(sha1, buffer) {
        this._appendResource(sha1, buffer);
      }
      onSnapshotterBlob(blob) {
        this._appendResource(blob.sha1, blob.buffer);
      }
      onFrameSnapshot(snapshot) {
        this._appendTraceEvent({
          type: "frame-snapshot",
          snapshot
        });
      }
      _startScreencastInPage(page) {
        page.setScreencastOptions(kScreencastOptions);
        const prefix = page.guid;
        let frameSeq = 0;
        this._screencastListeners.push(_eventsHelper.eventsHelper.addEventListener(page, _page.Page.Events.ScreencastFrame, (params) => {
          const suffix = String(++frameSeq).padStart(10, "0");
          const sha1 = `${prefix}-${suffix}.jpeg`;
          const event = {
            type: "screencast-frame",
            pageId: page.guid,
            sha1,
            width: params.width,
            height: params.height,
            timestamp: (0, _utils.monotonicTime)()
          };
          this._appendResource(sha1, params.buffer);
          this._appendTraceEvent(event);
        }));
      }
      _appendTraceEvent(event) {
        this._appendTraceOperation(() => __async(this, null, function* () {
          visitSha1s(event, this._state.traceSha1s);
          yield _fs.default.promises.appendFile(this._state.traceFile, JSON.stringify(event) + "\n");
        }));
      }
      _appendResource(sha1, buffer) {
        if (this._allResources.has(sha1))
          return;
        this._allResources.add(sha1);
        const resourcePath = _path.default.join(this._state.resourcesDir, sha1);
        this._appendTraceOperation(() => __async(this, null, function* () {
          try {
            yield _fs.default.promises.access(resourcePath);
          } catch (e) {
            yield _fs.default.promises.writeFile(resourcePath, buffer).catch(() => {
            });
          }
        }));
      }
      _appendTraceOperation(cb) {
        return __async(this, null, function* () {
          let error;
          let result;
          this._writeChain = this._writeChain.then(() => __async(this, null, function* () {
            if (this._context instanceof _browserContext.BrowserContext && !this._context._browser.isConnected())
              return;
            try {
              result = yield cb();
            } catch (e) {
              error = e;
            }
          }));
          yield this._writeChain;
          if (error)
            throw error;
          return result;
        });
      }
    };
    exports2.Tracing = Tracing;
    Tracing.Events = {
      Dispose: "dispose"
    };
    function visitSha1s(object, sha1s) {
      if (Array.isArray(object)) {
        object.forEach((o) => visitSha1s(o, sha1s));
        return;
      }
      if (typeof object === "object") {
        for (const key in object) {
          if (key === "sha1" || key === "_sha1" || key.endsWith("Sha1")) {
            const sha1 = object[key];
            if (sha1)
              sha1s.add(sha1);
          }
          visitSha1s(object[key], sha1s);
        }
        return;
      }
    }
    function shouldCaptureSnapshot(metadata) {
      return _channels.commandsWithTracingSnapshots.has(metadata.type + "." + metadata.method);
    }
  }
});

// node_modules/playwright-core/lib/server/har/harRecorder.js
var require_harRecorder = __commonJS({
  "node_modules/playwright-core/lib/server/har/harRecorder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.HarRecorder = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var _artifact = require_artifact();
    var _harTracer = require_harTracer();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var HarRecorder = class {
      constructor(context, options) {
        this._artifact = void 0;
        this._isFlushed = false;
        this._options = void 0;
        this._tracer = void 0;
        this._entries = [];
        this._artifact = new _artifact.Artifact(context, options.path);
        this._options = options;
        this._tracer = new _harTracer.HarTracer(context, this, {
          content: options.omitContent ? "omit" : "embedded",
          waitForContentOnStop: true,
          skipScripts: false
        });
        this._tracer.start();
      }
      onEntryStarted(entry) {
        this._entries.push(entry);
      }
      onEntryFinished(entry) {
      }
      onContentBlob(sha1, buffer) {
      }
      flush() {
        return __async(this, null, function* () {
          if (this._isFlushed)
            return;
          this._isFlushed = true;
          yield this._tracer.flush();
          const log = this._tracer.stop();
          log.entries = this._entries;
          yield _fs.default.promises.writeFile(this._options.path, JSON.stringify({
            log
          }, void 0, 2));
        });
      }
      export() {
        return __async(this, null, function* () {
          yield this.flush();
          this._artifact.reportFinished();
          return this._artifact;
        });
      }
    };
    exports2.HarRecorder = HarRecorder;
  }
});

// node_modules/playwright-core/lib/server/recorder/codeGenerator.js
var require_codeGenerator = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/codeGenerator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CodeGenerator = void 0;
    var _events = require("events");
    var CodeGenerator = class extends _events.EventEmitter {
      constructor(browserName, generateHeaders, launchOptions, contextOptions, deviceName, saveStorage) {
        super();
        this._currentAction = null;
        this._lastAction = null;
        this._actions = [];
        this._enabled = void 0;
        this._options = void 0;
        launchOptions = __spreadValues({
          headless: false
        }, launchOptions);
        contextOptions = __spreadValues({}, contextOptions);
        this._enabled = generateHeaders;
        this._options = {
          browserName,
          generateHeaders,
          launchOptions,
          contextOptions,
          deviceName,
          saveStorage
        };
        this.restart();
      }
      restart() {
        this._currentAction = null;
        this._lastAction = null;
        this._actions = [];
        this.emit("change");
      }
      setEnabled(enabled) {
        this._enabled = enabled;
      }
      addAction(action) {
        if (!this._enabled)
          return;
        this.willPerformAction(action);
        this.didPerformAction(action);
      }
      willPerformAction(action) {
        if (!this._enabled)
          return;
        this._currentAction = action;
      }
      performedActionFailed(action) {
        if (!this._enabled)
          return;
        if (this._currentAction === action)
          this._currentAction = null;
      }
      didPerformAction(actionInContext) {
        if (!this._enabled)
          return;
        const action = actionInContext.action;
        let eraseLastAction = false;
        if (this._lastAction && this._lastAction.frame.pageAlias === actionInContext.frame.pageAlias) {
          const lastAction = this._lastAction.action;
          if (this._lastAction && action.name === "fill" && lastAction.name === "fill") {
            if (action.selector === lastAction.selector)
              eraseLastAction = true;
          }
          if (lastAction && action.name === "click" && lastAction.name === "click") {
            if (action.selector === lastAction.selector && action.clickCount > lastAction.clickCount)
              eraseLastAction = true;
          }
          if (lastAction && action.name === "navigate" && lastAction.name === "navigate") {
            if (action.url === lastAction.url) {
              this._currentAction = null;
              return;
            }
          }
          if (lastAction && (action.name === "check" || action.name === "uncheck") && lastAction.name === "click") {
            if (action.selector === lastAction.selector)
              eraseLastAction = true;
          }
        }
        this._lastAction = actionInContext;
        this._currentAction = null;
        if (eraseLastAction)
          this._actions.pop();
        this._actions.push(actionInContext);
        this.emit("change");
      }
      commitLastAction() {
        if (!this._enabled)
          return;
        const action = this._lastAction;
        if (action)
          action.committed = true;
      }
      signal(pageAlias, frame, signal) {
        if (!this._enabled)
          return;
        if (this._currentAction) {
          this._currentAction.action.signals.push(signal);
          return;
        }
        if (this._lastAction && !this._lastAction.committed) {
          const signals = this._lastAction.action.signals;
          if (signal.name === "navigation" && signals.length && signals[signals.length - 1].name === "download")
            return;
          if (signal.name === "download" && signals.length && signals[signals.length - 1].name === "navigation")
            signals.length = signals.length - 1;
          signal.isAsync = true;
          this._lastAction.action.signals.push(signal);
          this.emit("change");
          return;
        }
        if (signal.name === "navigation") {
          this.addAction({
            frame: {
              pageAlias,
              isMainFrame: frame._page.mainFrame() === frame,
              url: frame.url()
            },
            committed: true,
            action: {
              name: "navigate",
              url: frame.url(),
              signals: []
            }
          });
        }
      }
      generateText(languageGenerator) {
        const text = [];
        if (this._options.generateHeaders)
          text.push(languageGenerator.generateHeader(this._options));
        for (const action of this._actions) {
          const actionText = languageGenerator.generateAction(action);
          if (actionText)
            text.push(actionText);
        }
        if (this._options.generateHeaders)
          text.push(languageGenerator.generateFooter(this._options.saveStorage));
        return text.join("\n");
      }
    };
    exports2.CodeGenerator = CodeGenerator;
  }
});

// node_modules/playwright-core/lib/server/recorder/utils.js
var require_utils3 = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.toClickOptions = toClickOptions;
    exports2.toModifiers = toModifiers;
    function toClickOptions(action) {
      let method = "click";
      if (action.clickCount === 2)
        method = "dblclick";
      const modifiers = toModifiers(action.modifiers);
      const options = {};
      if (action.button !== "left")
        options.button = action.button;
      if (modifiers.length)
        options.modifiers = modifiers;
      if (action.clickCount > 2)
        options.clickCount = action.clickCount;
      if (action.position)
        options.position = action.position;
      return {
        method,
        options
      };
    }
    function toModifiers(modifiers) {
      const result = [];
      if (modifiers & 1)
        result.push("Alt");
      if (modifiers & 2)
        result.push("Control");
      if (modifiers & 4)
        result.push("Meta");
      if (modifiers & 8)
        result.push("Shift");
      return result;
    }
  }
});

// node_modules/playwright-core/lib/server/recorder/language.js
var require_language = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/language.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.sanitizeDeviceOptions = sanitizeDeviceOptions;
    exports2.toSignalMap = toSignalMap;
    function sanitizeDeviceOptions(device, options) {
      const cleanedOptions = {};
      for (const property in options) {
        if (JSON.stringify(device[property]) !== JSON.stringify(options[property]))
          cleanedOptions[property] = options[property];
      }
      return cleanedOptions;
    }
    function toSignalMap(action) {
      let waitForNavigation;
      let assertNavigation;
      let popup;
      let download;
      let dialog;
      for (const signal of action.signals) {
        if (signal.name === "navigation" && signal.isAsync)
          waitForNavigation = signal;
        else if (signal.name === "navigation" && !signal.isAsync)
          assertNavigation = signal;
        else if (signal.name === "popup")
          popup = signal;
        else if (signal.name === "download")
          download = signal;
        else if (signal.name === "dialog")
          dialog = signal;
      }
      return {
        waitForNavigation,
        assertNavigation,
        popup,
        download,
        dialog
      };
    }
  }
});

// node_modules/playwright-core/lib/server/recorder/recorderActions.js
var require_recorderActions = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/recorderActions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.actionTitle = actionTitle;
    function actionTitle(action) {
      switch (action.name) {
        case "openPage":
          return `Open new page`;
        case "closePage":
          return `Close page`;
        case "check":
          return `Check ${action.selector}`;
        case "uncheck":
          return `Uncheck ${action.selector}`;
        case "click": {
          if (action.clickCount === 1)
            return `Click ${action.selector}`;
          if (action.clickCount === 2)
            return `Double click ${action.selector}`;
          if (action.clickCount === 3)
            return `Triple click ${action.selector}`;
          return `${action.clickCount}\xD7 click`;
        }
        case "fill":
          return `Fill ${action.selector}`;
        case "setInputFiles":
          if (action.files.length === 0)
            return `Clear selected files`;
          else
            return `Upload ${action.files.join(", ")}`;
        case "navigate":
          return `Go to ${action.url}`;
        case "press":
          return `Press ${action.key}` + (action.modifiers ? " with modifiers" : "");
        case "select":
          return `Select ${action.options.join(", ")}`;
      }
    }
  }
});

// node_modules/playwright-core/lib/server/deviceDescriptorsSource.json
var require_deviceDescriptorsSource = __commonJS({
  "node_modules/playwright-core/lib/server/deviceDescriptorsSource.json"(exports2, module2) {
    module2.exports = {
      "Blackberry PlayBook": {
        userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/15.4 Safari/536.2+",
        viewport: {
          width: 600,
          height: 1024
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Blackberry PlayBook landscape": {
        userAgent: "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/15.4 Safari/536.2+",
        viewport: {
          width: 1024,
          height: 600
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "BlackBerry Z30": {
        userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/15.4 Mobile Safari/537.10+",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "BlackBerry Z30 landscape": {
        userAgent: "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/15.4 Mobile Safari/537.10+",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy Note 3": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/15.4 Mobile Safari/534.30",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy Note 3 landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/15.4 Mobile Safari/534.30",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy Note II": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/15.4 Mobile Safari/534.30",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy Note II landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/15.4 Mobile Safari/534.30",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy S III": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/15.4 Mobile Safari/534.30",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy S III landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/15.4 Mobile Safari/534.30",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Galaxy S5": {
        userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S5 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S8": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 740
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S8 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; SM-G950U Build/NRD90M) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 740,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S9+": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 320,
          height: 658
        },
        deviceScaleFactor: 4.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy S9+ landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; SM-G965U Build/R16NW) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 658,
          height: 320
        },
        deviceScaleFactor: 4.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy Tab S4": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Safari/537.36",
        viewport: {
          width: 712,
          height: 1138
        },
        deviceScaleFactor: 2.25,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Galaxy Tab S4 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.1.0; SM-T837A) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Safari/537.36",
        viewport: {
          width: 1138,
          height: 712
        },
        deviceScaleFactor: 2.25,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "iPad (gen 6)": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 768,
          height: 1024
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad (gen 6) landscape": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1024,
          height: 768
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad (gen 7)": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 810,
          height: 1080
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad (gen 7) landscape": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1080,
          height: 810
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad Mini": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 768,
          height: 1024
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad Mini landscape": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1024,
          height: 768
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad Pro 11": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 834,
          height: 1194
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPad Pro 11 landscape": {
        userAgent: "Mozilla/5.0 (iPad; CPU OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 1194,
          height: 834
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 6": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 667
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 6 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 667,
          height: 375
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 6 Plus": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 414,
          height: 736
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 6 Plus landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 736,
          height: 414
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 7": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 667
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 7 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 667,
          height: 375
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 7 Plus": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 414,
          height: 736
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 7 Plus landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 736,
          height: 414
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 8": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 667
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 8 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 667,
          height: 375
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 8 Plus": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 414,
          height: 736
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 8 Plus landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 736,
          height: 414
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone SE": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/15.4 Mobile/14E304 Safari/602.1",
        viewport: {
          width: 320,
          height: 568
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone SE landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/15.4 Mobile/14E304 Safari/602.1",
        viewport: {
          width: 568,
          height: 320
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone X": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 375,
          height: 812
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone X landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/15.4 Mobile/15A372 Safari/604.1",
        viewport: {
          width: 812,
          height: 375
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone XR": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 414,
          height: 896
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone XR landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        viewport: {
          width: 896,
          height: 414
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 414,
          height: 896
        },
        viewport: {
          width: 414,
          height: 715
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 414,
          height: 896
        },
        viewport: {
          width: 800,
          height: 364
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 Pro": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 375,
          height: 635
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 Pro landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 724,
          height: 325
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 Pro Max": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 414,
          height: 896
        },
        viewport: {
          width: 414,
          height: 715
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 11 Pro Max landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 12_2 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 414,
          height: 896
        },
        viewport: {
          width: 808,
          height: 364
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 390,
          height: 664
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 750,
          height: 340
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Pro": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 390,
          height: 664
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Pro landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 750,
          height: 340
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Pro Max": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 428,
          height: 926
        },
        viewport: {
          width: 428,
          height: 746
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Pro Max landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 428,
          height: 926
        },
        viewport: {
          width: 832,
          height: 378
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Mini": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 375,
          height: 629
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 12 Mini landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 14_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 712,
          height: 325
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 390,
          height: 664
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 750,
          height: 342
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Pro": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 390,
          height: 664
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Pro landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 390,
          height: 844
        },
        viewport: {
          width: 750,
          height: 342
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Pro Max": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 428,
          height: 926
        },
        viewport: {
          width: 428,
          height: 746
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Pro Max landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 428,
          height: 926
        },
        viewport: {
          width: 832,
          height: 380
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Mini": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 375,
          height: 629
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "iPhone 13 Mini landscape": {
        userAgent: "Mozilla/5.0 (iPhone; CPU iPhone OS 15_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Mobile/15E148 Safari/604.1",
        screen: {
          width: 375,
          height: 812
        },
        viewport: {
          width: 712,
          height: 327
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "JioPhone 2": {
        userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:98.0.2) Gecko/48.0 Firefox/98.0.2 KAIOS/2.5",
        viewport: {
          width: 240,
          height: 320
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "firefox"
      },
      "JioPhone 2 landscape": {
        userAgent: "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:98.0.2) Gecko/48.0 Firefox/98.0.2 KAIOS/2.5",
        viewport: {
          width: 320,
          height: 240
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "firefox"
      },
      "Kindle Fire HDX": {
        userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
        viewport: {
          width: 800,
          height: 1280
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Kindle Fire HDX landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
        viewport: {
          width: 1280,
          height: 800
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "LG Optimus L70": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 384,
          height: 640
        },
        deviceScaleFactor: 1.25,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "LG Optimus L70 landscape": {
        userAgent: "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 384
        },
        deviceScaleFactor: 1.25,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Microsoft Lumia 550": {
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Microsoft Lumia 550 landscape": {
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Microsoft Lumia 950": {
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 4,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Microsoft Lumia 950 landscape": {
        userAgent: "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36 Edge/14.14263",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 4,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 10": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Safari/537.36",
        viewport: {
          width: 800,
          height: 1280
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 10 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Safari/537.36",
        viewport: {
          width: 1280,
          height: 800
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 4": {
        userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 384,
          height: 640
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 4 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 384
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 5": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 5 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 5X": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 412,
          height: 732
        },
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 5X landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 732,
          height: 412
        },
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 6": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 412,
          height: 732
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 6 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 732,
          height: 412
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 6P": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 412,
          height: 732
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 6P landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 732,
          height: 412
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 7": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Safari/537.36",
        viewport: {
          width: 600,
          height: 960
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nexus 7 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Safari/537.36",
        viewport: {
          width: 960,
          height: 600
        },
        deviceScaleFactor: 2,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nokia Lumia 520": {
        userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
        viewport: {
          width: 320,
          height: 533
        },
        deviceScaleFactor: 1.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nokia Lumia 520 landscape": {
        userAgent: "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
        viewport: {
          width: 533,
          height: 320
        },
        deviceScaleFactor: 1.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Nokia N9": {
        userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
        viewport: {
          width: 480,
          height: 854
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Nokia N9 landscape": {
        userAgent: "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
        viewport: {
          width: 854,
          height: 480
        },
        deviceScaleFactor: 1,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "webkit"
      },
      "Pixel 2": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 411,
          height: 731
        },
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 2 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 731,
          height: 411
        },
        deviceScaleFactor: 2.625,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 2 XL": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 411,
          height: 823
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 2 XL landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 823,
          height: 411
        },
        deviceScaleFactor: 3.5,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 3": {
        userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 393,
          height: 786
        },
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 3 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 9; Pixel 3 Build/PQ1A.181105.017.A1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 786,
          height: 393
        },
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 4": {
        userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 353,
          height: 745
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 4 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 10; Pixel 4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 745,
          height: 353
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 4a (5G)": {
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        screen: {
          width: 412,
          height: 892
        },
        viewport: {
          width: 412,
          height: 765
        },
        deviceScaleFactor: 2.63,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 4a (5G) landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 4a (5G)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        screen: {
          height: 892,
          width: 412
        },
        viewport: {
          width: 840,
          height: 312
        },
        deviceScaleFactor: 2.63,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 5": {
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        screen: {
          width: 393,
          height: 851
        },
        viewport: {
          width: 393,
          height: 727
        },
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Pixel 5 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 11; Pixel 5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        screen: {
          width: 851,
          height: 393
        },
        viewport: {
          width: 802,
          height: 293
        },
        deviceScaleFactor: 2.75,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Moto G4": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 360,
          height: 640
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Moto G4 landscape": {
        userAgent: "Mozilla/5.0 (Linux; Android 7.0; Moto G (4)) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Mobile Safari/537.36",
        viewport: {
          width: 640,
          height: 360
        },
        deviceScaleFactor: 3,
        isMobile: true,
        hasTouch: true,
        defaultBrowserType: "chromium"
      },
      "Desktop Chrome HiDPI": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Safari/537.36",
        screen: {
          width: 1792,
          height: 1120
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 2,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "chromium"
      },
      "Desktop Edge HiDPI": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Safari/537.36 Edg/101.0.4951.15",
        screen: {
          width: 1792,
          height: 1120
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 2,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "chromium"
      },
      "Desktop Firefox HiDPI": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:98.0.2) Gecko/20100101 Firefox/98.0.2",
        screen: {
          width: 1792,
          height: 1120
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 2,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "firefox"
      },
      "Desktop Safari": {
        userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Safari/605.1.15",
        screen: {
          width: 1792,
          height: 1120
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 2,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "webkit"
      },
      "Desktop Chrome": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Safari/537.36",
        screen: {
          width: 1920,
          height: 1080
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 1,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "chromium"
      },
      "Desktop Edge": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.15 Safari/537.36 Edg/101.0.4951.15",
        screen: {
          width: 1920,
          height: 1080
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 1,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "chromium"
      },
      "Desktop Firefox": {
        userAgent: "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:98.0.2) Gecko/20100101 Firefox/98.0.2",
        screen: {
          width: 1920,
          height: 1080
        },
        viewport: {
          width: 1280,
          height: 720
        },
        deviceScaleFactor: 1,
        isMobile: false,
        hasTouch: false,
        defaultBrowserType: "firefox"
      }
    };
  }
});

// node_modules/playwright-core/lib/server/deviceDescriptors.js
var require_deviceDescriptors = __commonJS({
  "node_modules/playwright-core/lib/server/deviceDescriptors.js"(exports2, module2) {
    module2.exports = require_deviceDescriptorsSource();
  }
});

// node_modules/playwright-core/lib/utils/isomorphic/stringUtils.js
var require_stringUtils = __commonJS({
  "node_modules/playwright-core/lib/utils/isomorphic/stringUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.escapeWithQuotes = escapeWithQuotes;
    function escapeWithQuotes(text, char = "'") {
      const stringified = JSON.stringify(text);
      const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\"/g, '"');
      if (char === "'")
        return char + escapedText.replace(/[']/g, "\\'") + char;
      if (char === '"')
        return char + escapedText.replace(/["]/g, '\\"') + char;
      if (char === "`")
        return char + escapedText.replace(/[`]/g, "`") + char;
      throw new Error("Invalid escape char");
    }
  }
});

// node_modules/playwright-core/lib/server/recorder/javascript.js
var require_javascript2 = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/javascript.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JavaScriptLanguageGenerator = exports2.JavaScriptFormatter = void 0;
    var _language = require_language();
    var _recorderActions = require_recorderActions();
    var _utils = require_utils3();
    var _deviceDescriptors = _interopRequireDefault(require_deviceDescriptors());
    var _stringUtils = require_stringUtils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var JavaScriptLanguageGenerator = class {
      constructor(isTest) {
        this.id = void 0;
        this.fileName = void 0;
        this.highlighter = "javascript";
        this._isTest = void 0;
        this.id = isTest ? "test" : "javascript";
        this.fileName = isTest ? "Playwright Test" : "JavaScript";
        this._isTest = isTest;
      }
      generateAction(actionInContext) {
        const action = actionInContext.action;
        if (this._isTest && (action.name === "openPage" || action.name === "closePage"))
          return "";
        const pageAlias = actionInContext.frame.pageAlias;
        const formatter = new JavaScriptFormatter(2);
        formatter.newLine();
        formatter.add("// " + (0, _recorderActions.actionTitle)(action));
        if (action.name === "openPage") {
          formatter.add(`const ${pageAlias} = await context.newPage();`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`await ${pageAlias}.goto(${quote(action.url)});`);
          return formatter.format();
        }
        let subject;
        if (actionInContext.frame.isMainFrame) {
          subject = pageAlias;
        } else if (actionInContext.frame.selectorsChain && action.name !== "navigate") {
          const locators = actionInContext.frame.selectorsChain.map((selector) => "." + asLocator(selector, "frameLocator"));
          subject = `${pageAlias}${locators.join("")}`;
        } else if (actionInContext.frame.name) {
          subject = `${pageAlias}.frame(${formatObject({
            name: actionInContext.frame.name
          })})`;
        } else {
          subject = `${pageAlias}.frame(${formatObject({
            url: actionInContext.frame.url
          })})`;
        }
        const signals = (0, _language.toSignalMap)(action);
        if (signals.dialog) {
          formatter.add(`  ${pageAlias}.once('dialog', dialog => {
    console.log(\`Dialog message: \${dialog.message()}\`);
    dialog.dismiss().catch(() => {});
  });`);
        }
        const emitPromiseAll = signals.waitForNavigation || signals.popup || signals.download;
        if (emitPromiseAll) {
          let leftHandSide = "";
          if (signals.popup)
            leftHandSide = `const [${signals.popup.popupAlias}] = `;
          else if (signals.download)
            leftHandSide = `const [download] = `;
          formatter.add(`${leftHandSide}await Promise.all([`);
        }
        if (signals.popup)
          formatter.add(`${pageAlias}.waitForEvent('popup'),`);
        if (signals.waitForNavigation)
          formatter.add(`${pageAlias}.waitForNavigation(/*{ url: ${quote(signals.waitForNavigation.url)} }*/),`);
        if (signals.download)
          formatter.add(`${pageAlias}.waitForEvent('download'),`);
        const prefix = signals.popup || signals.waitForNavigation || signals.download ? "" : "await ";
        const actionCall = this._generateActionCall(action);
        const suffix = signals.waitForNavigation || emitPromiseAll ? "" : ";";
        formatter.add(`${prefix}${subject}.${actionCall}${suffix}`);
        if (emitPromiseAll) {
          formatter.add(`]);`);
        } else if (signals.assertNavigation) {
          if (this._isTest)
            formatter.add(`  await expect(${pageAlias}).toHaveURL(${quote(signals.assertNavigation.url)});`);
          else
            formatter.add(`  // assert.equal(${pageAlias}.url(), ${quote(signals.assertNavigation.url)});`);
        }
        return formatter.format();
      }
      _generateActionCall(action) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "close()";
          case "click": {
            let method = "click";
            if (action.clickCount === 2)
              method = "dblclick";
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const options = {};
            if (action.button !== "left")
              options.button = action.button;
            if (modifiers.length)
              options.modifiers = modifiers;
            if (action.clickCount > 2)
              options.clickCount = action.clickCount;
            if (action.position)
              options.position = action.position;
            const optionsString = formatOptions(options, false);
            return asLocator(action.selector) + `.${method}(${optionsString})`;
          }
          case "check":
            return asLocator(action.selector) + `.check()`;
          case "uncheck":
            return asLocator(action.selector) + `.uncheck()`;
          case "fill":
            return asLocator(action.selector) + `.fill(${quote(action.text)})`;
          case "setInputFiles":
            return asLocator(action.selector) + `.setInputFiles(${formatObject(action.files.length === 1 ? action.files[0] : action.files)})`;
          case "press": {
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return asLocator(action.selector) + `.press(${quote(shortcut)})`;
          }
          case "navigate":
            return `goto(${quote(action.url)})`;
          case "select":
            return asLocator(action.selector) + `.selectOption(${formatObject(action.options.length > 1 ? action.options : action.options[0])})`;
        }
      }
      generateHeader(options) {
        if (this._isTest)
          return this.generateTestHeader(options);
        return this.generateStandaloneHeader(options);
      }
      generateFooter(saveStorage) {
        if (this._isTest)
          return this.generateTestFooter(saveStorage);
        return this.generateStandaloneFooter(saveStorage);
      }
      generateTestHeader(options) {
        const formatter = new JavaScriptFormatter();
        const useText = formatContextOptions(options.contextOptions, options.deviceName);
        formatter.add(`
      import { test, expect${options.deviceName ? ", devices" : ""} } from '@playwright/test';
${useText ? "\ntest.use(" + useText + ");\n" : ""}
      test('test', async ({ page }) => {`);
        return formatter.format();
      }
      generateTestFooter(saveStorage) {
        return `
});`;
      }
      generateStandaloneHeader(options) {
        const formatter = new JavaScriptFormatter();
        formatter.add(`
      const { ${options.browserName}${options.deviceName ? ", devices" : ""} } = require('playwright');

      (async () => {
        const browser = await ${options.browserName}.launch(${formatObjectOrVoid(options.launchOptions)});
        const context = await browser.newContext(${formatContextOptions(options.contextOptions, options.deviceName)});`);
        return formatter.format();
      }
      generateStandaloneFooter(saveStorage) {
        const storageStateLine = saveStorage ? `
  await context.storageState({ path: ${quote(saveStorage)} });` : "";
        return `
  // ---------------------${storageStateLine}
  await context.close();
  await browser.close();
})();`;
      }
    };
    exports2.JavaScriptLanguageGenerator = JavaScriptLanguageGenerator;
    function asLocator(selector, locatorFn = "locator") {
      const match = selector.match(/(.*)\s+>>\s+nth=(\d+)$/);
      if (!match)
        return `${locatorFn}(${quote(selector)})`;
      if (+match[2] === 0)
        return `${locatorFn}(${quote(match[1])}).first()`;
      return `${locatorFn}(${quote(match[1])}).nth(${match[2]})`;
    }
    function formatOptions(value, hasArguments) {
      const keys = Object.keys(value);
      if (!keys.length)
        return "";
      return (hasArguments ? ", " : "") + formatObject(value);
    }
    function formatObject(value, indent = "  ") {
      if (typeof value === "string")
        return quote(value);
      if (Array.isArray(value))
        return `[${value.map((o) => formatObject(o)).join(", ")}]`;
      if (typeof value === "object") {
        const keys = Object.keys(value);
        if (!keys.length)
          return "{}";
        const tokens = [];
        for (const key of keys)
          tokens.push(`${key}: ${formatObject(value[key])}`);
        return `{
${indent}${tokens.join(`,
${indent}`)}
}`;
      }
      return String(value);
    }
    function formatObjectOrVoid(value, indent = "  ") {
      const result = formatObject(value, indent);
      return result === "{}" ? "" : result;
    }
    function formatContextOptions(options, deviceName) {
      const device = deviceName && _deviceDescriptors.default[deviceName];
      if (!device)
        return formatObjectOrVoid(options);
      let serializedObject = formatObjectOrVoid((0, _language.sanitizeDeviceOptions)(device, options));
      if (!serializedObject)
        serializedObject = "{\n}";
      const lines = serializedObject.split("\n");
      lines.splice(1, 0, `...devices[${quote(deviceName)}],`);
      return lines.join("\n");
    }
    var JavaScriptFormatter = class {
      constructor(offset = 0) {
        this._baseIndent = void 0;
        this._baseOffset = void 0;
        this._lines = [];
        this._baseIndent = " ".repeat(2);
        this._baseOffset = " ".repeat(offset);
      }
      prepend(text) {
        this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
      }
      add(text) {
        this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
      }
      newLine() {
        this._lines.push("");
      }
      format() {
        let spaces = "";
        let previousLine = "";
        return this._lines.map((line) => {
          if (line === "")
            return line;
          if (line.startsWith("}") || line.startsWith("]"))
            spaces = spaces.substring(this._baseIndent.length);
          const extraSpaces = /^(for|while|if|try).*\(.*\)$/.test(previousLine) ? this._baseIndent : "";
          previousLine = line;
          const callCarryOver = line.startsWith(".set");
          line = spaces + extraSpaces + (callCarryOver ? this._baseIndent : "") + line;
          if (line.endsWith("{") || line.endsWith("["))
            spaces += this._baseIndent;
          return this._baseOffset + line;
        }).join("\n");
      }
    };
    exports2.JavaScriptFormatter = JavaScriptFormatter;
    function quote(text) {
      return (0, _stringUtils.escapeWithQuotes)(text, "'");
    }
  }
});

// node_modules/playwright-core/lib/server/recorder/java.js
var require_java = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/java.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JavaLanguageGenerator = void 0;
    var _language = require_language();
    var _recorderActions = require_recorderActions();
    var _utils = require_utils3();
    var _deviceDescriptors = _interopRequireDefault(require_deviceDescriptors());
    var _javascript = require_javascript2();
    var _stringUtils = require_stringUtils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var JavaLanguageGenerator = class {
      constructor() {
        this.id = "java";
        this.fileName = "Java";
        this.highlighter = "java";
      }
      generateAction(actionInContext) {
        const action = actionInContext.action;
        const pageAlias = actionInContext.frame.pageAlias;
        const formatter = new _javascript.JavaScriptFormatter(6);
        formatter.newLine();
        formatter.add("// " + (0, _recorderActions.actionTitle)(action));
        if (action.name === "openPage") {
          formatter.add(`Page ${pageAlias} = context.newPage();`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`${pageAlias}.navigate(${quote(action.url)});`);
          return formatter.format();
        }
        let subject;
        if (actionInContext.frame.isMainFrame) {
          subject = pageAlias;
        } else if (actionInContext.frame.selectorsChain && action.name !== "navigate") {
          const locators = actionInContext.frame.selectorsChain.map((selector) => "." + asLocator(selector, "frameLocator"));
          subject = `${pageAlias}${locators.join("")}`;
        } else if (actionInContext.frame.name) {
          subject = `${pageAlias}.frame(${quote(actionInContext.frame.name)})`;
        } else {
          subject = `${pageAlias}.frameByUrl(${quote(actionInContext.frame.url)})`;
        }
        const signals = (0, _language.toSignalMap)(action);
        if (signals.dialog) {
          formatter.add(`  ${pageAlias}.onceDialog(dialog -> {
        System.out.println(String.format("Dialog message: %s", dialog.message()));
        dialog.dismiss();
      });`);
        }
        const actionCall = this._generateActionCall(action);
        let code = `${subject}.${actionCall};`;
        if (signals.popup) {
          code = `Page ${signals.popup.popupAlias} = ${pageAlias}.waitForPopup(() -> {
        ${code}
      });`;
        }
        if (signals.download) {
          code = `Download download = ${pageAlias}.waitForDownload(() -> {
        ${code}
      });`;
        }
        if (signals.waitForNavigation) {
          code = `
      // ${pageAlias}.waitForNavigation(new Page.WaitForNavigationOptions().setUrl(${quote(signals.waitForNavigation.url)}), () ->
      ${pageAlias}.waitForNavigation(() -> {
        ${code}
      });`;
        }
        formatter.add(code);
        if (signals.assertNavigation)
          formatter.add(`// assertThat(${pageAlias}).hasURL(${quote(signals.assertNavigation.url)});`);
        return formatter.format();
      }
      _generateActionCall(action) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "close()";
          case "click": {
            let method = "click";
            if (action.clickCount === 2)
              method = "dblclick";
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const options = {};
            if (action.button !== "left")
              options.button = action.button;
            if (modifiers.length)
              options.modifiers = modifiers;
            if (action.clickCount > 2)
              options.clickCount = action.clickCount;
            if (action.position)
              options.position = action.position;
            const optionsText = formatClickOptions(options);
            return asLocator(action.selector) + `.${method}(${optionsText})`;
          }
          case "check":
            return asLocator(action.selector) + `.check()`;
          case "uncheck":
            return asLocator(action.selector) + `.uncheck()`;
          case "fill":
            return asLocator(action.selector) + `.fill(${quote(action.text)})`;
          case "setInputFiles":
            return asLocator(action.selector) + `.setInputFiles(${formatPath(action.files.length === 1 ? action.files[0] : action.files)})`;
          case "press": {
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return asLocator(action.selector) + `.press(${quote(shortcut)})`;
          }
          case "navigate":
            return `navigate(${quote(action.url)})`;
          case "select":
            return asLocator(action.selector) + `.selectOption(${formatSelectOption(action.options.length > 1 ? action.options : action.options[0])})`;
        }
      }
      generateHeader(options) {
        const formatter = new _javascript.JavaScriptFormatter();
        formatter.add(`
    import com.microsoft.playwright.*;
    import com.microsoft.playwright.options.*;
    import static com.microsoft.playwright.assertions.PlaywrightAssertions.assertThat;
    import java.util.*;

    public class Example {
      public static void main(String[] args) {
        try (Playwright playwright = Playwright.create()) {
          Browser browser = playwright.${options.browserName}().launch(${formatLaunchOptions(options.launchOptions)});
          BrowserContext context = browser.newContext(${formatContextOptions(options.contextOptions, options.deviceName)});`);
        return formatter.format();
      }
      generateFooter(saveStorage) {
        const storageStateLine = saveStorage ? `
      context.storageState(new BrowserContext.StorageStateOptions().setPath(${quote(saveStorage)}));
` : "";
        return `${storageStateLine}    }
  }
}`;
      }
    };
    exports2.JavaLanguageGenerator = JavaLanguageGenerator;
    function formatPath(files) {
      if (Array.isArray(files)) {
        if (files.length === 0)
          return "new Path[0]";
        return `new Path[] {${files.map((s) => "Paths.get(" + quote(s) + ")").join(", ")}}`;
      }
      return `Paths.get(${quote(files)})`;
    }
    function formatSelectOption(options) {
      if (Array.isArray(options)) {
        if (options.length === 0)
          return "new String[0]";
        return `new String[] {${options.map((s) => quote(s)).join(", ")}}`;
      }
      return quote(options);
    }
    function formatLaunchOptions(options) {
      const lines = [];
      if (!Object.keys(options).length)
        return "";
      lines.push("new BrowserType.LaunchOptions()");
      if (typeof options.headless === "boolean")
        lines.push(`  .setHeadless(false)`);
      if (options.channel)
        lines.push(`  .setChannel(${quote(options.channel)})`);
      return lines.join("\n");
    }
    function formatContextOptions(contextOptions, deviceName) {
      const lines = [];
      if (!Object.keys(contextOptions).length && !deviceName)
        return "";
      const device = deviceName ? _deviceDescriptors.default[deviceName] : {};
      const options = __spreadValues(__spreadValues({}, device), contextOptions);
      lines.push("new Browser.NewContextOptions()");
      if (options.acceptDownloads)
        lines.push(`  .setAcceptDownloads(true)`);
      if (options.bypassCSP)
        lines.push(`  .setBypassCSP(true)`);
      if (options.colorScheme)
        lines.push(`  .setColorScheme(ColorScheme.${options.colorScheme.toUpperCase()})`);
      if (options.deviceScaleFactor)
        lines.push(`  .setDeviceScaleFactor(${options.deviceScaleFactor})`);
      if (options.geolocation)
        lines.push(`  .setGeolocation(${options.geolocation.latitude}, ${options.geolocation.longitude})`);
      if (options.hasTouch)
        lines.push(`  .setHasTouch(${options.hasTouch})`);
      if (options.isMobile)
        lines.push(`  .setIsMobile(${options.isMobile})`);
      if (options.locale)
        lines.push(`  .setLocale(${quote(options.locale)})`);
      if (options.proxy)
        lines.push(`  .setProxy(new Proxy(${quote(options.proxy.server)}))`);
      if (options.storageState)
        lines.push(`  .setStorageStatePath(Paths.get(${quote(options.storageState)}))`);
      if (options.timezoneId)
        lines.push(`  .setTimezoneId(${quote(options.timezoneId)})`);
      if (options.userAgent)
        lines.push(`  .setUserAgent(${quote(options.userAgent)})`);
      if (options.viewport)
        lines.push(`  .setViewportSize(${options.viewport.width}, ${options.viewport.height})`);
      return lines.join("\n");
    }
    function formatClickOptions(options) {
      const lines = [];
      if (options.button)
        lines.push(`  .setButton(MouseButton.${options.button.toUpperCase()})`);
      if (options.modifiers)
        lines.push(`  .setModifiers(Arrays.asList(${options.modifiers.map((m) => `KeyboardModifier.${m.toUpperCase()}`).join(", ")}))`);
      if (options.clickCount)
        lines.push(`  .setClickCount(${options.clickCount})`);
      if (options.position)
        lines.push(`  .setPosition(${options.position.x}, ${options.position.y})`);
      if (!lines.length)
        return "";
      lines.unshift(`new Locator.ClickOptions()`);
      return lines.join("\n");
    }
    function quote(text) {
      return (0, _stringUtils.escapeWithQuotes)(text, '"');
    }
    function asLocator(selector, locatorFn = "locator") {
      const match = selector.match(/(.*)\s+>>\s+nth=(\d+)$/);
      if (!match)
        return `${locatorFn}(${quote(selector)})`;
      if (+match[2] === 0)
        return `${locatorFn}(${quote(match[1])}).first()`;
      return `${locatorFn}(${quote(match[1])}).nth(${match[2]})`;
    }
  }
});

// node_modules/playwright-core/lib/server/recorder/csharp.js
var require_csharp = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/csharp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CSharpLanguageGenerator = void 0;
    var _language = require_language();
    var _recorderActions = require_recorderActions();
    var _utils = require_utils3();
    var _stringUtils = require_stringUtils();
    var _deviceDescriptors = _interopRequireDefault(require_deviceDescriptors());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var CSharpLanguageGenerator = class {
      constructor() {
        this.id = "csharp";
        this.fileName = "C#";
        this.highlighter = "csharp";
      }
      generateAction(actionInContext) {
        const action = actionInContext.action;
        const pageAlias = actionInContext.frame.pageAlias;
        const formatter = new CSharpFormatter(8);
        formatter.newLine();
        formatter.add("// " + (0, _recorderActions.actionTitle)(action));
        if (action.name === "openPage") {
          formatter.add(`var ${pageAlias} = await context.NewPageAsync();`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`await ${pageAlias}.GotoAsync(${quote(action.url)});`);
          return formatter.format();
        }
        let subject;
        if (actionInContext.frame.isMainFrame) {
          subject = pageAlias;
        } else if (actionInContext.frame.selectorsChain && action.name !== "navigate") {
          const locators = actionInContext.frame.selectorsChain.map((selector) => "." + asLocator(selector, "FrameLocator"));
          subject = `${pageAlias}${locators.join("")}`;
        } else if (actionInContext.frame.name) {
          subject = `${pageAlias}.Frame(${quote(actionInContext.frame.name)})`;
        } else {
          subject = `${pageAlias}.FrameByUrl(${quote(actionInContext.frame.url)})`;
        }
        const signals = (0, _language.toSignalMap)(action);
        if (signals.dialog) {
          formatter.add(`    void ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler(object sender, IDialog dialog)
      {
          Console.WriteLine($"Dialog message: {dialog.Message}");
          dialog.DismissAsync();
          ${pageAlias}.Dialog -= ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler;
      }
      ${pageAlias}.Dialog += ${pageAlias}_Dialog${signals.dialog.dialogAlias}_EventHandler;`);
        }
        const lines = [];
        const actionCall = this._generateActionCall(action, actionInContext.frame.isMainFrame);
        if (signals.waitForNavigation) {
          lines.push(`await ${pageAlias}.RunAndWaitForNavigationAsync(async () =>`);
          lines.push(`{`);
          lines.push(`    await ${subject}.${actionCall};`);
          lines.push(`}/*, new ${actionInContext.frame.isMainFrame ? "Page" : "Frame"}WaitForNavigationOptions`);
          lines.push(`{`);
          lines.push(`    UrlString = ${quote(signals.waitForNavigation.url)}`);
          lines.push(`}*/);`);
        } else {
          lines.push(`await ${subject}.${actionCall};`);
        }
        if (signals.download) {
          lines.unshift(`var download${signals.download.downloadAlias} = await ${pageAlias}.RunAndWaitForDownloadAsync(async () =>
{`);
          lines.push(`});`);
        }
        if (signals.popup) {
          lines.unshift(`var ${signals.popup.popupAlias} = await ${pageAlias}.RunAndWaitForPopupAsync(async () =>
{`);
          lines.push(`});`);
        }
        for (const line of lines)
          formatter.add(line);
        if (signals.assertNavigation)
          formatter.add(`  // Assert.AreEqual(${quote(signals.assertNavigation.url)}, ${pageAlias}.Url);`);
        return formatter.format();
      }
      _generateActionCall(action, isPage) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "CloseAsync()";
          case "click": {
            let method = "Click";
            if (action.clickCount === 2)
              method = "DblClick";
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const options = {};
            if (action.button !== "left")
              options.button = action.button;
            if (modifiers.length)
              options.modifiers = modifiers;
            if (action.clickCount > 2)
              options.clickCount = action.clickCount;
            if (action.position)
              options.position = action.position;
            if (!Object.entries(options).length)
              return asLocator(action.selector) + `.${method}Async()`;
            const optionsString = formatObject(options, "    ", "Locator" + method + "Options");
            return asLocator(action.selector) + `.${method}Async(${optionsString})`;
          }
          case "check":
            return asLocator(action.selector) + `.CheckAsync()`;
          case "uncheck":
            return asLocator(action.selector) + `.UncheckAsync()`;
          case "fill":
            return asLocator(action.selector) + `.FillAsync(${quote(action.text)})`;
          case "setInputFiles":
            return asLocator(action.selector) + `.SetInputFilesAsync(${formatObject(action.files)})`;
          case "press": {
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return asLocator(action.selector) + `.PressAsync(${quote(shortcut)})`;
          }
          case "navigate":
            return `GotoAsync(${quote(action.url)})`;
          case "select":
            return asLocator(action.selector) + `.SelectOptionAsync(${formatObject(action.options)})`;
        }
      }
      generateHeader(options) {
        const formatter = new CSharpFormatter(0);
        formatter.add(`
      using Microsoft.Playwright;
      using System;
      using System.Threading.Tasks;

      class Program
      {
          public static async Task Main()
          {
              using var playwright = await Playwright.CreateAsync();
              await using var browser = await playwright.${toPascal(options.browserName)}.LaunchAsync(${formatObject(options.launchOptions, "    ", "BrowserTypeLaunchOptions")});
              var context = await browser.NewContextAsync(${formatContextOptions(options.contextOptions, options.deviceName)});`);
        return formatter.format();
      }
      generateFooter(saveStorage) {
        const storageStateLine = saveStorage ? `
        await context.StorageStateAsync(new BrowserContextStorageStateOptions
        {
            Path = ${quote(saveStorage)}
        });
` : "";
        return `${storageStateLine}    }
}
`;
      }
    };
    exports2.CSharpLanguageGenerator = CSharpLanguageGenerator;
    function formatObject(value, indent = "    ", name = "") {
      if (typeof value === "string") {
        if (["permissions", "colorScheme", "modifiers", "button"].includes(name))
          return `${getClassName(name)}.${toPascal(value)}`;
        return quote(value);
      }
      if (Array.isArray(value))
        return `new[] { ${value.map((o) => formatObject(o, indent, name)).join(", ")} }`;
      if (typeof value === "object") {
        const keys = Object.keys(value);
        if (!keys.length)
          return name ? `new ${getClassName(name)}` : "";
        const tokens = [];
        for (const key of keys) {
          const property = getPropertyName(key);
          tokens.push(`${property} = ${formatObject(value[key], indent, key)},`);
        }
        if (name)
          return `new ${getClassName(name)}
{
${indent}${tokens.join(`
${indent}`)}
${indent}}`;
        return `{
${indent}${tokens.join(`
${indent}`)}
${indent}}`;
      }
      if (name === "latitude" || name === "longitude")
        return String(value) + "m";
      return String(value);
    }
    function getClassName(value) {
      switch (value) {
        case "viewport":
          return "ViewportSize";
        case "proxy":
          return "ProxySettings";
        case "permissions":
          return "ContextPermission";
        case "modifiers":
          return "KeyboardModifier";
        case "button":
          return "MouseButton";
        default:
          return toPascal(value);
      }
    }
    function getPropertyName(key) {
      switch (key) {
        case "storageState":
          return "StorageStatePath";
        case "viewport":
          return "ViewportSize";
        default:
          return toPascal(key);
      }
    }
    function toPascal(value) {
      return value[0].toUpperCase() + value.slice(1);
    }
    function formatContextOptions(options, deviceName) {
      const device = deviceName && _deviceDescriptors.default[deviceName];
      if (!device) {
        if (!Object.entries(options).length)
          return "";
        return formatObject(options, "    ", "BrowserNewContextOptions");
      }
      options = (0, _language.sanitizeDeviceOptions)(device, options);
      if (!Object.entries(options).length)
        return `playwright.Devices[${quote(deviceName)}]`;
      return formatObject(options, "    ", `BrowserNewContextOptions(playwright.Devices[${quote(deviceName)}])`);
    }
    var CSharpFormatter = class {
      constructor(offset = 0) {
        this._baseIndent = void 0;
        this._baseOffset = void 0;
        this._lines = [];
        this._baseIndent = " ".repeat(4);
        this._baseOffset = " ".repeat(offset);
      }
      prepend(text) {
        this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
      }
      add(text) {
        this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
      }
      newLine() {
        this._lines.push("");
      }
      format() {
        let spaces = "";
        let previousLine = "";
        return this._lines.map((line) => {
          if (line === "")
            return line;
          if (line.startsWith("}") || line.startsWith("]") || line.includes("});") || line === ");")
            spaces = spaces.substring(this._baseIndent.length);
          const extraSpaces = /^(for|while|if).*\(.*\)$/.test(previousLine) ? this._baseIndent : "";
          previousLine = line;
          line = spaces + extraSpaces + line;
          if (line.endsWith("{") || line.endsWith("[") || line.endsWith("("))
            spaces += this._baseIndent;
          if (line.endsWith("));"))
            spaces = spaces.substring(this._baseIndent.length);
          return this._baseOffset + line;
        }).join("\n");
      }
    };
    function quote(text) {
      return (0, _stringUtils.escapeWithQuotes)(text, '"');
    }
    function asLocator(selector, locatorFn = "Locator") {
      const match = selector.match(/(.*)\s+>>\s+nth=(\d+)$/);
      if (!match)
        return `${locatorFn}(${quote(selector)})`;
      if (+match[2] === 0)
        return `${locatorFn}(${quote(match[1])}).First`;
      return `${locatorFn}(${quote(match[1])}).Nth(${match[2]})`;
    }
  }
});

// node_modules/playwright-core/lib/server/recorder/python.js
var require_python = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/python.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PythonLanguageGenerator = void 0;
    var _language = require_language();
    var _recorderActions = require_recorderActions();
    var _utils = require_utils3();
    var _stringUtils = require_stringUtils();
    var _deviceDescriptors = _interopRequireDefault(require_deviceDescriptors());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var PythonLanguageGenerator = class {
      constructor(isAsync) {
        this.id = "python";
        this.fileName = "Python";
        this.highlighter = "python";
        this._awaitPrefix = void 0;
        this._asyncPrefix = void 0;
        this._isAsync = void 0;
        this.id = isAsync ? "python-async" : "python";
        this.fileName = isAsync ? "Python Async" : "Python";
        this._isAsync = isAsync;
        this._awaitPrefix = isAsync ? "await " : "";
        this._asyncPrefix = isAsync ? "async " : "";
      }
      generateAction(actionInContext) {
        const action = actionInContext.action;
        const pageAlias = actionInContext.frame.pageAlias;
        const formatter = new PythonFormatter(4);
        formatter.newLine();
        formatter.add("# " + (0, _recorderActions.actionTitle)(action));
        if (action.name === "openPage") {
          formatter.add(`${pageAlias} = ${this._awaitPrefix}context.new_page()`);
          if (action.url && action.url !== "about:blank" && action.url !== "chrome://newtab/")
            formatter.add(`${this._awaitPrefix}${pageAlias}.goto(${quote(action.url)})`);
          return formatter.format();
        }
        let subject;
        if (actionInContext.frame.isMainFrame) {
          subject = pageAlias;
        } else if (actionInContext.frame.selectorsChain && action.name !== "navigate") {
          const locators = actionInContext.frame.selectorsChain.map((selector) => "." + asLocator(selector, "frame_locator"));
          subject = `${pageAlias}${locators.join("")}`;
        } else if (actionInContext.frame.name) {
          subject = `${pageAlias}.frame(${formatOptions({
            name: actionInContext.frame.name
          }, false)})`;
        } else {
          subject = `${pageAlias}.frame(${formatOptions({
            url: actionInContext.frame.url
          }, false)})`;
        }
        const signals = (0, _language.toSignalMap)(action);
        if (signals.dialog)
          formatter.add(`  ${pageAlias}.once("dialog", lambda dialog: dialog.dismiss())`);
        const actionCall = this._generateActionCall(action);
        let code = `${this._awaitPrefix}${subject}.${actionCall}`;
        if (signals.popup) {
          code = `${this._asyncPrefix}with ${pageAlias}.expect_popup() as popup_info {
        ${code}
      }
      ${signals.popup.popupAlias} = ${this._awaitPrefix}popup_info.value`;
        }
        if (signals.download) {
          code = `${this._asyncPrefix}with ${pageAlias}.expect_download() as download_info {
        ${code}
      }
      download = ${this._awaitPrefix}download_info.value`;
        }
        if (signals.waitForNavigation) {
          code = `
      # ${this._asyncPrefix}with ${pageAlias}.expect_navigation(url=${quote(signals.waitForNavigation.url)}):
      ${this._asyncPrefix}with ${pageAlias}.expect_navigation() {
        ${code}
      }`;
        }
        formatter.add(code);
        if (signals.assertNavigation)
          formatter.add(`  # ${this._awaitPrefix}expect(${pageAlias}).to_have_url(${quote(signals.assertNavigation.url)})`);
        return formatter.format();
      }
      _generateActionCall(action) {
        switch (action.name) {
          case "openPage":
            throw Error("Not reached");
          case "closePage":
            return "close()";
          case "click": {
            let method = "click";
            if (action.clickCount === 2)
              method = "dblclick";
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const options = {};
            if (action.button !== "left")
              options.button = action.button;
            if (modifiers.length)
              options.modifiers = modifiers;
            if (action.clickCount > 2)
              options.clickCount = action.clickCount;
            if (action.position)
              options.position = action.position;
            const optionsString = formatOptions(options, false);
            return asLocator(action.selector) + `.${method}(${optionsString})`;
          }
          case "check":
            return asLocator(action.selector) + `.check()`;
          case "uncheck":
            return asLocator(action.selector) + `.uncheck()`;
          case "fill":
            return asLocator(action.selector) + `.fill(${quote(action.text)})`;
          case "setInputFiles":
            return asLocator(action.selector) + `.set_input_files(${formatValue(action.files.length === 1 ? action.files[0] : action.files)})`;
          case "press": {
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            return asLocator(action.selector) + `.press(${quote(shortcut)})`;
          }
          case "navigate":
            return `goto(${quote(action.url)})`;
          case "select":
            return asLocator(action.selector) + `.select_option(${formatValue(action.options.length === 1 ? action.options[0] : action.options)})`;
        }
      }
      generateHeader(options) {
        const formatter = new PythonFormatter();
        if (this._isAsync) {
          formatter.add(`
import asyncio

from playwright.async_api import Playwright, async_playwright, expect


async def run(playwright: Playwright) -> None {
    browser = await playwright.${options.browserName}.launch(${formatOptions(options.launchOptions, false)})
    context = await browser.new_context(${formatContextOptions(options.contextOptions, options.deviceName)})`);
        } else {
          formatter.add(`
from playwright.sync_api import Playwright, sync_playwright, expect


def run(playwright: Playwright) -> None {
    browser = playwright.${options.browserName}.launch(${formatOptions(options.launchOptions, false)})
    context = browser.new_context(${formatContextOptions(options.contextOptions, options.deviceName)})`);
        }
        return formatter.format();
      }
      generateFooter(saveStorage) {
        if (this._isAsync) {
          const storageStateLine = saveStorage ? `
    await context.storage_state(path=${quote(saveStorage)})` : "";
          return `
    # ---------------------${storageStateLine}
    await context.close()
    await browser.close()


async def main() -> None:
    async with async_playwright() as playwright:
        await run(playwright)


asyncio.run(main())
`;
        } else {
          const storageStateLine = saveStorage ? `
    context.storage_state(path=${quote(saveStorage)})` : "";
          return `
    # ---------------------${storageStateLine}
    context.close()
    browser.close()


with sync_playwright() as playwright:
    run(playwright)
`;
        }
      }
    };
    exports2.PythonLanguageGenerator = PythonLanguageGenerator;
    function formatValue(value) {
      if (value === false)
        return "False";
      if (value === true)
        return "True";
      if (value === void 0)
        return "None";
      if (Array.isArray(value))
        return `[${value.map(formatValue).join(", ")}]`;
      if (typeof value === "string")
        return quote(value);
      if (typeof value === "object")
        return JSON.stringify(value);
      return String(value);
    }
    function toSnakeCase(name) {
      const toSnakeCaseRegex = /((?<=[a-z0-9])[A-Z]|(?!^)[A-Z](?=[a-z]))/g;
      return name.replace(toSnakeCaseRegex, `_$1`).toLowerCase();
    }
    function formatOptions(value, hasArguments) {
      const keys = Object.keys(value);
      if (!keys.length)
        return "";
      return (hasArguments ? ", " : "") + keys.map((key) => `${toSnakeCase(key)}=${formatValue(value[key])}`).join(", ");
    }
    function formatContextOptions(options, deviceName) {
      const device = deviceName && _deviceDescriptors.default[deviceName];
      if (!device)
        return formatOptions(options, false);
      return `**playwright.devices[${quote(deviceName)}]` + formatOptions((0, _language.sanitizeDeviceOptions)(device, options), true);
    }
    var PythonFormatter = class {
      constructor(offset = 0) {
        this._baseIndent = void 0;
        this._baseOffset = void 0;
        this._lines = [];
        this._baseIndent = " ".repeat(4);
        this._baseOffset = " ".repeat(offset);
      }
      prepend(text) {
        this._lines = text.trim().split("\n").map((line) => line.trim()).concat(this._lines);
      }
      add(text) {
        this._lines.push(...text.trim().split("\n").map((line) => line.trim()));
      }
      newLine() {
        this._lines.push("");
      }
      format() {
        let spaces = "";
        const lines = [];
        this._lines.forEach((line) => {
          if (line === "")
            return lines.push(line);
          if (line === "}") {
            spaces = spaces.substring(this._baseIndent.length);
            return;
          }
          line = spaces + line;
          if (line.endsWith("{")) {
            spaces += this._baseIndent;
            line = line.substring(0, line.length - 1).trimEnd() + ":";
          }
          return lines.push(this._baseOffset + line);
        });
        return lines.join("\n");
      }
    };
    function quote(text) {
      return (0, _stringUtils.escapeWithQuotes)(text, '"');
    }
    function asLocator(selector, locatorFn = "locator") {
      const match = selector.match(/(.*)\s+>>\s+nth=(\d+)$/);
      if (!match)
        return `${locatorFn}(${quote(selector)})`;
      if (+match[2] === 0)
        return `${locatorFn}(${quote(match[1])}).first`;
      return `${locatorFn}(${quote(match[1])}).nth(${match[2]})`;
    }
  }
});

// node_modules/playwright-core/lib/generated/recorderSource.js
var require_recorderSource = __commonJS({
  "node_modules/playwright-core/lib/generated/recorderSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.source = void 0;
    var source = 'var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === "object" || typeof from === "function") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));\n\n// packages/playwright-core/src/server/isomorphic/cssTokenizer.js\nvar require_cssTokenizer = __commonJS({\n  "packages/playwright-core/src/server/isomorphic/cssTokenizer.js"(exports2) {\n    (function(root, factory) {\n      if (typeof define === "function" && define.amd) {\n        define(["exports"], factory);\n      } else if (typeof exports2 !== "undefined") {\n        factory(exports2);\n      } else {\n        factory(root);\n      }\n    })(exports2, function(exports3) {\n      var between = function(num, first, last) {\n        return num >= first && num <= last;\n      };\n      function digit(code) {\n        return between(code, 48, 57);\n      }\n      function hexdigit(code) {\n        return digit(code) || between(code, 65, 70) || between(code, 97, 102);\n      }\n      function uppercaseletter(code) {\n        return between(code, 65, 90);\n      }\n      function lowercaseletter(code) {\n        return between(code, 97, 122);\n      }\n      function letter(code) {\n        return uppercaseletter(code) || lowercaseletter(code);\n      }\n      function nonascii(code) {\n        return code >= 128;\n      }\n      function namestartchar(code) {\n        return letter(code) || nonascii(code) || code == 95;\n      }\n      function namechar(code) {\n        return namestartchar(code) || digit(code) || code == 45;\n      }\n      function nonprintable(code) {\n        return between(code, 0, 8) || code == 11 || between(code, 14, 31) || code == 127;\n      }\n      function newline(code) {\n        return code == 10;\n      }\n      function whitespace(code) {\n        return newline(code) || code == 9 || code == 32;\n      }\n      function badescape(code) {\n        return newline(code) || isNaN(code);\n      }\n      var maximumallowedcodepoint = 1114111;\n      var InvalidCharacterError = function(message) {\n        this.message = message;\n      };\n      InvalidCharacterError.prototype = new Error();\n      InvalidCharacterError.prototype.name = "InvalidCharacterError";\n      function preprocess(str) {\n        var codepoints = [];\n        for (var i = 0; i < str.length; i++) {\n          var code = str.charCodeAt(i);\n          if (code == 13 && str.charCodeAt(i + 1) == 10) {\n            code = 10;\n            i++;\n          }\n          if (code == 13 || code == 12)\n            code = 10;\n          if (code == 0)\n            code = 65533;\n          if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {\n            var lead = code - 55296;\n            var trail = str.charCodeAt(i + 1) - 56320;\n            code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n            i++;\n          }\n          codepoints.push(code);\n        }\n        return codepoints;\n      }\n      function stringFromCode(code) {\n        if (code <= 65535)\n          return String.fromCharCode(code);\n        code -= Math.pow(2, 16);\n        var lead = Math.floor(code / Math.pow(2, 10)) + 55296;\n        var trail = code % Math.pow(2, 10) + 56320;\n        return String.fromCharCode(lead) + String.fromCharCode(trail);\n      }\n      function tokenize2(str) {\n        str = preprocess(str);\n        var i = -1;\n        var tokens = [];\n        var code;\n        var line = 0;\n        var column = 0;\n        var lastLineLength = 0;\n        var incrLineno = function() {\n          line += 1;\n          lastLineLength = column;\n          column = 0;\n        };\n        var locStart = { line, column };\n        var codepoint = function(i2) {\n          if (i2 >= str.length) {\n            return -1;\n          }\n          return str[i2];\n        };\n        var next = function(num) {\n          if (num === void 0)\n            num = 1;\n          if (num > 3)\n            throw "Spec Error: no more than three codepoints of lookahead.";\n          return codepoint(i + num);\n        };\n        var consume = function(num) {\n          if (num === void 0)\n            num = 1;\n          i += num;\n          code = codepoint(i);\n          if (newline(code))\n            incrLineno();\n          else\n            column += num;\n          return true;\n        };\n        var reconsume = function() {\n          i -= 1;\n          if (newline(code)) {\n            line -= 1;\n            column = lastLineLength;\n          } else {\n            column -= 1;\n          }\n          locStart.line = line;\n          locStart.column = column;\n          return true;\n        };\n        var eof = function(codepoint2) {\n          if (codepoint2 === void 0)\n            codepoint2 = code;\n          return codepoint2 == -1;\n        };\n        var donothing = function() {\n        };\n        var parseerror = function() {\n          console.log("Parse error at index " + i + ", processing codepoint 0x" + code.toString(16) + ".");\n          return true;\n        };\n        var consumeAToken = function() {\n          consumeComments();\n          consume();\n          if (whitespace(code)) {\n            while (whitespace(next()))\n              consume();\n            return new WhitespaceToken2();\n          } else if (code == 34)\n            return consumeAStringToken();\n          else if (code == 35) {\n            if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n              var token = new HashToken2();\n              if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n                token.type = "id";\n              token.value = consumeAName();\n              return token;\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 36) {\n            if (next() == 61) {\n              consume();\n              return new SuffixMatchToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 39)\n            return consumeAStringToken();\n          else if (code == 40)\n            return new OpenParenToken();\n          else if (code == 41)\n            return new CloseParenToken2();\n          else if (code == 42) {\n            if (next() == 61) {\n              consume();\n              return new SubstringMatchToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 43) {\n            if (startsWithANumber()) {\n              reconsume();\n              return consumeANumericToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 44)\n            return new CommaToken2();\n          else if (code == 45) {\n            if (startsWithANumber()) {\n              reconsume();\n              return consumeANumericToken();\n            } else if (next(1) == 45 && next(2) == 62) {\n              consume(2);\n              return new CDCToken2();\n            } else if (startsWithAnIdentifier()) {\n              reconsume();\n              return consumeAnIdentlikeToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 46) {\n            if (startsWithANumber()) {\n              reconsume();\n              return consumeANumericToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 58)\n            return new ColonToken2();\n          else if (code == 59)\n            return new SemicolonToken2();\n          else if (code == 60) {\n            if (next(1) == 33 && next(2) == 45 && next(3) == 45) {\n              consume(3);\n              return new CDOToken2();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 64) {\n            if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n              return new AtKeywordToken2(consumeAName());\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 91)\n            return new OpenSquareToken2();\n          else if (code == 92) {\n            if (startsWithAValidEscape()) {\n              reconsume();\n              return consumeAnIdentlikeToken();\n            } else {\n              parseerror();\n              return new DelimToken2(code);\n            }\n          } else if (code == 93)\n            return new CloseSquareToken2();\n          else if (code == 94) {\n            if (next() == 61) {\n              consume();\n              return new PrefixMatchToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 123)\n            return new OpenCurlyToken2();\n          else if (code == 124) {\n            if (next() == 61) {\n              consume();\n              return new DashMatchToken();\n            } else if (next() == 124) {\n              consume();\n              return new ColumnToken2();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 125)\n            return new CloseCurlyToken2();\n          else if (code == 126) {\n            if (next() == 61) {\n              consume();\n              return new IncludeMatchToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (digit(code)) {\n            reconsume();\n            return consumeANumericToken();\n          } else if (namestartchar(code)) {\n            reconsume();\n            return consumeAnIdentlikeToken();\n          } else if (eof())\n            return new EOFToken2();\n          else\n            return new DelimToken2(code);\n        };\n        var consumeComments = function() {\n          while (next(1) == 47 && next(2) == 42) {\n            consume(2);\n            while (true) {\n              consume();\n              if (code == 42 && next() == 47) {\n                consume();\n                break;\n              } else if (eof()) {\n                parseerror();\n                return;\n              }\n            }\n          }\n        };\n        var consumeANumericToken = function() {\n          var num = consumeANumber();\n          if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n            var token = new DimensionToken();\n            token.value = num.value;\n            token.repr = num.repr;\n            token.type = num.type;\n            token.unit = consumeAName();\n            return token;\n          } else if (next() == 37) {\n            consume();\n            var token = new PercentageToken2();\n            token.value = num.value;\n            token.repr = num.repr;\n            return token;\n          } else {\n            var token = new NumberToken2();\n            token.value = num.value;\n            token.repr = num.repr;\n            token.type = num.type;\n            return token;\n          }\n        };\n        var consumeAnIdentlikeToken = function() {\n          var str2 = consumeAName();\n          if (str2.toLowerCase() == "url" && next() == 40) {\n            consume();\n            while (whitespace(next(1)) && whitespace(next(2)))\n              consume();\n            if (next() == 34 || next() == 39) {\n              return new FunctionToken2(str2);\n            } else if (whitespace(next()) && (next(2) == 34 || next(2) == 39)) {\n              return new FunctionToken2(str2);\n            } else {\n              return consumeAURLToken();\n            }\n          } else if (next() == 40) {\n            consume();\n            return new FunctionToken2(str2);\n          } else {\n            return new IdentToken2(str2);\n          }\n        };\n        var consumeAStringToken = function(endingCodePoint) {\n          if (endingCodePoint === void 0)\n            endingCodePoint = code;\n          var string = "";\n          while (consume()) {\n            if (code == endingCodePoint || eof()) {\n              return new StringToken2(string);\n            } else if (newline(code)) {\n              parseerror();\n              reconsume();\n              return new BadStringToken2();\n            } else if (code == 92) {\n              if (eof(next())) {\n                donothing();\n              } else if (newline(next())) {\n                consume();\n              } else {\n                string += stringFromCode(consumeEscape());\n              }\n            } else {\n              string += stringFromCode(code);\n            }\n          }\n        };\n        var consumeAURLToken = function() {\n          var token = new URLToken2("");\n          while (whitespace(next()))\n            consume();\n          if (eof(next()))\n            return token;\n          while (consume()) {\n            if (code == 41 || eof()) {\n              return token;\n            } else if (whitespace(code)) {\n              while (whitespace(next()))\n                consume();\n              if (next() == 41 || eof(next())) {\n                consume();\n                return token;\n              } else {\n                consumeTheRemnantsOfABadURL();\n                return new BadURLToken2();\n              }\n            } else if (code == 34 || code == 39 || code == 40 || nonprintable(code)) {\n              parseerror();\n              consumeTheRemnantsOfABadURL();\n              return new BadURLToken2();\n            } else if (code == 92) {\n              if (startsWithAValidEscape()) {\n                token.value += stringFromCode(consumeEscape());\n              } else {\n                parseerror();\n                consumeTheRemnantsOfABadURL();\n                return new BadURLToken2();\n              }\n            } else {\n              token.value += stringFromCode(code);\n            }\n          }\n        };\n        var consumeEscape = function() {\n          consume();\n          if (hexdigit(code)) {\n            var digits = [code];\n            for (var total = 0; total < 5; total++) {\n              if (hexdigit(next())) {\n                consume();\n                digits.push(code);\n              } else {\n                break;\n              }\n            }\n            if (whitespace(next()))\n              consume();\n            var value = parseInt(digits.map(function(x) {\n              return String.fromCharCode(x);\n            }).join(""), 16);\n            if (value > maximumallowedcodepoint)\n              value = 65533;\n            return value;\n          } else if (eof()) {\n            return 65533;\n          } else {\n            return code;\n          }\n        };\n        var areAValidEscape = function(c1, c2) {\n          if (c1 != 92)\n            return false;\n          if (newline(c2))\n            return false;\n          return true;\n        };\n        var startsWithAValidEscape = function() {\n          return areAValidEscape(code, next());\n        };\n        var wouldStartAnIdentifier = function(c1, c2, c3) {\n          if (c1 == 45) {\n            return namestartchar(c2) || c2 == 45 || areAValidEscape(c2, c3);\n          } else if (namestartchar(c1)) {\n            return true;\n          } else if (c1 == 92) {\n            return areAValidEscape(c1, c2);\n          } else {\n            return false;\n          }\n        };\n        var startsWithAnIdentifier = function() {\n          return wouldStartAnIdentifier(code, next(1), next(2));\n        };\n        var wouldStartANumber = function(c1, c2, c3) {\n          if (c1 == 43 || c1 == 45) {\n            if (digit(c2))\n              return true;\n            if (c2 == 46 && digit(c3))\n              return true;\n            return false;\n          } else if (c1 == 46) {\n            if (digit(c2))\n              return true;\n            return false;\n          } else if (digit(c1)) {\n            return true;\n          } else {\n            return false;\n          }\n        };\n        var startsWithANumber = function() {\n          return wouldStartANumber(code, next(1), next(2));\n        };\n        var consumeAName = function() {\n          var result = "";\n          while (consume()) {\n            if (namechar(code)) {\n              result += stringFromCode(code);\n            } else if (startsWithAValidEscape()) {\n              result += stringFromCode(consumeEscape());\n            } else {\n              reconsume();\n              return result;\n            }\n          }\n        };\n        var consumeANumber = function() {\n          var repr = [];\n          var type = "integer";\n          if (next() == 43 || next() == 45) {\n            consume();\n            repr += stringFromCode(code);\n          }\n          while (digit(next())) {\n            consume();\n            repr += stringFromCode(code);\n          }\n          if (next(1) == 46 && digit(next(2))) {\n            consume();\n            repr += stringFromCode(code);\n            consume();\n            repr += stringFromCode(code);\n            type = "number";\n            while (digit(next())) {\n              consume();\n              repr += stringFromCode(code);\n            }\n          }\n          var c1 = next(1), c2 = next(2), c3 = next(3);\n          if ((c1 == 69 || c1 == 101) && digit(c2)) {\n            consume();\n            repr += stringFromCode(code);\n            consume();\n            repr += stringFromCode(code);\n            type = "number";\n            while (digit(next())) {\n              consume();\n              repr += stringFromCode(code);\n            }\n          } else if ((c1 == 69 || c1 == 101) && (c2 == 43 || c2 == 45) && digit(c3)) {\n            consume();\n            repr += stringFromCode(code);\n            consume();\n            repr += stringFromCode(code);\n            consume();\n            repr += stringFromCode(code);\n            type = "number";\n            while (digit(next())) {\n              consume();\n              repr += stringFromCode(code);\n            }\n          }\n          var value = convertAStringToANumber(repr);\n          return { type, value, repr };\n        };\n        var convertAStringToANumber = function(string) {\n          return +string;\n        };\n        var consumeTheRemnantsOfABadURL = function() {\n          while (consume()) {\n            if (code == 41 || eof()) {\n              return;\n            } else if (startsWithAValidEscape()) {\n              consumeEscape();\n              donothing();\n            } else {\n              donothing();\n            }\n          }\n        };\n        var iterationCount = 0;\n        while (!eof(next())) {\n          tokens.push(consumeAToken());\n          iterationCount++;\n          if (iterationCount > str.length * 2)\n            return "I\'m infinite-looping!";\n        }\n        return tokens;\n      }\n      function CSSParserToken() {\n        throw "Abstract Base Class";\n      }\n      CSSParserToken.prototype.toJSON = function() {\n        return { token: this.tokenType };\n      };\n      CSSParserToken.prototype.toString = function() {\n        return this.tokenType;\n      };\n      CSSParserToken.prototype.toSource = function() {\n        return "" + this;\n      };\n      function BadStringToken2() {\n        return this;\n      }\n      BadStringToken2.prototype = Object.create(CSSParserToken.prototype);\n      BadStringToken2.prototype.tokenType = "BADSTRING";\n      function BadURLToken2() {\n        return this;\n      }\n      BadURLToken2.prototype = Object.create(CSSParserToken.prototype);\n      BadURLToken2.prototype.tokenType = "BADURL";\n      function WhitespaceToken2() {\n        return this;\n      }\n      WhitespaceToken2.prototype = Object.create(CSSParserToken.prototype);\n      WhitespaceToken2.prototype.tokenType = "WHITESPACE";\n      WhitespaceToken2.prototype.toString = function() {\n        return "WS";\n      };\n      WhitespaceToken2.prototype.toSource = function() {\n        return " ";\n      };\n      function CDOToken2() {\n        return this;\n      }\n      CDOToken2.prototype = Object.create(CSSParserToken.prototype);\n      CDOToken2.prototype.tokenType = "CDO";\n      CDOToken2.prototype.toSource = function() {\n        return "<!--";\n      };\n      function CDCToken2() {\n        return this;\n      }\n      CDCToken2.prototype = Object.create(CSSParserToken.prototype);\n      CDCToken2.prototype.tokenType = "CDC";\n      CDCToken2.prototype.toSource = function() {\n        return "-->";\n      };\n      function ColonToken2() {\n        return this;\n      }\n      ColonToken2.prototype = Object.create(CSSParserToken.prototype);\n      ColonToken2.prototype.tokenType = ":";\n      function SemicolonToken2() {\n        return this;\n      }\n      SemicolonToken2.prototype = Object.create(CSSParserToken.prototype);\n      SemicolonToken2.prototype.tokenType = ";";\n      function CommaToken2() {\n        return this;\n      }\n      CommaToken2.prototype = Object.create(CSSParserToken.prototype);\n      CommaToken2.prototype.tokenType = ",";\n      function GroupingToken() {\n        throw "Abstract Base Class";\n      }\n      GroupingToken.prototype = Object.create(CSSParserToken.prototype);\n      function OpenCurlyToken2() {\n        this.value = "{";\n        this.mirror = "}";\n        return this;\n      }\n      OpenCurlyToken2.prototype = Object.create(GroupingToken.prototype);\n      OpenCurlyToken2.prototype.tokenType = "{";\n      function CloseCurlyToken2() {\n        this.value = "}";\n        this.mirror = "{";\n        return this;\n      }\n      CloseCurlyToken2.prototype = Object.create(GroupingToken.prototype);\n      CloseCurlyToken2.prototype.tokenType = "}";\n      function OpenSquareToken2() {\n        this.value = "[";\n        this.mirror = "]";\n        return this;\n      }\n      OpenSquareToken2.prototype = Object.create(GroupingToken.prototype);\n      OpenSquareToken2.prototype.tokenType = "[";\n      function CloseSquareToken2() {\n        this.value = "]";\n        this.mirror = "[";\n        return this;\n      }\n      CloseSquareToken2.prototype = Object.create(GroupingToken.prototype);\n      CloseSquareToken2.prototype.tokenType = "]";\n      function OpenParenToken() {\n        this.value = "(";\n        this.mirror = ")";\n        return this;\n      }\n      OpenParenToken.prototype = Object.create(GroupingToken.prototype);\n      OpenParenToken.prototype.tokenType = "(";\n      function CloseParenToken2() {\n        this.value = ")";\n        this.mirror = "(";\n        return this;\n      }\n      CloseParenToken2.prototype = Object.create(GroupingToken.prototype);\n      CloseParenToken2.prototype.tokenType = ")";\n      function IncludeMatchToken() {\n        return this;\n      }\n      IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);\n      IncludeMatchToken.prototype.tokenType = "~=";\n      function DashMatchToken() {\n        return this;\n      }\n      DashMatchToken.prototype = Object.create(CSSParserToken.prototype);\n      DashMatchToken.prototype.tokenType = "|=";\n      function PrefixMatchToken() {\n        return this;\n      }\n      PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n      PrefixMatchToken.prototype.tokenType = "^=";\n      function SuffixMatchToken() {\n        return this;\n      }\n      SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n      SuffixMatchToken.prototype.tokenType = "$=";\n      function SubstringMatchToken() {\n        return this;\n      }\n      SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);\n      SubstringMatchToken.prototype.tokenType = "*=";\n      function ColumnToken2() {\n        return this;\n      }\n      ColumnToken2.prototype = Object.create(CSSParserToken.prototype);\n      ColumnToken2.prototype.tokenType = "||";\n      function EOFToken2() {\n        return this;\n      }\n      EOFToken2.prototype = Object.create(CSSParserToken.prototype);\n      EOFToken2.prototype.tokenType = "EOF";\n      EOFToken2.prototype.toSource = function() {\n        return "";\n      };\n      function DelimToken2(code) {\n        this.value = stringFromCode(code);\n        return this;\n      }\n      DelimToken2.prototype = Object.create(CSSParserToken.prototype);\n      DelimToken2.prototype.tokenType = "DELIM";\n      DelimToken2.prototype.toString = function() {\n        return "DELIM(" + this.value + ")";\n      };\n      DelimToken2.prototype.toJSON = function() {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        return json;\n      };\n      DelimToken2.prototype.toSource = function() {\n        if (this.value == "\\\\")\n          return "\\\\\\n";\n        else\n          return this.value;\n      };\n      function StringValuedToken() {\n        throw "Abstract Base Class";\n      }\n      StringValuedToken.prototype = Object.create(CSSParserToken.prototype);\n      StringValuedToken.prototype.ASCIIMatch = function(str) {\n        return this.value.toLowerCase() == str.toLowerCase();\n      };\n      StringValuedToken.prototype.toJSON = function() {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        return json;\n      };\n      function IdentToken2(val) {\n        this.value = val;\n      }\n      IdentToken2.prototype = Object.create(StringValuedToken.prototype);\n      IdentToken2.prototype.tokenType = "IDENT";\n      IdentToken2.prototype.toString = function() {\n        return "IDENT(" + this.value + ")";\n      };\n      IdentToken2.prototype.toSource = function() {\n        return escapeIdent(this.value);\n      };\n      function FunctionToken2(val) {\n        this.value = val;\n        this.mirror = ")";\n      }\n      FunctionToken2.prototype = Object.create(StringValuedToken.prototype);\n      FunctionToken2.prototype.tokenType = "FUNCTION";\n      FunctionToken2.prototype.toString = function() {\n        return "FUNCTION(" + this.value + ")";\n      };\n      FunctionToken2.prototype.toSource = function() {\n        return escapeIdent(this.value) + "(";\n      };\n      function AtKeywordToken2(val) {\n        this.value = val;\n      }\n      AtKeywordToken2.prototype = Object.create(StringValuedToken.prototype);\n      AtKeywordToken2.prototype.tokenType = "AT-KEYWORD";\n      AtKeywordToken2.prototype.toString = function() {\n        return "AT(" + this.value + ")";\n      };\n      AtKeywordToken2.prototype.toSource = function() {\n        return "@" + escapeIdent(this.value);\n      };\n      function HashToken2(val) {\n        this.value = val;\n        this.type = "unrestricted";\n      }\n      HashToken2.prototype = Object.create(StringValuedToken.prototype);\n      HashToken2.prototype.tokenType = "HASH";\n      HashToken2.prototype.toString = function() {\n        return "HASH(" + this.value + ")";\n      };\n      HashToken2.prototype.toJSON = function() {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        return json;\n      };\n      HashToken2.prototype.toSource = function() {\n        if (this.type == "id") {\n          return "#" + escapeIdent(this.value);\n        } else {\n          return "#" + escapeHash(this.value);\n        }\n      };\n      function StringToken2(val) {\n        this.value = val;\n      }\n      StringToken2.prototype = Object.create(StringValuedToken.prototype);\n      StringToken2.prototype.tokenType = "STRING";\n      StringToken2.prototype.toString = function() {\n        return \'"\' + escapeString(this.value) + \'"\';\n      };\n      function URLToken2(val) {\n        this.value = val;\n      }\n      URLToken2.prototype = Object.create(StringValuedToken.prototype);\n      URLToken2.prototype.tokenType = "URL";\n      URLToken2.prototype.toString = function() {\n        return "URL(" + this.value + ")";\n      };\n      URLToken2.prototype.toSource = function() {\n        return \'url("\' + escapeString(this.value) + \'")\';\n      };\n      function NumberToken2() {\n        this.value = null;\n        this.type = "integer";\n        this.repr = "";\n      }\n      NumberToken2.prototype = Object.create(CSSParserToken.prototype);\n      NumberToken2.prototype.tokenType = "NUMBER";\n      NumberToken2.prototype.toString = function() {\n        if (this.type == "integer")\n          return "INT(" + this.value + ")";\n        return "NUMBER(" + this.value + ")";\n      };\n      NumberToken2.prototype.toJSON = function() {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        json.repr = this.repr;\n        return json;\n      };\n      NumberToken2.prototype.toSource = function() {\n        return this.repr;\n      };\n      function PercentageToken2() {\n        this.value = null;\n        this.repr = "";\n      }\n      PercentageToken2.prototype = Object.create(CSSParserToken.prototype);\n      PercentageToken2.prototype.tokenType = "PERCENTAGE";\n      PercentageToken2.prototype.toString = function() {\n        return "PERCENTAGE(" + this.value + ")";\n      };\n      PercentageToken2.prototype.toJSON = function() {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.repr = this.repr;\n        return json;\n      };\n      PercentageToken2.prototype.toSource = function() {\n        return this.repr + "%";\n      };\n      function DimensionToken() {\n        this.value = null;\n        this.type = "integer";\n        this.repr = "";\n        this.unit = "";\n      }\n      DimensionToken.prototype = Object.create(CSSParserToken.prototype);\n      DimensionToken.prototype.tokenType = "DIMENSION";\n      DimensionToken.prototype.toString = function() {\n        return "DIM(" + this.value + "," + this.unit + ")";\n      };\n      DimensionToken.prototype.toJSON = function() {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        json.repr = this.repr;\n        json.unit = this.unit;\n        return json;\n      };\n      DimensionToken.prototype.toSource = function() {\n        var source = this.repr;\n        var unit = escapeIdent(this.unit);\n        if (unit[0].toLowerCase() == "e" && (unit[1] == "-" || between(unit.charCodeAt(1), 48, 57))) {\n          unit = "\\\\65 " + unit.slice(1, unit.length);\n        }\n        return source + unit;\n      };\n      function escapeIdent(string) {\n        string = "" + string;\n        var result = "";\n        var firstcode = string.charCodeAt(0);\n        for (var i = 0; i < string.length; i++) {\n          var code = string.charCodeAt(i);\n          if (code == 0) {\n            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n          }\n          if (between(code, 1, 31) || code == 127 || i == 0 && between(code, 48, 57) || i == 1 && between(code, 48, 57) && firstcode == 45) {\n            result += "\\\\" + code.toString(16) + " ";\n          } else if (code >= 128 || code == 45 || code == 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122)) {\n            result += string[i];\n          } else {\n            result += "\\\\" + string[i];\n          }\n        }\n        return result;\n      }\n      function escapeHash(string) {\n        string = "" + string;\n        var result = "";\n        var firstcode = string.charCodeAt(0);\n        for (var i = 0; i < string.length; i++) {\n          var code = string.charCodeAt(i);\n          if (code == 0) {\n            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n          }\n          if (code >= 128 || code == 45 || code == 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122)) {\n            result += string[i];\n          } else {\n            result += "\\\\" + code.toString(16) + " ";\n          }\n        }\n        return result;\n      }\n      function escapeString(string) {\n        string = "" + string;\n        var result = "";\n        for (var i = 0; i < string.length; i++) {\n          var code = string.charCodeAt(i);\n          if (code == 0) {\n            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n          }\n          if (between(code, 1, 31) || code == 127) {\n            result += "\\\\" + code.toString(16) + " ";\n          } else if (code == 34 || code == 92) {\n            result += "\\\\" + string[i];\n          } else {\n            result += string[i];\n          }\n        }\n        return result;\n      }\n      exports3.tokenize = tokenize2;\n      exports3.IdentToken = IdentToken2;\n      exports3.FunctionToken = FunctionToken2;\n      exports3.AtKeywordToken = AtKeywordToken2;\n      exports3.HashToken = HashToken2;\n      exports3.StringToken = StringToken2;\n      exports3.BadStringToken = BadStringToken2;\n      exports3.URLToken = URLToken2;\n      exports3.BadURLToken = BadURLToken2;\n      exports3.DelimToken = DelimToken2;\n      exports3.NumberToken = NumberToken2;\n      exports3.PercentageToken = PercentageToken2;\n      exports3.DimensionToken = DimensionToken;\n      exports3.IncludeMatchToken = IncludeMatchToken;\n      exports3.DashMatchToken = DashMatchToken;\n      exports3.PrefixMatchToken = PrefixMatchToken;\n      exports3.SuffixMatchToken = SuffixMatchToken;\n      exports3.SubstringMatchToken = SubstringMatchToken;\n      exports3.ColumnToken = ColumnToken2;\n      exports3.WhitespaceToken = WhitespaceToken2;\n      exports3.CDOToken = CDOToken2;\n      exports3.CDCToken = CDCToken2;\n      exports3.ColonToken = ColonToken2;\n      exports3.SemicolonToken = SemicolonToken2;\n      exports3.CommaToken = CommaToken2;\n      exports3.OpenParenToken = OpenParenToken;\n      exports3.CloseParenToken = CloseParenToken2;\n      exports3.OpenSquareToken = OpenSquareToken2;\n      exports3.CloseSquareToken = CloseSquareToken2;\n      exports3.OpenCurlyToken = OpenCurlyToken2;\n      exports3.CloseCurlyToken = CloseCurlyToken2;\n      exports3.EOFToken = EOFToken2;\n      exports3.CSSParserToken = CSSParserToken;\n      exports3.GroupingToken = GroupingToken;\n    });\n  }\n});\n\n// packages/playwright-core/src/server/isomorphic/cssParser.ts\nvar css = __toESM(require_cssTokenizer());\n\n// packages/playwright-core/src/server/injected/selectorEvaluator.ts\nfunction shouldSkipForTextMatching(element) {\n  return element.nodeName === "SCRIPT" || element.nodeName === "STYLE" || document.head && document.head.contains(element);\n}\nfunction elementText(evaluator, root) {\n  let value = evaluator._cacheText.get(root);\n  if (value === void 0) {\n    value = { full: "", immediate: [] };\n    if (!shouldSkipForTextMatching(root)) {\n      let currentImmediate = "";\n      if (root instanceof HTMLInputElement && (root.type === "submit" || root.type === "button")) {\n        value = { full: root.value, immediate: [root.value] };\n      } else {\n        for (let child = root.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType === Node.TEXT_NODE) {\n            value.full += child.nodeValue || "";\n            currentImmediate += child.nodeValue || "";\n          } else {\n            if (currentImmediate)\n              value.immediate.push(currentImmediate);\n            currentImmediate = "";\n            if (child.nodeType === Node.ELEMENT_NODE)\n              value.full += elementText(evaluator, child).full;\n          }\n        }\n        if (currentImmediate)\n          value.immediate.push(currentImmediate);\n        if (root.shadowRoot)\n          value.full += elementText(evaluator, root.shadowRoot).full;\n      }\n    }\n    evaluator._cacheText.set(root, value);\n  }\n  return value;\n}\n\n// packages/playwright-core/src/server/injected/selectorGenerator.ts\nvar cacheAllowText = /* @__PURE__ */ new Map();\nvar cacheDisallowText = /* @__PURE__ */ new Map();\nvar kNthScore = 1e3;\nfunction querySelector(injectedScript, selector, ownerDocument) {\n  try {\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n      selector,\n      elements: injectedScript.querySelectorAll(parsedSelector, ownerDocument)\n    };\n  } catch (e) {\n    return {\n      selector,\n      elements: []\n    };\n  }\n}\nfunction generateSelector(injectedScript, targetElement, strict) {\n  injectedScript._evaluator.begin();\n  try {\n    targetElement = targetElement.closest("button,select,input,[role=button],[role=checkbox],[role=radio]") || targetElement;\n    const targetTokens = generateSelectorFor(injectedScript, targetElement, strict);\n    const bestTokens = targetTokens || cssFallback(injectedScript, targetElement, strict);\n    const selector = joinTokens(bestTokens);\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n      selector,\n      elements: injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument)\n    };\n  } finally {\n    cacheAllowText.clear();\n    cacheDisallowText.clear();\n    injectedScript._evaluator.end();\n  }\n}\nfunction filterRegexTokens(textCandidates) {\n  return textCandidates.filter((c) => c[0].selector[0] !== "/");\n}\nfunction generateSelectorFor(injectedScript, targetElement, strict) {\n  if (targetElement.ownerDocument.documentElement === targetElement)\n    return [{ engine: "css", selector: "html", score: 1 }];\n  const calculate = (element, allowText) => {\n    const allowNthMatch = element === targetElement;\n    let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement).map((token) => [token]) : [];\n    if (element !== targetElement) {\n      textCandidates = filterRegexTokens(textCandidates);\n    }\n    const noTextCandidates = buildCandidates(injectedScript, element).map((token) => [token]);\n    let result = chooseFirstSelector(injectedScript, targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch, strict);\n    textCandidates = filterRegexTokens(textCandidates);\n    const checkWithText = (textCandidatesToUse) => {\n      const allowParentText = allowText && !textCandidatesToUse.length;\n      const candidates = [...textCandidatesToUse, ...noTextCandidates].filter((c) => {\n        if (!result)\n          return true;\n        return combineScores(c) < combineScores(result);\n      });\n      let bestPossibleInParent = candidates[0];\n      if (!bestPossibleInParent)\n        return;\n      for (let parent = parentElementOrShadowHost(element); parent; parent = parentElementOrShadowHost(parent)) {\n        const parentTokens = calculateCached(parent, allowParentText);\n        if (!parentTokens)\n          continue;\n        if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))\n          continue;\n        bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch, strict);\n        if (!bestPossibleInParent)\n          return;\n        const combined = [...parentTokens, ...bestPossibleInParent];\n        if (!result || combineScores(combined) < combineScores(result))\n          result = combined;\n      }\n    };\n    checkWithText(textCandidates);\n    if (element === targetElement && textCandidates.length)\n      checkWithText([]);\n    return result;\n  };\n  const calculateCached = (element, allowText) => {\n    const cache = allowText ? cacheAllowText : cacheDisallowText;\n    let value = cache.get(element);\n    if (value === void 0) {\n      value = calculate(element, allowText);\n      cache.set(element, value);\n    }\n    return value;\n  };\n  return calculateCached(targetElement, true);\n}\nfunction buildCandidates(injectedScript, element) {\n  const candidates = [];\n  for (const attribute of ["data-testid", "data-test-id", "data-test"]) {\n    if (element.getAttribute(attribute))\n      candidates.push({ engine: "css", selector: `[${attribute}=${quoteAttributeValue(element.getAttribute(attribute))}]`, score: 1 });\n  }\n  if (element.nodeName === "INPUT") {\n    const input = element;\n    if (input.placeholder)\n      candidates.push({ engine: "css", selector: `[placeholder=${quoteAttributeValue(input.placeholder)}]`, score: 10 });\n  }\n  if (element.getAttribute("aria-label"))\n    candidates.push({ engine: "css", selector: `[aria-label=${quoteAttributeValue(element.getAttribute("aria-label"))}]`, score: 10 });\n  if (element.getAttribute("alt") && ["APPLET", "AREA", "IMG", "INPUT"].includes(element.nodeName))\n    candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[alt=${quoteAttributeValue(element.getAttribute("alt"))}]`, score: 10 });\n  if (element.getAttribute("role"))\n    candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[role=${quoteAttributeValue(element.getAttribute("role"))}]`, score: 50 });\n  if (element.getAttribute("name") && ["BUTTON", "FORM", "FIELDSET", "IFRAME", "INPUT", "KEYGEN", "OBJECT", "OUTPUT", "SELECT", "TEXTAREA", "MAP", "META", "PARAM"].includes(element.nodeName))\n    candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[name=${quoteAttributeValue(element.getAttribute("name"))}]`, score: 50 });\n  if (["INPUT", "TEXTAREA"].includes(element.nodeName) && element.getAttribute("type") !== "hidden") {\n    if (element.getAttribute("type"))\n      candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[type=${quoteAttributeValue(element.getAttribute("type"))}]`, score: 50 });\n  }\n  if (["INPUT", "TEXTAREA", "SELECT"].includes(element.nodeName))\n    candidates.push({ engine: "css", selector: cssEscape(element.nodeName.toLowerCase()), score: 50 });\n  const idAttr = element.getAttribute("id");\n  if (idAttr && !isGuidLike(idAttr))\n    candidates.push({ engine: "css", selector: makeSelectorForId(idAttr), score: 100 });\n  candidates.push({ engine: "css", selector: cssEscape(element.nodeName.toLowerCase()), score: 200 });\n  return candidates;\n}\nfunction buildTextCandidates(injectedScript, element, allowHasText) {\n  if (element.nodeName === "SELECT")\n    return [];\n  const text = elementText(injectedScript._evaluator, element).full.trim().replace(/\\s+/g, " ").substring(0, 80);\n  if (!text)\n    return [];\n  const candidates = [];\n  let escaped = text;\n  if (text.includes(\'"\') || text.includes(">>") || text[0] === "/")\n    escaped = `/.*${escapeForRegex(text)}.*/`;\n  candidates.push({ engine: "text", selector: escaped, score: 10 });\n  if (allowHasText && escaped === text) {\n    let prefix = element.nodeName.toLowerCase();\n    if (element.hasAttribute("role"))\n      prefix += `[role=${quoteAttributeValue(element.getAttribute("role"))}]`;\n    candidates.push({ engine: "css", selector: `${prefix}:has-text("${text}")`, score: 30 });\n  }\n  return candidates;\n}\nfunction parentElementOrShadowHost(element) {\n  if (element.parentElement)\n    return element.parentElement;\n  if (!element.parentNode)\n    return null;\n  if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\n    return element.parentNode.host;\n  return null;\n}\nfunction makeSelectorForId(id) {\n  return /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(id) ? "#" + id : `[id="${cssEscape(id)}"]`;\n}\nfunction cssFallback(injectedScript, targetElement, strict) {\n  const kFallbackScore = 1e7;\n  const root = targetElement.ownerDocument;\n  const tokens = [];\n  function uniqueCSSSelector(prefix) {\n    const path = tokens.slice();\n    if (prefix)\n      path.unshift(prefix);\n    const selector = path.join(" ");\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const node = injectedScript.querySelector(parsedSelector, targetElement.ownerDocument, false);\n    return node === targetElement ? selector : void 0;\n  }\n  function makeStrict(selector) {\n    const token = { engine: "css", selector, score: kFallbackScore };\n    if (!strict)\n      return [token];\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const elements = injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument);\n    if (elements.length === 1)\n      return [token];\n    const nth = { engine: "nth", selector: String(elements.indexOf(targetElement)), score: kNthScore };\n    return [token, nth];\n  }\n  for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {\n    const nodeName = element.nodeName.toLowerCase();\n    let bestTokenForLevel = "";\n    if (element.id) {\n      const token = makeSelectorForId(element.id);\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      bestTokenForLevel = token;\n    }\n    const parent = element.parentNode;\n    const classes = [...element.classList];\n    for (let i = 0; i < classes.length; ++i) {\n      const token = "." + classes.slice(0, i + 1).join(".");\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel && parent) {\n        const sameClassSiblings = parent.querySelectorAll(token);\n        if (sameClassSiblings.length === 1)\n          bestTokenForLevel = token;\n      }\n    }\n    if (parent) {\n      const siblings = [...parent.children];\n      const sameTagSiblings = siblings.filter((sibling) => sibling.nodeName.toLowerCase() === nodeName);\n      const token = sameTagSiblings.indexOf(element) === 0 ? cssEscape(nodeName) : `${cssEscape(nodeName)}:nth-child(${1 + siblings.indexOf(element)})`;\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel)\n        bestTokenForLevel = token;\n    } else if (!bestTokenForLevel) {\n      bestTokenForLevel = nodeName;\n    }\n    tokens.unshift(bestTokenForLevel);\n  }\n  return makeStrict(uniqueCSSSelector());\n}\nfunction escapeForRegex(text) {\n  return text.replace(/[.*+?^>${}()|[\\]\\\\]/g, "\\\\$&");\n}\nfunction quoteAttributeValue(text) {\n  return `"${cssEscape(text).replace(/\\\\ /g, " ")}"`;\n}\nfunction joinTokens(tokens) {\n  const parts = [];\n  let lastEngine = "";\n  for (const { engine, selector } of tokens) {\n    if (parts.length && (lastEngine !== "css" || engine !== "css" || selector.startsWith(":nth-match(")))\n      parts.push(">>");\n    lastEngine = engine;\n    if (engine === "css")\n      parts.push(selector);\n    else\n      parts.push(`${engine}=${selector}`);\n  }\n  return parts.join(" ");\n}\nfunction combineScores(tokens) {\n  let score = 0;\n  for (let i = 0; i < tokens.length; i++)\n    score += tokens[i].score * (tokens.length - i);\n  return score;\n}\nfunction chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch, strict) {\n  const joined = selectors.map((tokens) => ({ tokens, score: combineScores(tokens) }));\n  joined.sort((a, b) => a.score - b.score);\n  let bestWithIndex = null;\n  for (const { tokens } of joined) {\n    const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));\n    const result = injectedScript.querySelectorAll(parsedSelector, scope);\n    const isStrictEnough = !strict || result.length === 1;\n    const index = result.indexOf(targetElement);\n    if (index === 0 && isStrictEnough) {\n      return tokens;\n    }\n    if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)\n      continue;\n    const nth = { engine: "nth", selector: String(index), score: kNthScore };\n    bestWithIndex = [...tokens, nth];\n  }\n  return bestWithIndex;\n}\nfunction isGuidLike(id) {\n  let lastCharacterType;\n  let transitionCount = 0;\n  for (let i = 0; i < id.length; ++i) {\n    const c = id[i];\n    let characterType;\n    if (c === "-" || c === "_")\n      continue;\n    if (c >= "a" && c <= "z")\n      characterType = "lower";\n    else if (c >= "A" && c <= "Z")\n      characterType = "upper";\n    else if (c >= "0" && c <= "9")\n      characterType = "digit";\n    else\n      characterType = "other";\n    if (characterType === "lower" && lastCharacterType === "upper") {\n      lastCharacterType = characterType;\n      continue;\n    }\n    if (lastCharacterType && lastCharacterType !== characterType)\n      ++transitionCount;\n    lastCharacterType = characterType;\n  }\n  return transitionCount >= id.length / 4;\n}\nfunction cssEscape(s) {\n  let result = "";\n  for (let i = 0; i < s.length; i++)\n    result += cssEscapeOne(s, i);\n  return result;\n}\nfunction cssEscapeOne(s, i) {\n  const c = s.charCodeAt(i);\n  if (c === 0)\n    return "\\uFFFD";\n  if (c >= 1 && c <= 31 || c >= 48 && c <= 57 && (i === 0 || i === 1 && s.charCodeAt(0) === 45))\n    return "\\\\" + c.toString(16) + " ";\n  if (i === 0 && c === 45 && s.length === 1)\n    return "\\\\" + s.charAt(i);\n  if (c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122)\n    return s.charAt(i);\n  return "\\\\" + s.charAt(i);\n}\n\n// packages/playwright-core/src/server/injected/highlight.ts\nvar Highlight = class {\n  constructor(isUnderTest) {\n    this._highlightElements = [];\n    this._isUnderTest = isUnderTest;\n    this._outerGlassPaneElement = document.createElement("x-pw-glass");\n    this._outerGlassPaneElement.style.position = "fixed";\n    this._outerGlassPaneElement.style.top = "0";\n    this._outerGlassPaneElement.style.right = "0";\n    this._outerGlassPaneElement.style.bottom = "0";\n    this._outerGlassPaneElement.style.left = "0";\n    this._outerGlassPaneElement.style.zIndex = "2147483647";\n    this._outerGlassPaneElement.style.pointerEvents = "none";\n    this._outerGlassPaneElement.style.display = "flex";\n    this._tooltipElement = document.createElement("x-pw-tooltip");\n    this._actionPointElement = document.createElement("x-pw-action-point");\n    this._actionPointElement.setAttribute("hidden", "true");\n    this._innerGlassPaneElement = document.createElement("x-pw-glass-inner");\n    this._innerGlassPaneElement.style.flex = "auto";\n    this._innerGlassPaneElement.appendChild(this._tooltipElement);\n    this._glassPaneShadow = this._outerGlassPaneElement.attachShadow({ mode: isUnderTest ? "open" : "closed" });\n    this._glassPaneShadow.appendChild(this._innerGlassPaneElement);\n    this._glassPaneShadow.appendChild(this._actionPointElement);\n    const styleElement = document.createElement("style");\n    styleElement.textContent = `\n        x-pw-tooltip {\n          align-items: center;\n          backdrop-filter: blur(5px);\n          background-color: rgba(0, 0, 0, 0.7);\n          border-radius: 2px;\n          box-shadow: rgba(0, 0, 0, 0.1) 0px 3.6px 3.7px,\n                      rgba(0, 0, 0, 0.15) 0px 12.1px 12.3px,\n                      rgba(0, 0, 0, 0.1) 0px -2px 4px,\n                      rgba(0, 0, 0, 0.15) 0px -12.1px 24px,\n                      rgba(0, 0, 0, 0.25) 0px 54px 55px;\n          color: rgb(204, 204, 204);\n          display: none;\n          font-family: \'Dank Mono\', \'Operator Mono\', Inconsolata, \'Fira Mono\',\n                      \'SF Mono\', Monaco, \'Droid Sans Mono\', \'Source Code Pro\', monospace;\n          font-size: 12.8px;\n          font-weight: normal;\n          left: 0;\n          line-height: 1.5;\n          max-width: 600px;\n          padding: 3.2px 5.12px 3.2px;\n          position: absolute;\n          top: 0;\n        }\n        x-pw-action-point {\n          position: absolute;\n          width: 20px;\n          height: 20px;\n          background: red;\n          border-radius: 10px;\n          pointer-events: none;\n          margin: -10px 0 0 -10px;\n          z-index: 2;\n        }\n        *[hidden] {\n          display: none !important;\n        }\n    `;\n    this._glassPaneShadow.appendChild(styleElement);\n  }\n  install() {\n    document.documentElement.appendChild(this._outerGlassPaneElement);\n  }\n  uninstall() {\n    this._outerGlassPaneElement.remove();\n  }\n  isInstalled() {\n    return this._outerGlassPaneElement.parentElement === document.documentElement && !this._outerGlassPaneElement.nextElementSibling;\n  }\n  showActionPoint(x, y) {\n    this._actionPointElement.style.top = y + "px";\n    this._actionPointElement.style.left = x + "px";\n    this._actionPointElement.hidden = false;\n    if (this._isUnderTest)\n      console.error("Action point for test: " + JSON.stringify({ x, y }));\n  }\n  hideActionPoint() {\n    this._actionPointElement.hidden = true;\n  }\n  updateHighlight(elements, selector, isRecording) {\n    this._tooltipElement.textContent = selector;\n    this._tooltipElement.style.top = "0";\n    this._tooltipElement.style.left = "0";\n    this._tooltipElement.style.display = "flex";\n    const boxes = elements.map((e) => e.getBoundingClientRect());\n    const tooltipWidth = this._tooltipElement.offsetWidth;\n    const tooltipHeight = this._tooltipElement.offsetHeight;\n    const totalWidth = this._innerGlassPaneElement.offsetWidth;\n    const totalHeight = this._innerGlassPaneElement.offsetHeight;\n    if (boxes.length) {\n      const primaryBox = boxes[0];\n      let anchorLeft = primaryBox.left;\n      if (anchorLeft + tooltipWidth > totalWidth - 5)\n        anchorLeft = totalWidth - tooltipWidth - 5;\n      let anchorTop = primaryBox.bottom + 5;\n      if (anchorTop + tooltipHeight > totalHeight - 5) {\n        if (primaryBox.top > tooltipHeight + 5) {\n          anchorTop = primaryBox.top - tooltipHeight - 5;\n        } else {\n          anchorTop = totalHeight - 5 - tooltipHeight;\n        }\n      }\n      this._tooltipElement.style.top = anchorTop + "px";\n      this._tooltipElement.style.left = anchorLeft + "px";\n    } else {\n      this._tooltipElement.style.display = "none";\n    }\n    const pool = this._highlightElements;\n    this._highlightElements = [];\n    for (const box of boxes) {\n      const highlightElement = pool.length ? pool.shift() : this._createHighlightElement();\n      const color = isRecording ? "#dc6f6f7f" : "#6fa8dc7f";\n      highlightElement.style.backgroundColor = this._highlightElements.length ? "#f6b26b7f" : color;\n      highlightElement.style.left = box.x + "px";\n      highlightElement.style.top = box.y + "px";\n      highlightElement.style.width = box.width + "px";\n      highlightElement.style.height = box.height + "px";\n      highlightElement.style.display = "block";\n      this._highlightElements.push(highlightElement);\n      if (this._isUnderTest)\n        console.error("Highlight box for test: " + JSON.stringify({ x: box.x, y: box.y, width: box.width, height: box.height }));\n    }\n    for (const highlightElement of pool) {\n      highlightElement.style.display = "none";\n      this._highlightElements.push(highlightElement);\n    }\n  }\n  maskElements(elements) {\n    const boxes = elements.map((e) => e.getBoundingClientRect());\n    const pool = this._highlightElements;\n    this._highlightElements = [];\n    for (const box of boxes) {\n      const highlightElement = pool.length ? pool.shift() : this._createHighlightElement();\n      highlightElement.style.backgroundColor = "#F0F";\n      highlightElement.style.left = box.x + "px";\n      highlightElement.style.top = box.y + "px";\n      highlightElement.style.width = box.width + "px";\n      highlightElement.style.height = box.height + "px";\n      highlightElement.style.display = "block";\n      this._highlightElements.push(highlightElement);\n    }\n    for (const highlightElement of pool) {\n      highlightElement.style.display = "none";\n      this._highlightElements.push(highlightElement);\n    }\n  }\n  _createHighlightElement() {\n    const highlightElement = document.createElement("x-pw-highlight");\n    highlightElement.style.position = "absolute";\n    highlightElement.style.top = "0";\n    highlightElement.style.left = "0";\n    highlightElement.style.width = "0";\n    highlightElement.style.height = "0";\n    highlightElement.style.boxSizing = "border-box";\n    this._glassPaneShadow.appendChild(highlightElement);\n    return highlightElement;\n  }\n};\n\n// packages/playwright-core/src/server/injected/recorder.ts\nvar Recorder = class {\n  constructor(injectedScript) {\n    this._performingAction = false;\n    this._listeners = [];\n    this._hoveredModel = null;\n    this._hoveredElement = null;\n    this._activeModel = null;\n    this._expectProgrammaticKeyUp = false;\n    this._mode = "none";\n    this._injectedScript = injectedScript;\n    this._highlight = new Highlight(injectedScript.isUnderTest);\n    this._refreshListenersIfNeeded();\n    injectedScript.onGlobalListenersRemoved.add(() => this._refreshListenersIfNeeded());\n    globalThis._playwrightRefreshOverlay = () => {\n      this._pollRecorderMode().catch((e) => console.log(e));\n    };\n    globalThis._playwrightRefreshOverlay();\n    if (injectedScript.isUnderTest)\n      console.error("Recorder script ready for test");\n  }\n  _refreshListenersIfNeeded() {\n    if (this._highlight.isInstalled())\n      return;\n    removeEventListeners(this._listeners);\n    this._listeners = [\n      addEventListener(document, "click", (event) => this._onClick(event), true),\n      addEventListener(document, "auxclick", (event) => this._onClick(event), true),\n      addEventListener(document, "input", (event) => this._onInput(event), true),\n      addEventListener(document, "keydown", (event) => this._onKeyDown(event), true),\n      addEventListener(document, "keyup", (event) => this._onKeyUp(event), true),\n      addEventListener(document, "mousedown", (event) => this._onMouseDown(event), true),\n      addEventListener(document, "mouseup", (event) => this._onMouseUp(event), true),\n      addEventListener(document, "mousemove", (event) => this._onMouseMove(event), true),\n      addEventListener(document, "mouseleave", (event) => this._onMouseLeave(event), true),\n      addEventListener(document, "focus", () => this._onFocus(), true),\n      addEventListener(document, "scroll", () => {\n        this._hoveredModel = null;\n        this._highlight.hideActionPoint();\n        this._updateHighlight();\n      }, true)\n    ];\n    this._highlight.install();\n  }\n  async _pollRecorderMode() {\n    var _a;\n    const pollPeriod = 1e3;\n    if (this._pollRecorderModeTimer)\n      clearTimeout(this._pollRecorderModeTimer);\n    const state = await globalThis._playwrightRecorderState().catch((e) => null);\n    if (!state) {\n      this._pollRecorderModeTimer = setTimeout(() => this._pollRecorderMode(), pollPeriod);\n      return;\n    }\n    const { mode, actionPoint, actionSelector } = state;\n    if (mode !== this._mode) {\n      this._mode = mode;\n      this._clearHighlight();\n    }\n    if (actionPoint && this._actionPoint && actionPoint.x === this._actionPoint.x && actionPoint.y === this._actionPoint.y) {\n    } else if (!actionPoint && !this._actionPoint) {\n    } else {\n      if (actionPoint)\n        this._highlight.showActionPoint(actionPoint.x, actionPoint.y);\n      else\n        this._highlight.hideActionPoint();\n      this._actionPoint = actionPoint;\n    }\n    if (this._actionSelector && !((_a = this._hoveredModel) == null ? void 0 : _a.elements.length))\n      this._actionSelector = void 0;\n    if (actionSelector !== this._actionSelector) {\n      this._hoveredModel = actionSelector ? querySelector(this._injectedScript, actionSelector, document) : null;\n      this._updateHighlight();\n      this._actionSelector = actionSelector;\n    }\n    this._pollRecorderModeTimer = setTimeout(() => this._pollRecorderMode(), pollPeriod);\n  }\n  _clearHighlight() {\n    this._hoveredModel = null;\n    this._activeModel = null;\n    this._updateHighlight();\n  }\n  _actionInProgress(event) {\n    if (this._performingAction)\n      return true;\n    consumeEvent(event);\n    return false;\n  }\n  _consumedDueToNoModel(event, model) {\n    if (model)\n      return false;\n    consumeEvent(event);\n    return true;\n  }\n  _consumedDueWrongTarget(event) {\n    if (this._activeModel && this._activeModel.elements[0] === this._deepEventTarget(event))\n      return false;\n    consumeEvent(event);\n    return true;\n  }\n  _onClick(event) {\n    if (this._mode === "inspecting")\n      globalThis._playwrightRecorderSetSelector(this._hoveredModel ? this._hoveredModel.selector : "");\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (this._actionInProgress(event))\n      return;\n    if (this._consumedDueToNoModel(event, this._hoveredModel))\n      return;\n    const checkbox = asCheckbox(this._deepEventTarget(event));\n    if (checkbox) {\n      this._performAction({\n        name: checkbox.checked ? "check" : "uncheck",\n        selector: this._hoveredModel.selector,\n        signals: []\n      });\n      return;\n    }\n    this._performAction({\n      name: "click",\n      selector: this._hoveredModel.selector,\n      position: positionForEvent(event),\n      signals: [],\n      button: buttonForEvent(event),\n      modifiers: modifiersForEvent(event),\n      clickCount: event.detail\n    });\n  }\n  _shouldIgnoreMouseEvent(event) {\n    const target = this._deepEventTarget(event);\n    if (this._mode === "none")\n      return true;\n    if (this._mode === "inspecting") {\n      consumeEvent(event);\n      return true;\n    }\n    const nodeName = target.nodeName;\n    if (nodeName === "SELECT")\n      return true;\n    if (nodeName === "INPUT" && ["date"].includes(target.type))\n      return true;\n    return false;\n  }\n  _onMouseDown(event) {\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (!this._performingAction)\n      consumeEvent(event);\n    this._activeModel = this._hoveredModel;\n  }\n  _onMouseUp(event) {\n    if (this._shouldIgnoreMouseEvent(event))\n      return;\n    if (!this._performingAction)\n      consumeEvent(event);\n  }\n  _onMouseMove(event) {\n    if (this._mode === "none")\n      return;\n    const target = this._deepEventTarget(event);\n    if (this._hoveredElement === target)\n      return;\n    this._hoveredElement = target;\n    this._updateModelForHoveredElement();\n  }\n  _onMouseLeave(event) {\n    if (this._deepEventTarget(event).nodeType === Node.DOCUMENT_NODE) {\n      this._hoveredElement = null;\n      this._updateModelForHoveredElement();\n    }\n  }\n  _onFocus() {\n    const activeElement = this._deepActiveElement(document);\n    const result = activeElement ? generateSelector(this._injectedScript, activeElement, true) : null;\n    this._activeModel = result && result.selector ? result : null;\n    if (this._injectedScript.isUnderTest)\n      console.error("Highlight updated for test: " + (result ? result.selector : null));\n  }\n  _updateModelForHoveredElement() {\n    if (!this._hoveredElement) {\n      this._hoveredModel = null;\n      this._updateHighlight();\n      return;\n    }\n    const hoveredElement = this._hoveredElement;\n    const { selector, elements } = generateSelector(this._injectedScript, hoveredElement, true);\n    if (this._hoveredModel && this._hoveredModel.selector === selector || this._hoveredElement !== hoveredElement)\n      return;\n    this._hoveredModel = selector ? { selector, elements } : null;\n    this._updateHighlight();\n    if (this._injectedScript.isUnderTest)\n      console.error("Highlight updated for test: " + selector);\n  }\n  _updateHighlight() {\n    const elements = this._hoveredModel ? this._hoveredModel.elements : [];\n    const selector = this._hoveredModel ? this._hoveredModel.selector : "";\n    this._highlight.updateHighlight(elements, selector, this._mode === "recording");\n  }\n  _onInput(event) {\n    if (this._mode !== "recording")\n      return true;\n    const target = this._deepEventTarget(event);\n    if (["INPUT", "TEXTAREA"].includes(target.nodeName)) {\n      const inputElement = target;\n      const elementType = (inputElement.type || "").toLowerCase();\n      if (["checkbox", "radio"].includes(elementType)) {\n        return;\n      }\n      if (elementType === "file") {\n        globalThis._playwrightRecorderRecordAction({\n          name: "setInputFiles",\n          selector: this._activeModel.selector,\n          signals: [],\n          files: [...inputElement.files || []].map((file) => file.name)\n        });\n        return;\n      }\n      if (this._consumedDueWrongTarget(event))\n        return;\n      globalThis._playwrightRecorderRecordAction({\n        name: "fill",\n        selector: this._activeModel.selector,\n        signals: [],\n        text: inputElement.value\n      });\n    }\n    if (target.nodeName === "SELECT") {\n      const selectElement = target;\n      if (this._actionInProgress(event))\n        return;\n      this._performAction({\n        name: "select",\n        selector: this._hoveredModel.selector,\n        options: [...selectElement.selectedOptions].map((option) => option.value),\n        signals: []\n      });\n    }\n  }\n  _shouldGenerateKeyPressFor(event) {\n    if (["Backspace", "Delete", "AltGraph"].includes(event.key))\n      return false;\n    if (event.key === "@" && event.code === "KeyL")\n      return false;\n    if (navigator.platform.includes("Mac")) {\n      if (event.key === "v" && event.metaKey)\n        return false;\n    } else {\n      if (event.key === "v" && event.ctrlKey)\n        return false;\n      if (event.key === "Insert" && event.shiftKey)\n        return false;\n    }\n    if (["Shift", "Control", "Meta", "Alt"].includes(event.key))\n      return false;\n    const hasModifier = event.ctrlKey || event.altKey || event.metaKey;\n    if (event.key.length === 1 && !hasModifier)\n      return !!asCheckbox(this._deepEventTarget(event));\n    return true;\n  }\n  _onKeyDown(event) {\n    if (this._mode === "inspecting") {\n      consumeEvent(event);\n      return;\n    }\n    if (this._mode !== "recording")\n      return;\n    if (!this._shouldGenerateKeyPressFor(event))\n      return;\n    if (this._actionInProgress(event)) {\n      this._expectProgrammaticKeyUp = true;\n      return;\n    }\n    if (this._consumedDueWrongTarget(event))\n      return;\n    if (event.key === " ") {\n      const checkbox = asCheckbox(this._deepEventTarget(event));\n      if (checkbox) {\n        this._performAction({\n          name: checkbox.checked ? "uncheck" : "check",\n          selector: this._activeModel.selector,\n          signals: []\n        });\n        return;\n      }\n    }\n    this._performAction({\n      name: "press",\n      selector: this._activeModel.selector,\n      signals: [],\n      key: event.key,\n      modifiers: modifiersForEvent(event)\n    });\n  }\n  _onKeyUp(event) {\n    if (this._mode === "none")\n      return;\n    if (!this._shouldGenerateKeyPressFor(event))\n      return;\n    if (!this._expectProgrammaticKeyUp) {\n      consumeEvent(event);\n      return;\n    }\n    this._expectProgrammaticKeyUp = false;\n  }\n  async _performAction(action) {\n    this._clearHighlight();\n    this._performingAction = true;\n    await globalThis._playwrightRecorderPerformAction(action).catch(() => {\n    });\n    this._performingAction = false;\n    this._updateModelForHoveredElement();\n    this._onFocus();\n    if (this._injectedScript.isUnderTest) {\n      console.error("Action performed for test: " + JSON.stringify({\n        hovered: this._hoveredModel ? this._hoveredModel.selector : null,\n        active: this._activeModel ? this._activeModel.selector : null\n      }));\n    }\n  }\n  _deepEventTarget(event) {\n    return event.composedPath()[0];\n  }\n  _deepActiveElement(document2) {\n    let activeElement = document2.activeElement;\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n      activeElement = activeElement.shadowRoot.activeElement;\n    return activeElement;\n  }\n};\nfunction modifiersForEvent(event) {\n  return (event.altKey ? 1 : 0) | (event.ctrlKey ? 2 : 0) | (event.metaKey ? 4 : 0) | (event.shiftKey ? 8 : 0);\n}\nfunction buttonForEvent(event) {\n  switch (event.which) {\n    case 1:\n      return "left";\n    case 2:\n      return "middle";\n    case 3:\n      return "right";\n  }\n  return "left";\n}\nfunction positionForEvent(event) {\n  const targetElement = event.target;\n  if (targetElement.nodeName !== "CANVAS")\n    return;\n  return {\n    x: event.offsetX,\n    y: event.offsetY\n  };\n}\nfunction consumeEvent(e) {\n  e.preventDefault();\n  e.stopPropagation();\n  e.stopImmediatePropagation();\n}\nfunction asCheckbox(node) {\n  if (!node || node.nodeName !== "INPUT")\n    return null;\n  const inputElement = node;\n  return ["checkbox", "radio"].includes(inputElement.type) ? inputElement : null;\n}\nfunction addEventListener(target, eventName, listener, useCapture) {\n  target.addEventListener(eventName, listener, useCapture);\n  const remove = () => {\n    target.removeEventListener(eventName, listener, useCapture);\n  };\n  return remove;\n}\nfunction removeEventListeners(listeners) {\n  for (const listener of listeners)\n    listener();\n  listeners.splice(0, listeners.length);\n}\nmodule.exports = Recorder;\n';
    exports2.source = source;
  }
});

// node_modules/playwright-core/lib/generated/consoleApiSource.js
var require_consoleApiSource = __commonJS({
  "node_modules/playwright-core/lib/generated/consoleApiSource.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.source = void 0;
    var source = 'var __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === "object" || typeof from === "function") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));\n\n// packages/playwright-core/src/server/isomorphic/cssTokenizer.js\nvar require_cssTokenizer = __commonJS({\n  "packages/playwright-core/src/server/isomorphic/cssTokenizer.js"(exports2) {\n    (function(root, factory) {\n      if (typeof define === "function" && define.amd) {\n        define(["exports"], factory);\n      } else if (typeof exports2 !== "undefined") {\n        factory(exports2);\n      } else {\n        factory(root);\n      }\n    })(exports2, function(exports3) {\n      var between = function(num, first, last) {\n        return num >= first && num <= last;\n      };\n      function digit(code) {\n        return between(code, 48, 57);\n      }\n      function hexdigit(code) {\n        return digit(code) || between(code, 65, 70) || between(code, 97, 102);\n      }\n      function uppercaseletter(code) {\n        return between(code, 65, 90);\n      }\n      function lowercaseletter(code) {\n        return between(code, 97, 122);\n      }\n      function letter(code) {\n        return uppercaseletter(code) || lowercaseletter(code);\n      }\n      function nonascii(code) {\n        return code >= 128;\n      }\n      function namestartchar(code) {\n        return letter(code) || nonascii(code) || code == 95;\n      }\n      function namechar(code) {\n        return namestartchar(code) || digit(code) || code == 45;\n      }\n      function nonprintable(code) {\n        return between(code, 0, 8) || code == 11 || between(code, 14, 31) || code == 127;\n      }\n      function newline(code) {\n        return code == 10;\n      }\n      function whitespace(code) {\n        return newline(code) || code == 9 || code == 32;\n      }\n      function badescape(code) {\n        return newline(code) || isNaN(code);\n      }\n      var maximumallowedcodepoint = 1114111;\n      var InvalidCharacterError = function(message) {\n        this.message = message;\n      };\n      InvalidCharacterError.prototype = new Error();\n      InvalidCharacterError.prototype.name = "InvalidCharacterError";\n      function preprocess(str) {\n        var codepoints = [];\n        for (var i = 0; i < str.length; i++) {\n          var code = str.charCodeAt(i);\n          if (code == 13 && str.charCodeAt(i + 1) == 10) {\n            code = 10;\n            i++;\n          }\n          if (code == 13 || code == 12)\n            code = 10;\n          if (code == 0)\n            code = 65533;\n          if (between(code, 55296, 56319) && between(str.charCodeAt(i + 1), 56320, 57343)) {\n            var lead = code - 55296;\n            var trail = str.charCodeAt(i + 1) - 56320;\n            code = Math.pow(2, 16) + lead * Math.pow(2, 10) + trail;\n            i++;\n          }\n          codepoints.push(code);\n        }\n        return codepoints;\n      }\n      function stringFromCode(code) {\n        if (code <= 65535)\n          return String.fromCharCode(code);\n        code -= Math.pow(2, 16);\n        var lead = Math.floor(code / Math.pow(2, 10)) + 55296;\n        var trail = code % Math.pow(2, 10) + 56320;\n        return String.fromCharCode(lead) + String.fromCharCode(trail);\n      }\n      function tokenize2(str) {\n        str = preprocess(str);\n        var i = -1;\n        var tokens = [];\n        var code;\n        var line = 0;\n        var column = 0;\n        var lastLineLength = 0;\n        var incrLineno = function() {\n          line += 1;\n          lastLineLength = column;\n          column = 0;\n        };\n        var locStart = { line, column };\n        var codepoint = function(i2) {\n          if (i2 >= str.length) {\n            return -1;\n          }\n          return str[i2];\n        };\n        var next = function(num) {\n          if (num === void 0)\n            num = 1;\n          if (num > 3)\n            throw "Spec Error: no more than three codepoints of lookahead.";\n          return codepoint(i + num);\n        };\n        var consume = function(num) {\n          if (num === void 0)\n            num = 1;\n          i += num;\n          code = codepoint(i);\n          if (newline(code))\n            incrLineno();\n          else\n            column += num;\n          return true;\n        };\n        var reconsume = function() {\n          i -= 1;\n          if (newline(code)) {\n            line -= 1;\n            column = lastLineLength;\n          } else {\n            column -= 1;\n          }\n          locStart.line = line;\n          locStart.column = column;\n          return true;\n        };\n        var eof = function(codepoint2) {\n          if (codepoint2 === void 0)\n            codepoint2 = code;\n          return codepoint2 == -1;\n        };\n        var donothing = function() {\n        };\n        var parseerror = function() {\n          console.log("Parse error at index " + i + ", processing codepoint 0x" + code.toString(16) + ".");\n          return true;\n        };\n        var consumeAToken = function() {\n          consumeComments();\n          consume();\n          if (whitespace(code)) {\n            while (whitespace(next()))\n              consume();\n            return new WhitespaceToken2();\n          } else if (code == 34)\n            return consumeAStringToken();\n          else if (code == 35) {\n            if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n              var token = new HashToken2();\n              if (wouldStartAnIdentifier(next(1), next(2), next(3)))\n                token.type = "id";\n              token.value = consumeAName();\n              return token;\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 36) {\n            if (next() == 61) {\n              consume();\n              return new SuffixMatchToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 39)\n            return consumeAStringToken();\n          else if (code == 40)\n            return new OpenParenToken();\n          else if (code == 41)\n            return new CloseParenToken2();\n          else if (code == 42) {\n            if (next() == 61) {\n              consume();\n              return new SubstringMatchToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 43) {\n            if (startsWithANumber()) {\n              reconsume();\n              return consumeANumericToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 44)\n            return new CommaToken2();\n          else if (code == 45) {\n            if (startsWithANumber()) {\n              reconsume();\n              return consumeANumericToken();\n            } else if (next(1) == 45 && next(2) == 62) {\n              consume(2);\n              return new CDCToken2();\n            } else if (startsWithAnIdentifier()) {\n              reconsume();\n              return consumeAnIdentlikeToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 46) {\n            if (startsWithANumber()) {\n              reconsume();\n              return consumeANumericToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 58)\n            return new ColonToken2();\n          else if (code == 59)\n            return new SemicolonToken2();\n          else if (code == 60) {\n            if (next(1) == 33 && next(2) == 45 && next(3) == 45) {\n              consume(3);\n              return new CDOToken2();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 64) {\n            if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n              return new AtKeywordToken2(consumeAName());\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 91)\n            return new OpenSquareToken2();\n          else if (code == 92) {\n            if (startsWithAValidEscape()) {\n              reconsume();\n              return consumeAnIdentlikeToken();\n            } else {\n              parseerror();\n              return new DelimToken2(code);\n            }\n          } else if (code == 93)\n            return new CloseSquareToken2();\n          else if (code == 94) {\n            if (next() == 61) {\n              consume();\n              return new PrefixMatchToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 123)\n            return new OpenCurlyToken2();\n          else if (code == 124) {\n            if (next() == 61) {\n              consume();\n              return new DashMatchToken();\n            } else if (next() == 124) {\n              consume();\n              return new ColumnToken2();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (code == 125)\n            return new CloseCurlyToken2();\n          else if (code == 126) {\n            if (next() == 61) {\n              consume();\n              return new IncludeMatchToken();\n            } else {\n              return new DelimToken2(code);\n            }\n          } else if (digit(code)) {\n            reconsume();\n            return consumeANumericToken();\n          } else if (namestartchar(code)) {\n            reconsume();\n            return consumeAnIdentlikeToken();\n          } else if (eof())\n            return new EOFToken2();\n          else\n            return new DelimToken2(code);\n        };\n        var consumeComments = function() {\n          while (next(1) == 47 && next(2) == 42) {\n            consume(2);\n            while (true) {\n              consume();\n              if (code == 42 && next() == 47) {\n                consume();\n                break;\n              } else if (eof()) {\n                parseerror();\n                return;\n              }\n            }\n          }\n        };\n        var consumeANumericToken = function() {\n          var num = consumeANumber();\n          if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n            var token = new DimensionToken();\n            token.value = num.value;\n            token.repr = num.repr;\n            token.type = num.type;\n            token.unit = consumeAName();\n            return token;\n          } else if (next() == 37) {\n            consume();\n            var token = new PercentageToken2();\n            token.value = num.value;\n            token.repr = num.repr;\n            return token;\n          } else {\n            var token = new NumberToken2();\n            token.value = num.value;\n            token.repr = num.repr;\n            token.type = num.type;\n            return token;\n          }\n        };\n        var consumeAnIdentlikeToken = function() {\n          var str2 = consumeAName();\n          if (str2.toLowerCase() == "url" && next() == 40) {\n            consume();\n            while (whitespace(next(1)) && whitespace(next(2)))\n              consume();\n            if (next() == 34 || next() == 39) {\n              return new FunctionToken2(str2);\n            } else if (whitespace(next()) && (next(2) == 34 || next(2) == 39)) {\n              return new FunctionToken2(str2);\n            } else {\n              return consumeAURLToken();\n            }\n          } else if (next() == 40) {\n            consume();\n            return new FunctionToken2(str2);\n          } else {\n            return new IdentToken2(str2);\n          }\n        };\n        var consumeAStringToken = function(endingCodePoint) {\n          if (endingCodePoint === void 0)\n            endingCodePoint = code;\n          var string = "";\n          while (consume()) {\n            if (code == endingCodePoint || eof()) {\n              return new StringToken2(string);\n            } else if (newline(code)) {\n              parseerror();\n              reconsume();\n              return new BadStringToken2();\n            } else if (code == 92) {\n              if (eof(next())) {\n                donothing();\n              } else if (newline(next())) {\n                consume();\n              } else {\n                string += stringFromCode(consumeEscape());\n              }\n            } else {\n              string += stringFromCode(code);\n            }\n          }\n        };\n        var consumeAURLToken = function() {\n          var token = new URLToken2("");\n          while (whitespace(next()))\n            consume();\n          if (eof(next()))\n            return token;\n          while (consume()) {\n            if (code == 41 || eof()) {\n              return token;\n            } else if (whitespace(code)) {\n              while (whitespace(next()))\n                consume();\n              if (next() == 41 || eof(next())) {\n                consume();\n                return token;\n              } else {\n                consumeTheRemnantsOfABadURL();\n                return new BadURLToken2();\n              }\n            } else if (code == 34 || code == 39 || code == 40 || nonprintable(code)) {\n              parseerror();\n              consumeTheRemnantsOfABadURL();\n              return new BadURLToken2();\n            } else if (code == 92) {\n              if (startsWithAValidEscape()) {\n                token.value += stringFromCode(consumeEscape());\n              } else {\n                parseerror();\n                consumeTheRemnantsOfABadURL();\n                return new BadURLToken2();\n              }\n            } else {\n              token.value += stringFromCode(code);\n            }\n          }\n        };\n        var consumeEscape = function() {\n          consume();\n          if (hexdigit(code)) {\n            var digits = [code];\n            for (var total = 0; total < 5; total++) {\n              if (hexdigit(next())) {\n                consume();\n                digits.push(code);\n              } else {\n                break;\n              }\n            }\n            if (whitespace(next()))\n              consume();\n            var value = parseInt(digits.map(function(x) {\n              return String.fromCharCode(x);\n            }).join(""), 16);\n            if (value > maximumallowedcodepoint)\n              value = 65533;\n            return value;\n          } else if (eof()) {\n            return 65533;\n          } else {\n            return code;\n          }\n        };\n        var areAValidEscape = function(c1, c2) {\n          if (c1 != 92)\n            return false;\n          if (newline(c2))\n            return false;\n          return true;\n        };\n        var startsWithAValidEscape = function() {\n          return areAValidEscape(code, next());\n        };\n        var wouldStartAnIdentifier = function(c1, c2, c3) {\n          if (c1 == 45) {\n            return namestartchar(c2) || c2 == 45 || areAValidEscape(c2, c3);\n          } else if (namestartchar(c1)) {\n            return true;\n          } else if (c1 == 92) {\n            return areAValidEscape(c1, c2);\n          } else {\n            return false;\n          }\n        };\n        var startsWithAnIdentifier = function() {\n          return wouldStartAnIdentifier(code, next(1), next(2));\n        };\n        var wouldStartANumber = function(c1, c2, c3) {\n          if (c1 == 43 || c1 == 45) {\n            if (digit(c2))\n              return true;\n            if (c2 == 46 && digit(c3))\n              return true;\n            return false;\n          } else if (c1 == 46) {\n            if (digit(c2))\n              return true;\n            return false;\n          } else if (digit(c1)) {\n            return true;\n          } else {\n            return false;\n          }\n        };\n        var startsWithANumber = function() {\n          return wouldStartANumber(code, next(1), next(2));\n        };\n        var consumeAName = function() {\n          var result = "";\n          while (consume()) {\n            if (namechar(code)) {\n              result += stringFromCode(code);\n            } else if (startsWithAValidEscape()) {\n              result += stringFromCode(consumeEscape());\n            } else {\n              reconsume();\n              return result;\n            }\n          }\n        };\n        var consumeANumber = function() {\n          var repr = [];\n          var type = "integer";\n          if (next() == 43 || next() == 45) {\n            consume();\n            repr += stringFromCode(code);\n          }\n          while (digit(next())) {\n            consume();\n            repr += stringFromCode(code);\n          }\n          if (next(1) == 46 && digit(next(2))) {\n            consume();\n            repr += stringFromCode(code);\n            consume();\n            repr += stringFromCode(code);\n            type = "number";\n            while (digit(next())) {\n              consume();\n              repr += stringFromCode(code);\n            }\n          }\n          var c1 = next(1), c2 = next(2), c3 = next(3);\n          if ((c1 == 69 || c1 == 101) && digit(c2)) {\n            consume();\n            repr += stringFromCode(code);\n            consume();\n            repr += stringFromCode(code);\n            type = "number";\n            while (digit(next())) {\n              consume();\n              repr += stringFromCode(code);\n            }\n          } else if ((c1 == 69 || c1 == 101) && (c2 == 43 || c2 == 45) && digit(c3)) {\n            consume();\n            repr += stringFromCode(code);\n            consume();\n            repr += stringFromCode(code);\n            consume();\n            repr += stringFromCode(code);\n            type = "number";\n            while (digit(next())) {\n              consume();\n              repr += stringFromCode(code);\n            }\n          }\n          var value = convertAStringToANumber(repr);\n          return { type, value, repr };\n        };\n        var convertAStringToANumber = function(string) {\n          return +string;\n        };\n        var consumeTheRemnantsOfABadURL = function() {\n          while (consume()) {\n            if (code == 41 || eof()) {\n              return;\n            } else if (startsWithAValidEscape()) {\n              consumeEscape();\n              donothing();\n            } else {\n              donothing();\n            }\n          }\n        };\n        var iterationCount = 0;\n        while (!eof(next())) {\n          tokens.push(consumeAToken());\n          iterationCount++;\n          if (iterationCount > str.length * 2)\n            return "I\'m infinite-looping!";\n        }\n        return tokens;\n      }\n      function CSSParserToken() {\n        throw "Abstract Base Class";\n      }\n      CSSParserToken.prototype.toJSON = function() {\n        return { token: this.tokenType };\n      };\n      CSSParserToken.prototype.toString = function() {\n        return this.tokenType;\n      };\n      CSSParserToken.prototype.toSource = function() {\n        return "" + this;\n      };\n      function BadStringToken2() {\n        return this;\n      }\n      BadStringToken2.prototype = Object.create(CSSParserToken.prototype);\n      BadStringToken2.prototype.tokenType = "BADSTRING";\n      function BadURLToken2() {\n        return this;\n      }\n      BadURLToken2.prototype = Object.create(CSSParserToken.prototype);\n      BadURLToken2.prototype.tokenType = "BADURL";\n      function WhitespaceToken2() {\n        return this;\n      }\n      WhitespaceToken2.prototype = Object.create(CSSParserToken.prototype);\n      WhitespaceToken2.prototype.tokenType = "WHITESPACE";\n      WhitespaceToken2.prototype.toString = function() {\n        return "WS";\n      };\n      WhitespaceToken2.prototype.toSource = function() {\n        return " ";\n      };\n      function CDOToken2() {\n        return this;\n      }\n      CDOToken2.prototype = Object.create(CSSParserToken.prototype);\n      CDOToken2.prototype.tokenType = "CDO";\n      CDOToken2.prototype.toSource = function() {\n        return "<!--";\n      };\n      function CDCToken2() {\n        return this;\n      }\n      CDCToken2.prototype = Object.create(CSSParserToken.prototype);\n      CDCToken2.prototype.tokenType = "CDC";\n      CDCToken2.prototype.toSource = function() {\n        return "-->";\n      };\n      function ColonToken2() {\n        return this;\n      }\n      ColonToken2.prototype = Object.create(CSSParserToken.prototype);\n      ColonToken2.prototype.tokenType = ":";\n      function SemicolonToken2() {\n        return this;\n      }\n      SemicolonToken2.prototype = Object.create(CSSParserToken.prototype);\n      SemicolonToken2.prototype.tokenType = ";";\n      function CommaToken2() {\n        return this;\n      }\n      CommaToken2.prototype = Object.create(CSSParserToken.prototype);\n      CommaToken2.prototype.tokenType = ",";\n      function GroupingToken() {\n        throw "Abstract Base Class";\n      }\n      GroupingToken.prototype = Object.create(CSSParserToken.prototype);\n      function OpenCurlyToken2() {\n        this.value = "{";\n        this.mirror = "}";\n        return this;\n      }\n      OpenCurlyToken2.prototype = Object.create(GroupingToken.prototype);\n      OpenCurlyToken2.prototype.tokenType = "{";\n      function CloseCurlyToken2() {\n        this.value = "}";\n        this.mirror = "{";\n        return this;\n      }\n      CloseCurlyToken2.prototype = Object.create(GroupingToken.prototype);\n      CloseCurlyToken2.prototype.tokenType = "}";\n      function OpenSquareToken2() {\n        this.value = "[";\n        this.mirror = "]";\n        return this;\n      }\n      OpenSquareToken2.prototype = Object.create(GroupingToken.prototype);\n      OpenSquareToken2.prototype.tokenType = "[";\n      function CloseSquareToken2() {\n        this.value = "]";\n        this.mirror = "[";\n        return this;\n      }\n      CloseSquareToken2.prototype = Object.create(GroupingToken.prototype);\n      CloseSquareToken2.prototype.tokenType = "]";\n      function OpenParenToken() {\n        this.value = "(";\n        this.mirror = ")";\n        return this;\n      }\n      OpenParenToken.prototype = Object.create(GroupingToken.prototype);\n      OpenParenToken.prototype.tokenType = "(";\n      function CloseParenToken2() {\n        this.value = ")";\n        this.mirror = "(";\n        return this;\n      }\n      CloseParenToken2.prototype = Object.create(GroupingToken.prototype);\n      CloseParenToken2.prototype.tokenType = ")";\n      function IncludeMatchToken() {\n        return this;\n      }\n      IncludeMatchToken.prototype = Object.create(CSSParserToken.prototype);\n      IncludeMatchToken.prototype.tokenType = "~=";\n      function DashMatchToken() {\n        return this;\n      }\n      DashMatchToken.prototype = Object.create(CSSParserToken.prototype);\n      DashMatchToken.prototype.tokenType = "|=";\n      function PrefixMatchToken() {\n        return this;\n      }\n      PrefixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n      PrefixMatchToken.prototype.tokenType = "^=";\n      function SuffixMatchToken() {\n        return this;\n      }\n      SuffixMatchToken.prototype = Object.create(CSSParserToken.prototype);\n      SuffixMatchToken.prototype.tokenType = "$=";\n      function SubstringMatchToken() {\n        return this;\n      }\n      SubstringMatchToken.prototype = Object.create(CSSParserToken.prototype);\n      SubstringMatchToken.prototype.tokenType = "*=";\n      function ColumnToken2() {\n        return this;\n      }\n      ColumnToken2.prototype = Object.create(CSSParserToken.prototype);\n      ColumnToken2.prototype.tokenType = "||";\n      function EOFToken2() {\n        return this;\n      }\n      EOFToken2.prototype = Object.create(CSSParserToken.prototype);\n      EOFToken2.prototype.tokenType = "EOF";\n      EOFToken2.prototype.toSource = function() {\n        return "";\n      };\n      function DelimToken2(code) {\n        this.value = stringFromCode(code);\n        return this;\n      }\n      DelimToken2.prototype = Object.create(CSSParserToken.prototype);\n      DelimToken2.prototype.tokenType = "DELIM";\n      DelimToken2.prototype.toString = function() {\n        return "DELIM(" + this.value + ")";\n      };\n      DelimToken2.prototype.toJSON = function() {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        return json;\n      };\n      DelimToken2.prototype.toSource = function() {\n        if (this.value == "\\\\")\n          return "\\\\\\n";\n        else\n          return this.value;\n      };\n      function StringValuedToken() {\n        throw "Abstract Base Class";\n      }\n      StringValuedToken.prototype = Object.create(CSSParserToken.prototype);\n      StringValuedToken.prototype.ASCIIMatch = function(str) {\n        return this.value.toLowerCase() == str.toLowerCase();\n      };\n      StringValuedToken.prototype.toJSON = function() {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        return json;\n      };\n      function IdentToken2(val) {\n        this.value = val;\n      }\n      IdentToken2.prototype = Object.create(StringValuedToken.prototype);\n      IdentToken2.prototype.tokenType = "IDENT";\n      IdentToken2.prototype.toString = function() {\n        return "IDENT(" + this.value + ")";\n      };\n      IdentToken2.prototype.toSource = function() {\n        return escapeIdent(this.value);\n      };\n      function FunctionToken2(val) {\n        this.value = val;\n        this.mirror = ")";\n      }\n      FunctionToken2.prototype = Object.create(StringValuedToken.prototype);\n      FunctionToken2.prototype.tokenType = "FUNCTION";\n      FunctionToken2.prototype.toString = function() {\n        return "FUNCTION(" + this.value + ")";\n      };\n      FunctionToken2.prototype.toSource = function() {\n        return escapeIdent(this.value) + "(";\n      };\n      function AtKeywordToken2(val) {\n        this.value = val;\n      }\n      AtKeywordToken2.prototype = Object.create(StringValuedToken.prototype);\n      AtKeywordToken2.prototype.tokenType = "AT-KEYWORD";\n      AtKeywordToken2.prototype.toString = function() {\n        return "AT(" + this.value + ")";\n      };\n      AtKeywordToken2.prototype.toSource = function() {\n        return "@" + escapeIdent(this.value);\n      };\n      function HashToken2(val) {\n        this.value = val;\n        this.type = "unrestricted";\n      }\n      HashToken2.prototype = Object.create(StringValuedToken.prototype);\n      HashToken2.prototype.tokenType = "HASH";\n      HashToken2.prototype.toString = function() {\n        return "HASH(" + this.value + ")";\n      };\n      HashToken2.prototype.toJSON = function() {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        return json;\n      };\n      HashToken2.prototype.toSource = function() {\n        if (this.type == "id") {\n          return "#" + escapeIdent(this.value);\n        } else {\n          return "#" + escapeHash(this.value);\n        }\n      };\n      function StringToken2(val) {\n        this.value = val;\n      }\n      StringToken2.prototype = Object.create(StringValuedToken.prototype);\n      StringToken2.prototype.tokenType = "STRING";\n      StringToken2.prototype.toString = function() {\n        return \'"\' + escapeString(this.value) + \'"\';\n      };\n      function URLToken2(val) {\n        this.value = val;\n      }\n      URLToken2.prototype = Object.create(StringValuedToken.prototype);\n      URLToken2.prototype.tokenType = "URL";\n      URLToken2.prototype.toString = function() {\n        return "URL(" + this.value + ")";\n      };\n      URLToken2.prototype.toSource = function() {\n        return \'url("\' + escapeString(this.value) + \'")\';\n      };\n      function NumberToken2() {\n        this.value = null;\n        this.type = "integer";\n        this.repr = "";\n      }\n      NumberToken2.prototype = Object.create(CSSParserToken.prototype);\n      NumberToken2.prototype.tokenType = "NUMBER";\n      NumberToken2.prototype.toString = function() {\n        if (this.type == "integer")\n          return "INT(" + this.value + ")";\n        return "NUMBER(" + this.value + ")";\n      };\n      NumberToken2.prototype.toJSON = function() {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        json.repr = this.repr;\n        return json;\n      };\n      NumberToken2.prototype.toSource = function() {\n        return this.repr;\n      };\n      function PercentageToken2() {\n        this.value = null;\n        this.repr = "";\n      }\n      PercentageToken2.prototype = Object.create(CSSParserToken.prototype);\n      PercentageToken2.prototype.tokenType = "PERCENTAGE";\n      PercentageToken2.prototype.toString = function() {\n        return "PERCENTAGE(" + this.value + ")";\n      };\n      PercentageToken2.prototype.toJSON = function() {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.repr = this.repr;\n        return json;\n      };\n      PercentageToken2.prototype.toSource = function() {\n        return this.repr + "%";\n      };\n      function DimensionToken() {\n        this.value = null;\n        this.type = "integer";\n        this.repr = "";\n        this.unit = "";\n      }\n      DimensionToken.prototype = Object.create(CSSParserToken.prototype);\n      DimensionToken.prototype.tokenType = "DIMENSION";\n      DimensionToken.prototype.toString = function() {\n        return "DIM(" + this.value + "," + this.unit + ")";\n      };\n      DimensionToken.prototype.toJSON = function() {\n        var json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n        json.value = this.value;\n        json.type = this.type;\n        json.repr = this.repr;\n        json.unit = this.unit;\n        return json;\n      };\n      DimensionToken.prototype.toSource = function() {\n        var source = this.repr;\n        var unit = escapeIdent(this.unit);\n        if (unit[0].toLowerCase() == "e" && (unit[1] == "-" || between(unit.charCodeAt(1), 48, 57))) {\n          unit = "\\\\65 " + unit.slice(1, unit.length);\n        }\n        return source + unit;\n      };\n      function escapeIdent(string) {\n        string = "" + string;\n        var result = "";\n        var firstcode = string.charCodeAt(0);\n        for (var i = 0; i < string.length; i++) {\n          var code = string.charCodeAt(i);\n          if (code == 0) {\n            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n          }\n          if (between(code, 1, 31) || code == 127 || i == 0 && between(code, 48, 57) || i == 1 && between(code, 48, 57) && firstcode == 45) {\n            result += "\\\\" + code.toString(16) + " ";\n          } else if (code >= 128 || code == 45 || code == 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122)) {\n            result += string[i];\n          } else {\n            result += "\\\\" + string[i];\n          }\n        }\n        return result;\n      }\n      function escapeHash(string) {\n        string = "" + string;\n        var result = "";\n        var firstcode = string.charCodeAt(0);\n        for (var i = 0; i < string.length; i++) {\n          var code = string.charCodeAt(i);\n          if (code == 0) {\n            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n          }\n          if (code >= 128 || code == 45 || code == 95 || between(code, 48, 57) || between(code, 65, 90) || between(code, 97, 122)) {\n            result += string[i];\n          } else {\n            result += "\\\\" + code.toString(16) + " ";\n          }\n        }\n        return result;\n      }\n      function escapeString(string) {\n        string = "" + string;\n        var result = "";\n        for (var i = 0; i < string.length; i++) {\n          var code = string.charCodeAt(i);\n          if (code == 0) {\n            throw new InvalidCharacterError("Invalid character: the input contains U+0000.");\n          }\n          if (between(code, 1, 31) || code == 127) {\n            result += "\\\\" + code.toString(16) + " ";\n          } else if (code == 34 || code == 92) {\n            result += "\\\\" + string[i];\n          } else {\n            result += string[i];\n          }\n        }\n        return result;\n      }\n      exports3.tokenize = tokenize2;\n      exports3.IdentToken = IdentToken2;\n      exports3.FunctionToken = FunctionToken2;\n      exports3.AtKeywordToken = AtKeywordToken2;\n      exports3.HashToken = HashToken2;\n      exports3.StringToken = StringToken2;\n      exports3.BadStringToken = BadStringToken2;\n      exports3.URLToken = URLToken2;\n      exports3.BadURLToken = BadURLToken2;\n      exports3.DelimToken = DelimToken2;\n      exports3.NumberToken = NumberToken2;\n      exports3.PercentageToken = PercentageToken2;\n      exports3.DimensionToken = DimensionToken;\n      exports3.IncludeMatchToken = IncludeMatchToken;\n      exports3.DashMatchToken = DashMatchToken;\n      exports3.PrefixMatchToken = PrefixMatchToken;\n      exports3.SuffixMatchToken = SuffixMatchToken;\n      exports3.SubstringMatchToken = SubstringMatchToken;\n      exports3.ColumnToken = ColumnToken2;\n      exports3.WhitespaceToken = WhitespaceToken2;\n      exports3.CDOToken = CDOToken2;\n      exports3.CDCToken = CDCToken2;\n      exports3.ColonToken = ColonToken2;\n      exports3.SemicolonToken = SemicolonToken2;\n      exports3.CommaToken = CommaToken2;\n      exports3.OpenParenToken = OpenParenToken;\n      exports3.CloseParenToken = CloseParenToken2;\n      exports3.OpenSquareToken = OpenSquareToken2;\n      exports3.CloseSquareToken = CloseSquareToken2;\n      exports3.OpenCurlyToken = OpenCurlyToken2;\n      exports3.CloseCurlyToken = CloseCurlyToken2;\n      exports3.EOFToken = EOFToken2;\n      exports3.CSSParserToken = CSSParserToken;\n      exports3.GroupingToken = GroupingToken;\n    });\n  }\n});\n\n// packages/playwright-core/src/utils/isomorphic/stringUtils.ts\nfunction escapeWithQuotes(text, char = "\'") {\n  const stringified = JSON.stringify(text);\n  const escapedText = stringified.substring(1, stringified.length - 1).replace(/\\\\"/g, \'"\');\n  if (char === "\'")\n    return char + escapedText.replace(/[\']/g, "\\\\\'") + char;\n  if (char === \'"\')\n    return char + escapedText.replace(/["]/g, \'\\\\"\') + char;\n  if (char === "`")\n    return char + escapedText.replace(/[`]/g, "`") + char;\n  throw new Error("Invalid escape char");\n}\n\n// packages/playwright-core/src/server/isomorphic/cssParser.ts\nvar css = __toESM(require_cssTokenizer());\n\n// packages/playwright-core/src/server/injected/selectorEvaluator.ts\nfunction shouldSkipForTextMatching(element) {\n  return element.nodeName === "SCRIPT" || element.nodeName === "STYLE" || document.head && document.head.contains(element);\n}\nfunction elementText(evaluator, root) {\n  let value = evaluator._cacheText.get(root);\n  if (value === void 0) {\n    value = { full: "", immediate: [] };\n    if (!shouldSkipForTextMatching(root)) {\n      let currentImmediate = "";\n      if (root instanceof HTMLInputElement && (root.type === "submit" || root.type === "button")) {\n        value = { full: root.value, immediate: [root.value] };\n      } else {\n        for (let child = root.firstChild; child; child = child.nextSibling) {\n          if (child.nodeType === Node.TEXT_NODE) {\n            value.full += child.nodeValue || "";\n            currentImmediate += child.nodeValue || "";\n          } else {\n            if (currentImmediate)\n              value.immediate.push(currentImmediate);\n            currentImmediate = "";\n            if (child.nodeType === Node.ELEMENT_NODE)\n              value.full += elementText(evaluator, child).full;\n          }\n        }\n        if (currentImmediate)\n          value.immediate.push(currentImmediate);\n        if (root.shadowRoot)\n          value.full += elementText(evaluator, root.shadowRoot).full;\n      }\n    }\n    evaluator._cacheText.set(root, value);\n  }\n  return value;\n}\n\n// packages/playwright-core/src/server/injected/selectorGenerator.ts\nvar cacheAllowText = /* @__PURE__ */ new Map();\nvar cacheDisallowText = /* @__PURE__ */ new Map();\nvar kNthScore = 1e3;\nfunction generateSelector(injectedScript, targetElement, strict) {\n  injectedScript._evaluator.begin();\n  try {\n    targetElement = targetElement.closest("button,select,input,[role=button],[role=checkbox],[role=radio]") || targetElement;\n    const targetTokens = generateSelectorFor(injectedScript, targetElement, strict);\n    const bestTokens = targetTokens || cssFallback(injectedScript, targetElement, strict);\n    const selector = joinTokens(bestTokens);\n    const parsedSelector = injectedScript.parseSelector(selector);\n    return {\n      selector,\n      elements: injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument)\n    };\n  } finally {\n    cacheAllowText.clear();\n    cacheDisallowText.clear();\n    injectedScript._evaluator.end();\n  }\n}\nfunction filterRegexTokens(textCandidates) {\n  return textCandidates.filter((c) => c[0].selector[0] !== "/");\n}\nfunction generateSelectorFor(injectedScript, targetElement, strict) {\n  if (targetElement.ownerDocument.documentElement === targetElement)\n    return [{ engine: "css", selector: "html", score: 1 }];\n  const calculate = (element, allowText) => {\n    const allowNthMatch = element === targetElement;\n    let textCandidates = allowText ? buildTextCandidates(injectedScript, element, element === targetElement).map((token) => [token]) : [];\n    if (element !== targetElement) {\n      textCandidates = filterRegexTokens(textCandidates);\n    }\n    const noTextCandidates = buildCandidates(injectedScript, element).map((token) => [token]);\n    let result = chooseFirstSelector(injectedScript, targetElement.ownerDocument, element, [...textCandidates, ...noTextCandidates], allowNthMatch, strict);\n    textCandidates = filterRegexTokens(textCandidates);\n    const checkWithText = (textCandidatesToUse) => {\n      const allowParentText = allowText && !textCandidatesToUse.length;\n      const candidates = [...textCandidatesToUse, ...noTextCandidates].filter((c) => {\n        if (!result)\n          return true;\n        return combineScores(c) < combineScores(result);\n      });\n      let bestPossibleInParent = candidates[0];\n      if (!bestPossibleInParent)\n        return;\n      for (let parent = parentElementOrShadowHost(element); parent; parent = parentElementOrShadowHost(parent)) {\n        const parentTokens = calculateCached(parent, allowParentText);\n        if (!parentTokens)\n          continue;\n        if (result && combineScores([...parentTokens, ...bestPossibleInParent]) >= combineScores(result))\n          continue;\n        bestPossibleInParent = chooseFirstSelector(injectedScript, parent, element, candidates, allowNthMatch, strict);\n        if (!bestPossibleInParent)\n          return;\n        const combined = [...parentTokens, ...bestPossibleInParent];\n        if (!result || combineScores(combined) < combineScores(result))\n          result = combined;\n      }\n    };\n    checkWithText(textCandidates);\n    if (element === targetElement && textCandidates.length)\n      checkWithText([]);\n    return result;\n  };\n  const calculateCached = (element, allowText) => {\n    const cache = allowText ? cacheAllowText : cacheDisallowText;\n    let value = cache.get(element);\n    if (value === void 0) {\n      value = calculate(element, allowText);\n      cache.set(element, value);\n    }\n    return value;\n  };\n  return calculateCached(targetElement, true);\n}\nfunction buildCandidates(injectedScript, element) {\n  const candidates = [];\n  for (const attribute of ["data-testid", "data-test-id", "data-test"]) {\n    if (element.getAttribute(attribute))\n      candidates.push({ engine: "css", selector: `[${attribute}=${quoteAttributeValue(element.getAttribute(attribute))}]`, score: 1 });\n  }\n  if (element.nodeName === "INPUT") {\n    const input = element;\n    if (input.placeholder)\n      candidates.push({ engine: "css", selector: `[placeholder=${quoteAttributeValue(input.placeholder)}]`, score: 10 });\n  }\n  if (element.getAttribute("aria-label"))\n    candidates.push({ engine: "css", selector: `[aria-label=${quoteAttributeValue(element.getAttribute("aria-label"))}]`, score: 10 });\n  if (element.getAttribute("alt") && ["APPLET", "AREA", "IMG", "INPUT"].includes(element.nodeName))\n    candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[alt=${quoteAttributeValue(element.getAttribute("alt"))}]`, score: 10 });\n  if (element.getAttribute("role"))\n    candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[role=${quoteAttributeValue(element.getAttribute("role"))}]`, score: 50 });\n  if (element.getAttribute("name") && ["BUTTON", "FORM", "FIELDSET", "IFRAME", "INPUT", "KEYGEN", "OBJECT", "OUTPUT", "SELECT", "TEXTAREA", "MAP", "META", "PARAM"].includes(element.nodeName))\n    candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[name=${quoteAttributeValue(element.getAttribute("name"))}]`, score: 50 });\n  if (["INPUT", "TEXTAREA"].includes(element.nodeName) && element.getAttribute("type") !== "hidden") {\n    if (element.getAttribute("type"))\n      candidates.push({ engine: "css", selector: `${cssEscape(element.nodeName.toLowerCase())}[type=${quoteAttributeValue(element.getAttribute("type"))}]`, score: 50 });\n  }\n  if (["INPUT", "TEXTAREA", "SELECT"].includes(element.nodeName))\n    candidates.push({ engine: "css", selector: cssEscape(element.nodeName.toLowerCase()), score: 50 });\n  const idAttr = element.getAttribute("id");\n  if (idAttr && !isGuidLike(idAttr))\n    candidates.push({ engine: "css", selector: makeSelectorForId(idAttr), score: 100 });\n  candidates.push({ engine: "css", selector: cssEscape(element.nodeName.toLowerCase()), score: 200 });\n  return candidates;\n}\nfunction buildTextCandidates(injectedScript, element, allowHasText) {\n  if (element.nodeName === "SELECT")\n    return [];\n  const text = elementText(injectedScript._evaluator, element).full.trim().replace(/\\s+/g, " ").substring(0, 80);\n  if (!text)\n    return [];\n  const candidates = [];\n  let escaped = text;\n  if (text.includes(\'"\') || text.includes(">>") || text[0] === "/")\n    escaped = `/.*${escapeForRegex(text)}.*/`;\n  candidates.push({ engine: "text", selector: escaped, score: 10 });\n  if (allowHasText && escaped === text) {\n    let prefix = element.nodeName.toLowerCase();\n    if (element.hasAttribute("role"))\n      prefix += `[role=${quoteAttributeValue(element.getAttribute("role"))}]`;\n    candidates.push({ engine: "css", selector: `${prefix}:has-text("${text}")`, score: 30 });\n  }\n  return candidates;\n}\nfunction parentElementOrShadowHost(element) {\n  if (element.parentElement)\n    return element.parentElement;\n  if (!element.parentNode)\n    return null;\n  if (element.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE && element.parentNode.host)\n    return element.parentNode.host;\n  return null;\n}\nfunction makeSelectorForId(id) {\n  return /^[a-zA-Z][a-zA-Z0-9\\-\\_]+$/.test(id) ? "#" + id : `[id="${cssEscape(id)}"]`;\n}\nfunction cssFallback(injectedScript, targetElement, strict) {\n  const kFallbackScore = 1e7;\n  const root = targetElement.ownerDocument;\n  const tokens = [];\n  function uniqueCSSSelector(prefix) {\n    const path = tokens.slice();\n    if (prefix)\n      path.unshift(prefix);\n    const selector = path.join(" ");\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const node = injectedScript.querySelector(parsedSelector, targetElement.ownerDocument, false);\n    return node === targetElement ? selector : void 0;\n  }\n  function makeStrict(selector) {\n    const token = { engine: "css", selector, score: kFallbackScore };\n    if (!strict)\n      return [token];\n    const parsedSelector = injectedScript.parseSelector(selector);\n    const elements = injectedScript.querySelectorAll(parsedSelector, targetElement.ownerDocument);\n    if (elements.length === 1)\n      return [token];\n    const nth = { engine: "nth", selector: String(elements.indexOf(targetElement)), score: kNthScore };\n    return [token, nth];\n  }\n  for (let element = targetElement; element && element !== root; element = parentElementOrShadowHost(element)) {\n    const nodeName = element.nodeName.toLowerCase();\n    let bestTokenForLevel = "";\n    if (element.id) {\n      const token = makeSelectorForId(element.id);\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      bestTokenForLevel = token;\n    }\n    const parent = element.parentNode;\n    const classes = [...element.classList];\n    for (let i = 0; i < classes.length; ++i) {\n      const token = "." + classes.slice(0, i + 1).join(".");\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel && parent) {\n        const sameClassSiblings = parent.querySelectorAll(token);\n        if (sameClassSiblings.length === 1)\n          bestTokenForLevel = token;\n      }\n    }\n    if (parent) {\n      const siblings = [...parent.children];\n      const sameTagSiblings = siblings.filter((sibling) => sibling.nodeName.toLowerCase() === nodeName);\n      const token = sameTagSiblings.indexOf(element) === 0 ? cssEscape(nodeName) : `${cssEscape(nodeName)}:nth-child(${1 + siblings.indexOf(element)})`;\n      const selector = uniqueCSSSelector(token);\n      if (selector)\n        return makeStrict(selector);\n      if (!bestTokenForLevel)\n        bestTokenForLevel = token;\n    } else if (!bestTokenForLevel) {\n      bestTokenForLevel = nodeName;\n    }\n    tokens.unshift(bestTokenForLevel);\n  }\n  return makeStrict(uniqueCSSSelector());\n}\nfunction escapeForRegex(text) {\n  return text.replace(/[.*+?^>${}()|[\\]\\\\]/g, "\\\\$&");\n}\nfunction quoteAttributeValue(text) {\n  return `"${cssEscape(text).replace(/\\\\ /g, " ")}"`;\n}\nfunction joinTokens(tokens) {\n  const parts = [];\n  let lastEngine = "";\n  for (const { engine, selector } of tokens) {\n    if (parts.length && (lastEngine !== "css" || engine !== "css" || selector.startsWith(":nth-match(")))\n      parts.push(">>");\n    lastEngine = engine;\n    if (engine === "css")\n      parts.push(selector);\n    else\n      parts.push(`${engine}=${selector}`);\n  }\n  return parts.join(" ");\n}\nfunction combineScores(tokens) {\n  let score = 0;\n  for (let i = 0; i < tokens.length; i++)\n    score += tokens[i].score * (tokens.length - i);\n  return score;\n}\nfunction chooseFirstSelector(injectedScript, scope, targetElement, selectors, allowNthMatch, strict) {\n  const joined = selectors.map((tokens) => ({ tokens, score: combineScores(tokens) }));\n  joined.sort((a, b) => a.score - b.score);\n  let bestWithIndex = null;\n  for (const { tokens } of joined) {\n    const parsedSelector = injectedScript.parseSelector(joinTokens(tokens));\n    const result = injectedScript.querySelectorAll(parsedSelector, scope);\n    const isStrictEnough = !strict || result.length === 1;\n    const index = result.indexOf(targetElement);\n    if (index === 0 && isStrictEnough) {\n      return tokens;\n    }\n    if (!allowNthMatch || bestWithIndex || index === -1 || result.length > 5)\n      continue;\n    const nth = { engine: "nth", selector: String(index), score: kNthScore };\n    bestWithIndex = [...tokens, nth];\n  }\n  return bestWithIndex;\n}\nfunction isGuidLike(id) {\n  let lastCharacterType;\n  let transitionCount = 0;\n  for (let i = 0; i < id.length; ++i) {\n    const c = id[i];\n    let characterType;\n    if (c === "-" || c === "_")\n      continue;\n    if (c >= "a" && c <= "z")\n      characterType = "lower";\n    else if (c >= "A" && c <= "Z")\n      characterType = "upper";\n    else if (c >= "0" && c <= "9")\n      characterType = "digit";\n    else\n      characterType = "other";\n    if (characterType === "lower" && lastCharacterType === "upper") {\n      lastCharacterType = characterType;\n      continue;\n    }\n    if (lastCharacterType && lastCharacterType !== characterType)\n      ++transitionCount;\n    lastCharacterType = characterType;\n  }\n  return transitionCount >= id.length / 4;\n}\nfunction cssEscape(s) {\n  let result = "";\n  for (let i = 0; i < s.length; i++)\n    result += cssEscapeOne(s, i);\n  return result;\n}\nfunction cssEscapeOne(s, i) {\n  const c = s.charCodeAt(i);\n  if (c === 0)\n    return "\\uFFFD";\n  if (c >= 1 && c <= 31 || c >= 48 && c <= 57 && (i === 0 || i === 1 && s.charCodeAt(0) === 45))\n    return "\\\\" + c.toString(16) + " ";\n  if (i === 0 && c === 45 && s.length === 1)\n    return "\\\\" + s.charAt(i);\n  if (c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122)\n    return s.charAt(i);\n  return "\\\\" + s.charAt(i);\n}\n\n// packages/playwright-core/src/server/injected/consoleApi.ts\nfunction createLocator(injectedScript, initial, options) {\n  class Locator {\n    constructor(selector, options2) {\n      this.selector = selector;\n      if (options2 == null ? void 0 : options2.hasText) {\n        const text = options2.hasText;\n        if (text instanceof RegExp)\n          this.selector += ` >> :scope:text-matches(${escapeWithQuotes(text.source, \'"\')}, "${text.flags}")`;\n        else\n          this.selector += ` >> :scope:has-text(${escapeWithQuotes(text)})`;\n      }\n      if (options2 == null ? void 0 : options2.has)\n        this.selector += ` >> has=` + JSON.stringify(options2.has.selector);\n      const parsed = injectedScript.parseSelector(this.selector);\n      this.element = injectedScript.querySelector(parsed, document, false);\n      this.elements = injectedScript.querySelectorAll(parsed, document);\n    }\n    locator(selector, options2) {\n      return new Locator(this.selector ? this.selector + " >> " + selector : selector, options2);\n    }\n  }\n  return new Locator(initial, options);\n}\nvar ConsoleAPI = class {\n  constructor(injectedScript) {\n    this._injectedScript = injectedScript;\n    if (window.playwright)\n      return;\n    window.playwright = {\n      $: (selector, strict) => this._querySelector(selector, !!strict),\n      $$: (selector) => this._querySelectorAll(selector),\n      locator: (selector, options) => createLocator(this._injectedScript, selector, options),\n      inspect: (selector) => this._inspect(selector),\n      selector: (element) => this._selector(element),\n      resume: () => this._resume()\n    };\n  }\n  _querySelector(selector, strict) {\n    if (typeof selector !== "string")\n      throw new Error(`Usage: playwright.query(\'Playwright >> selector\').`);\n    const parsed = this._injectedScript.parseSelector(selector);\n    return this._injectedScript.querySelector(parsed, document, strict);\n  }\n  _querySelectorAll(selector) {\n    if (typeof selector !== "string")\n      throw new Error(`Usage: playwright.$$(\'Playwright >> selector\').`);\n    const parsed = this._injectedScript.parseSelector(selector);\n    return this._injectedScript.querySelectorAll(parsed, document);\n  }\n  _inspect(selector) {\n    if (typeof selector !== "string")\n      throw new Error(`Usage: playwright.inspect(\'Playwright >> selector\').`);\n    window.inspect(this._querySelector(selector, false));\n  }\n  _selector(element) {\n    if (!(element instanceof Element))\n      throw new Error(`Usage: playwright.selector(element).`);\n    return generateSelector(this._injectedScript, element, true).selector;\n  }\n  _resume() {\n    window._playwrightResume().catch(() => {\n    });\n  }\n};\nmodule.exports = ConsoleAPI;\n';
    exports2.source = source;
  }
});

// node_modules/playwright-core/lib/server/chromium/crApp.js
var require_crApp = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crApp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.installAppIcon = installAppIcon;
    var _fs = _interopRequireDefault(require("fs"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function installAppIcon(page) {
      return __async(this, null, function* () {
        const icon = yield _fs.default.promises.readFile(require.resolve("./appIcon.png"));
        const crPage = page._delegate;
        yield crPage._mainFrameSession._client.send("Browser.setDockTile", {
          image: icon.toString("base64")
        });
      });
    }
  }
});

// node_modules/playwright-core/lib/server/download.js
var require_download2 = __commonJS({
  "node_modules/playwright-core/lib/server/download.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Download = void 0;
    var _path = _interopRequireDefault(require("path"));
    var _page = require_page();
    var _utils = require_utils();
    var _artifact = require_artifact();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Download = class {
      constructor(page, downloadsPath, uuid, url, suggestedFilename) {
        this.artifact = void 0;
        this.url = void 0;
        this._page = void 0;
        this._suggestedFilename = void 0;
        const unaccessibleErrorMessage = !page._browserContext._options.acceptDownloads ? "Pass { acceptDownloads: true } when you are creating your browser context." : void 0;
        this.artifact = new _artifact.Artifact(page, _path.default.join(downloadsPath, uuid), unaccessibleErrorMessage, () => {
          return this._page._browserContext.cancelDownload(uuid);
        });
        this._page = page;
        this.url = url;
        this._suggestedFilename = suggestedFilename;
        page._browserContext._downloads.add(this);
        if (suggestedFilename !== void 0)
          this._page.emit(_page.Page.Events.Download, this);
      }
      _filenameSuggested(suggestedFilename) {
        (0, _utils.assert)(this._suggestedFilename === void 0);
        this._suggestedFilename = suggestedFilename;
        this._page.emit(_page.Page.Events.Download, this);
      }
      suggestedFilename() {
        return this._suggestedFilename;
      }
    };
    exports2.Download = Download;
  }
});

// node_modules/playwright-core/lib/server/browser.js
var require_browser3 = __commonJS({
  "node_modules/playwright-core/lib/server/browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Browser = void 0;
    var _browserContext = require_browserContext();
    var _page = require_page();
    var _download = require_download2();
    var _instrumentation = require_instrumentation();
    var _artifact = require_artifact();
    var Browser = class extends _instrumentation.SdkObject {
      constructor(options) {
        super(options.rootSdkObject, "browser");
        this.options = void 0;
        this._downloads = /* @__PURE__ */ new Map();
        this._defaultContext = null;
        this._startedClosing = false;
        this._idToVideo = /* @__PURE__ */ new Map();
        this.attribution.browser = this;
        this.options = options;
      }
      newContext(metadata, options) {
        return __async(this, null, function* () {
          (0, _browserContext.validateBrowserContextOptions)(options, this.options);
          const context = yield this.doCreateNewContext(options);
          if (options.storageState)
            yield context.setStorageState(metadata, options.storageState);
          return context;
        });
      }
      _downloadCreated(page, uuid, url, suggestedFilename) {
        const download = new _download.Download(page, this.options.downloadsPath || "", uuid, url, suggestedFilename);
        this._downloads.set(uuid, download);
      }
      _downloadFilenameSuggested(uuid, suggestedFilename) {
        const download = this._downloads.get(uuid);
        if (!download)
          return;
        download._filenameSuggested(suggestedFilename);
      }
      _downloadFinished(uuid, error) {
        const download = this._downloads.get(uuid);
        if (!download)
          return;
        download.artifact.reportFinished(error);
        this._downloads.delete(uuid);
      }
      _videoStarted(context, videoId, path, pageOrError) {
        const artifact = new _artifact.Artifact(context, path);
        this._idToVideo.set(videoId, {
          context,
          artifact
        });
        pageOrError.then((page) => {
          if (page instanceof _page.Page) {
            page._video = artifact;
            page.emitOnContext(_browserContext.BrowserContext.Events.VideoStarted, artifact);
            page.emit(_page.Page.Events.Video, artifact);
          }
        });
      }
      _takeVideo(videoId) {
        const video = this._idToVideo.get(videoId);
        this._idToVideo.delete(videoId);
        return video === null || video === void 0 ? void 0 : video.artifact;
      }
      _didClose() {
        for (const context of this.contexts())
          context._browserClosed();
        if (this._defaultContext)
          this._defaultContext._browserClosed();
        this.emit(Browser.Events.Disconnected);
      }
      close() {
        return __async(this, null, function* () {
          if (!this._startedClosing) {
            this._startedClosing = true;
            yield this.options.browserProcess.close();
          }
          if (this.isConnected())
            yield new Promise((x) => this.once(Browser.Events.Disconnected, x));
        });
      }
      killForTests() {
        return __async(this, null, function* () {
          yield this.options.browserProcess.kill();
        });
      }
    };
    exports2.Browser = Browser;
    Browser.Events = {
      Disconnected: "disconnected"
    };
  }
});

// node_modules/playwright-core/lib/server/chromium/crConnection.js
var require_crConnection = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.kBrowserCloseMessageId = exports2.ConnectionEvents = exports2.CRSessionEvents = exports2.CRSession = exports2.CRConnection = void 0;
    var _utils = require_utils();
    var _events = require("events");
    var _stackTrace = require_stackTrace();
    var _debugLogger = require_debugLogger();
    var _helper = require_helper();
    var _protocolError = require_protocolError();
    var ConnectionEvents = {
      Disconnected: Symbol("ConnectionEvents.Disconnected")
    };
    exports2.ConnectionEvents = ConnectionEvents;
    var kBrowserCloseMessageId = -9999;
    exports2.kBrowserCloseMessageId = kBrowserCloseMessageId;
    var CRConnection = class extends _events.EventEmitter {
      constructor(transport, protocolLogger, browserLogsCollector) {
        super();
        this._lastId = 0;
        this._transport = void 0;
        this._sessions = /* @__PURE__ */ new Map();
        this._protocolLogger = void 0;
        this._browserLogsCollector = void 0;
        this.rootSession = void 0;
        this._closed = false;
        this.setMaxListeners(0);
        this._transport = transport;
        this._protocolLogger = protocolLogger;
        this._browserLogsCollector = browserLogsCollector;
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this.rootSession = new CRSession(this, "", "browser", "");
        this._sessions.set("", this.rootSession);
      }
      static fromSession(session) {
        return session._connection;
      }
      session(sessionId) {
        return this._sessions.get(sessionId) || null;
      }
      _rawSend(sessionId, method, params) {
        const id = ++this._lastId;
        const message = {
          id,
          method,
          params
        };
        if (sessionId)
          message.sessionId = sessionId;
        this._protocolLogger("send", message);
        this._transport.send(message);
        return id;
      }
      _onMessage(message) {
        return __async(this, null, function* () {
          this._protocolLogger("receive", message);
          if (message.id === kBrowserCloseMessageId)
            return;
          if (message.method === "Target.attachedToTarget") {
            const sessionId = message.params.sessionId;
            const rootSessionId = message.sessionId || "";
            const session2 = new CRSession(this, rootSessionId, message.params.targetInfo.type, sessionId);
            this._sessions.set(sessionId, session2);
          } else if (message.method === "Target.detachedFromTarget") {
            const session2 = this._sessions.get(message.params.sessionId);
            if (session2) {
              session2._onClosed(void 0);
              this._sessions.delete(message.params.sessionId);
            }
          }
          const session = this._sessions.get(message.sessionId || "");
          if (session)
            session._onMessage(message);
        });
      }
      _onClose() {
        this._closed = true;
        this._transport.onmessage = void 0;
        this._transport.onclose = void 0;
        const browserDisconnectedLogs = _helper.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs());
        for (const session of this._sessions.values())
          session._onClosed(browserDisconnectedLogs);
        this._sessions.clear();
        Promise.resolve().then(() => this.emit(ConnectionEvents.Disconnected));
      }
      close() {
        if (!this._closed)
          this._transport.close();
      }
      createSession(targetInfo) {
        return __async(this, null, function* () {
          const {
            sessionId
          } = yield this.rootSession.send("Target.attachToTarget", {
            targetId: targetInfo.targetId,
            flatten: true
          });
          return this._sessions.get(sessionId);
        });
      }
      createBrowserSession() {
        return __async(this, null, function* () {
          const {
            sessionId
          } = yield this.rootSession.send("Target.attachToBrowserTarget");
          return this._sessions.get(sessionId);
        });
      }
    };
    exports2.CRConnection = CRConnection;
    var CRSessionEvents = {
      Disconnected: Symbol("Events.CDPSession.Disconnected")
    };
    exports2.CRSessionEvents = CRSessionEvents;
    var CRSession = class extends _events.EventEmitter {
      constructor(connection, rootSessionId, targetType, sessionId) {
        super();
        this._connection = void 0;
        this._eventListener = void 0;
        this._callbacks = /* @__PURE__ */ new Map();
        this._targetType = void 0;
        this._sessionId = void 0;
        this._rootSessionId = void 0;
        this._crashed = false;
        this._browserDisconnectedLogs = void 0;
        this.on = void 0;
        this.addListener = void 0;
        this.off = void 0;
        this.removeListener = void 0;
        this.once = void 0;
        this.guid = void 0;
        this.guid = `cdp-session@${sessionId}`;
        this.setMaxListeners(0);
        this._connection = connection;
        this._rootSessionId = rootSessionId;
        this._targetType = targetType;
        this._sessionId = sessionId;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      _markAsCrashed() {
        this._crashed = true;
      }
      send(method, params) {
        return __async(this, null, function* () {
          if (this._crashed)
            throw new _protocolError.ProtocolError(true, "Target crashed");
          if (this._browserDisconnectedLogs !== void 0)
            throw new _protocolError.ProtocolError(true, `Browser closed.` + this._browserDisconnectedLogs);
          if (!this._connection)
            throw new _protocolError.ProtocolError(true, `Target closed`);
          const id = this._connection._rawSend(this._sessionId, method, params);
          return new Promise((resolve, reject) => {
            this._callbacks.set(id, {
              resolve,
              reject,
              error: new _protocolError.ProtocolError(false),
              method
            });
          });
        });
      }
      _sendMayFail(method, params) {
        return this.send(method, params).catch((error) => _debugLogger.debugLogger.log("error", error));
      }
      _onMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
          const callback = this._callbacks.get(object.id);
          this._callbacks.delete(object.id);
          if (object.error)
            callback.reject(createProtocolError(callback.error, callback.method, object.error));
          else
            callback.resolve(object.result);
        } else {
          (0, _utils.assert)(!object.id);
          Promise.resolve().then(() => {
            if (this._eventListener)
              this._eventListener(object.method, object.params);
            this.emit(object.method, object.params);
          });
        }
      }
      detach() {
        return __async(this, null, function* () {
          if (!this._connection)
            throw new Error(`Session already detached. Most likely the ${this._targetType} has been closed.`);
          const rootSession = this._connection.session(this._rootSessionId);
          if (!rootSession)
            throw new Error("Root session has been closed");
          yield rootSession.send("Target.detachFromTarget", {
            sessionId: this._sessionId
          });
        });
      }
      _onClosed(browserDisconnectedLogs) {
        this._browserDisconnectedLogs = browserDisconnectedLogs;
        const errorMessage = browserDisconnectedLogs !== void 0 ? "Browser closed." + browserDisconnectedLogs : "Target closed";
        for (const callback of this._callbacks.values()) {
          callback.error.sessionClosed = true;
          callback.reject((0, _stackTrace.rewriteErrorMessage)(callback.error, errorMessage));
        }
        this._callbacks.clear();
        this._connection = null;
        Promise.resolve().then(() => this.emit(CRSessionEvents.Disconnected));
      }
    };
    exports2.CRSession = CRSession;
    function createProtocolError(error, method, protocolError) {
      let message = `Protocol error (${method}): ${protocolError.message}`;
      if ("data" in protocolError)
        message += ` ${protocolError.data}`;
      return (0, _stackTrace.rewriteErrorMessage)(error, message);
    }
  }
});

// node_modules/playwright-core/lib/server/dialog.js
var require_dialog = __commonJS({
  "node_modules/playwright-core/lib/server/dialog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Dialog = void 0;
    var _utils = require_utils();
    var _instrumentation = require_instrumentation();
    var Dialog = class extends _instrumentation.SdkObject {
      constructor(page, type, message, onHandle, defaultValue) {
        super(page, "dialog");
        this._page = void 0;
        this._type = void 0;
        this._message = void 0;
        this._onHandle = void 0;
        this._handled = false;
        this._defaultValue = void 0;
        this._page = page;
        this._type = type;
        this._message = message;
        this._onHandle = onHandle;
        this._defaultValue = defaultValue || "";
        this._page._frameManager.dialogDidOpen(this);
      }
      type() {
        return this._type;
      }
      message() {
        return this._message;
      }
      defaultValue() {
        return this._defaultValue;
      }
      accept(promptText) {
        return __async(this, null, function* () {
          (0, _utils.assert)(!this._handled, "Cannot accept dialog which is already handled!");
          this._handled = true;
          this._page._frameManager.dialogWillClose(this);
          yield this._onHandle(true, promptText);
        });
      }
      dismiss() {
        return __async(this, null, function* () {
          (0, _utils.assert)(!this._handled, "Cannot dismiss dialog which is already handled!");
          this._handled = true;
          this._page._frameManager.dialogWillClose(this);
          yield this._onHandle(false);
        });
      }
    };
    exports2.Dialog = Dialog;
  }
});

// node_modules/playwright-core/lib/server/chromium/crAccessibility.js
var require_crAccessibility = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crAccessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getAccessibilityTree = getAccessibilityTree;
    function getAccessibilityTree(client, needle) {
      return __async(this, null, function* () {
        const {
          nodes
        } = yield client.send("Accessibility.getFullAXTree");
        const tree = CRAXNode.createTree(client, nodes);
        return {
          tree,
          needle: needle ? yield tree._findElement(needle) : null
        };
      });
    }
    var CRAXNode = class {
      constructor(client, payload) {
        this._payload = void 0;
        this._children = [];
        this._richlyEditable = false;
        this._editable = false;
        this._focusable = false;
        this._expanded = false;
        this._hidden = false;
        this._name = void 0;
        this._role = void 0;
        this._cachedHasFocusableChild = void 0;
        this._client = void 0;
        this._client = client;
        this._payload = payload;
        this._name = this._payload.name ? this._payload.name.value : "";
        this._role = this._payload.role ? this._payload.role.value : "Unknown";
        for (const property of this._payload.properties || []) {
          if (property.name === "editable") {
            this._richlyEditable = property.value.value === "richtext";
            this._editable = true;
          }
          if (property.name === "focusable")
            this._focusable = property.value.value;
          if (property.name === "expanded")
            this._expanded = property.value.value;
          if (property.name === "hidden")
            this._hidden = property.value.value;
        }
      }
      _isPlainTextField() {
        if (this._richlyEditable)
          return false;
        if (this._editable)
          return true;
        return this._role === "textbox" || this._role === "ComboBox" || this._role === "searchbox";
      }
      _isTextOnlyObject() {
        const role = this._role;
        return role === "LineBreak" || role === "text" || role === "InlineTextBox" || role === "StaticText";
      }
      _hasFocusableChild() {
        if (this._cachedHasFocusableChild === void 0) {
          this._cachedHasFocusableChild = false;
          for (const child of this._children) {
            if (child._focusable || child._hasFocusableChild()) {
              this._cachedHasFocusableChild = true;
              break;
            }
          }
        }
        return this._cachedHasFocusableChild;
      }
      children() {
        return this._children;
      }
      _findElement(element) {
        return __async(this, null, function* () {
          const objectId = element._objectId;
          const {
            node: {
              backendNodeId
            }
          } = yield this._client.send("DOM.describeNode", {
            objectId
          });
          const needle = this.find((node) => node._payload.backendDOMNodeId === backendNodeId);
          return needle || null;
        });
      }
      find(predicate) {
        if (predicate(this))
          return this;
        for (const child of this._children) {
          const result = child.find(predicate);
          if (result)
            return result;
        }
        return null;
      }
      isLeafNode() {
        if (!this._children.length)
          return true;
        if (this._isPlainTextField() || this._isTextOnlyObject())
          return true;
        switch (this._role) {
          case "doc-cover":
          case "graphics-symbol":
          case "img":
          case "Meter":
          case "scrollbar":
          case "slider":
          case "separator":
          case "progressbar":
            return true;
          default:
            break;
        }
        if (this._hasFocusableChild())
          return false;
        if (this._focusable && this._role !== "WebArea" && this._role !== "RootWebArea" && this._name)
          return true;
        if (this._role === "heading" && this._name)
          return true;
        return false;
      }
      isControl() {
        switch (this._role) {
          case "button":
          case "checkbox":
          case "ColorWell":
          case "combobox":
          case "DisclosureTriangle":
          case "listbox":
          case "menu":
          case "menubar":
          case "menuitem":
          case "menuitemcheckbox":
          case "menuitemradio":
          case "radio":
          case "scrollbar":
          case "searchbox":
          case "slider":
          case "spinbutton":
          case "switch":
          case "tab":
          case "textbox":
          case "tree":
            return true;
          default:
            return false;
        }
      }
      isInteresting(insideControl) {
        const role = this._role;
        if (role === "Ignored" || this._hidden)
          return false;
        if (this._focusable || this._richlyEditable)
          return true;
        if (this.isControl())
          return true;
        if (insideControl)
          return false;
        return this.isLeafNode() && !!this._name;
      }
      normalizedRole() {
        switch (this._role) {
          case "RootWebArea":
            return "WebArea";
          case "StaticText":
            return "text";
          default:
            return this._role;
        }
      }
      serialize() {
        const properties = /* @__PURE__ */ new Map();
        for (const property of this._payload.properties || [])
          properties.set(property.name.toLowerCase(), property.value.value);
        if (this._payload.description)
          properties.set("description", this._payload.description.value);
        const node = {
          role: this.normalizedRole(),
          name: this._payload.name ? this._payload.name.value || "" : ""
        };
        const userStringProperties = ["description", "keyshortcuts", "roledescription", "valuetext"];
        for (const userStringProperty of userStringProperties) {
          if (!properties.has(userStringProperty))
            continue;
          node[userStringProperty] = properties.get(userStringProperty);
        }
        const booleanProperties = ["disabled", "expanded", "focused", "modal", "multiline", "multiselectable", "readonly", "required", "selected"];
        for (const booleanProperty of booleanProperties) {
          if (booleanProperty === "focused" && (this._role === "WebArea" || this._role === "RootWebArea"))
            continue;
          const value = properties.get(booleanProperty);
          if (!value)
            continue;
          node[booleanProperty] = value;
        }
        const numericalProperties = ["level", "valuemax", "valuemin"];
        for (const numericalProperty of numericalProperties) {
          if (!properties.has(numericalProperty))
            continue;
          node[numericalProperty] = properties.get(numericalProperty);
        }
        const tokenProperties = ["autocomplete", "haspopup", "invalid", "orientation"];
        for (const tokenProperty of tokenProperties) {
          const value = properties.get(tokenProperty);
          if (!value || value === "false")
            continue;
          node[tokenProperty] = value;
        }
        const axNode = node;
        if (this._payload.value) {
          if (typeof this._payload.value.value === "string")
            axNode.valueString = this._payload.value.value;
          if (typeof this._payload.value.value === "number")
            axNode.valueNumber = this._payload.value.value;
        }
        if (properties.has("checked"))
          axNode.checked = properties.get("checked") === "true" ? "checked" : properties.get("checked") === "false" ? "unchecked" : "mixed";
        if (properties.has("pressed"))
          axNode.pressed = properties.get("pressed") === "true" ? "pressed" : properties.get("pressed") === "false" ? "released" : "mixed";
        return axNode;
      }
      static createTree(client, payloads) {
        const nodeById = /* @__PURE__ */ new Map();
        for (const payload of payloads)
          nodeById.set(payload.nodeId, new CRAXNode(client, payload));
        for (const node of nodeById.values()) {
          for (const childId of node._payload.childIds || [])
            node._children.push(nodeById.get(childId));
        }
        return nodeById.values().next().value;
      }
    };
  }
});

// node_modules/playwright-core/lib/server/chromium/crCoverage.js
var require_crCoverage = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crCoverage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRCoverage = void 0;
    var _eventsHelper = require_eventsHelper();
    var _utils = require_utils();
    var CRCoverage = class {
      constructor(client) {
        this._jsCoverage = void 0;
        this._cssCoverage = void 0;
        this._jsCoverage = new JSCoverage(client);
        this._cssCoverage = new CSSCoverage(client);
      }
      startJSCoverage(options) {
        return __async(this, null, function* () {
          return yield this._jsCoverage.start(options);
        });
      }
      stopJSCoverage() {
        return __async(this, null, function* () {
          return yield this._jsCoverage.stop();
        });
      }
      startCSSCoverage(options) {
        return __async(this, null, function* () {
          return yield this._cssCoverage.start(options);
        });
      }
      stopCSSCoverage() {
        return __async(this, null, function* () {
          return yield this._cssCoverage.stop();
        });
      }
    };
    exports2.CRCoverage = CRCoverage;
    var JSCoverage = class {
      constructor(client) {
        this._client = void 0;
        this._enabled = void 0;
        this._scriptIds = void 0;
        this._scriptSources = void 0;
        this._eventListeners = void 0;
        this._resetOnNavigation = void 0;
        this._reportAnonymousScripts = false;
        this._client = client;
        this._enabled = false;
        this._scriptIds = /* @__PURE__ */ new Set();
        this._scriptSources = /* @__PURE__ */ new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
      }
      start() {
        return __async(this, arguments, function* (options = {}) {
          (0, _utils.assert)(!this._enabled, "JSCoverage is already enabled");
          const {
            resetOnNavigation = true,
            reportAnonymousScripts = false
          } = options;
          this._resetOnNavigation = resetOnNavigation;
          this._reportAnonymousScripts = reportAnonymousScripts;
          this._enabled = true;
          this._scriptIds.clear();
          this._scriptSources.clear();
          this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._client, "Debugger.scriptParsed", this._onScriptParsed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._client, "Debugger.paused", this._onDebuggerPaused.bind(this))];
          yield Promise.all([this._client.send("Profiler.enable"), this._client.send("Profiler.startPreciseCoverage", {
            callCount: true,
            detailed: true
          }), this._client.send("Debugger.enable"), this._client.send("Debugger.setSkipAllPauses", {
            skip: true
          })]);
        });
      }
      _onDebuggerPaused() {
        this._client.send("Debugger.resume");
      }
      _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
          return;
        this._scriptIds.clear();
        this._scriptSources.clear();
      }
      _onScriptParsed(event) {
        return __async(this, null, function* () {
          this._scriptIds.add(event.scriptId);
          if (!event.url && !this._reportAnonymousScripts)
            return;
          const response = yield this._client._sendMayFail("Debugger.getScriptSource", {
            scriptId: event.scriptId
          });
          if (response)
            this._scriptSources.set(event.scriptId, response.scriptSource);
        });
      }
      stop() {
        return __async(this, null, function* () {
          (0, _utils.assert)(this._enabled, "JSCoverage is not enabled");
          this._enabled = false;
          const [profileResponse] = yield Promise.all([this._client.send("Profiler.takePreciseCoverage"), this._client.send("Profiler.stopPreciseCoverage"), this._client.send("Profiler.disable"), this._client.send("Debugger.disable")]);
          _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
          const coverage = [];
          for (const entry of profileResponse.result) {
            if (!this._scriptIds.has(entry.scriptId))
              continue;
            if (!entry.url && !this._reportAnonymousScripts)
              continue;
            const source = this._scriptSources.get(entry.scriptId);
            if (source)
              coverage.push(__spreadProps(__spreadValues({}, entry), {
                source
              }));
            else
              coverage.push(entry);
          }
          return coverage;
        });
      }
    };
    var CSSCoverage = class {
      constructor(client) {
        this._client = void 0;
        this._enabled = void 0;
        this._stylesheetURLs = void 0;
        this._stylesheetSources = void 0;
        this._eventListeners = void 0;
        this._resetOnNavigation = void 0;
        this._client = client;
        this._enabled = false;
        this._stylesheetURLs = /* @__PURE__ */ new Map();
        this._stylesheetSources = /* @__PURE__ */ new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
      }
      start() {
        return __async(this, arguments, function* (options = {}) {
          (0, _utils.assert)(!this._enabled, "CSSCoverage is already enabled");
          const {
            resetOnNavigation = true
          } = options;
          this._resetOnNavigation = resetOnNavigation;
          this._enabled = true;
          this._stylesheetURLs.clear();
          this._stylesheetSources.clear();
          this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._client, "CSS.styleSheetAdded", this._onStyleSheet.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this))];
          yield Promise.all([this._client.send("DOM.enable"), this._client.send("CSS.enable"), this._client.send("CSS.startRuleUsageTracking")]);
        });
      }
      _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
          return;
        this._stylesheetURLs.clear();
        this._stylesheetSources.clear();
      }
      _onStyleSheet(event) {
        return __async(this, null, function* () {
          const header = event.header;
          if (!header.sourceURL)
            return;
          const response = yield this._client._sendMayFail("CSS.getStyleSheetText", {
            styleSheetId: header.styleSheetId
          });
          if (response) {
            this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);
            this._stylesheetSources.set(header.styleSheetId, response.text);
          }
        });
      }
      stop() {
        return __async(this, null, function* () {
          (0, _utils.assert)(this._enabled, "CSSCoverage is not enabled");
          this._enabled = false;
          const ruleTrackingResponse = yield this._client.send("CSS.stopRuleUsageTracking");
          yield Promise.all([this._client.send("CSS.disable"), this._client.send("DOM.disable")]);
          _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
          const styleSheetIdToCoverage = /* @__PURE__ */ new Map();
          for (const entry of ruleTrackingResponse.ruleUsage) {
            let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
            if (!ranges) {
              ranges = [];
              styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
            }
            ranges.push({
              startOffset: entry.startOffset,
              endOffset: entry.endOffset,
              count: entry.used ? 1 : 0
            });
          }
          const coverage = [];
          for (const styleSheetId of this._stylesheetURLs.keys()) {
            const url = this._stylesheetURLs.get(styleSheetId);
            const text = this._stylesheetSources.get(styleSheetId);
            const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
            coverage.push({
              url,
              ranges,
              text
            });
          }
          return coverage;
        });
      }
    };
    function convertToDisjointRanges(nestedRanges) {
      const points = [];
      for (const range of nestedRanges) {
        points.push({
          offset: range.startOffset,
          type: 0,
          range
        });
        points.push({
          offset: range.endOffset,
          type: 1,
          range
        });
      }
      points.sort((a, b) => {
        if (a.offset !== b.offset)
          return a.offset - b.offset;
        if (a.type !== b.type)
          return b.type - a.type;
        const aLength = a.range.endOffset - a.range.startOffset;
        const bLength = b.range.endOffset - b.range.startOffset;
        if (a.type === 0)
          return bLength - aLength;
        return aLength - bLength;
      });
      const hitCountStack = [];
      const results = [];
      let lastOffset = 0;
      for (const point of points) {
        if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
          const lastResult = results.length ? results[results.length - 1] : null;
          if (lastResult && lastResult.end === lastOffset)
            lastResult.end = point.offset;
          else
            results.push({
              start: lastOffset,
              end: point.offset
            });
        }
        lastOffset = point.offset;
        if (point.type === 0)
          hitCountStack.push(point.range.count);
        else
          hitCountStack.pop();
      }
      return results.filter((range) => range.end - range.start > 1);
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/crProtocolHelper.js
var require_crProtocolHelper = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crProtocolHelper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.exceptionToError = exceptionToError;
    exports2.getExceptionMessage = getExceptionMessage;
    exports2.readProtocolStream = readProtocolStream;
    exports2.releaseObject = releaseObject;
    exports2.toButtonsMask = toButtonsMask;
    exports2.toConsoleMessageLocation = toConsoleMessageLocation;
    exports2.toModifiersMask = toModifiersMask;
    var _fs = _interopRequireDefault(require("fs"));
    var _fileUtils = require_fileUtils();
    var _stackTrace = require_stackTrace();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function getExceptionMessage(exceptionDetails) {
      if (exceptionDetails.exception)
        return exceptionDetails.exception.description || String(exceptionDetails.exception.value);
      let message = exceptionDetails.text;
      if (exceptionDetails.stackTrace) {
        for (const callframe of exceptionDetails.stackTrace.callFrames) {
          const location2 = callframe.url + ":" + callframe.lineNumber + ":" + callframe.columnNumber;
          const functionName = callframe.functionName || "<anonymous>";
          message += `
    at ${functionName} (${location2})`;
        }
      }
      return message;
    }
    function releaseObject(client, objectId) {
      return __async(this, null, function* () {
        yield client.send("Runtime.releaseObject", {
          objectId
        }).catch((error) => {
        });
      });
    }
    function readProtocolStream(client, handle, path) {
      return __async(this, null, function* () {
        let eof = false;
        let fd;
        if (path) {
          yield (0, _fileUtils.mkdirIfNeeded)(path);
          fd = yield _fs.default.promises.open(path, "w");
        }
        const bufs = [];
        while (!eof) {
          const response = yield client.send("IO.read", {
            handle
          });
          eof = response.eof;
          const buf = Buffer.from(response.data, response.base64Encoded ? "base64" : void 0);
          bufs.push(buf);
          if (fd)
            yield fd.write(buf);
        }
        if (fd)
          yield fd.close();
        yield client.send("IO.close", {
          handle
        });
        return Buffer.concat(bufs);
      });
    }
    function toConsoleMessageLocation(stackTrace) {
      return stackTrace && stackTrace.callFrames.length ? {
        url: stackTrace.callFrames[0].url,
        lineNumber: stackTrace.callFrames[0].lineNumber,
        columnNumber: stackTrace.callFrames[0].columnNumber
      } : {
        url: "",
        lineNumber: 0,
        columnNumber: 0
      };
    }
    function exceptionToError(exceptionDetails) {
      const messageWithStack = getExceptionMessage(exceptionDetails);
      const lines = messageWithStack.split("\n");
      const firstStackTraceLine = lines.findIndex((line) => line.startsWith("    at"));
      let messageWithName = "";
      let stack = "";
      if (firstStackTraceLine === -1) {
        messageWithName = messageWithStack;
      } else {
        messageWithName = lines.slice(0, firstStackTraceLine).join("\n");
        stack = messageWithStack;
      }
      const {
        name,
        message
      } = (0, _stackTrace.splitErrorMessage)(messageWithName);
      const err = new Error(message);
      err.stack = stack;
      err.name = name;
      return err;
    }
    function toModifiersMask(modifiers) {
      let mask = 0;
      if (modifiers.has("Alt"))
        mask |= 1;
      if (modifiers.has("Control"))
        mask |= 2;
      if (modifiers.has("Meta"))
        mask |= 4;
      if (modifiers.has("Shift"))
        mask |= 8;
      return mask;
    }
    function toButtonsMask(buttons) {
      let mask = 0;
      if (buttons.has("left"))
        mask |= 1;
      if (buttons.has("right"))
        mask |= 2;
      if (buttons.has("middle"))
        mask |= 4;
      return mask;
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/crDragDrop.js
var require_crDragDrop = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crDragDrop.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DragManager = void 0;
    var _utils = require_utils();
    var _crProtocolHelper = require_crProtocolHelper();
    var DragManager = class {
      constructor(page) {
        this._crPage = void 0;
        this._dragState = null;
        this._lastPosition = {
          x: 0,
          y: 0
        };
        this._crPage = page;
      }
      cancelDrag() {
        return __async(this, null, function* () {
          if (!this._dragState)
            return false;
          yield this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
            type: "dragCancel",
            x: this._lastPosition.x,
            y: this._lastPosition.y,
            data: {
              items: [],
              dragOperationsMask: 65535
            }
          });
          this._dragState = null;
          return true;
        });
      }
      interceptDragCausedByMove(x, y, button, buttons, modifiers, moveCallback) {
        return __async(this, null, function* () {
          this._lastPosition = {
            x,
            y
          };
          if (this._dragState) {
            yield this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
              type: "dragOver",
              x,
              y,
              data: this._dragState,
              modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
            });
            return;
          }
          if (button !== "left")
            return moveCallback();
          const client = this._crPage._mainFrameSession._client;
          let onDragIntercepted;
          const dragInterceptedPromise = new Promise((x2) => onDragIntercepted = x2);
          yield Promise.all(this._crPage._page.frames().map((frame) => __async(this, null, function* () {
            yield frame.nonStallingEvaluateInExistingContext(function() {
              let didStartDrag = Promise.resolve(false);
              let dragEvent = null;
              const dragListener = (event) => dragEvent = event;
              const mouseListener = () => {
                didStartDrag = new Promise((callback) => {
                  window.addEventListener("dragstart", dragListener, {
                    once: true,
                    capture: true
                  });
                  setTimeout(() => callback(dragEvent ? !dragEvent.defaultPrevented : false), 0);
                });
              };
              window.addEventListener("mousemove", mouseListener, {
                once: true,
                capture: true
              });
              window.__cleanupDrag = () => __async(this, null, function* () {
                const val = yield didStartDrag;
                window.removeEventListener("mousemove", mouseListener, {
                  capture: true
                });
                window.removeEventListener("dragstart", dragListener, {
                  capture: true
                });
                delete window.__cleanupDrag;
                return val;
              });
            }.toString(), true, "utility").catch(() => {
            });
          })));
          client.on("Input.dragIntercepted", onDragIntercepted);
          try {
            yield client.send("Input.setInterceptDrags", {
              enabled: true
            });
          } catch (e) {
            client.off("Input.dragIntercepted", onDragIntercepted);
            return moveCallback();
          }
          yield moveCallback();
          const expectingDrag = (yield Promise.all(this._crPage._page.frames().map((frame) => __async(this, null, function* () {
            return frame.nonStallingEvaluateInExistingContext("window.__cleanupDrag && window.__cleanupDrag()", false, "utility").catch(() => false);
          })))).some((x2) => x2);
          this._dragState = expectingDrag ? (yield dragInterceptedPromise).data : null;
          client.off("Input.dragIntercepted", onDragIntercepted);
          yield client.send("Input.setInterceptDrags", {
            enabled: false
          });
          if (this._dragState) {
            yield this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
              type: "dragEnter",
              x,
              y,
              data: this._dragState,
              modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
            });
          }
        });
      }
      isDragging() {
        return !!this._dragState;
      }
      drop(x, y, modifiers) {
        return __async(this, null, function* () {
          (0, _utils.assert)(this._dragState, "missing drag state");
          yield this._crPage._mainFrameSession._client.send("Input.dispatchDragEvent", {
            type: "drop",
            x,
            y,
            data: this._dragState,
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
          });
          this._dragState = null;
        });
      }
    };
    exports2.DragManager = DragManager;
  }
});

// node_modules/playwright-core/lib/server/chromium/crExecutionContext.js
var require_crExecutionContext = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crExecutionContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRExecutionContext = void 0;
    var _crProtocolHelper = require_crProtocolHelper();
    var js = _interopRequireWildcard(require_javascript());
    var _stackTrace = require_stackTrace();
    var _utilityScriptSerializers = require_utilityScriptSerializers();
    var _protocolError = require_protocolError();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var CRExecutionContext = class {
      constructor(client, contextPayload) {
        this._client = void 0;
        this._contextId = void 0;
        this._client = client;
        this._contextId = contextPayload.id;
      }
      rawEvaluateJSON(expression) {
        return __async(this, null, function* () {
          const {
            exceptionDetails,
            result: remoteObject
          } = yield this._client.send("Runtime.evaluate", {
            expression,
            contextId: this._contextId,
            returnByValue: true
          }).catch(rewriteError);
          if (exceptionDetails)
            throw new js.JavaScriptErrorInEvaluate((0, _crProtocolHelper.getExceptionMessage)(exceptionDetails));
          return remoteObject.value;
        });
      }
      rawEvaluateHandle(expression) {
        return __async(this, null, function* () {
          const {
            exceptionDetails,
            result: remoteObject
          } = yield this._client.send("Runtime.evaluate", {
            expression,
            contextId: this._contextId
          }).catch(rewriteError);
          if (exceptionDetails)
            throw new js.JavaScriptErrorInEvaluate((0, _crProtocolHelper.getExceptionMessage)(exceptionDetails));
          return remoteObject.objectId;
        });
      }
      rawCallFunctionNoReply(func, ...args) {
        this._client.send("Runtime.callFunctionOn", {
          functionDeclaration: func.toString(),
          arguments: args.map((a) => a instanceof js.JSHandle ? {
            objectId: a._objectId
          } : {
            value: a
          }),
          returnByValue: true,
          executionContextId: this._contextId,
          userGesture: true
        }).catch(() => {
        });
      }
      evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        return __async(this, null, function* () {
          const {
            exceptionDetails,
            result: remoteObject
          } = yield this._client.send("Runtime.callFunctionOn", {
            functionDeclaration: expression,
            objectId: utilityScript._objectId,
            arguments: [{
              objectId: utilityScript._objectId
            }, ...values.map((value) => ({
              value
            })), ...objectIds.map((objectId) => ({
              objectId
            }))],
            returnByValue,
            awaitPromise: true,
            userGesture: true
          }).catch(rewriteError);
          if (exceptionDetails)
            throw new js.JavaScriptErrorInEvaluate((0, _crProtocolHelper.getExceptionMessage)(exceptionDetails));
          return returnByValue ? (0, _utilityScriptSerializers.parseEvaluationResultValue)(remoteObject.value) : utilityScript._context.createHandle(remoteObject);
        });
      }
      getProperties(context, objectId) {
        return __async(this, null, function* () {
          const response = yield this._client.send("Runtime.getProperties", {
            objectId,
            ownProperties: true
          });
          const result = /* @__PURE__ */ new Map();
          for (const property of response.result) {
            if (!property.enumerable || !property.value)
              continue;
            result.set(property.name, context.createHandle(property.value));
          }
          return result;
        });
      }
      createHandle(context, remoteObject) {
        return new js.JSHandle(context, remoteObject.subtype || remoteObject.type, renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
      }
      releaseHandle(objectId) {
        return __async(this, null, function* () {
          yield (0, _crProtocolHelper.releaseObject)(this._client, objectId);
        });
      }
    };
    exports2.CRExecutionContext = CRExecutionContext;
    function rewriteError(error) {
      if (error.message.includes("Object reference chain is too long"))
        return {
          result: {
            type: "undefined"
          }
        };
      if (error.message.includes("Object couldn't be returned by value"))
        return {
          result: {
            type: "undefined"
          }
        };
      if (error instanceof TypeError && error.message.startsWith("Converting circular structure to JSON"))
        (0, _stackTrace.rewriteErrorMessage)(error, error.message + " Are you passing a nested JSHandle?");
      if (!js.isJavaScriptErrorInEvaluate(error) && !(0, _protocolError.isSessionClosedError)(error))
        throw new Error("Execution context was destroyed, most likely because of a navigation.");
      throw error;
    }
    function potentiallyUnserializableValue(remoteObject) {
      const value = remoteObject.value;
      const unserializableValue = remoteObject.unserializableValue;
      return unserializableValue ? js.parseUnserializableValue(unserializableValue) : value;
    }
    function renderPreview(object) {
      if (object.type === "undefined")
        return "undefined";
      if ("value" in object)
        return String(object.value);
      if (object.unserializableValue)
        return String(object.unserializableValue);
      if (object.description === "Object" && object.preview) {
        const tokens = [];
        for (const {
          name,
          value
        } of object.preview.properties)
          tokens.push(`${name}: ${value}`);
        return `{${tokens.join(", ")}}`;
      }
      if (object.subtype === "array" && object.preview) {
        const result = [];
        for (const {
          name,
          value
        } of object.preview.properties)
          result[+name] = value;
        return "[" + String(result) + "]";
      }
      return object.description;
    }
  }
});

// node_modules/playwright-core/lib/server/macEditingCommands.js
var require_macEditingCommands = __commonJS({
  "node_modules/playwright-core/lib/server/macEditingCommands.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.macEditingCommands = void 0;
    var macEditingCommands = {
      "Backspace": "deleteBackward:",
      "Enter": "insertNewline:",
      "NumpadEnter": "insertNewline:",
      "Escape": "cancelOperation:",
      "ArrowUp": "moveUp:",
      "ArrowDown": "moveDown:",
      "ArrowLeft": "moveLeft:",
      "ArrowRight": "moveRight:",
      "F5": "complete:",
      "Delete": "deleteForward:",
      "Home": "scrollToBeginningOfDocument:",
      "End": "scrollToEndOfDocument:",
      "PageUp": "scrollPageUp:",
      "PageDown": "scrollPageDown:",
      "Shift+Backspace": "deleteBackward:",
      "Shift+Enter": "insertNewline:",
      "Shift+NumpadEnter": "insertNewline:",
      "Shift+Escape": "cancelOperation:",
      "Shift+ArrowUp": "moveUpAndModifySelection:",
      "Shift+ArrowDown": "moveDownAndModifySelection:",
      "Shift+ArrowLeft": "moveLeftAndModifySelection:",
      "Shift+ArrowRight": "moveRightAndModifySelection:",
      "Shift+F5": "complete:",
      "Shift+Delete": "deleteForward:",
      "Shift+Home": "moveToBeginningOfDocumentAndModifySelection:",
      "Shift+End": "moveToEndOfDocumentAndModifySelection:",
      "Shift+PageUp": "pageUpAndModifySelection:",
      "Shift+PageDown": "pageDownAndModifySelection:",
      "Shift+Numpad5": "delete:",
      "Control+Tab": "selectNextKeyView:",
      "Control+Enter": "insertLineBreak:",
      "Control+NumpadEnter": "insertLineBreak:",
      "Control+Quote": "insertSingleQuoteIgnoringSubstitution:",
      "Control+KeyA": "moveToBeginningOfParagraph:",
      "Control+KeyB": "moveBackward:",
      "Control+KeyD": "deleteForward:",
      "Control+KeyE": "moveToEndOfParagraph:",
      "Control+KeyF": "moveForward:",
      "Control+KeyH": "deleteBackward:",
      "Control+KeyK": "deleteToEndOfParagraph:",
      "Control+KeyL": "centerSelectionInVisibleArea:",
      "Control+KeyN": "moveDown:",
      "Control+KeyO": ["insertNewlineIgnoringFieldEditor:", "moveBackward:"],
      "Control+KeyP": "moveUp:",
      "Control+KeyT": "transpose:",
      "Control+KeyV": "pageDown:",
      "Control+KeyY": "yank:",
      "Control+Backspace": "deleteBackwardByDecomposingPreviousCharacter:",
      "Control+ArrowUp": "scrollPageUp:",
      "Control+ArrowDown": "scrollPageDown:",
      "Control+ArrowLeft": "moveToLeftEndOfLine:",
      "Control+ArrowRight": "moveToRightEndOfLine:",
      "Shift+Control+Enter": "insertLineBreak:",
      "Shift+Control+NumpadEnter": "insertLineBreak:",
      "Shift+Control+Tab": "selectPreviousKeyView:",
      "Shift+Control+Quote": "insertDoubleQuoteIgnoringSubstitution:",
      "Shift+Control+KeyA": "moveToBeginningOfParagraphAndModifySelection:",
      "Shift+Control+KeyB": "moveBackwardAndModifySelection:",
      "Shift+Control+KeyE": "moveToEndOfParagraphAndModifySelection:",
      "Shift+Control+KeyF": "moveForwardAndModifySelection:",
      "Shift+Control+KeyN": "moveDownAndModifySelection:",
      "Shift+Control+KeyP": "moveUpAndModifySelection:",
      "Shift+Control+KeyV": "pageDownAndModifySelection:",
      "Shift+Control+Backspace": "deleteBackwardByDecomposingPreviousCharacter:",
      "Shift+Control+ArrowUp": "scrollPageUp:",
      "Shift+Control+ArrowDown": "scrollPageDown:",
      "Shift+Control+ArrowLeft": "moveToLeftEndOfLineAndModifySelection:",
      "Shift+Control+ArrowRight": "moveToRightEndOfLineAndModifySelection:",
      "Alt+Backspace": "deleteWordBackward:",
      "Alt+Enter": "insertNewlineIgnoringFieldEditor:",
      "Alt+NumpadEnter": "insertNewlineIgnoringFieldEditor:",
      "Alt+Escape": "complete:",
      "Alt+ArrowUp": ["moveBackward:", "moveToBeginningOfParagraph:"],
      "Alt+ArrowDown": ["moveForward:", "moveToEndOfParagraph:"],
      "Alt+ArrowLeft": "moveWordLeft:",
      "Alt+ArrowRight": "moveWordRight:",
      "Alt+Delete": "deleteWordForward:",
      "Alt+PageUp": "pageUp:",
      "Alt+PageDown": "pageDown:",
      "Shift+Alt+Backspace": "deleteWordBackward:",
      "Shift+Alt+Enter": "insertNewlineIgnoringFieldEditor:",
      "Shift+Alt+NumpadEnter": "insertNewlineIgnoringFieldEditor:",
      "Shift+Alt+Escape": "complete:",
      "Shift+Alt+ArrowUp": "moveParagraphBackwardAndModifySelection:",
      "Shift+Alt+ArrowDown": "moveParagraphForwardAndModifySelection:",
      "Shift+Alt+ArrowLeft": "moveWordLeftAndModifySelection:",
      "Shift+Alt+ArrowRight": "moveWordRightAndModifySelection:",
      "Shift+Alt+Delete": "deleteWordForward:",
      "Shift+Alt+PageUp": "pageUp:",
      "Shift+Alt+PageDown": "pageDown:",
      "Control+Alt+KeyB": "moveWordBackward:",
      "Control+Alt+KeyF": "moveWordForward:",
      "Control+Alt+Backspace": "deleteWordBackward:",
      "Shift+Control+Alt+KeyB": "moveWordBackwardAndModifySelection:",
      "Shift+Control+Alt+KeyF": "moveWordForwardAndModifySelection:",
      "Shift+Control+Alt+Backspace": "deleteWordBackward:",
      "Meta+NumpadSubtract": "cancel:",
      "Meta+Backspace": "deleteToBeginningOfLine:",
      "Meta+ArrowUp": "moveToBeginningOfDocument:",
      "Meta+ArrowDown": "moveToEndOfDocument:",
      "Meta+ArrowLeft": "moveToLeftEndOfLine:",
      "Meta+ArrowRight": "moveToRightEndOfLine:",
      "Shift+Meta+NumpadSubtract": "cancel:",
      "Shift+Meta+Backspace": "deleteToBeginningOfLine:",
      "Shift+Meta+ArrowUp": "moveToBeginningOfDocumentAndModifySelection:",
      "Shift+Meta+ArrowDown": "moveToEndOfDocumentAndModifySelection:",
      "Shift+Meta+ArrowLeft": "moveToLeftEndOfLineAndModifySelection:",
      "Shift+Meta+ArrowRight": "moveToRightEndOfLineAndModifySelection:",
      "Meta+KeyA": "selectAll:",
      "Meta+KeyC": "copy:",
      "Meta+KeyV": "paste:"
    };
    exports2.macEditingCommands = macEditingCommands;
  }
});

// node_modules/playwright-core/lib/server/chromium/crInput.js
var require_crInput = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crInput.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RawTouchscreenImpl = exports2.RawMouseImpl = exports2.RawKeyboardImpl = void 0;
    var input = _interopRequireWildcard(require_input());
    var _macEditingCommands = require_macEditingCommands();
    var _utils = require_utils();
    var _crProtocolHelper = require_crProtocolHelper();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var RawKeyboardImpl = class {
      constructor(_client, _isMac, _dragManger) {
        this._client = _client;
        this._isMac = _isMac;
        this._dragManger = _dragManger;
      }
      _commandsForCode(code, modifiers) {
        if (!this._isMac)
          return [];
        const parts = [];
        for (const modifier of ["Shift", "Control", "Alt", "Meta"]) {
          if (modifiers.has(modifier))
            parts.push(modifier);
        }
        parts.push(code);
        const shortcut = parts.join("+");
        let commands = _macEditingCommands.macEditingCommands[shortcut] || [];
        if ((0, _utils.isString)(commands))
          commands = [commands];
        commands = commands.filter((x) => !x.startsWith("insert"));
        return commands.map((c) => c.substring(0, c.length - 1));
      }
      keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2, autoRepeat, text) {
        return __async(this, null, function* () {
          if (code === "Escape" && (yield this._dragManger.cancelDrag()))
            return;
          const commands = this._commandsForCode(code, modifiers);
          yield this._client.send("Input.dispatchKeyEvent", {
            type: text ? "keyDown" : "rawKeyDown",
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            windowsVirtualKeyCode: keyCodeWithoutLocation,
            code,
            commands,
            key,
            text,
            unmodifiedText: text,
            autoRepeat,
            location: location2,
            isKeypad: location2 === input.keypadLocation
          });
        });
      }
      keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2) {
        return __async(this, null, function* () {
          yield this._client.send("Input.dispatchKeyEvent", {
            type: "keyUp",
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            key,
            windowsVirtualKeyCode: keyCodeWithoutLocation,
            code,
            location: location2
          });
        });
      }
      sendText(text) {
        return __async(this, null, function* () {
          yield this._client.send("Input.insertText", {
            text
          });
        });
      }
    };
    exports2.RawKeyboardImpl = RawKeyboardImpl;
    var RawMouseImpl = class {
      constructor(page, client, dragManager) {
        this._client = void 0;
        this._page = void 0;
        this._dragManager = void 0;
        this._page = page;
        this._client = client;
        this._dragManager = dragManager;
      }
      move(x, y, button, buttons, modifiers, forClick) {
        return __async(this, null, function* () {
          const actualMove = () => __async(this, null, function* () {
            yield this._client.send("Input.dispatchMouseEvent", {
              type: "mouseMoved",
              button,
              buttons: (0, _crProtocolHelper.toButtonsMask)(buttons),
              x,
              y,
              modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers)
            });
          });
          if (forClick) {
            return actualMove();
          }
          yield this._dragManager.interceptDragCausedByMove(x, y, button, buttons, modifiers, actualMove);
        });
      }
      down(x, y, button, buttons, modifiers, clickCount) {
        return __async(this, null, function* () {
          if (this._dragManager.isDragging())
            return;
          yield this._client.send("Input.dispatchMouseEvent", {
            type: "mousePressed",
            button,
            buttons: (0, _crProtocolHelper.toButtonsMask)(buttons),
            x,
            y,
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            clickCount
          });
        });
      }
      up(x, y, button, buttons, modifiers, clickCount) {
        return __async(this, null, function* () {
          if (this._dragManager.isDragging()) {
            yield this._dragManager.drop(x, y, modifiers);
            return;
          }
          yield this._client.send("Input.dispatchMouseEvent", {
            type: "mouseReleased",
            button,
            buttons: (0, _crProtocolHelper.toButtonsMask)(buttons),
            x,
            y,
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            clickCount
          });
        });
      }
      wheel(x, y, buttons, modifiers, deltaX, deltaY) {
        return __async(this, null, function* () {
          yield this._client.send("Input.dispatchMouseEvent", {
            type: "mouseWheel",
            x,
            y,
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            deltaX,
            deltaY
          });
        });
      }
    };
    exports2.RawMouseImpl = RawMouseImpl;
    var RawTouchscreenImpl = class {
      constructor(client) {
        this._client = void 0;
        this._client = client;
      }
      tap(x, y, modifiers) {
        return __async(this, null, function* () {
          yield Promise.all([this._client.send("Input.dispatchTouchEvent", {
            type: "touchStart",
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            touchPoints: [{
              x,
              y
            }]
          }), this._client.send("Input.dispatchTouchEvent", {
            type: "touchEnd",
            modifiers: (0, _crProtocolHelper.toModifiersMask)(modifiers),
            touchPoints: []
          })]);
        });
      }
    };
    exports2.RawTouchscreenImpl = RawTouchscreenImpl;
  }
});

// node_modules/playwright-core/lib/server/chromium/crNetworkManager.js
var require_crNetworkManager = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crNetworkManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRNetworkManager = void 0;
    var _helper = require_helper();
    var _eventsHelper = require_eventsHelper();
    var network = _interopRequireWildcard(require_network());
    var _utils = require_utils();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var CRNetworkManager = class {
      constructor(client, page, parentManager) {
        this._client = void 0;
        this._page = void 0;
        this._parentManager = void 0;
        this._requestIdToRequest = /* @__PURE__ */ new Map();
        this._requestIdToRequestWillBeSentEvent = /* @__PURE__ */ new Map();
        this._credentials = null;
        this._attemptedAuthentications = /* @__PURE__ */ new Set();
        this._userRequestInterceptionEnabled = false;
        this._protocolRequestInterceptionEnabled = false;
        this._requestIdToRequestPausedEvent = /* @__PURE__ */ new Map();
        this._eventListeners = void 0;
        this._responseExtraInfoTracker = new ResponseExtraInfoTracker();
        this._client = client;
        this._page = page;
        this._parentManager = parentManager;
        this._eventListeners = this.instrumentNetworkEvents(client);
      }
      instrumentNetworkEvents(session, workerFrame) {
        return [_eventsHelper.eventsHelper.addEventListener(session, "Fetch.requestPaused", this._onRequestPaused.bind(this, workerFrame)), _eventsHelper.eventsHelper.addEventListener(session, "Fetch.authRequired", this._onAuthRequired.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestWillBeSent", this._onRequestWillBeSent.bind(this, workerFrame)), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestWillBeSentExtraInfo", this._onRequestWillBeSentExtraInfo.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestServedFromCache", this._onRequestServedFromCache.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.responseReceived", this._onResponseReceived.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.responseReceivedExtraInfo", this._onResponseReceivedExtraInfo.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.loadingFinished", this._onLoadingFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.loadingFailed", this._onLoadingFailed.bind(this, workerFrame)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketCreated", (e) => this._page._frameManager.onWebSocketCreated(e.requestId, e.url)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketWillSendHandshakeRequest", (e) => this._page._frameManager.onWebSocketRequest(e.requestId)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketHandshakeResponseReceived", (e) => this._page._frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketFrameSent", (e) => e.response.payloadData && this._page._frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketFrameReceived", (e) => e.response.payloadData && this._page._frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketClosed", (e) => this._page._frameManager.webSocketClosed(e.requestId)), _eventsHelper.eventsHelper.addEventListener(session, "Network.webSocketFrameError", (e) => this._page._frameManager.webSocketError(e.requestId, e.errorMessage))];
      }
      initialize() {
        return __async(this, null, function* () {
          yield this._client.send("Network.enable");
        });
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
      }
      authenticate(credentials) {
        return __async(this, null, function* () {
          this._credentials = credentials;
          yield this._updateProtocolRequestInterception();
        });
      }
      setOffline(offline) {
        return __async(this, null, function* () {
          yield this._client.send("Network.emulateNetworkConditions", {
            offline,
            latency: 0,
            downloadThroughput: -1,
            uploadThroughput: -1
          });
        });
      }
      setRequestInterception(value) {
        return __async(this, null, function* () {
          this._userRequestInterceptionEnabled = value;
          yield this._updateProtocolRequestInterception();
        });
      }
      _updateProtocolRequestInterception() {
        return __async(this, null, function* () {
          const enabled = this._userRequestInterceptionEnabled || !!this._credentials;
          if (enabled === this._protocolRequestInterceptionEnabled)
            return;
          this._protocolRequestInterceptionEnabled = enabled;
          if (enabled) {
            yield Promise.all([this._client.send("Network.setCacheDisabled", {
              cacheDisabled: true
            }), this._client.send("Fetch.enable", {
              handleAuthRequests: true,
              patterns: [{
                urlPattern: "*",
                requestStage: "Request"
              }]
            })]);
          } else {
            yield Promise.all([this._client.send("Network.setCacheDisabled", {
              cacheDisabled: false
            }), this._client.send("Fetch.disable")]);
          }
        });
      }
      _onRequestWillBeSent(workerFrame, event) {
        this._responseExtraInfoTracker.requestWillBeSent(event);
        if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith("data:")) {
          const requestId = event.requestId;
          const requestPausedEvent = this._requestIdToRequestPausedEvent.get(requestId);
          if (requestPausedEvent) {
            this._onRequest(workerFrame, event, requestPausedEvent);
            this._requestIdToRequestPausedEvent.delete(requestId);
          } else {
            this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);
          }
        } else {
          this._onRequest(workerFrame, event, null);
        }
      }
      _onRequestServedFromCache(event) {
        this._responseExtraInfoTracker.requestServedFromCache(event);
      }
      _onRequestWillBeSentExtraInfo(event) {
        this._responseExtraInfoTracker.requestWillBeSentExtraInfo(event);
      }
      _onAuthRequired(event) {
        let response = "Default";
        if (this._attemptedAuthentications.has(event.requestId)) {
          response = "CancelAuth";
        } else if (this._credentials) {
          response = "ProvideCredentials";
          this._attemptedAuthentications.add(event.requestId);
        }
        const {
          username,
          password
        } = this._credentials || {
          username: void 0,
          password: void 0
        };
        this._client._sendMayFail("Fetch.continueWithAuth", {
          requestId: event.requestId,
          authChallengeResponse: {
            response,
            username,
            password
          }
        });
      }
      _onRequestPaused(workerFrame, event) {
        if (!event.responseStatusCode && !event.responseErrorReason) {
          const request = this._requestIdToRequest.get(event.networkId);
          if (request)
            this._responseExtraInfoTracker.requestPaused(request.request, event);
        }
        if (!event.networkId) {
          this._client._sendMayFail("Fetch.failRequest", {
            requestId: event.requestId,
            errorReason: "Aborted"
          });
          return;
        }
        if (event.request.url.startsWith("data:"))
          return;
        const requestId = event.networkId;
        const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);
        if (requestWillBeSentEvent) {
          this._onRequest(workerFrame, requestWillBeSentEvent, event);
          this._requestIdToRequestWillBeSentEvent.delete(requestId);
        } else {
          this._requestIdToRequestPausedEvent.set(requestId, event);
        }
      }
      _onRequest(workerFrame, requestWillBeSentEvent, requestPausedEvent) {
        if (requestWillBeSentEvent.request.url.startsWith("data:"))
          return;
        let redirectedFrom = null;
        if (requestWillBeSentEvent.redirectResponse) {
          const request2 = this._requestIdToRequest.get(requestWillBeSentEvent.requestId);
          if (request2) {
            this._handleRequestRedirect(request2, requestWillBeSentEvent.redirectResponse, requestWillBeSentEvent.timestamp);
            redirectedFrom = request2;
          }
        }
        let frame = requestWillBeSentEvent.frameId ? this._page._frameManager.frame(requestWillBeSentEvent.frameId) : workerFrame;
        if (!frame && requestPausedEvent && requestPausedEvent.frameId)
          frame = this._page._frameManager.frame(requestPausedEvent.frameId);
        if (!frame && requestWillBeSentEvent.frameId === this._page._delegate._targetId) {
          frame = this._page._frameManager.frameAttached(requestWillBeSentEvent.frameId, null);
        }
        if (requestPausedEvent && requestPausedEvent.request.method === "OPTIONS" && this._page._needsRequestInterception()) {
          const requestHeaders = requestPausedEvent.request.headers;
          const responseHeaders = [{
            name: "Access-Control-Allow-Origin",
            value: requestHeaders["Origin"] || "*"
          }, {
            name: "Access-Control-Allow-Methods",
            value: requestHeaders["Access-Control-Request-Method"] || "GET, POST, OPTIONS, DELETE"
          }, {
            name: "Access-Control-Allow-Credentials",
            value: "true"
          }];
          if (requestHeaders["Access-Control-Request-Headers"])
            responseHeaders.push({
              name: "Access-Control-Allow-Headers",
              value: requestHeaders["Access-Control-Request-Headers"]
            });
          this._client._sendMayFail("Fetch.fulfillRequest", {
            requestId: requestPausedEvent.requestId,
            responseCode: 204,
            responsePhrase: network.STATUS_TEXTS["204"],
            responseHeaders,
            body: ""
          });
          return;
        }
        if (!frame) {
          if (requestPausedEvent)
            this._client._sendMayFail("Fetch.continueRequest", {
              requestId: requestPausedEvent.requestId
            });
          return;
        }
        let route = null;
        if (requestPausedEvent) {
          if (redirectedFrom || !this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled)
            this._client._sendMayFail("Fetch.continueRequest", {
              requestId: requestPausedEvent.requestId
            });
          else
            route = new RouteImpl(this._client, requestPausedEvent.requestId);
        }
        const isNavigationRequest = requestWillBeSentEvent.requestId === requestWillBeSentEvent.loaderId && requestWillBeSentEvent.type === "Document";
        const documentId = isNavigationRequest ? requestWillBeSentEvent.loaderId : void 0;
        const request = new InterceptableRequest({
          frame,
          documentId,
          route,
          requestWillBeSentEvent,
          requestPausedEvent,
          redirectedFrom
        });
        this._requestIdToRequest.set(requestWillBeSentEvent.requestId, request);
        this._page._frameManager.requestStarted(request.request, route || void 0);
      }
      _createResponse(request, responsePayload) {
        var _responsePayload$secu, _responsePayload$secu2, _responsePayload$secu3, _responsePayload$secu4, _responsePayload$secu5;
        const getResponseBody = () => __async(this, null, function* () {
          const response2 = yield this._client.send("Network.getResponseBody", {
            requestId: request._requestId
          });
          return Buffer.from(response2.body, response2.base64Encoded ? "base64" : "utf8");
        });
        const timingPayload = responsePayload.timing;
        let timing;
        if (timingPayload) {
          timing = {
            startTime: (timingPayload.requestTime - request._timestamp + request._wallTime) * 1e3,
            domainLookupStart: timingPayload.dnsStart,
            domainLookupEnd: timingPayload.dnsEnd,
            connectStart: timingPayload.connectStart,
            secureConnectionStart: timingPayload.sslStart,
            connectEnd: timingPayload.connectEnd,
            requestStart: timingPayload.sendStart,
            responseStart: timingPayload.receiveHeadersEnd
          };
        } else {
          timing = {
            startTime: request._wallTime * 1e3,
            domainLookupStart: -1,
            domainLookupEnd: -1,
            connectStart: -1,
            secureConnectionStart: -1,
            connectEnd: -1,
            requestStart: -1,
            responseStart: -1
          };
        }
        const response = new network.Response(request.request, responsePayload.status, responsePayload.statusText, (0, _utils.headersObjectToArray)(responsePayload.headers), timing, getResponseBody, responsePayload.protocol);
        if (responsePayload !== null && responsePayload !== void 0 && responsePayload.remoteIPAddress && typeof (responsePayload === null || responsePayload === void 0 ? void 0 : responsePayload.remotePort) === "number") {
          response._serverAddrFinished({
            ipAddress: responsePayload.remoteIPAddress,
            port: responsePayload.remotePort
          });
        } else {
          response._serverAddrFinished();
        }
        response._securityDetailsFinished({
          protocol: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu = responsePayload.securityDetails) === null || _responsePayload$secu === void 0 ? void 0 : _responsePayload$secu.protocol,
          subjectName: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu2 = responsePayload.securityDetails) === null || _responsePayload$secu2 === void 0 ? void 0 : _responsePayload$secu2.subjectName,
          issuer: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu3 = responsePayload.securityDetails) === null || _responsePayload$secu3 === void 0 ? void 0 : _responsePayload$secu3.issuer,
          validFrom: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu4 = responsePayload.securityDetails) === null || _responsePayload$secu4 === void 0 ? void 0 : _responsePayload$secu4.validFrom,
          validTo: responsePayload === null || responsePayload === void 0 ? void 0 : (_responsePayload$secu5 = responsePayload.securityDetails) === null || _responsePayload$secu5 === void 0 ? void 0 : _responsePayload$secu5.validTo
        });
        this._responseExtraInfoTracker.processResponse(request._requestId, response, request.wasFulfilled());
        return response;
      }
      _handleRequestRedirect(request, responsePayload, timestamp) {
        const response = this._createResponse(request, responsePayload);
        response._requestFinished((timestamp - request._timestamp) * 1e3);
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
          this._attemptedAuthentications.delete(request._interceptionId);
        this._page._frameManager.requestReceivedResponse(response);
        this._page._frameManager.reportRequestFinished(request.request, response);
      }
      _onResponseReceivedExtraInfo(event) {
        this._responseExtraInfoTracker.responseReceivedExtraInfo(event);
      }
      _onResponseReceived(event) {
        this._responseExtraInfoTracker.responseReceived(event);
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        const response = this._createResponse(request, event.response);
        this._page._frameManager.requestReceivedResponse(response);
      }
      _onLoadingFinished(event) {
        this._responseExtraInfoTracker.loadingFinished(event);
        let request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          request = this._maybeAdoptMainRequest(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response) {
          request.request.responseSize.transferSize = event.encodedDataLength;
          request.request.responseSize.encodedBodySize = event.encodedDataLength - request.request.responseSize.responseHeadersSize;
          response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        }
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
          this._attemptedAuthentications.delete(request._interceptionId);
        this._page._frameManager.reportRequestFinished(request.request, response);
      }
      _onLoadingFailed(workerFrame, event) {
        this._responseExtraInfoTracker.loadingFailed(event);
        let request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          request = this._maybeAdoptMainRequest(event.requestId);
        if (!request) {
          const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(event.requestId);
          if (requestWillBeSentEvent) {
            this._requestIdToRequestWillBeSentEvent.delete(event.requestId);
            this._onRequest(workerFrame, requestWillBeSentEvent, null);
            request = this._requestIdToRequest.get(event.requestId);
          }
        }
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response)
          response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        this._requestIdToRequest.delete(request._requestId);
        if (request._interceptionId)
          this._attemptedAuthentications.delete(request._interceptionId);
        request.request._setFailureText(event.errorText);
        this._page._frameManager.requestFailed(request.request, !!event.canceled);
      }
      _maybeAdoptMainRequest(requestId) {
        if (!this._parentManager)
          return;
        const request = this._parentManager._requestIdToRequest.get(requestId);
        if (!request || request._documentId !== requestId)
          return;
        this._requestIdToRequest.set(requestId, request);
        this._parentManager._requestIdToRequest.delete(requestId);
        if (request._interceptionId && this._parentManager._attemptedAuthentications.has(request._interceptionId)) {
          this._parentManager._attemptedAuthentications.delete(request._interceptionId);
          this._attemptedAuthentications.add(request._interceptionId);
        }
        return request;
      }
    };
    exports2.CRNetworkManager = CRNetworkManager;
    var InterceptableRequest = class {
      constructor(options) {
        this.request = void 0;
        this._requestId = void 0;
        this._interceptionId = void 0;
        this._documentId = void 0;
        this._timestamp = void 0;
        this._wallTime = void 0;
        this._route = void 0;
        this._redirectedFrom = void 0;
        const {
          frame,
          documentId,
          route,
          requestWillBeSentEvent,
          requestPausedEvent,
          redirectedFrom
        } = options;
        this._timestamp = requestWillBeSentEvent.timestamp;
        this._wallTime = requestWillBeSentEvent.wallTime;
        this._requestId = requestWillBeSentEvent.requestId;
        this._interceptionId = requestPausedEvent && requestPausedEvent.requestId;
        this._documentId = documentId;
        this._route = route;
        this._redirectedFrom = redirectedFrom;
        const {
          headers,
          method,
          url,
          postDataEntries = null
        } = requestPausedEvent ? requestPausedEvent.request : requestWillBeSentEvent.request;
        const type = (requestWillBeSentEvent.type || "").toLowerCase();
        let postDataBuffer = null;
        if (postDataEntries && postDataEntries.length && postDataEntries[0].bytes)
          postDataBuffer = Buffer.from(postDataEntries[0].bytes, "base64");
        this.request = new network.Request(frame, (redirectedFrom === null || redirectedFrom === void 0 ? void 0 : redirectedFrom.request) || null, documentId, url, type, method, postDataBuffer, (0, _utils.headersObjectToArray)(headers));
      }
      _routeForRedirectChain() {
        let request = this;
        while (request._redirectedFrom)
          request = request._redirectedFrom;
        return request._route;
      }
      wasFulfilled() {
        var _this$_routeForRedire;
        return ((_this$_routeForRedire = this._routeForRedirectChain()) === null || _this$_routeForRedire === void 0 ? void 0 : _this$_routeForRedire._wasFulfilled) || false;
      }
    };
    var RouteImpl = class {
      constructor(client, interceptionId) {
        this._client = void 0;
        this._interceptionId = void 0;
        this._wasFulfilled = false;
        this._client = client;
        this._interceptionId = interceptionId;
      }
      continue(request, overrides) {
        return __async(this, null, function* () {
          yield this._client._sendMayFail("Fetch.continueRequest", {
            requestId: this._interceptionId,
            url: overrides.url,
            headers: overrides.headers,
            method: overrides.method,
            postData: overrides.postData ? overrides.postData.toString("base64") : void 0
          });
        });
      }
      fulfill(response) {
        return __async(this, null, function* () {
          this._wasFulfilled = true;
          const body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
          const responseHeaders = splitSetCookieHeader(response.headers);
          yield this._client._sendMayFail("Fetch.fulfillRequest", {
            requestId: this._interceptionId,
            responseCode: response.status,
            responsePhrase: network.STATUS_TEXTS[String(response.status)],
            responseHeaders,
            body
          });
        });
      }
      abort(errorCode = "failed") {
        return __async(this, null, function* () {
          const errorReason = errorReasons[errorCode];
          (0, _utils.assert)(errorReason, "Unknown error code: " + errorCode);
          yield this._client._sendMayFail("Fetch.failRequest", {
            requestId: this._interceptionId,
            errorReason
          });
        });
      }
    };
    function splitSetCookieHeader(headers) {
      const index = headers.findIndex(({
        name
      }) => name.toLowerCase() === "set-cookie");
      if (index === -1)
        return headers;
      const header = headers[index];
      const values = header.value.split("\n");
      if (values.length === 1)
        return headers;
      const result = headers.slice();
      result.splice(index, 1, ...values.map((value) => ({
        name: header.name,
        value
      })));
      return result;
    }
    var errorReasons = {
      "aborted": "Aborted",
      "accessdenied": "AccessDenied",
      "addressunreachable": "AddressUnreachable",
      "blockedbyclient": "BlockedByClient",
      "blockedbyresponse": "BlockedByResponse",
      "connectionaborted": "ConnectionAborted",
      "connectionclosed": "ConnectionClosed",
      "connectionfailed": "ConnectionFailed",
      "connectionrefused": "ConnectionRefused",
      "connectionreset": "ConnectionReset",
      "internetdisconnected": "InternetDisconnected",
      "namenotresolved": "NameNotResolved",
      "timedout": "TimedOut",
      "failed": "Failed"
    };
    var ResponseExtraInfoTracker = class {
      constructor() {
        this._requests = /* @__PURE__ */ new Map();
      }
      requestWillBeSent(event) {
        const info = this._requests.get(event.requestId);
        if (info && event.redirectResponse)
          this._innerResponseReceived(info, event.redirectResponse);
        else
          this._getOrCreateEntry(event.requestId);
      }
      requestWillBeSentExtraInfo(event) {
        const info = this._getOrCreateEntry(event.requestId);
        info.requestWillBeSentExtraInfo.push(event);
        this._patchHeaders(info, info.requestWillBeSentExtraInfo.length - 1);
      }
      requestServedFromCache(event) {
        const info = this._getOrCreateEntry(event.requestId);
        info.requestServedFromCache = true;
      }
      responseReceived(event) {
        const info = this._requests.get(event.requestId);
        if (!info)
          return;
        this._innerResponseReceived(info, event.response);
      }
      requestPaused(request, event) {
        request.setRawRequestHeaders((0, _utils.headersObjectToArray)(event.request.headers, "\n"));
      }
      _innerResponseReceived(info, response) {
        if (!response.connectionId) {
          info.sawResponseWithoutConnectionId = true;
        }
      }
      responseReceivedExtraInfo(event) {
        const info = this._getOrCreateEntry(event.requestId);
        info.responseReceivedExtraInfo.push(event);
        this._patchHeaders(info, info.responseReceivedExtraInfo.length - 1);
        this._checkFinished(info);
      }
      processResponse(requestId, response, wasFulfilled) {
        if (wasFulfilled) {
          this._stopTracking(requestId);
          return;
        }
        const info = this._requests.get(requestId);
        if (!info || info.sawResponseWithoutConnectionId)
          return;
        if (!info.requestServedFromCache)
          response.setWillReceiveExtraHeaders();
        info.responses.push(response);
        this._patchHeaders(info, info.responses.length - 1);
      }
      loadingFinished(event) {
        const info = this._requests.get(event.requestId);
        if (!info)
          return;
        info.loadingFinished = event;
        this._checkFinished(info);
      }
      loadingFailed(event) {
        const info = this._requests.get(event.requestId);
        if (!info)
          return;
        info.loadingFailed = event;
        this._checkFinished(info);
      }
      _getOrCreateEntry(requestId) {
        let info = this._requests.get(requestId);
        if (!info) {
          info = {
            requestId,
            requestWillBeSentExtraInfo: [],
            responseReceivedExtraInfo: [],
            responses: [],
            sawResponseWithoutConnectionId: false,
            requestServedFromCache: false
          };
          this._requests.set(requestId, info);
        }
        return info;
      }
      _patchHeaders(info, index) {
        const response = info.responses[index];
        const requestExtraInfo = info.requestWillBeSentExtraInfo[index];
        if (response && requestExtraInfo)
          response.request().setRawRequestHeaders((0, _utils.headersObjectToArray)(requestExtraInfo.headers, "\n"));
        const responseExtraInfo = info.responseReceivedExtraInfo[index];
        if (response && responseExtraInfo) {
          var _responseExtraInfo$he;
          response.setRawResponseHeaders((0, _utils.headersObjectToArray)(responseExtraInfo.headers, "\n"));
          response.request().responseSize.responseHeadersSize = ((_responseExtraInfo$he = responseExtraInfo.headersText) === null || _responseExtraInfo$he === void 0 ? void 0 : _responseExtraInfo$he.length) || 0;
        }
      }
      _checkFinished(info) {
        if (!info.loadingFinished && !info.loadingFailed)
          return;
        if (info.responses.length <= info.responseReceivedExtraInfo.length) {
          this._stopTracking(info.requestId);
          return;
        }
      }
      _stopTracking(requestId) {
        this._requests.delete(requestId);
      }
    };
  }
});

// node_modules/playwright-core/lib/server/chromium/crPdf.js
var require_crPdf = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crPdf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRPDF = void 0;
    var _utils = require_utils();
    var _crProtocolHelper = require_crProtocolHelper();
    var PagePaperFormats = {
      letter: {
        width: 8.5,
        height: 11
      },
      legal: {
        width: 8.5,
        height: 14
      },
      tabloid: {
        width: 11,
        height: 17
      },
      ledger: {
        width: 17,
        height: 11
      },
      a0: {
        width: 33.1,
        height: 46.8
      },
      a1: {
        width: 23.4,
        height: 33.1
      },
      a2: {
        width: 16.54,
        height: 23.4
      },
      a3: {
        width: 11.7,
        height: 16.54
      },
      a4: {
        width: 8.27,
        height: 11.7
      },
      a5: {
        width: 5.83,
        height: 8.27
      },
      a6: {
        width: 4.13,
        height: 5.83
      }
    };
    var unitToPixels = {
      "px": 1,
      "in": 96,
      "cm": 37.8,
      "mm": 3.78
    };
    function convertPrintParameterToInches(text) {
      if (text === void 0)
        return void 0;
      let unit = text.substring(text.length - 2).toLowerCase();
      let valueText = "";
      if (unitToPixels.hasOwnProperty(unit)) {
        valueText = text.substring(0, text.length - 2);
      } else {
        unit = "px";
        valueText = text;
      }
      const value = Number(valueText);
      (0, _utils.assert)(!isNaN(value), "Failed to parse parameter value: " + text);
      const pixels = value * unitToPixels[unit];
      return pixels / 96;
    }
    var CRPDF = class {
      constructor(client) {
        this._client = void 0;
        this._client = client;
      }
      generate() {
        return __async(this, arguments, function* (options = {}) {
          const {
            scale = 1,
            displayHeaderFooter = false,
            headerTemplate = "",
            footerTemplate = "",
            printBackground = false,
            landscape = false,
            pageRanges = "",
            preferCSSPageSize = false,
            margin = {}
          } = options;
          let paperWidth = 8.5;
          let paperHeight = 11;
          if (options.format) {
            const format = PagePaperFormats[options.format.toLowerCase()];
            (0, _utils.assert)(format, "Unknown paper format: " + options.format);
            paperWidth = format.width;
            paperHeight = format.height;
          } else {
            paperWidth = convertPrintParameterToInches(options.width) || paperWidth;
            paperHeight = convertPrintParameterToInches(options.height) || paperHeight;
          }
          const marginTop = convertPrintParameterToInches(margin.top) || 0;
          const marginLeft = convertPrintParameterToInches(margin.left) || 0;
          const marginBottom = convertPrintParameterToInches(margin.bottom) || 0;
          const marginRight = convertPrintParameterToInches(margin.right) || 0;
          const result = yield this._client.send("Page.printToPDF", {
            transferMode: "ReturnAsStream",
            landscape,
            displayHeaderFooter,
            headerTemplate,
            footerTemplate,
            printBackground,
            scale,
            paperWidth,
            paperHeight,
            marginTop,
            marginBottom,
            marginLeft,
            marginRight,
            pageRanges,
            preferCSSPageSize
          });
          return yield (0, _crProtocolHelper.readProtocolStream)(this._client, result.stream, null);
        });
      }
    };
    exports2.CRPDF = CRPDF;
  }
});

// node_modules/playwright-core/lib/server/chromium/defaultFontFamilies.js
var require_defaultFontFamilies = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/defaultFontFamilies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.platformToFontFamilies = void 0;
    var platformToFontFamilies = {
      "linux": {
        "fontFamilies": {
          "standard": "Times New Roman",
          "fixed": "Monospace",
          "serif": "Times New Roman",
          "sansSerif": "Arial",
          "cursive": "Comic Sans MS",
          "fantasy": "Impact",
          "pictograph": "Times New Roman"
        }
      },
      "mac": {
        "fontFamilies": {
          "standard": "Times",
          "fixed": "Courier",
          "serif": "Times",
          "sansSerif": "Helvetica",
          "cursive": "Apple Chancery",
          "fantasy": "Papyrus",
          "pictograph": "Apple Color Emoji"
        },
        "forScripts": [{
          "script": "jpan",
          "fontFamilies": {
            "standard": "Hiragino Kaku Gothic ProN",
            "fixed": "Osaka-Mono",
            "serif": "Hiragino Mincho ProN",
            "sansSerif": "Hiragino Kaku Gothic ProN"
          }
        }, {
          "script": "hang",
          "fontFamilies": {
            "standard": "Apple SD Gothic Neo",
            "serif": "AppleMyungjo",
            "sansSerif": "Apple SD Gothic Neo"
          }
        }, {
          "script": "hans",
          "fontFamilies": {
            "standard": ",PingFang SC,STHeiti",
            "serif": "Songti SC",
            "sansSerif": ",PingFang SC,STHeiti",
            "cursive": "Kaiti SC"
          }
        }, {
          "script": "hant",
          "fontFamilies": {
            "standard": ",PingFang TC,Heiti TC",
            "serif": "Songti TC",
            "sansSerif": ",PingFang TC,Heiti TC",
            "cursive": "Kaiti TC"
          }
        }]
      },
      "win": {
        "fontFamilies": {
          "standard": "Times New Roman",
          "fixed": "Consolas",
          "serif": "Times New Roman",
          "sansSerif": "Arial",
          "cursive": "Comic Sans MS",
          "fantasy": "Impact",
          "pictograph": "Segoe UI Symbol"
        },
        "forScripts": [{
          "script": "cyrl",
          "fontFamilies": {
            "standard": "Times New Roman",
            "fixed": "Courier New",
            "serif": "Times New Roman",
            "sansSerif": "Arial"
          }
        }, {
          "script": "arab",
          "fontFamilies": {
            "fixed": "Courier New",
            "sansSerif": "Segoe UI"
          }
        }, {
          "script": "grek",
          "fontFamilies": {
            "standard": "Times New Roman",
            "fixed": "Courier New",
            "serif": "Times New Roman",
            "sansSerif": "Arial"
          }
        }, {
          "script": "jpan",
          "fontFamilies": {
            "standard": ",Meiryo,Yu Gothic",
            "fixed": "MS Gothic",
            "serif": ",Yu Mincho,MS PMincho",
            "sansSerif": ",Meiryo,Yu Gothic"
          }
        }, {
          "script": "hang",
          "fontFamilies": {
            "standard": "Malgun Gothic",
            "fixed": "Gulimche",
            "serif": "Batang",
            "sansSerif": "Malgun Gothic",
            "cursive": "Gungsuh"
          }
        }, {
          "script": "hans",
          "fontFamilies": {
            "standard": "Microsoft YaHei",
            "fixed": "NSimsun",
            "serif": "Simsun",
            "sansSerif": "Microsoft YaHei",
            "cursive": "KaiTi"
          }
        }, {
          "script": "hant",
          "fontFamilies": {
            "standard": "Microsoft JhengHei",
            "fixed": "MingLiU",
            "serif": "PMingLiU",
            "sansSerif": "Microsoft JhengHei",
            "cursive": "DFKai-SB"
          }
        }]
      }
    };
    exports2.platformToFontFamilies = platformToFontFamilies;
  }
});

// node_modules/playwright-core/lib/utils/processLauncher.js
var require_processLauncher = __commonJS({
  "node_modules/playwright-core/lib/utils/processLauncher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.envArrayToObject = envArrayToObject;
    exports2.gracefullyCloseAll = gracefullyCloseAll;
    exports2.gracefullyCloseSet = void 0;
    exports2.launchProcess = launchProcess;
    var childProcess = _interopRequireWildcard(require("child_process"));
    var readline = _interopRequireWildcard(require("readline"));
    var _eventsHelper = require_eventsHelper();
    var _ = require_utils();
    var _fileUtils = require_fileUtils();
    var _rimraf = _interopRequireDefault(require_rimraf());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var gracefullyCloseSet = /* @__PURE__ */ new Set();
    exports2.gracefullyCloseSet = gracefullyCloseSet;
    function gracefullyCloseAll() {
      return __async(this, null, function* () {
        yield Promise.all(Array.from(gracefullyCloseSet).map((gracefullyClose) => gracefullyClose().catch((e) => {
        })));
      });
    }
    var maxListeners = process.getMaxListeners();
    if (maxListeners !== 0)
      process.setMaxListeners(Math.max(maxListeners || 0, 100));
    function launchProcess(options) {
      return __async(this, null, function* () {
        const stdio = options.stdio === "pipe" ? ["ignore", "pipe", "pipe", "pipe", "pipe"] : ["pipe", "pipe", "pipe"];
        options.log(`<launching> ${options.command} ${options.args ? options.args.join(" ") : ""}`);
        const spawnOptions = {
          detached: process.platform !== "win32",
          env: options.env,
          cwd: options.cwd,
          shell: options.shell,
          stdio
        };
        const spawnedProcess = childProcess.spawn(options.command, options.args || [], spawnOptions);
        const cleanup = () => __async(this, null, function* () {
          options.log(`[pid=${spawnedProcess.pid || "N/A"}] starting temporary directories cleanup`);
          const errors = yield (0, _fileUtils.removeFolders)(options.tempDirectories);
          for (let i = 0; i < options.tempDirectories.length; ++i) {
            if (errors[i])
              options.log(`[pid=${spawnedProcess.pid || "N/A"}] exception while removing ${options.tempDirectories[i]}: ${errors[i]}`);
          }
          options.log(`[pid=${spawnedProcess.pid || "N/A"}] finished temporary directories cleanup`);
        });
        spawnedProcess.on("error", () => {
        });
        if (!spawnedProcess.pid) {
          let failed;
          const failedPromise = new Promise((f, r) => failed = f);
          spawnedProcess.once("error", (error) => {
            failed(new Error("Failed to launch: " + error));
          });
          return cleanup().then(() => failedPromise).then((e) => Promise.reject(e));
        }
        options.log(`<launched> pid=${spawnedProcess.pid}`);
        const stdout = readline.createInterface({
          input: spawnedProcess.stdout
        });
        stdout.on("line", (data) => {
          options.log(`[pid=${spawnedProcess.pid}][out] ` + data);
        });
        const stderr = readline.createInterface({
          input: spawnedProcess.stderr
        });
        stderr.on("line", (data) => {
          options.log(`[pid=${spawnedProcess.pid}][err] ` + data);
        });
        let processClosed = false;
        let fulfillClose = () => {
        };
        const waitForClose = new Promise((f) => fulfillClose = f);
        let fulfillCleanup = () => {
        };
        const waitForCleanup = new Promise((f) => fulfillCleanup = f);
        spawnedProcess.once("exit", (exitCode, signal) => {
          options.log(`[pid=${spawnedProcess.pid}] <process did exit: exitCode=${exitCode}, signal=${signal}>`);
          processClosed = true;
          _eventsHelper.eventsHelper.removeEventListeners(listeners);
          gracefullyCloseSet.delete(gracefullyClose);
          options.onExit(exitCode, signal);
          fulfillClose();
          cleanup().then(fulfillCleanup);
        });
        const listeners = [_eventsHelper.eventsHelper.addEventListener(process, "exit", killProcessAndCleanup)];
        if (options.handleSIGINT) {
          listeners.push(_eventsHelper.eventsHelper.addEventListener(process, "SIGINT", () => {
            gracefullyClose().then(() => {
              if ((0, _.isUnderTest)())
                setTimeout(() => process.exit(130), 0);
              else
                process.exit(130);
            });
          }));
        }
        if (options.handleSIGTERM)
          listeners.push(_eventsHelper.eventsHelper.addEventListener(process, "SIGTERM", gracefullyClose));
        if (options.handleSIGHUP)
          listeners.push(_eventsHelper.eventsHelper.addEventListener(process, "SIGHUP", gracefullyClose));
        gracefullyCloseSet.add(gracefullyClose);
        let gracefullyClosing = false;
        function gracefullyClose() {
          return __async(this, null, function* () {
            gracefullyCloseSet.delete(gracefullyClose);
            if (gracefullyClosing) {
              options.log(`[pid=${spawnedProcess.pid}] <forecefully close>`);
              killProcess();
              yield waitForClose;
              return;
            }
            gracefullyClosing = true;
            options.log(`[pid=${spawnedProcess.pid}] <gracefully close start>`);
            yield options.attemptToGracefullyClose().catch(() => killProcess());
            yield waitForCleanup;
            options.log(`[pid=${spawnedProcess.pid}] <gracefully close end>`);
          });
        }
        function killProcess() {
          options.log(`[pid=${spawnedProcess.pid}] <kill>`);
          _eventsHelper.eventsHelper.removeEventListeners(listeners);
          if (spawnedProcess.pid && !spawnedProcess.killed && !processClosed) {
            options.log(`[pid=${spawnedProcess.pid}] <will force kill>`);
            try {
              if (process.platform === "win32") {
                const taskkillProcess = childProcess.spawnSync(`taskkill /pid ${spawnedProcess.pid} /T /F /FI "MEMUSAGE gt 0"`, {
                  shell: true
                });
                const [stderr2, stdout2] = [taskkillProcess.stdout.toString(), taskkillProcess.stderr.toString()];
                if (stdout2)
                  options.log(`[pid=${spawnedProcess.pid}] taskkill stdout: ${stdout2}`);
                if (stderr2)
                  options.log(`[pid=${spawnedProcess.pid}] taskkill stderr: ${stderr2}`);
              } else {
                process.kill(-spawnedProcess.pid, "SIGKILL");
              }
            } catch (e) {
              options.log(`[pid=${spawnedProcess.pid}] exception while trying to kill process: ${e}`);
            }
          } else {
            options.log(`[pid=${spawnedProcess.pid}] <skipped force kill spawnedProcess.killed=${spawnedProcess.killed} processClosed=${processClosed}>`);
          }
        }
        function killProcessAndCleanup() {
          killProcess();
          options.log(`[pid=${spawnedProcess.pid || "N/A"}] starting temporary directories cleanup`);
          for (const dir of options.tempDirectories) {
            try {
              _rimraf.default.sync(dir, {
                maxBusyTries: 10
              });
            } catch (e) {
              options.log(`[pid=${spawnedProcess.pid || "N/A"}] exception while removing ${dir}: ${e}`);
            }
          }
          options.log(`[pid=${spawnedProcess.pid || "N/A"}] finished temporary directories cleanup`);
        }
        function killAndWait() {
          killProcess();
          return waitForCleanup;
        }
        return {
          launchedProcess: spawnedProcess,
          gracefullyClose,
          kill: killAndWait
        };
      });
    }
    function envArrayToObject(env) {
      const result = {};
      for (const {
        name,
        value
      } of env)
        result[name] = value;
      return result;
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/videoRecorder.js
var require_videoRecorder = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/videoRecorder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.VideoRecorder = void 0;
    var _utils = require_utils();
    var _page = require_page();
    var _processLauncher = require_processLauncher();
    var _progress = require_progress2();
    var _instrumentation = require_instrumentation();
    var fps = 25;
    var VideoRecorder = class {
      static launch(page, ffmpegPath, options) {
        return __async(this, null, function* () {
          if (!options.outputFile.endsWith(".webm"))
            throw new Error("File must have .webm extension");
          const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), page);
          controller.setLogName("browser");
          return yield controller.run((progress) => __async(this, null, function* () {
            const recorder = new VideoRecorder(page, ffmpegPath, progress);
            yield recorder._launch(options);
            return recorder;
          }));
        });
      }
      constructor(page, ffmpegPath, progress) {
        this._process = null;
        this._gracefullyClose = null;
        this._lastWritePromise = Promise.resolve();
        this._lastFrameTimestamp = 0;
        this._lastFrameBuffer = null;
        this._lastWriteTimestamp = 0;
        this._progress = void 0;
        this._frameQueue = [];
        this._isStopped = false;
        this._ffmpegPath = void 0;
        this._progress = progress;
        this._ffmpegPath = ffmpegPath;
        page.on(_page.Page.Events.ScreencastFrame, (frame) => this.writeFrame(frame.buffer, frame.timestamp));
      }
      _launch(options) {
        return __async(this, null, function* () {
          const w = options.width;
          const h = options.height;
          const args = `-loglevel error -f image2pipe -avioflags direct -fpsprobesize 0 -probesize 32 -analyzeduration 0 -c:v mjpeg -i - -y -an -r ${fps} -c:v vp8 -qmin 0 -qmax 50 -crf 8 -deadline realtime -speed 8 -b:v 1M -threads 1 -vf pad=${w}:${h}:0:0:gray,crop=${w}:${h}:0:0`.split(" ");
          args.push(options.outputFile);
          const progress = this._progress;
          const {
            launchedProcess,
            gracefullyClose
          } = yield (0, _processLauncher.launchProcess)({
            command: this._ffmpegPath,
            args,
            stdio: "stdin",
            log: (message) => progress.log(message),
            tempDirectories: [],
            attemptToGracefullyClose: () => __async(this, null, function* () {
              progress.log("Closing stdin...");
              launchedProcess.stdin.end();
            }),
            onExit: (exitCode, signal) => {
              progress.log(`ffmpeg onkill exitCode=${exitCode} signal=${signal}`);
            }
          });
          launchedProcess.stdin.on("finish", () => {
            progress.log("ffmpeg finished input.");
          });
          launchedProcess.stdin.on("error", () => {
            progress.log("ffmpeg error.");
          });
          this._process = launchedProcess;
          this._gracefullyClose = gracefullyClose;
        });
      }
      writeFrame(frame, timestamp) {
        (0, _utils.assert)(this._process);
        if (this._isStopped)
          return;
        this._progress.log(`writing frame ` + timestamp);
        if (this._lastFrameBuffer) {
          const durationSec = timestamp - this._lastFrameTimestamp;
          const repeatCount = Math.max(1, Math.round(fps * durationSec));
          for (let i = 0; i < repeatCount; ++i)
            this._frameQueue.push(this._lastFrameBuffer);
          this._lastWritePromise = this._lastWritePromise.then(() => this._sendFrames());
        }
        this._lastFrameBuffer = frame;
        this._lastFrameTimestamp = timestamp;
        this._lastWriteTimestamp = (0, _utils.monotonicTime)();
      }
      _sendFrames() {
        return __async(this, null, function* () {
          while (this._frameQueue.length)
            yield this._sendFrame(this._frameQueue.shift());
        });
      }
      _sendFrame(frame) {
        return __async(this, null, function* () {
          return new Promise((f) => this._process.stdin.write(frame, f)).then((error) => {
            if (error)
              this._progress.log(`ffmpeg failed to write: ${error}`);
          });
        });
      }
      stop() {
        return __async(this, null, function* () {
          if (this._isStopped)
            return;
          this.writeFrame(Buffer.from([]), this._lastFrameTimestamp + ((0, _utils.monotonicTime)() - this._lastWriteTimestamp) / 1e3);
          this._isStopped = true;
          yield this._lastWritePromise;
          yield this._gracefullyClose();
        });
      }
    };
    exports2.VideoRecorder = VideoRecorder;
  }
});

// node_modules/playwright-core/lib/server/chromium/crPage.js
var require_crPage = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crPage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRPage = void 0;
    var _path = _interopRequireDefault(require("path"));
    var _eventsHelper = require_eventsHelper();
    var _registry = require_registry();
    var _stackTrace = require_stackTrace();
    var _utils = require_utils();
    var dialog = _interopRequireWildcard(require_dialog());
    var dom = _interopRequireWildcard(require_dom());
    var _helper = require_helper();
    var network = _interopRequireWildcard(require_network());
    var _page = require_page();
    var _crAccessibility = require_crAccessibility();
    var _crBrowser = require_crBrowser();
    var _crConnection = require_crConnection();
    var _crCoverage = require_crCoverage();
    var _crDragDrop = require_crDragDrop();
    var _crExecutionContext = require_crExecutionContext();
    var _crInput = require_crInput();
    var _crNetworkManager = require_crNetworkManager();
    var _crPdf = require_crPdf();
    var _crProtocolHelper = require_crProtocolHelper();
    var _defaultFontFamilies = require_defaultFontFamilies();
    var _videoRecorder = require_videoRecorder();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var UTILITY_WORLD_NAME = "__playwright_utility_world__";
    var CRPage = class {
      static mainFrameSession(page) {
        const crPage = page._delegate;
        return crPage._mainFrameSession;
      }
      constructor(client, targetId, browserContext, opener, bits) {
        this._mainFrameSession = void 0;
        this._sessions = /* @__PURE__ */ new Map();
        this._page = void 0;
        this.rawMouse = void 0;
        this.rawKeyboard = void 0;
        this.rawTouchscreen = void 0;
        this._targetId = void 0;
        this._opener = void 0;
        this._pdf = void 0;
        this._coverage = void 0;
        this._browserContext = void 0;
        this._pagePromise = void 0;
        this._initializedPage = null;
        this._isBackgroundPage = void 0;
        this._nextWindowOpenPopupFeatures = [];
        this._targetId = targetId;
        this._opener = opener;
        this._isBackgroundPage = bits.isBackgroundPage;
        const dragManager = new _crDragDrop.DragManager(this);
        this.rawKeyboard = new _crInput.RawKeyboardImpl(client, browserContext._browser._platform() === "mac", dragManager);
        this.rawMouse = new _crInput.RawMouseImpl(this, client, dragManager);
        this.rawTouchscreen = new _crInput.RawTouchscreenImpl(client);
        this._pdf = new _crPdf.CRPDF(client);
        this._coverage = new _crCoverage.CRCoverage(client);
        this._browserContext = browserContext;
        this._page = new _page.Page(this, browserContext);
        this._mainFrameSession = new FrameSession(this, client, targetId, null);
        this._sessions.set(targetId, this._mainFrameSession);
        client.once(_crConnection.CRSessionEvents.Disconnected, () => this._page._didDisconnect());
        if (opener && !browserContext._options.noDefaultViewport) {
          const features = opener._nextWindowOpenPopupFeatures.shift() || [];
          const viewportSize = _helper.helper.getViewportSizeFromWindowFeatures(features);
          if (viewportSize)
            this._page._state.emulatedSize = {
              viewport: viewportSize,
              screen: viewportSize
            };
        }
        this._pagePromise = this._mainFrameSession._initialize(bits.hasUIWindow).then((r) => __async(this, null, function* () {
          yield this._page.initOpener(this._opener);
          return r;
        })).catch((e) => __async(this, null, function* () {
          yield this._page.initOpener(this._opener);
          throw e;
        })).then(() => {
          this._initializedPage = this._page;
          this._reportAsNew();
          return this._page;
        }).catch((e) => {
          this._reportAsNew(e);
          return e;
        });
      }
      potentiallyUninitializedPage() {
        return this._page;
      }
      _reportAsNew(error) {
        if (this._isBackgroundPage) {
          if (!error)
            this._browserContext.emit(_crBrowser.CRBrowserContext.CREvents.BackgroundPage, this._page);
        } else {
          this._page.reportAsNew(error);
        }
      }
      _forAllFrameSessions(cb) {
        return __async(this, null, function* () {
          const frameSessions = Array.from(this._sessions.values());
          yield Promise.all(frameSessions.map((frameSession) => {
            if (frameSession._isMainFrame())
              return cb(frameSession);
            return cb(frameSession).catch((e) => {
              if (e.message && (e.message.includes("Target closed.") || e.message.includes("Session closed.")))
                return;
              throw e;
            });
          }));
        });
      }
      _sessionForFrame(frame) {
        while (!this._sessions.has(frame._id)) {
          const parent = frame.parentFrame();
          if (!parent)
            throw new Error(`Frame has been detached.`);
          frame = parent;
        }
        return this._sessions.get(frame._id);
      }
      _sessionForHandle(handle) {
        const frame = handle._context.frame;
        return this._sessionForFrame(frame);
      }
      willBeginDownload() {
        this._mainFrameSession._willBeginDownload();
      }
      pageOrError() {
        return __async(this, null, function* () {
          return this._pagePromise;
        });
      }
      didClose() {
        for (const session of this._sessions.values())
          session.dispose();
        this._page._didClose();
      }
      navigateFrame(frame, url, referrer) {
        return __async(this, null, function* () {
          return this._sessionForFrame(frame)._navigate(frame, url, referrer);
        });
      }
      exposeBinding(binding) {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._initBinding(binding));
          yield Promise.all(this._page.frames().map((frame) => frame.evaluateExpression(binding.source, false, {}).catch((e) => {
          })));
        });
      }
      removeExposedBindings() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._removeExposedBindings());
        });
      }
      updateExtraHTTPHeaders() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateExtraHTTPHeaders(false));
        });
      }
      updateGeolocation() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateGeolocation(false));
        });
      }
      updateOffline() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateOffline(false));
        });
      }
      updateHttpCredentials() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateHttpCredentials(false));
        });
      }
      setEmulatedSize(emulatedSize) {
        return __async(this, null, function* () {
          (0, _utils.assert)(this._page._state.emulatedSize === emulatedSize);
          yield this._mainFrameSession._updateViewport();
        });
      }
      bringToFront() {
        return __async(this, null, function* () {
          yield this._mainFrameSession._client.send("Page.bringToFront");
        });
      }
      updateEmulateMedia() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateEmulateMedia(false));
        });
      }
      updateRequestInterception() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._updateRequestInterception());
        });
      }
      setFileChooserIntercepted(enabled) {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame.setFileChooserIntercepted(enabled));
        });
      }
      reload() {
        return __async(this, null, function* () {
          yield this._mainFrameSession._client.send("Page.reload");
        });
      }
      _go(delta) {
        return __async(this, null, function* () {
          const history = yield this._mainFrameSession._client.send("Page.getNavigationHistory");
          const entry = history.entries[history.currentIndex + delta];
          if (!entry)
            return false;
          yield this._mainFrameSession._client.send("Page.navigateToHistoryEntry", {
            entryId: entry.id
          });
          return true;
        });
      }
      goBack() {
        return this._go(-1);
      }
      goForward() {
        return this._go(1);
      }
      addInitScript(source, world = "main") {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._evaluateOnNewDocument(source, world));
        });
      }
      removeInitScripts() {
        return __async(this, null, function* () {
          yield this._forAllFrameSessions((frame) => frame._removeEvaluatesOnNewDocument());
        });
      }
      closePage(runBeforeUnload) {
        return __async(this, null, function* () {
          if (runBeforeUnload)
            yield this._mainFrameSession._client.send("Page.close");
          else
            yield this._browserContext._browser._closePage(this);
        });
      }
      setBackgroundColor(color) {
        return __async(this, null, function* () {
          yield this._mainFrameSession._client.send("Emulation.setDefaultBackgroundColorOverride", {
            color
          });
        });
      }
      takeScreenshot(progress, format, documentRect, viewportRect, quality, fitsViewport, scale) {
        return __async(this, null, function* () {
          const {
            visualViewport
          } = yield this._mainFrameSession._client.send("Page.getLayoutMetrics");
          if (!documentRect) {
            documentRect = __spreadValues({
              x: visualViewport.pageX + viewportRect.x,
              y: visualViewport.pageY + viewportRect.y
            }, _helper.helper.enclosingIntSize({
              width: viewportRect.width / visualViewport.scale,
              height: viewportRect.height / visualViewport.scale
            }));
          }
          const clip = __spreadProps(__spreadValues({}, documentRect), {
            scale: viewportRect ? visualViewport.scale : 1
          });
          if (scale === "css") {
            const deviceScaleFactor = this._browserContext._options.deviceScaleFactor || 1;
            clip.scale /= deviceScaleFactor;
          }
          progress.throwIfAborted();
          const result = yield this._mainFrameSession._client.send("Page.captureScreenshot", {
            format,
            quality,
            clip,
            captureBeyondViewport: !fitsViewport
          });
          return Buffer.from(result.data, "base64");
        });
      }
      getContentFrame(handle) {
        return __async(this, null, function* () {
          return this._sessionForHandle(handle)._getContentFrame(handle);
        });
      }
      getOwnerFrame(handle) {
        return __async(this, null, function* () {
          return this._sessionForHandle(handle)._getOwnerFrame(handle);
        });
      }
      isElementHandle(remoteObject) {
        return remoteObject.subtype === "node";
      }
      getBoundingBox(handle) {
        return __async(this, null, function* () {
          return this._sessionForHandle(handle)._getBoundingBox(handle);
        });
      }
      scrollRectIntoViewIfNeeded(handle, rect) {
        return __async(this, null, function* () {
          return this._sessionForHandle(handle)._scrollRectIntoViewIfNeeded(handle, rect);
        });
      }
      setScreencastOptions(options) {
        return __async(this, null, function* () {
          if (options) {
            yield this._mainFrameSession._startScreencast(this, {
              format: "jpeg",
              quality: options.quality,
              maxWidth: options.width,
              maxHeight: options.height
            });
          } else {
            yield this._mainFrameSession._stopScreencast(this);
          }
        });
      }
      rafCountForStablePosition() {
        return 1;
      }
      getContentQuads(handle) {
        return __async(this, null, function* () {
          return this._sessionForHandle(handle)._getContentQuads(handle);
        });
      }
      setInputFiles(handle, files) {
        return __async(this, null, function* () {
          yield handle.evaluateInUtility(([injected, node, files2]) => injected.setInputFiles(node, files2), files);
        });
      }
      setInputFilePaths(handle, files) {
        return __async(this, null, function* () {
          const frame = yield handle.ownerFrame();
          if (!frame)
            throw new Error("Cannot set input files to detached input element");
          const parentSession = this._sessionForFrame(frame);
          yield parentSession._client.send("DOM.setFileInputFiles", {
            objectId: handle._objectId,
            files
          });
        });
      }
      adoptElementHandle(handle, to) {
        return __async(this, null, function* () {
          return this._sessionForHandle(handle)._adoptElementHandle(handle, to);
        });
      }
      getAccessibilityTree(needle) {
        return __async(this, null, function* () {
          return (0, _crAccessibility.getAccessibilityTree)(this._mainFrameSession._client, needle);
        });
      }
      inputActionEpilogue() {
        return __async(this, null, function* () {
          yield this._mainFrameSession._client.send("Page.enable").catch((e) => {
          });
        });
      }
      pdf(options) {
        return __async(this, null, function* () {
          return this._pdf.generate(options);
        });
      }
      coverage() {
        return this._coverage;
      }
      getFrameElement(frame) {
        return __async(this, null, function* () {
          let parent = frame.parentFrame();
          if (!parent)
            throw new Error("Frame has been detached.");
          const parentSession = this._sessionForFrame(parent);
          const {
            backendNodeId
          } = yield parentSession._client.send("DOM.getFrameOwner", {
            frameId: frame._id
          }).catch((e) => {
            if (e instanceof Error && e.message.includes("Frame with the given id was not found."))
              (0, _stackTrace.rewriteErrorMessage)(e, "Frame has been detached.");
            throw e;
          });
          parent = frame.parentFrame();
          if (!parent)
            throw new Error("Frame has been detached.");
          return parentSession._adoptBackendNodeId(backendNodeId, yield parent._mainContext());
        });
      }
    };
    exports2.CRPage = CRPage;
    var FrameSession = class {
      constructor(crPage, client, targetId, parentSession) {
        this._client = void 0;
        this._crPage = void 0;
        this._page = void 0;
        this._networkManager = void 0;
        this._contextIdToContext = /* @__PURE__ */ new Map();
        this._eventListeners = [];
        this._targetId = void 0;
        this._firstNonInitialNavigationCommittedPromise = void 0;
        this._firstNonInitialNavigationCommittedFulfill = () => {
        };
        this._firstNonInitialNavigationCommittedReject = (e) => {
        };
        this._windowId = void 0;
        this._swappedIn = false;
        this._videoRecorder = null;
        this._screencastId = null;
        this._screencastClients = /* @__PURE__ */ new Set();
        this._evaluateOnNewDocumentIdentifiers = [];
        this._exposedBindingNames = [];
        this._client = client;
        this._crPage = crPage;
        this._page = crPage._page;
        this._targetId = targetId;
        this._networkManager = new _crNetworkManager.CRNetworkManager(client, this._page, parentSession ? parentSession._networkManager : null);
        this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {
          this._firstNonInitialNavigationCommittedFulfill = f;
          this._firstNonInitialNavigationCommittedReject = r;
        });
        client.once(_crConnection.CRSessionEvents.Disconnected, () => {
          this._firstNonInitialNavigationCommittedReject(new Error("Page closed"));
        });
      }
      _isMainFrame() {
        return this._targetId === this._crPage._targetId;
      }
      _addRendererListeners() {
        this._eventListeners.push(...[_eventsHelper.eventsHelper.addEventListener(this._client, "Log.entryAdded", (event) => this._onLogEntryAdded(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.fileChooserOpened", (event) => this._onFileChooserOpened(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameAttached", (event) => this._onFrameAttached(event.frameId, event.parentFrameId)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameDetached", (event) => this._onFrameDetached(event.frameId, event.reason)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameNavigated", (event) => this._onFrameNavigated(event.frame, false)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameRequestedNavigation", (event) => this._onFrameRequestedNavigation(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.frameStoppedLoading", (event) => this._onFrameStoppedLoading(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.javascriptDialogOpening", (event) => this._onDialog(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.navigatedWithinDocument", (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.bindingCalled", (event) => this._onBindingCalled(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.consoleAPICalled", (event) => this._onConsoleAPI(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.exceptionThrown", (exception) => this._handleException(exception.exceptionDetails)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextCreated", (event) => this._onExecutionContextCreated(event.context)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextDestroyed", (event) => this._onExecutionContextDestroyed(event.executionContextId)), _eventsHelper.eventsHelper.addEventListener(this._client, "Runtime.executionContextsCleared", (event) => this._onExecutionContextsCleared()), _eventsHelper.eventsHelper.addEventListener(this._client, "Target.attachedToTarget", (event) => this._onAttachedToTarget(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Target.detachedFromTarget", (event) => this._onDetachedFromTarget(event))]);
      }
      _addBrowserListeners() {
        this._eventListeners.push(...[_eventsHelper.eventsHelper.addEventListener(this._client, "Inspector.targetCrashed", (event) => this._onTargetCrashed()), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.screencastFrame", (event) => this._onScreencastFrame(event)), _eventsHelper.eventsHelper.addEventListener(this._client, "Page.windowOpen", (event) => this._onWindowOpen(event))]);
      }
      _initialize(hasUIWindow) {
        return __async(this, null, function* () {
          const isSettingStorageState = this._page._browserContext.isSettingStorageState();
          if (!isSettingStorageState && hasUIWindow && !this._crPage._browserContext._browser.isClank() && !this._crPage._browserContext._options.noDefaultViewport) {
            const {
              windowId
            } = yield this._client.send("Browser.getWindowForTarget");
            this._windowId = windowId;
          }
          let screencastOptions;
          if (!isSettingStorageState && this._isMainFrame() && this._crPage._browserContext._options.recordVideo && hasUIWindow) {
            const screencastId = (0, _utils.createGuid)();
            const outputFile = _path.default.join(this._crPage._browserContext._options.recordVideo.dir, screencastId + ".webm");
            screencastOptions = __spreadProps(__spreadValues({}, this._crPage._browserContext._options.recordVideo.size), {
              outputFile
            });
            yield this._crPage._browserContext._ensureVideosPath();
            yield this._createVideoRecorder(screencastId, screencastOptions);
            this._crPage.pageOrError().then((p) => {
              if (p instanceof Error)
                this._stopVideoRecording().catch(() => {
                });
            });
          }
          let lifecycleEventsEnabled;
          if (!this._isMainFrame())
            this._addRendererListeners();
          this._addBrowserListeners();
          const promises = [this._client.send("Page.enable"), this._client.send("Page.getFrameTree").then(({
            frameTree
          }) => {
            if (this._isMainFrame()) {
              this._handleFrameTree(frameTree);
              this._addRendererListeners();
            }
            const localFrames = this._isMainFrame() ? this._page.frames() : [this._page._frameManager.frame(this._targetId)];
            for (const frame of localFrames) {
              this._client._sendMayFail("Page.createIsolatedWorld", {
                frameId: frame._id,
                grantUniveralAccess: true,
                worldName: UTILITY_WORLD_NAME
              });
              for (const binding of this._crPage._browserContext._pageBindings.values())
                frame.evaluateExpression(binding.source, false, void 0).catch((e) => {
                });
              for (const source of this._crPage._browserContext.initScripts)
                frame.evaluateExpression(source, false, void 0, "main").catch((e) => {
                });
            }
            const isInitialEmptyPage = this._isMainFrame() && this._page.mainFrame().url() === ":";
            if (isInitialEmptyPage) {
              lifecycleEventsEnabled.catch((e) => {
              }).then(() => {
                this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._client, "Page.lifecycleEvent", (event) => this._onLifecycleEvent(event)));
              });
            } else {
              this._firstNonInitialNavigationCommittedFulfill();
              this._eventListeners.push(_eventsHelper.eventsHelper.addEventListener(this._client, "Page.lifecycleEvent", (event) => this._onLifecycleEvent(event)));
            }
          }), this._client.send("Log.enable", {}), lifecycleEventsEnabled = this._client.send("Page.setLifecycleEventsEnabled", {
            enabled: true
          }), this._client.send("Runtime.enable", {}), this._client.send("Page.addScriptToEvaluateOnNewDocument", {
            source: "",
            worldName: UTILITY_WORLD_NAME
          }), this._networkManager.initialize(), this._client.send("Target.setAutoAttach", {
            autoAttach: true,
            waitForDebuggerOnStart: true,
            flatten: true
          })];
          if (!isSettingStorageState) {
            if (this._isMainFrame())
              promises.push(this._client.send("Emulation.setFocusEmulationEnabled", {
                enabled: true
              }));
            const options = this._crPage._browserContext._options;
            if (options.bypassCSP)
              promises.push(this._client.send("Page.setBypassCSP", {
                enabled: true
              }));
            if (options.ignoreHTTPSErrors)
              promises.push(this._client.send("Security.setIgnoreCertificateErrors", {
                ignore: true
              }));
            if (this._isMainFrame())
              promises.push(this._updateViewport());
            if (options.hasTouch)
              promises.push(this._client.send("Emulation.setTouchEmulationEnabled", {
                enabled: true
              }));
            if (options.javaScriptEnabled === false)
              promises.push(this._client.send("Emulation.setScriptExecutionDisabled", {
                value: true
              }));
            if (options.userAgent || options.locale)
              promises.push(this._client.send("Emulation.setUserAgentOverride", {
                userAgent: options.userAgent || "",
                acceptLanguage: options.locale
              }));
            if (options.locale)
              promises.push(emulateLocale(this._client, options.locale));
            if (options.timezoneId)
              promises.push(emulateTimezone(this._client, options.timezoneId));
            if (!this._crPage._browserContext._browser.options.headful)
              promises.push(this._setDefaultFontFamilies(this._client));
            promises.push(this._updateGeolocation(true));
            promises.push(this._updateExtraHTTPHeaders(true));
            promises.push(this._updateRequestInterception());
            promises.push(this._updateOffline(true));
            promises.push(this._updateHttpCredentials(true));
            promises.push(this._updateEmulateMedia(true));
            for (const binding of this._crPage._page.allBindings())
              promises.push(this._initBinding(binding));
            for (const source of this._crPage._browserContext.initScripts)
              promises.push(this._evaluateOnNewDocument(source, "main"));
            for (const source of this._crPage._page.initScripts)
              promises.push(this._evaluateOnNewDocument(source, "main"));
            if (screencastOptions)
              promises.push(this._startVideoRecording(screencastOptions));
          }
          promises.push(this._client.send("Runtime.runIfWaitingForDebugger"));
          promises.push(this._firstNonInitialNavigationCommittedPromise);
          yield Promise.all(promises);
        });
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        this._networkManager.dispose();
        this._crPage._sessions.delete(this._targetId);
      }
      _navigate(frame, url, referrer) {
        return __async(this, null, function* () {
          const response = yield this._client.send("Page.navigate", {
            url,
            referrer,
            frameId: frame._id
          });
          if (response.errorText)
            throw new Error(`${response.errorText} at ${url}`);
          return {
            newDocumentId: response.loaderId
          };
        });
      }
      _onLifecycleEvent(event) {
        if (this._eventBelongsToStaleFrame(event.frameId))
          return;
        if (event.name === "load")
          this._page._frameManager.frameLifecycleEvent(event.frameId, "load");
        else if (event.name === "DOMContentLoaded")
          this._page._frameManager.frameLifecycleEvent(event.frameId, "domcontentloaded");
      }
      _onFrameStoppedLoading(frameId) {
        if (this._eventBelongsToStaleFrame(frameId))
          return;
        this._page._frameManager.frameStoppedLoading(frameId);
      }
      _handleFrameTree(frameTree) {
        this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
        this._onFrameNavigated(frameTree.frame, true);
        if (!frameTree.childFrames)
          return;
        for (const child of frameTree.childFrames)
          this._handleFrameTree(child);
      }
      _eventBelongsToStaleFrame(frameId) {
        const frame = this._page._frameManager.frame(frameId);
        if (!frame)
          return true;
        const session = this._crPage._sessionForFrame(frame);
        return session && session !== this && !session._swappedIn;
      }
      _onFrameAttached(frameId, parentFrameId) {
        const frameSession = this._crPage._sessions.get(frameId);
        if (frameSession && frameId !== this._targetId) {
          frameSession._swappedIn = true;
          const frame = this._page._frameManager.frame(frameId);
          if (frame)
            this._page._frameManager.removeChildFramesRecursively(frame);
          return;
        }
        if (parentFrameId && !this._page._frameManager.frame(parentFrameId)) {
          return;
        }
        this._page._frameManager.frameAttached(frameId, parentFrameId);
      }
      _onFrameNavigated(framePayload, initial) {
        if (this._eventBelongsToStaleFrame(framePayload.id))
          return;
        this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url + (framePayload.urlFragment || ""), framePayload.name || "", framePayload.loaderId, initial);
        if (!initial)
          this._firstNonInitialNavigationCommittedFulfill();
      }
      _onFrameRequestedNavigation(payload) {
        if (this._eventBelongsToStaleFrame(payload.frameId))
          return;
        if (payload.disposition === "currentTab")
          this._page._frameManager.frameRequestedNavigation(payload.frameId);
      }
      _onFrameNavigatedWithinDocument(frameId, url) {
        if (this._eventBelongsToStaleFrame(frameId))
          return;
        this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);
      }
      _onFrameDetached(frameId, reason) {
        if (this._crPage._sessions.has(frameId)) {
          return;
        }
        if (reason === "swap") {
          const frame = this._page._frameManager.frame(frameId);
          if (frame)
            this._page._frameManager.removeChildFramesRecursively(frame);
          return;
        }
        this._page._frameManager.frameDetached(frameId);
      }
      _onExecutionContextCreated(contextPayload) {
        const frame = contextPayload.auxData ? this._page._frameManager.frame(contextPayload.auxData.frameId) : null;
        if (!frame || this._eventBelongsToStaleFrame(frame._id))
          return;
        const delegate = new _crExecutionContext.CRExecutionContext(this._client, contextPayload);
        let worldName = null;
        if (contextPayload.auxData && !!contextPayload.auxData.isDefault)
          worldName = "main";
        else if (contextPayload.name === UTILITY_WORLD_NAME)
          worldName = "utility";
        const context = new dom.FrameExecutionContext(delegate, frame, worldName);
        context[contextDelegateSymbol] = delegate;
        if (worldName)
          frame._contextCreated(worldName, context);
        this._contextIdToContext.set(contextPayload.id, context);
      }
      _onExecutionContextDestroyed(executionContextId) {
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
          return;
        this._contextIdToContext.delete(executionContextId);
        context.frame._contextDestroyed(context);
      }
      _onExecutionContextsCleared() {
        for (const contextId of Array.from(this._contextIdToContext.keys()))
          this._onExecutionContextDestroyed(contextId);
      }
      _onAttachedToTarget(event) {
        const session = _crConnection.CRConnection.fromSession(this._client).session(event.sessionId);
        if (event.targetInfo.type === "iframe") {
          const targetId = event.targetInfo.targetId;
          const frame = this._page._frameManager.frame(targetId);
          if (!frame)
            return;
          this._page._frameManager.removeChildFramesRecursively(frame);
          const frameSession = new FrameSession(this._crPage, session, targetId, this);
          this._crPage._sessions.set(targetId, frameSession);
          frameSession._initialize(false).catch((e) => e);
          return;
        }
        if (event.targetInfo.type !== "worker") {
          session._sendMayFail("Runtime.runIfWaitingForDebugger").then(() => {
            this._client._sendMayFail("Target.detachFromTarget", {
              sessionId: event.sessionId
            });
          });
          return;
        }
        const url = event.targetInfo.url;
        const worker = new _page.Worker(this._page, url);
        this._page._addWorker(event.sessionId, worker);
        session.once("Runtime.executionContextCreated", (event2) => __async(this, null, function* () {
          worker._createExecutionContext(new _crExecutionContext.CRExecutionContext(session, event2.context));
        }));
        session._sendMayFail("Runtime.enable");
        session._sendMayFail("Network.enable");
        session._sendMayFail("Runtime.runIfWaitingForDebugger");
        session.on("Runtime.consoleAPICalled", (event2) => {
          const args = event2.args.map((o) => worker._existingExecutionContext.createHandle(o));
          this._page._addConsoleMessage(event2.type, args, (0, _crProtocolHelper.toConsoleMessageLocation)(event2.stackTrace));
        });
        session.on("Runtime.exceptionThrown", (exception) => this._page.emit(_page.Page.Events.PageError, (0, _crProtocolHelper.exceptionToError)(exception.exceptionDetails)));
        this._networkManager.instrumentNetworkEvents(session, this._page._frameManager.frame(this._targetId));
      }
      _onDetachedFromTarget(event) {
        this._page._removeWorker(event.sessionId);
        const childFrameSession = this._crPage._sessions.get(event.targetId);
        if (!childFrameSession)
          return;
        if (childFrameSession._swappedIn) {
          childFrameSession.dispose();
          return;
        }
        this._client.send("Page.enable").catch((e) => null).then(() => {
          if (!childFrameSession._swappedIn)
            this._page._frameManager.frameDetached(event.targetId);
          childFrameSession.dispose();
        });
      }
      _onWindowOpen(event) {
        this._crPage._nextWindowOpenPopupFeatures.push(event.windowFeatures);
      }
      _onConsoleAPI(event) {
        return __async(this, null, function* () {
          if (event.executionContextId === 0) {
            return;
          }
          const context = this._contextIdToContext.get(event.executionContextId);
          if (!context)
            return;
          const values = event.args.map((arg) => context.createHandle(arg));
          this._page._addConsoleMessage(event.type, values, (0, _crProtocolHelper.toConsoleMessageLocation)(event.stackTrace));
        });
      }
      _initBinding(binding) {
        return __async(this, null, function* () {
          const [, response] = yield Promise.all([this._client.send("Runtime.addBinding", {
            name: binding.name
          }), this._client.send("Page.addScriptToEvaluateOnNewDocument", {
            source: binding.source
          })]);
          this._exposedBindingNames.push(binding.name);
          this._evaluateOnNewDocumentIdentifiers.push(response.identifier);
        });
      }
      _removeExposedBindings() {
        return __async(this, null, function* () {
          const names = this._exposedBindingNames;
          this._exposedBindingNames = [];
          yield Promise.all(names.map((name) => this._client.send("Runtime.removeBinding", {
            name
          })));
        });
      }
      _onBindingCalled(event) {
        return __async(this, null, function* () {
          const pageOrError = yield this._crPage.pageOrError();
          if (!(pageOrError instanceof Error)) {
            const context = this._contextIdToContext.get(event.executionContextId);
            if (context)
              yield this._page._onBindingCalled(event.payload, context);
          }
        });
      }
      _onDialog(event) {
        if (!this._page._frameManager.frame(this._targetId))
          return;
        this._page.emit(_page.Page.Events.Dialog, new dialog.Dialog(this._page, event.type, event.message, (accept, promptText) => __async(this, null, function* () {
          yield this._client.send("Page.handleJavaScriptDialog", {
            accept,
            promptText
          });
        }), event.defaultPrompt));
      }
      _handleException(exceptionDetails) {
        this._page.firePageError((0, _crProtocolHelper.exceptionToError)(exceptionDetails));
      }
      _onTargetCrashed() {
        return __async(this, null, function* () {
          this._client._markAsCrashed();
          this._page._didCrash();
        });
      }
      _onLogEntryAdded(event) {
        const {
          level,
          text,
          args,
          source,
          url,
          lineNumber
        } = event.entry;
        if (args)
          args.map((arg) => (0, _crProtocolHelper.releaseObject)(this._client, arg.objectId));
        if (source !== "worker") {
          const location2 = {
            url: url || "",
            lineNumber: lineNumber || 0,
            columnNumber: 0
          };
          this._page._addConsoleMessage(level, [], location2, text);
        }
      }
      _onFileChooserOpened(event) {
        return __async(this, null, function* () {
          const frame = this._page._frameManager.frame(event.frameId);
          if (!frame)
            return;
          let handle;
          try {
            const utilityContext = yield frame._utilityContext();
            handle = yield this._adoptBackendNodeId(event.backendNodeId, utilityContext);
          } catch (e) {
            return;
          }
          yield this._page._onFileChooserOpened(handle);
        });
      }
      _willBeginDownload() {
        const originPage = this._crPage._initializedPage;
        if (!originPage) {
          this._firstNonInitialNavigationCommittedReject(new Error("Starting new page download"));
        }
      }
      _onScreencastFrame(payload) {
        this._page.throttleScreencastFrameAck(() => {
          this._client.send("Page.screencastFrameAck", {
            sessionId: payload.sessionId
          }).catch(() => {
          });
        });
        const buffer = Buffer.from(payload.data, "base64");
        this._page.emit(_page.Page.Events.ScreencastFrame, {
          buffer,
          timestamp: payload.metadata.timestamp,
          width: payload.metadata.deviceWidth,
          height: payload.metadata.deviceHeight
        });
      }
      _createVideoRecorder(screencastId, options) {
        return __async(this, null, function* () {
          (0, _utils.assert)(!this._screencastId);
          const ffmpegPath = _registry.registry.findExecutable("ffmpeg").executablePathOrDie(this._page._browserContext._browser.options.sdkLanguage);
          this._videoRecorder = yield _videoRecorder.VideoRecorder.launch(this._crPage._page, ffmpegPath, options);
          this._screencastId = screencastId;
        });
      }
      _startVideoRecording(options) {
        return __async(this, null, function* () {
          const screencastId = this._screencastId;
          (0, _utils.assert)(screencastId);
          this._page.once(_page.Page.Events.Close, () => this._stopVideoRecording().catch(() => {
          }));
          const gotFirstFrame = new Promise((f) => this._client.once("Page.screencastFrame", f));
          yield this._startScreencast(this._videoRecorder, {
            format: "jpeg",
            quality: 90,
            maxWidth: options.width,
            maxHeight: options.height
          });
          gotFirstFrame.then(() => {
            this._crPage._browserContext._browser._videoStarted(this._crPage._browserContext, screencastId, options.outputFile, this._crPage.pageOrError());
          });
        });
      }
      _stopVideoRecording() {
        return __async(this, null, function* () {
          if (!this._screencastId)
            return;
          const screencastId = this._screencastId;
          this._screencastId = null;
          const recorder = this._videoRecorder;
          this._videoRecorder = null;
          yield this._stopScreencast(recorder);
          yield recorder.stop().catch(() => {
          });
          const video = this._crPage._browserContext._browser._takeVideo(screencastId);
          video === null || video === void 0 ? void 0 : video.reportFinished();
        });
      }
      _startScreencast(_0) {
        return __async(this, arguments, function* (client, options = {}) {
          this._screencastClients.add(client);
          if (this._screencastClients.size === 1)
            yield this._client.send("Page.startScreencast", options);
        });
      }
      _stopScreencast(client) {
        return __async(this, null, function* () {
          this._screencastClients.delete(client);
          if (!this._screencastClients.size)
            yield this._client._sendMayFail("Page.stopScreencast");
        });
      }
      _updateExtraHTTPHeaders(initial) {
        return __async(this, null, function* () {
          const headers = network.mergeHeaders([this._crPage._browserContext._options.extraHTTPHeaders, this._page._state.extraHTTPHeaders]);
          if (!initial || headers.length)
            yield this._client.send("Network.setExtraHTTPHeaders", {
              headers: (0, _utils.headersArrayToObject)(headers, false)
            });
        });
      }
      _updateGeolocation(initial) {
        return __async(this, null, function* () {
          const geolocation = this._crPage._browserContext._options.geolocation;
          if (!initial || geolocation)
            yield this._client.send("Emulation.setGeolocationOverride", geolocation || {});
        });
      }
      _updateOffline(initial) {
        return __async(this, null, function* () {
          const offline = !!this._crPage._browserContext._options.offline;
          if (!initial || offline)
            yield this._networkManager.setOffline(offline);
        });
      }
      _updateHttpCredentials(initial) {
        return __async(this, null, function* () {
          const credentials = this._crPage._browserContext._options.httpCredentials || null;
          if (!initial || credentials)
            yield this._networkManager.authenticate(credentials);
        });
      }
      _updateViewport() {
        return __async(this, null, function* () {
          if (this._crPage._browserContext._browser.isClank())
            return;
          (0, _utils.assert)(this._isMainFrame());
          const options = this._crPage._browserContext._options;
          const emulatedSize = this._page._state.emulatedSize;
          if (emulatedSize === null)
            return;
          const viewportSize = emulatedSize.viewport;
          const screenSize = emulatedSize.screen;
          const isLandscape = viewportSize.width > viewportSize.height;
          const promises = [this._client.send("Emulation.setDeviceMetricsOverride", {
            mobile: !!options.isMobile,
            width: viewportSize.width,
            height: viewportSize.height,
            screenWidth: screenSize.width,
            screenHeight: screenSize.height,
            deviceScaleFactor: options.deviceScaleFactor || 1,
            screenOrientation: isLandscape ? {
              angle: 90,
              type: "landscapePrimary"
            } : {
              angle: 0,
              type: "portraitPrimary"
            }
          })];
          if (this._windowId) {
            let insets = {
              width: 0,
              height: 0
            };
            if (this._crPage._browserContext._browser.options.headful) {
              insets = {
                width: 24,
                height: 88
              };
              if (process.platform === "win32")
                insets = {
                  width: 16,
                  height: 88
                };
              else if (process.platform === "linux")
                insets = {
                  width: 8,
                  height: 85
                };
              else if (process.platform === "darwin")
                insets = {
                  width: 2,
                  height: 80
                };
              if (this._crPage._browserContext.isPersistentContext()) {
                insets.height += 46;
              }
            }
            promises.push(this.setWindowBounds({
              width: viewportSize.width + insets.width,
              height: viewportSize.height + insets.height
            }));
          }
          yield Promise.all(promises);
        });
      }
      windowBounds() {
        return __async(this, null, function* () {
          const {
            bounds
          } = yield this._client.send("Browser.getWindowBounds", {
            windowId: this._windowId
          });
          return bounds;
        });
      }
      setWindowBounds(bounds) {
        return __async(this, null, function* () {
          return yield this._client.send("Browser.setWindowBounds", {
            windowId: this._windowId,
            bounds
          });
        });
      }
      _updateEmulateMedia(initial) {
        return __async(this, null, function* () {
          const colorScheme = this._page._state.colorScheme === null ? "" : this._page._state.colorScheme;
          const reducedMotion = this._page._state.reducedMotion === null ? "" : this._page._state.reducedMotion;
          const forcedColors = this._page._state.forcedColors === null ? "" : this._page._state.forcedColors;
          const features = [{
            name: "prefers-color-scheme",
            value: colorScheme
          }, {
            name: "prefers-reduced-motion",
            value: reducedMotion
          }, {
            name: "forced-colors",
            value: forcedColors
          }];
          yield this._client.send("Emulation.setEmulatedMedia", {
            media: this._page._state.mediaType || "",
            features
          });
        });
      }
      _setDefaultFontFamilies(session) {
        return __async(this, null, function* () {
          const fontFamilies = _defaultFontFamilies.platformToFontFamilies[this._crPage._browserContext._browser._platform()];
          yield session.send("Page.setFontFamilies", fontFamilies);
        });
      }
      _updateRequestInterception() {
        return __async(this, null, function* () {
          yield this._networkManager.setRequestInterception(this._page._needsRequestInterception());
        });
      }
      setFileChooserIntercepted(enabled) {
        return __async(this, null, function* () {
          yield this._client.send("Page.setInterceptFileChooserDialog", {
            enabled
          }).catch((e) => {
          });
        });
      }
      _evaluateOnNewDocument(source, world) {
        return __async(this, null, function* () {
          const worldName = world === "utility" ? UTILITY_WORLD_NAME : void 0;
          const {
            identifier
          } = yield this._client.send("Page.addScriptToEvaluateOnNewDocument", {
            source,
            worldName
          });
          this._evaluateOnNewDocumentIdentifiers.push(identifier);
        });
      }
      _removeEvaluatesOnNewDocument() {
        return __async(this, null, function* () {
          const identifiers = this._evaluateOnNewDocumentIdentifiers;
          this._evaluateOnNewDocumentIdentifiers = [];
          yield Promise.all(identifiers.map((identifier) => this._client.send("Page.removeScriptToEvaluateOnNewDocument", {
            identifier
          })));
        });
      }
      _getContentFrame(handle) {
        return __async(this, null, function* () {
          const nodeInfo = yield this._client.send("DOM.describeNode", {
            objectId: handle._objectId
          });
          if (!nodeInfo || typeof nodeInfo.node.frameId !== "string")
            return null;
          return this._page._frameManager.frame(nodeInfo.node.frameId);
        });
      }
      _getOwnerFrame(handle) {
        return __async(this, null, function* () {
          const documentElement = yield handle.evaluateHandle((node) => {
            const doc = node;
            if (doc.documentElement && doc.documentElement.ownerDocument === doc)
              return doc.documentElement;
            return node.ownerDocument ? node.ownerDocument.documentElement : null;
          });
          if (!documentElement)
            return null;
          if (!documentElement._objectId)
            return null;
          const nodeInfo = yield this._client.send("DOM.describeNode", {
            objectId: documentElement._objectId
          });
          const frameId = nodeInfo && typeof nodeInfo.node.frameId === "string" ? nodeInfo.node.frameId : null;
          documentElement.dispose();
          return frameId;
        });
      }
      _getBoundingBox(handle) {
        return __async(this, null, function* () {
          const result = yield this._client._sendMayFail("DOM.getBoxModel", {
            objectId: handle._objectId
          });
          if (!result)
            return null;
          const quad = result.model.border;
          const x = Math.min(quad[0], quad[2], quad[4], quad[6]);
          const y = Math.min(quad[1], quad[3], quad[5], quad[7]);
          const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;
          const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;
          const position = yield this._framePosition();
          if (!position)
            return null;
          return {
            x: x + position.x,
            y: y + position.y,
            width,
            height
          };
        });
      }
      _framePosition() {
        return __async(this, null, function* () {
          const frame = this._page._frameManager.frame(this._targetId);
          if (!frame)
            return null;
          if (frame === this._page.mainFrame())
            return {
              x: 0,
              y: 0
            };
          const element = yield frame.frameElement();
          const box = yield element.boundingBox();
          return box;
        });
      }
      _scrollRectIntoViewIfNeeded(handle, rect) {
        return __async(this, null, function* () {
          return yield this._client.send("DOM.scrollIntoViewIfNeeded", {
            objectId: handle._objectId,
            rect
          }).then(() => "done").catch((e) => {
            if (e instanceof Error && e.message.includes("Node does not have a layout object"))
              return "error:notvisible";
            if (e instanceof Error && e.message.includes("Node is detached from document"))
              return "error:notconnected";
            throw e;
          });
        });
      }
      _getContentQuads(handle) {
        return __async(this, null, function* () {
          const result = yield this._client._sendMayFail("DOM.getContentQuads", {
            objectId: handle._objectId
          });
          if (!result)
            return null;
          const position = yield this._framePosition();
          if (!position)
            return null;
          return result.quads.map((quad) => [{
            x: quad[0] + position.x,
            y: quad[1] + position.y
          }, {
            x: quad[2] + position.x,
            y: quad[3] + position.y
          }, {
            x: quad[4] + position.x,
            y: quad[5] + position.y
          }, {
            x: quad[6] + position.x,
            y: quad[7] + position.y
          }]);
        });
      }
      _adoptElementHandle(handle, to) {
        return __async(this, null, function* () {
          const nodeInfo = yield this._client.send("DOM.describeNode", {
            objectId: handle._objectId
          });
          return this._adoptBackendNodeId(nodeInfo.node.backendNodeId, to);
        });
      }
      _adoptBackendNodeId(backendNodeId, to) {
        return __async(this, null, function* () {
          const result = yield this._client._sendMayFail("DOM.resolveNode", {
            backendNodeId,
            executionContextId: to[contextDelegateSymbol]._contextId
          });
          if (!result || result.object.subtype === "null")
            throw new Error(dom.kUnableToAdoptErrorMessage);
          return to.createHandle(result.object).asElement();
        });
      }
    };
    function emulateLocale(session, locale) {
      return __async(this, null, function* () {
        try {
          yield session.send("Emulation.setLocaleOverride", {
            locale
          });
        } catch (exception) {
          if (exception.message.includes("Another locale override is already in effect"))
            return;
          throw exception;
        }
      });
    }
    function emulateTimezone(session, timezoneId) {
      return __async(this, null, function* () {
        try {
          yield session.send("Emulation.setTimezoneOverride", {
            timezoneId
          });
        } catch (exception) {
          if (exception.message.includes("Timezone override is already in effect"))
            return;
          if (exception.message.includes("Invalid timezone"))
            throw new Error(`Invalid timezone ID: ${timezoneId}`);
          throw exception;
        }
      });
    }
    var contextDelegateSymbol = Symbol("delegate");
  }
});

// node_modules/playwright-core/lib/server/chromium/crBrowser.js
var require_crBrowser = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crBrowser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRBrowserContext = exports2.CRBrowser = void 0;
    var _browser = require_browser3();
    var _browserContext = require_browserContext();
    var _utils = require_utils();
    var network = _interopRequireWildcard(require_network());
    var _page = require_page();
    var _frames = require_frames();
    var _crConnection = require_crConnection();
    var _crPage = require_crPage();
    var _crProtocolHelper = require_crProtocolHelper();
    var _crExecutionContext = require_crExecutionContext();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var CRBrowser = class extends _browser.Browser {
      static connect(transport, options, devtools) {
        return __async(this, null, function* () {
          options = __spreadValues({}, options);
          const connection = new _crConnection.CRConnection(transport, options.protocolLogger, options.browserLogsCollector);
          const browser = new CRBrowser(connection, options);
          browser._devtools = devtools;
          const session = connection.rootSession;
          if (options.__testHookOnConnectToBrowser)
            yield options.__testHookOnConnectToBrowser();
          const version = yield session.send("Browser.getVersion");
          browser._version = version.product.substring(version.product.indexOf("/") + 1);
          browser._userAgent = version.userAgent;
          browser.options.headful = !version.userAgent.includes("Headless");
          if (!options.persistent) {
            yield session.send("Target.setAutoAttach", {
              autoAttach: true,
              waitForDebuggerOnStart: true,
              flatten: true
            });
            return browser;
          }
          browser._defaultContext = new CRBrowserContext(browser, void 0, options.persistent);
          yield Promise.all([session.send("Target.setAutoAttach", {
            autoAttach: true,
            waitForDebuggerOnStart: true,
            flatten: true
          }).then(() => __async(this, null, function* () {
            yield session.send("Target.getTargetInfo");
          })), browser._defaultContext._initialize()]);
          yield browser._waitForAllPagesToBeInitialized();
          return browser;
        });
      }
      constructor(connection, options) {
        super(options);
        this._connection = void 0;
        this._session = void 0;
        this._clientRootSessionPromise = null;
        this._contexts = /* @__PURE__ */ new Map();
        this._crPages = /* @__PURE__ */ new Map();
        this._backgroundPages = /* @__PURE__ */ new Map();
        this._serviceWorkers = /* @__PURE__ */ new Map();
        this._devtools = void 0;
        this._version = "";
        this._tracingRecording = false;
        this._tracingPath = "";
        this._tracingClient = void 0;
        this._userAgent = "";
        this._connection = connection;
        this._session = this._connection.rootSession;
        this._connection.on(_crConnection.ConnectionEvents.Disconnected, () => this._didClose());
        this._session.on("Target.attachedToTarget", this._onAttachedToTarget.bind(this));
        this._session.on("Target.detachedFromTarget", this._onDetachedFromTarget.bind(this));
        this._session.on("Browser.downloadWillBegin", this._onDownloadWillBegin.bind(this));
        this._session.on("Browser.downloadProgress", this._onDownloadProgress.bind(this));
      }
      doCreateNewContext(options) {
        return __async(this, null, function* () {
          let proxyBypassList = void 0;
          if (options.proxy) {
            if (process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK)
              proxyBypassList = options.proxy.bypass;
            else
              proxyBypassList = "<-loopback>" + (options.proxy.bypass ? `,${options.proxy.bypass}` : "");
          }
          const {
            browserContextId
          } = yield this._session.send("Target.createBrowserContext", {
            disposeOnDetach: true,
            proxyServer: options.proxy ? options.proxy.server : void 0,
            proxyBypassList
          });
          const context = new CRBrowserContext(this, browserContextId, options);
          yield context._initialize();
          this._contexts.set(browserContextId, context);
          return context;
        });
      }
      contexts() {
        return Array.from(this._contexts.values());
      }
      version() {
        return this._version;
      }
      userAgent() {
        return this._userAgent;
      }
      _platform() {
        if (this._userAgent.includes("Windows"))
          return "win";
        if (this._userAgent.includes("Macintosh"))
          return "mac";
        return "linux";
      }
      isClank() {
        return this.options.name === "clank";
      }
      _waitForAllPagesToBeInitialized() {
        return __async(this, null, function* () {
          yield Promise.all([...this._crPages.values()].map((page) => page.pageOrError()));
        });
      }
      _onAttachedToTarget({
        targetInfo,
        sessionId,
        waitingForDebugger
      }) {
        if (targetInfo.type === "browser")
          return;
        const session = this._connection.session(sessionId);
        (0, _utils.assert)(targetInfo.browserContextId, "targetInfo: " + JSON.stringify(targetInfo, null, 2));
        let context = this._contexts.get(targetInfo.browserContextId) || null;
        if (!context) {
          context = this._defaultContext;
        }
        if (targetInfo.type === "other" && targetInfo.url.startsWith("devtools://devtools") && this._devtools) {
          this._devtools.install(session);
          return;
        }
        if (targetInfo.type === "other" || !context) {
          if (waitingForDebugger) {
            session._sendMayFail("Runtime.runIfWaitingForDebugger").then(() => {
              this._session._sendMayFail("Target.detachFromTarget", {
                sessionId
              });
            });
          }
          return;
        }
        (0, _utils.assert)(!this._crPages.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
        (0, _utils.assert)(!this._backgroundPages.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
        (0, _utils.assert)(!this._serviceWorkers.has(targetInfo.targetId), "Duplicate target " + targetInfo.targetId);
        if (targetInfo.type === "background_page") {
          const backgroundPage = new _crPage.CRPage(session, targetInfo.targetId, context, null, {
            hasUIWindow: false,
            isBackgroundPage: true
          });
          this._backgroundPages.set(targetInfo.targetId, backgroundPage);
          return;
        }
        if (targetInfo.type === "page") {
          const opener = targetInfo.openerId ? this._crPages.get(targetInfo.openerId) || null : null;
          const crPage = new _crPage.CRPage(session, targetInfo.targetId, context, opener, {
            hasUIWindow: true,
            isBackgroundPage: false
          });
          this._crPages.set(targetInfo.targetId, crPage);
          return;
        }
        if (targetInfo.type === "service_worker") {
          const serviceWorker = new CRServiceWorker(context, session, targetInfo.url);
          this._serviceWorkers.set(targetInfo.targetId, serviceWorker);
          context.emit(CRBrowserContext.CREvents.ServiceWorker, serviceWorker);
          return;
        }
      }
      _onDetachedFromTarget(payload) {
        const targetId = payload.targetId;
        const crPage = this._crPages.get(targetId);
        if (crPage) {
          this._crPages.delete(targetId);
          crPage.didClose();
          return;
        }
        const backgroundPage = this._backgroundPages.get(targetId);
        if (backgroundPage) {
          this._backgroundPages.delete(targetId);
          backgroundPage.didClose();
          return;
        }
        const serviceWorker = this._serviceWorkers.get(targetId);
        if (serviceWorker) {
          this._serviceWorkers.delete(targetId);
          serviceWorker.didClose();
          return;
        }
      }
      _findOwningPage(frameId) {
        for (const crPage of this._crPages.values()) {
          const frame = crPage._page._frameManager.frame(frameId);
          if (frame)
            return crPage;
        }
        return null;
      }
      _onDownloadWillBegin(payload) {
        const page = this._findOwningPage(payload.frameId);
        (0, _utils.assert)(page, "Download started in unknown page: " + JSON.stringify(payload));
        page.willBeginDownload();
        let originPage = page._initializedPage;
        if (!originPage && page._opener)
          originPage = page._opener._initializedPage;
        if (!originPage)
          return;
        this._downloadCreated(originPage, payload.guid, payload.url, payload.suggestedFilename);
      }
      _onDownloadProgress(payload) {
        if (payload.state === "completed")
          this._downloadFinished(payload.guid, "");
        if (payload.state === "canceled")
          this._downloadFinished(payload.guid, "canceled");
      }
      _closePage(crPage) {
        return __async(this, null, function* () {
          yield this._session.send("Target.closeTarget", {
            targetId: crPage._targetId
          });
        });
      }
      newBrowserCDPSession() {
        return __async(this, null, function* () {
          return yield this._connection.createBrowserSession();
        });
      }
      startTracing(_0) {
        return __async(this, arguments, function* (page, options = {}) {
          (0, _utils.assert)(!this._tracingRecording, "Cannot start recording trace while already recording trace.");
          this._tracingClient = page ? page._delegate._mainFrameSession._client : this._session;
          const defaultCategories = ["-*", "devtools.timeline", "v8.execute", "disabled-by-default-devtools.timeline", "disabled-by-default-devtools.timeline.frame", "toplevel", "blink.console", "blink.user_timing", "latencyInfo", "disabled-by-default-devtools.timeline.stack", "disabled-by-default-v8.cpu_profiler", "disabled-by-default-v8.cpu_profiler.hires"];
          const {
            path = null,
            screenshots = false,
            categories = defaultCategories
          } = options;
          if (screenshots)
            categories.push("disabled-by-default-devtools.screenshot");
          this._tracingPath = path;
          this._tracingRecording = true;
          yield this._tracingClient.send("Tracing.start", {
            transferMode: "ReturnAsStream",
            categories: categories.join(",")
          });
        });
      }
      stopTracing() {
        return __async(this, null, function* () {
          (0, _utils.assert)(this._tracingClient, "Tracing was not started.");
          const [event] = yield Promise.all([new Promise((f) => this._tracingClient.once("Tracing.tracingComplete", f)), this._tracingClient.send("Tracing.end")]);
          const result = yield (0, _crProtocolHelper.readProtocolStream)(this._tracingClient, event.stream, this._tracingPath);
          this._tracingRecording = false;
          return result;
        });
      }
      isConnected() {
        return !this._connection._closed;
      }
      _clientRootSession() {
        return __async(this, null, function* () {
          if (!this._clientRootSessionPromise)
            this._clientRootSessionPromise = this._connection.createBrowserSession();
          return this._clientRootSessionPromise;
        });
      }
    };
    exports2.CRBrowser = CRBrowser;
    var CRServiceWorker = class extends _page.Worker {
      constructor(browserContext, session, url) {
        super(browserContext, url);
        this._browserContext = void 0;
        this._browserContext = browserContext;
        session.once("Runtime.executionContextCreated", (event) => {
          this._createExecutionContext(new _crExecutionContext.CRExecutionContext(session, event.context));
        });
        session.send("Runtime.enable", {}).catch((e) => {
        });
        session.send("Runtime.runIfWaitingForDebugger").catch((e) => {
        });
      }
    };
    var CRBrowserContext = class extends _browserContext.BrowserContext {
      constructor(browser, browserContextId, options) {
        super(browser, options, browserContextId);
        this._authenticateProxyViaCredentials();
      }
      _initialize() {
        var __superGet = (key) => super[key];
        return __async(this, null, function* () {
          (0, _utils.assert)(!Array.from(this._browser._crPages.values()).some((page) => page._browserContext === this));
          const promises = [__superGet("_initialize").call(this)];
          if (this._browser.options.name !== "electron" && this._browser.options.name !== "clank") {
            promises.push(this._browser._session.send("Browser.setDownloadBehavior", {
              behavior: this._options.acceptDownloads ? "allowAndName" : "deny",
              browserContextId: this._browserContextId,
              downloadPath: this._browser.options.downloadsPath,
              eventsEnabled: true
            }));
          }
          if (this._options.permissions)
            promises.push(this.grantPermissions(this._options.permissions));
          yield Promise.all(promises);
        });
      }
      pages() {
        const result = [];
        for (const crPage of this._browser._crPages.values()) {
          if (crPage._browserContext === this && crPage._initializedPage)
            result.push(crPage._initializedPage);
        }
        return result;
      }
      newPageDelegate() {
        return __async(this, null, function* () {
          (0, _browserContext.assertBrowserContextIsNotOwned)(this);
          const oldKeys = this._browser.isClank() ? new Set(this._browser._crPages.keys()) : void 0;
          let {
            targetId
          } = yield this._browser._session.send("Target.createTarget", {
            url: "about:blank",
            browserContextId: this._browserContextId
          });
          if (oldKeys) {
            const newKeys = new Set(this._browser._crPages.keys());
            for (const key of oldKeys)
              newKeys.delete(key);
            for (const key of newKeys) {
              const page = this._browser._crPages.get(key);
              if (page._opener)
                newKeys.delete(key);
            }
            (0, _utils.assert)(newKeys.size === 1);
            [targetId] = [...newKeys];
          }
          return this._browser._crPages.get(targetId);
        });
      }
      doGetCookies(urls) {
        return __async(this, null, function* () {
          const {
            cookies
          } = yield this._browser._session.send("Storage.getCookies", {
            browserContextId: this._browserContextId
          });
          return network.filterCookies(cookies.map((c) => {
            const copy = __spreadValues({
              sameSite: "Lax"
            }, c);
            delete copy.size;
            delete copy.priority;
            delete copy.session;
            delete copy.sameParty;
            delete copy.sourceScheme;
            delete copy.sourcePort;
            return copy;
          }), urls);
        });
      }
      addCookies(cookies) {
        return __async(this, null, function* () {
          yield this._browser._session.send("Storage.setCookies", {
            cookies: network.rewriteCookies(cookies),
            browserContextId: this._browserContextId
          });
        });
      }
      clearCookies() {
        return __async(this, null, function* () {
          yield this._browser._session.send("Storage.clearCookies", {
            browserContextId: this._browserContextId
          });
        });
      }
      doGrantPermissions(origin, permissions) {
        return __async(this, null, function* () {
          const webPermissionToProtocol = /* @__PURE__ */ new Map([
            ["geolocation", "geolocation"],
            ["midi", "midi"],
            ["notifications", "notifications"],
            ["camera", "videoCapture"],
            ["microphone", "audioCapture"],
            ["background-sync", "backgroundSync"],
            ["ambient-light-sensor", "sensors"],
            ["accelerometer", "sensors"],
            ["gyroscope", "sensors"],
            ["magnetometer", "sensors"],
            ["accessibility-events", "accessibilityEvents"],
            ["clipboard-read", "clipboardReadWrite"],
            ["clipboard-write", "clipboardSanitizedWrite"],
            ["payment-handler", "paymentHandler"],
            ["midi-sysex", "midiSysex"]
          ]);
          const filtered = permissions.map((permission) => {
            const protocolPermission = webPermissionToProtocol.get(permission);
            if (!protocolPermission)
              throw new Error("Unknown permission: " + permission);
            return protocolPermission;
          });
          yield this._browser._session.send("Browser.grantPermissions", {
            origin: origin === "*" ? void 0 : origin,
            browserContextId: this._browserContextId,
            permissions: filtered
          });
        });
      }
      doClearPermissions() {
        return __async(this, null, function* () {
          yield this._browser._session.send("Browser.resetPermissions", {
            browserContextId: this._browserContextId
          });
        });
      }
      setGeolocation(geolocation) {
        return __async(this, null, function* () {
          (0, _browserContext.verifyGeolocation)(geolocation);
          this._options.geolocation = geolocation;
          for (const page of this.pages())
            yield page._delegate.updateGeolocation();
        });
      }
      setExtraHTTPHeaders(headers) {
        return __async(this, null, function* () {
          this._options.extraHTTPHeaders = headers;
          for (const page of this.pages())
            yield page._delegate.updateExtraHTTPHeaders();
        });
      }
      setOffline(offline) {
        return __async(this, null, function* () {
          this._options.offline = offline;
          for (const page of this.pages())
            yield page._delegate.updateOffline();
        });
      }
      doSetHTTPCredentials(httpCredentials) {
        return __async(this, null, function* () {
          this._options.httpCredentials = httpCredentials;
          for (const page of this.pages())
            yield page._delegate.updateHttpCredentials();
        });
      }
      doAddInitScript(source) {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.addInitScript(source);
        });
      }
      doRemoveInitScripts() {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.removeInitScripts();
        });
      }
      doExposeBinding(binding) {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.exposeBinding(binding);
        });
      }
      doRemoveExposedBindings() {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.removeExposedBindings();
        });
      }
      doUpdateRequestInterception() {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.updateRequestInterception();
        });
      }
      doClose() {
        return __async(this, null, function* () {
          (0, _utils.assert)(this._browserContextId);
          const openedBeforeUnloadDialogs = [];
          for (const crPage of this._browser._crPages.values()) {
            if (crPage._browserContext !== this)
              continue;
            const dialogs = [...crPage._page._frameManager._openedDialogs].filter((dialog) => dialog.type() === "beforeunload");
            openedBeforeUnloadDialogs.push(...dialogs);
          }
          yield Promise.all(openedBeforeUnloadDialogs.map((dialog) => dialog.dismiss()));
          yield this._browser._session.send("Target.disposeBrowserContext", {
            browserContextId: this._browserContextId
          });
          this._browser._contexts.delete(this._browserContextId);
          for (const [targetId, serviceWorker] of this._browser._serviceWorkers) {
            if (serviceWorker._browserContext !== this)
              continue;
            serviceWorker.didClose();
            this._browser._serviceWorkers.delete(targetId);
          }
        });
      }
      onClosePersistent() {
        for (const [targetId, backgroundPage] of this._browser._backgroundPages.entries()) {
          if (backgroundPage._browserContext === this && backgroundPage._initializedPage) {
            backgroundPage.didClose();
            this._browser._backgroundPages.delete(targetId);
          }
        }
      }
      cancelDownload(guid) {
        return __async(this, null, function* () {
          yield this._browser._session.send("Browser.cancelDownload", {
            guid,
            browserContextId: this._browserContextId
          });
        });
      }
      backgroundPages() {
        const result = [];
        for (const backgroundPage of this._browser._backgroundPages.values()) {
          if (backgroundPage._browserContext === this && backgroundPage._initializedPage)
            result.push(backgroundPage._initializedPage);
        }
        return result;
      }
      serviceWorkers() {
        return Array.from(this._browser._serviceWorkers.values()).filter((serviceWorker) => serviceWorker._browserContext === this);
      }
      newCDPSession(page) {
        return __async(this, null, function* () {
          let targetId = null;
          if (page instanceof _page.Page) {
            targetId = page._delegate._targetId;
          } else if (page instanceof _frames.Frame) {
            const session = page._page._delegate._sessions.get(page._id);
            if (!session)
              throw new Error(`This frame does not have a separate CDP session, it is a part of the parent frame's session`);
            targetId = session._targetId;
          } else {
            throw new Error("page: expected Page or Frame");
          }
          const rootSession = yield this._browser._clientRootSession();
          const {
            sessionId
          } = yield rootSession.send("Target.attachToTarget", {
            targetId,
            flatten: true
          });
          return this._browser._connection.session(sessionId);
        });
      }
    };
    exports2.CRBrowserContext = CRBrowserContext;
    CRBrowserContext.CREvents = {
      BackgroundPage: "backgroundpage",
      ServiceWorker: "serviceworker"
    };
  }
});

// node_modules/playwright-core/lib/protocol/transport.js
var require_transport = __commonJS({
  "node_modules/playwright-core/lib/protocol/transport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PipeTransport = exports2.IpcTransport = void 0;
    var _utils = require_utils();
    var PipeTransport = class {
      constructor(pipeWrite, pipeRead, closeable, endian = "le") {
        this._pipeWrite = void 0;
        this._data = Buffer.from([]);
        this._waitForNextTask = (0, _utils.makeWaitForNextTask)();
        this._closed = false;
        this._bytesLeft = 0;
        this.onmessage = void 0;
        this.onclose = void 0;
        this._endian = void 0;
        this._closeableStream = void 0;
        this._pipeWrite = pipeWrite;
        this._endian = endian;
        this._closeableStream = closeable;
        pipeRead.on("data", (buffer) => this._dispatch(buffer));
        pipeRead.on("close", () => {
          this._closed = true;
          if (this.onclose)
            this.onclose();
        });
        this.onmessage = void 0;
        this.onclose = void 0;
      }
      send(message) {
        if (this._closed)
          throw new Error("Pipe has been closed");
        const data = Buffer.from(message, "utf-8");
        const dataLength = Buffer.alloc(4);
        if (this._endian === "be")
          dataLength.writeUInt32BE(data.length, 0);
        else
          dataLength.writeUInt32LE(data.length, 0);
        this._pipeWrite.write(dataLength);
        this._pipeWrite.write(data);
      }
      close() {
        this._closeableStream.close();
      }
      _dispatch(buffer) {
        this._data = Buffer.concat([this._data, buffer]);
        while (true) {
          if (!this._bytesLeft && this._data.length < 4) {
            break;
          }
          if (!this._bytesLeft) {
            this._bytesLeft = this._endian === "be" ? this._data.readUInt32BE(0) : this._data.readUInt32LE(0);
            this._data = this._data.slice(4);
          }
          if (!this._bytesLeft || this._data.length < this._bytesLeft) {
            break;
          }
          const message = this._data.slice(0, this._bytesLeft);
          this._data = this._data.slice(this._bytesLeft);
          this._bytesLeft = 0;
          this._waitForNextTask(() => {
            if (this.onmessage)
              this.onmessage(message.toString("utf-8"));
          });
        }
      }
    };
    exports2.PipeTransport = PipeTransport;
    var IpcTransport = class {
      constructor(process2) {
        this._process = void 0;
        this.onmessage = void 0;
        this.onclose = void 0;
        this._process = process2;
        this._process.on("message", (message) => {
          var _this$onclose, _this$onmessage;
          if (message === "<eof>")
            (_this$onclose = this.onclose) === null || _this$onclose === void 0 ? void 0 : _this$onclose.call(this);
          else
            (_this$onmessage = this.onmessage) === null || _this$onmessage === void 0 ? void 0 : _this$onmessage.call(this, message);
        });
      }
      send(message) {
        this._process.send(message);
      }
      close() {
        this._process.send("<eof>");
      }
    };
    exports2.IpcTransport = IpcTransport;
  }
});

// node_modules/playwright-core/lib/server/android/android.js
var require_android = __commonJS({
  "node_modules/playwright-core/lib/server/android/android.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AndroidDevice = exports2.Android = void 0;
    var _debug = _interopRequireDefault(require_src3());
    var _events = require("events");
    var _fs = _interopRequireDefault(require("fs"));
    var _os = _interopRequireDefault(require("os"));
    var _path = _interopRequireDefault(require("path"));
    var ws = _interopRequireWildcard(require("ws"));
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _browserContext = require_browserContext();
    var _progress = require_progress2();
    var _crBrowser = require_crBrowser();
    var _helper = require_helper();
    var _transport = require_transport();
    var _debugLogger = require_debugLogger();
    var _processLauncher = require_processLauncher();
    var _timeoutSettings = require_timeoutSettings();
    var _instrumentation = require_instrumentation();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ARTIFACTS_FOLDER = _path.default.join(_os.default.tmpdir(), "playwright-artifacts-");
    var Android = class extends _instrumentation.SdkObject {
      constructor(backend, playwrightOptions) {
        super(playwrightOptions.rootSdkObject, "android");
        this._backend = void 0;
        this._devices = /* @__PURE__ */ new Map();
        this._timeoutSettings = void 0;
        this._playwrightOptions = void 0;
        this._backend = backend;
        this._playwrightOptions = playwrightOptions;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      devices(options) {
        return __async(this, null, function* () {
          const devices = (yield this._backend.devices(options)).filter((d) => d.status === "device");
          const newSerials = /* @__PURE__ */ new Set();
          for (const d of devices) {
            newSerials.add(d.serial);
            if (this._devices.has(d.serial))
              continue;
            const device = yield AndroidDevice.create(this, d, options);
            this._devices.set(d.serial, device);
          }
          for (const d of this._devices.keys()) {
            if (!newSerials.has(d))
              this._devices.delete(d);
          }
          return [...this._devices.values()];
        });
      }
      _deviceClosed(device) {
        this._devices.delete(device.serial);
      }
    };
    exports2.Android = Android;
    var AndroidDevice = class extends _instrumentation.SdkObject {
      constructor(android, backend, model, options) {
        super(android, "android-device");
        this._backend = void 0;
        this.model = void 0;
        this.serial = void 0;
        this._options = void 0;
        this._driverPromise = void 0;
        this._lastId = 0;
        this._callbacks = /* @__PURE__ */ new Map();
        this._pollingWebViews = void 0;
        this._timeoutSettings = void 0;
        this._webViews = /* @__PURE__ */ new Map();
        this._browserConnections = /* @__PURE__ */ new Set();
        this._android = void 0;
        this._isClosed = false;
        this._android = android;
        this._backend = backend;
        this.model = model;
        this.serial = backend.serial;
        this._options = options;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings(android._timeoutSettings);
      }
      static create(android, backend, options) {
        return __async(this, null, function* () {
          yield backend.init();
          const model = yield backend.runCommand("shell:getprop ro.product.model");
          const device = new AndroidDevice(android, backend, model.toString().trim(), options);
          yield device._init();
          return device;
        });
      }
      _init() {
        return __async(this, null, function* () {
          yield this._refreshWebViews();
          const poll = () => {
            this._pollingWebViews = setTimeout(() => this._refreshWebViews().then(poll).catch(() => {
            }), 500);
          };
          poll();
        });
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      shell(command) {
        return __async(this, null, function* () {
          const result = yield this._backend.runCommand(`shell:${command}`);
          yield this._refreshWebViews();
          return result;
        });
      }
      open(command) {
        return __async(this, null, function* () {
          return yield this._backend.open(`${command}`);
        });
      }
      screenshot() {
        return __async(this, null, function* () {
          return yield this._backend.runCommand(`shell:screencap -p`);
        });
      }
      _driver() {
        return __async(this, null, function* () {
          if (!this._driverPromise)
            this._driverPromise = this._installDriver();
          return this._driverPromise;
        });
      }
      _installDriver() {
        return __async(this, null, function* () {
          (0, _debug.default)("pw:android")("Stopping the old driver");
          yield this.shell(`am force-stop com.microsoft.playwright.androiddriver`);
          if (!this._options.omitDriverInstall) {
            (0, _debug.default)("pw:android")("Uninstalling the old driver");
            yield this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver`);
            yield this.shell(`cmd package uninstall com.microsoft.playwright.androiddriver.test`);
            (0, _debug.default)("pw:android")("Installing the new driver");
            for (const file of ["android-driver.apk", "android-driver-target.apk"])
              yield this.installApk(yield _fs.default.promises.readFile(require.resolve(`../../../bin/${file}`)));
          } else {
            (0, _debug.default)("pw:android")("Skipping the driver installation");
          }
          (0, _debug.default)("pw:android")("Starting the new driver");
          this.shell("am instrument -w com.microsoft.playwright.androiddriver.test/androidx.test.runner.AndroidJUnitRunner").catch((e) => (0, _debug.default)("pw:android")(e));
          const socket = yield this._waitForLocalAbstract("playwright_android_driver_socket");
          const transport = new _transport.PipeTransport(socket, socket, socket, "be");
          transport.onmessage = (message) => {
            const response = JSON.parse(message);
            const {
              id,
              result,
              error
            } = response;
            const callback = this._callbacks.get(id);
            if (!callback)
              return;
            if (error)
              callback.reject(new Error(error));
            else
              callback.fulfill(result);
            this._callbacks.delete(id);
          };
          return transport;
        });
      }
      _waitForLocalAbstract(socketName) {
        return __async(this, null, function* () {
          let socket;
          (0, _debug.default)("pw:android")(`Polling the socket localabstract:${socketName}`);
          while (!socket) {
            try {
              socket = yield this._backend.open(`localabstract:${socketName}`);
            } catch (e) {
              yield new Promise((f) => setTimeout(f, 250));
            }
          }
          (0, _debug.default)("pw:android")(`Connected to localabstract:${socketName}`);
          return socket;
        });
      }
      send(_0) {
        return __async(this, arguments, function* (method, params = {}) {
          params.timeout = this._timeoutSettings.timeout(params);
          const driver = yield this._driver();
          const id = ++this._lastId;
          const result = new Promise((fulfill, reject) => this._callbacks.set(id, {
            fulfill,
            reject
          }));
          driver.send(JSON.stringify({
            id,
            method,
            params
          }));
          return result;
        });
      }
      close() {
        return __async(this, null, function* () {
          this._isClosed = true;
          if (this._pollingWebViews)
            clearTimeout(this._pollingWebViews);
          for (const connection of this._browserConnections)
            yield connection.close();
          if (this._driverPromise) {
            const driver = yield this._driver();
            driver.close();
          }
          yield this._backend.close();
          this._android._deviceClosed(this);
          this.emit(AndroidDevice.Events.Closed);
        });
      }
      launchBrowser(pkg = "com.android.chrome", options) {
        return __async(this, null, function* () {
          (0, _debug.default)("pw:android")("Force-stopping", pkg);
          yield this._backend.runCommand(`shell:am force-stop ${pkg}`);
          const socketName = "playwright-" + (0, _utils.createGuid)();
          const commandLine = `_ --disable-fre --no-default-browser-check --no-first-run --remote-debugging-socket-name=${socketName}`;
          (0, _debug.default)("pw:android")("Starting", pkg, commandLine);
          yield this._backend.runCommand(`shell:echo "${commandLine}" > /data/local/tmp/chrome-command-line`);
          yield this._backend.runCommand(`shell:am start -n ${pkg}/com.google.android.apps.chrome.Main about:blank`);
          return yield this._connectToBrowser(socketName, options);
        });
      }
      connectToWebView(pid) {
        return __async(this, null, function* () {
          const webView = this._webViews.get(pid);
          if (!webView)
            throw new Error("WebView has been closed");
          return yield this._connectToBrowser(`webview_devtools_remote_${pid}`);
        });
      }
      _connectToBrowser(_0) {
        return __async(this, arguments, function* (socketName, options = {}) {
          const socket = yield this._waitForLocalAbstract(socketName);
          const androidBrowser = new AndroidBrowser(this, socket);
          yield androidBrowser._init();
          this._browserConnections.add(androidBrowser);
          const artifactsDir = yield _fs.default.promises.mkdtemp(ARTIFACTS_FOLDER);
          const cleanupArtifactsDir = () => __async(this, null, function* () {
            const errors = yield (0, _fileUtils.removeFolders)([artifactsDir]);
            for (let i = 0; i < (errors || []).length; ++i)
              (0, _debug.default)("pw:android")(`exception while removing ${artifactsDir}: ${errors[i]}`);
          });
          _processLauncher.gracefullyCloseSet.add(cleanupArtifactsDir);
          socket.on("close", () => __async(this, null, function* () {
            _processLauncher.gracefullyCloseSet.delete(cleanupArtifactsDir);
            cleanupArtifactsDir().catch((e) => (0, _debug.default)("pw:android")(`could not cleanup artifacts dir: ${e}`));
          }));
          const browserOptions = __spreadProps(__spreadValues({}, this._android._playwrightOptions), {
            name: "clank",
            isChromium: true,
            slowMo: 0,
            persistent: __spreadProps(__spreadValues({}, options), {
              noDefaultViewport: true
            }),
            artifactsDir,
            downloadsPath: artifactsDir,
            tracesDir: artifactsDir,
            browserProcess: new ClankBrowserProcess(androidBrowser),
            proxy: options.proxy,
            protocolLogger: _helper.helper.debugProtocolLogger(),
            browserLogsCollector: new _debugLogger.RecentLogsCollector()
          });
          (0, _browserContext.validateBrowserContextOptions)(options, browserOptions);
          const browser = yield _crBrowser.CRBrowser.connect(androidBrowser, browserOptions);
          const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), this);
          const defaultContext = browser._defaultContext;
          yield controller.run((progress) => __async(this, null, function* () {
            yield defaultContext._loadDefaultContextAsIs(progress);
          }));
          return defaultContext;
        });
      }
      webViews() {
        return [...this._webViews.values()];
      }
      installApk(content, options) {
        return __async(this, null, function* () {
          const args = options && options.args ? options.args : ["-r", "-t", "-S"];
          (0, _debug.default)("pw:android")("Opening install socket");
          const installSocket = yield this._backend.open(`shell:cmd package install ${args.join(" ")} ${content.length}`);
          (0, _debug.default)("pw:android")("Writing driver bytes: " + content.length);
          yield installSocket.write(content);
          const success = yield new Promise((f) => installSocket.on("data", f));
          (0, _debug.default)("pw:android")("Written driver bytes: " + success);
          installSocket.close();
        });
      }
      push(content, path, mode = 420) {
        return __async(this, null, function* () {
          const socket = yield this._backend.open(`sync:`);
          const sendHeader = (command, length) => __async(this, null, function* () {
            const buffer = Buffer.alloc(command.length + 4);
            buffer.write(command, 0);
            buffer.writeUInt32LE(length, command.length);
            yield socket.write(buffer);
          });
          const send = (command, data) => __async(this, null, function* () {
            yield sendHeader(command, data.length);
            yield socket.write(data);
          });
          yield send("SEND", Buffer.from(`${path},${mode}`));
          const maxChunk = 65535;
          for (let i = 0; i < content.length; i += maxChunk)
            yield send("DATA", content.slice(i, i + maxChunk));
          yield sendHeader("DONE", Date.now() / 1e3 | 0);
          const result = yield new Promise((f) => socket.once("data", f));
          const code = result.slice(0, 4).toString();
          if (code !== "OKAY")
            throw new Error("Could not push: " + code);
          socket.close();
        });
      }
      _refreshWebViews() {
        return __async(this, null, function* () {
          const sockets = (yield this._backend.runCommand(`shell:cat /proc/net/unix | grep webview_devtools_remote`)).toString().split("\n");
          if (this._isClosed)
            return;
          const newPids = /* @__PURE__ */ new Set();
          for (const line of sockets) {
            const match = line.match(/[^@]+@webview_devtools_remote_(\d+)/);
            if (!match)
              continue;
            const pid = +match[1];
            newPids.add(pid);
          }
          for (const pid of newPids) {
            if (this._webViews.has(pid))
              continue;
            const procs = (yield this._backend.runCommand(`shell:ps -A | grep ${pid}`)).toString().split("\n");
            if (this._isClosed)
              return;
            let pkg = "";
            for (const proc of procs) {
              const match = proc.match(/[^\s]+\s+(\d+).*$/);
              if (!match)
                continue;
              const p = match[1];
              if (+p !== pid)
                continue;
              pkg = proc.substring(proc.lastIndexOf(" ") + 1);
            }
            const webView = {
              pid,
              pkg
            };
            this._webViews.set(pid, webView);
            this.emit(AndroidDevice.Events.WebViewAdded, webView);
          }
          for (const p of this._webViews.keys()) {
            if (!newPids.has(p)) {
              this._webViews.delete(p);
              this.emit(AndroidDevice.Events.WebViewRemoved, p);
            }
          }
        });
      }
    };
    exports2.AndroidDevice = AndroidDevice;
    AndroidDevice.Events = {
      WebViewAdded: "webViewAdded",
      WebViewRemoved: "webViewRemoved",
      Closed: "closed"
    };
    var AndroidBrowser = class extends _events.EventEmitter {
      constructor(device, socket) {
        super();
        this.device = void 0;
        this._socket = void 0;
        this._receiver = void 0;
        this._waitForNextTask = (0, _utils.makeWaitForNextTask)();
        this.onmessage = void 0;
        this.onclose = void 0;
        this.setMaxListeners(0);
        this.device = device;
        this._socket = socket;
        this._socket.on("close", () => {
          this._waitForNextTask(() => {
            if (this.onclose)
              this.onclose();
          });
        });
        this._receiver = new ws.Receiver();
        this._receiver.on("message", (message) => {
          this._waitForNextTask(() => {
            if (this.onmessage)
              this.onmessage(JSON.parse(message));
          });
        });
      }
      _init() {
        return __async(this, null, function* () {
          yield this._socket.write(Buffer.from(`GET /devtools/browser HTTP/1.1\r
Upgrade: WebSocket\r
Connection: Upgrade\r
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\r
Sec-WebSocket-Version: 13\r
\r
`));
          yield new Promise((f) => this._socket.once("data", f));
          this._socket.on("data", (data) => this._receiver._write(data, "binary", () => {
          }));
        });
      }
      send(s) {
        return __async(this, null, function* () {
          yield this._socket.write(encodeWebFrame(JSON.stringify(s)));
        });
      }
      close() {
        return __async(this, null, function* () {
          this._socket.close();
        });
      }
    };
    function encodeWebFrame(data) {
      return ws.Sender.frame(Buffer.from(data), {
        opcode: 1,
        mask: true,
        fin: true,
        readOnly: true
      })[0];
    }
    var ClankBrowserProcess = class {
      constructor(browser) {
        this._browser = void 0;
        this.onclose = void 0;
        this._browser = browser;
      }
      kill() {
        return __async(this, null, function* () {
        });
      }
      close() {
        return __async(this, null, function* () {
          yield this._browser.close();
        });
      }
    };
  }
});

// node_modules/playwright-core/lib/server/android/backendAdb.js
var require_backendAdb = __commonJS({
  "node_modules/playwright-core/lib/server/android/backendAdb.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AdbBackend = void 0;
    var _debug = _interopRequireDefault(require_src3());
    var net = _interopRequireWildcard(require("net"));
    var _events = require("events");
    var _utils = require_utils();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var AdbBackend = class {
      devices() {
        return __async(this, arguments, function* (options = {}) {
          const port = options.port ? options.port : 5037;
          const result = yield runCommand("host:devices", port);
          const lines = result.toString().trim().split("\n");
          return lines.map((line) => {
            const [serial, status] = line.trim().split("	");
            return new AdbDevice(serial, status, port);
          });
        });
      }
    };
    exports2.AdbBackend = AdbBackend;
    var AdbDevice = class {
      constructor(serial, status, port) {
        this.serial = serial;
        this.status = status;
        this.port = port;
      }
      init() {
        return __async(this, null, function* () {
        });
      }
      close() {
        return __async(this, null, function* () {
        });
      }
      runCommand(command) {
        return runCommand(command, this.port, this.serial);
      }
      open(command) {
        return __async(this, null, function* () {
          const result = yield open(command, this.port, this.serial);
          result.becomeSocket();
          return result;
        });
      }
    };
    function runCommand(command, port = 5037, serial) {
      return __async(this, null, function* () {
        (0, _debug.default)("pw:adb:runCommand")(command, serial);
        const socket = new BufferedSocketWrapper(command, net.createConnection({
          port
        }));
        if (serial) {
          yield socket.write(encodeMessage(`host:transport:${serial}`));
          const status2 = yield socket.read(4);
          (0, _utils.assert)(status2.toString() === "OKAY", status2.toString());
        }
        yield socket.write(encodeMessage(command));
        const status = yield socket.read(4);
        (0, _utils.assert)(status.toString() === "OKAY", status.toString());
        let commandOutput;
        if (!command.startsWith("shell:")) {
          const remainingLength = parseInt((yield socket.read(4)).toString(), 16);
          commandOutput = yield socket.read(remainingLength);
        } else {
          commandOutput = yield socket.readAll();
        }
        socket.close();
        return commandOutput;
      });
    }
    function open(command, port = 5037, serial) {
      return __async(this, null, function* () {
        const socket = new BufferedSocketWrapper(command, net.createConnection({
          port
        }));
        if (serial) {
          yield socket.write(encodeMessage(`host:transport:${serial}`));
          const status2 = yield socket.read(4);
          (0, _utils.assert)(status2.toString() === "OKAY", status2.toString());
        }
        yield socket.write(encodeMessage(command));
        const status = yield socket.read(4);
        (0, _utils.assert)(status.toString() === "OKAY", status.toString());
        return socket;
      });
    }
    function encodeMessage(message) {
      let lenHex = message.length.toString(16);
      lenHex = "0".repeat(4 - lenHex.length) + lenHex;
      return Buffer.from(lenHex + message);
    }
    var BufferedSocketWrapper = class extends _events.EventEmitter {
      constructor(command, socket) {
        super();
        this.guid = (0, _utils.createGuid)();
        this._socket = void 0;
        this._buffer = Buffer.from([]);
        this._isSocket = false;
        this._notifyReader = void 0;
        this._connectPromise = void 0;
        this._isClosed = false;
        this._command = void 0;
        this._command = command;
        this._socket = socket;
        this._connectPromise = new Promise((f) => this._socket.on("connect", f));
        this._socket.on("data", (data) => {
          (0, _debug.default)("pw:adb:data")(data.toString());
          if (this._isSocket) {
            this.emit("data", data);
            return;
          }
          this._buffer = Buffer.concat([this._buffer, data]);
          if (this._notifyReader)
            this._notifyReader();
        });
        this._socket.on("close", () => {
          this._isClosed = true;
          if (this._notifyReader)
            this._notifyReader();
          this.close();
          this.emit("close");
        });
        this._socket.on("error", (error) => this.emit("error", error));
      }
      write(data) {
        return __async(this, null, function* () {
          (0, _debug.default)("pw:adb:send")(data.toString().substring(0, 100) + "...");
          yield this._connectPromise;
          yield new Promise((f) => this._socket.write(data, f));
        });
      }
      close() {
        if (this._isClosed)
          return;
        (0, _debug.default)("pw:adb")("Close " + this._command);
        this._socket.destroy();
      }
      read(length) {
        return __async(this, null, function* () {
          yield this._connectPromise;
          (0, _utils.assert)(!this._isSocket, "Can not read by length in socket mode");
          while (this._buffer.length < length)
            yield new Promise((f) => this._notifyReader = f);
          const result = this._buffer.slice(0, length);
          this._buffer = this._buffer.slice(length);
          (0, _debug.default)("pw:adb:recv")(result.toString().substring(0, 100) + "...");
          return result;
        });
      }
      readAll() {
        return __async(this, null, function* () {
          while (!this._isClosed)
            yield new Promise((f) => this._notifyReader = f);
          return this._buffer;
        });
      }
      becomeSocket() {
        (0, _utils.assert)(!this._buffer.length);
        this._isSocket = true;
      }
    };
  }
});

// node_modules/playwright-core/lib/server/transport.js
var require_transport2 = __commonJS({
  "node_modules/playwright-core/lib/server/transport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WebSocketTransport = void 0;
    var _ws = _interopRequireDefault(require("ws"));
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var WebSocketTransport = class {
      static connect(progress, url, headers, followRedirects) {
        return __async(this, null, function* () {
          progress.log(`<ws connecting> ${url}`);
          const transport = new WebSocketTransport(progress, url, headers, followRedirects);
          let success = false;
          progress.cleanupWhenAborted(() => __async(this, null, function* () {
            if (!success)
              yield transport.closeAndWait().catch((e) => null);
          }));
          yield new Promise((fulfill, reject) => {
            transport._ws.addEventListener("open", () => __async(this, null, function* () {
              progress.log(`<ws connected> ${url}`);
              fulfill(transport);
            }));
            transport._ws.addEventListener("error", (event) => {
              progress.log(`<ws connect error> ${url} ${event.message}`);
              reject(new Error("WebSocket error: " + event.message));
              transport._ws.close();
            });
          });
          success = true;
          return transport;
        });
      }
      constructor(progress, url, headers, followRedirects) {
        this._ws = void 0;
        this._progress = void 0;
        this.onmessage = void 0;
        this.onclose = void 0;
        this.wsEndpoint = void 0;
        this.wsEndpoint = url;
        this._ws = new _ws.default(url, [], {
          perMessageDeflate: false,
          maxPayload: 256 * 1024 * 1024,
          handshakeTimeout: Math.max(progress.timeUntilDeadline(), 1),
          headers,
          followRedirects
        });
        this._progress = progress;
        const messageWrap = (0, _utils.makeWaitForNextTask)();
        this._ws.addEventListener("message", (event) => {
          messageWrap(() => {
            try {
              if (this.onmessage)
                this.onmessage.call(null, JSON.parse(event.data));
            } catch (e) {
              this._ws.close();
            }
          });
        });
        this._ws.addEventListener("close", (event) => {
          this._progress && this._progress.log(`<ws disconnected> ${url} code=${event.code} reason=${event.reason}`);
          if (this.onclose)
            this.onclose.call(null);
        });
        this._ws.addEventListener("error", (error) => this._progress && this._progress.log(`<ws error> ${error}`));
      }
      send(message) {
        this._ws.send(JSON.stringify(message));
      }
      close() {
        this._progress && this._progress.log(`<ws disconnecting> ${this._ws.url}`);
        this._ws.close();
      }
      closeAndWait() {
        return __async(this, null, function* () {
          if (this._ws.readyState === _ws.default.CLOSED)
            return;
          const promise = new Promise((f) => this._ws.once("close", f));
          this.close();
          yield promise;
        });
      }
    };
    exports2.WebSocketTransport = WebSocketTransport;
  }
});

// node_modules/playwright-core/lib/server/pipeTransport.js
var require_pipeTransport = __commonJS({
  "node_modules/playwright-core/lib/server/pipeTransport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PipeTransport = void 0;
    var _utils = require_utils();
    var _debugLogger = require_debugLogger();
    var PipeTransport = class {
      constructor(pipeWrite, pipeRead) {
        this._pipeWrite = void 0;
        this._pendingMessage = "";
        this._waitForNextTask = (0, _utils.makeWaitForNextTask)();
        this._closed = false;
        this.onmessage = void 0;
        this.onclose = void 0;
        this._pipeWrite = pipeWrite;
        pipeRead.on("data", (buffer) => this._dispatch(buffer));
        pipeRead.on("close", () => {
          this._closed = true;
          if (this.onclose)
            this.onclose.call(null);
        });
        pipeRead.on("error", (e) => _debugLogger.debugLogger.log("error", e));
        pipeWrite.on("error", (e) => _debugLogger.debugLogger.log("error", e));
        this.onmessage = void 0;
        this.onclose = void 0;
      }
      send(message) {
        if (this._closed)
          throw new Error("Pipe has been closed");
        this._pipeWrite.write(JSON.stringify(message));
        this._pipeWrite.write("\0");
      }
      close() {
        throw new Error("unimplemented");
      }
      _dispatch(buffer) {
        let end = buffer.indexOf("\0");
        if (end === -1) {
          this._pendingMessage += buffer.toString();
          return;
        }
        const message = this._pendingMessage + buffer.toString(void 0, 0, end);
        this._waitForNextTask(() => {
          if (this.onmessage)
            this.onmessage.call(null, JSON.parse(message));
        });
        let start = end + 1;
        end = buffer.indexOf("\0", start);
        while (end !== -1) {
          const message2 = buffer.toString(void 0, start, end);
          this._waitForNextTask(() => {
            if (this.onmessage)
              this.onmessage.call(null, JSON.parse(message2));
          });
          start = end + 1;
          end = buffer.indexOf("\0", start);
        }
        this._pendingMessage = buffer.toString(void 0, start);
      }
    };
    exports2.PipeTransport = PipeTransport;
  }
});

// node_modules/playwright-core/lib/server/browserType.js
var require_browserType = __commonJS({
  "node_modules/playwright-core/lib/server/browserType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.kNoXServerRunningError = exports2.BrowserType = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var os = _interopRequireWildcard(require("os"));
    var _path = _interopRequireDefault(require("path"));
    var _browserContext = require_browserContext();
    var _registry = require_registry();
    var _transport = require_transport2();
    var _processLauncher = require_processLauncher();
    var _pipeTransport = require_pipeTransport();
    var _progress = require_progress2();
    var _timeoutSettings = require_timeoutSettings();
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _helper = require_helper();
    var _debugLogger = require_debugLogger();
    var _instrumentation = require_instrumentation();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var kNoXServerRunningError = "Looks like you launched a headed browser without having a XServer running.\nSet either 'headless: false' or use 'xvfb-run <your-playwright-app>' before running Playwright.\n\n<3 Playwright Team";
    exports2.kNoXServerRunningError = kNoXServerRunningError;
    var BrowserType = class extends _instrumentation.SdkObject {
      constructor(browserName, playwrightOptions) {
        super(playwrightOptions.rootSdkObject, "browser-type");
        this._name = void 0;
        this._playwrightOptions = void 0;
        this.attribution.browserType = this;
        this._playwrightOptions = playwrightOptions;
        this._name = browserName;
      }
      executablePath() {
        return _registry.registry.findExecutable(this._name).executablePath(this._playwrightOptions.sdkLanguage) || "";
      }
      name() {
        return this._name;
      }
      launch(metadata, options, protocolLogger) {
        return __async(this, null, function* () {
          options = this._validateLaunchOptions(options);
          const controller = new _progress.ProgressController(metadata, this);
          controller.setLogName("browser");
          const browser = yield controller.run((progress) => {
            const seleniumHubUrl = options.__testHookSeleniumRemoteURL || process.env.SELENIUM_REMOTE_URL;
            if (seleniumHubUrl)
              return this._launchWithSeleniumHub(progress, seleniumHubUrl, options);
            return this._innerLaunchWithRetries(progress, options, void 0, _helper.helper.debugProtocolLogger(protocolLogger)).catch((e) => {
              throw this._rewriteStartupError(e);
            });
          }, _timeoutSettings.TimeoutSettings.timeout(options));
          return browser;
        });
      }
      launchPersistentContext(metadata, userDataDir, options) {
        return __async(this, null, function* () {
          options = this._validateLaunchOptions(options);
          const controller = new _progress.ProgressController(metadata, this);
          const persistent = options;
          controller.setLogName("browser");
          const browser = yield controller.run((progress) => {
            return this._innerLaunchWithRetries(progress, options, persistent, _helper.helper.debugProtocolLogger(), userDataDir).catch((e) => {
              throw this._rewriteStartupError(e);
            });
          }, _timeoutSettings.TimeoutSettings.timeout(options));
          return browser._defaultContext;
        });
      }
      _innerLaunchWithRetries(progress, options, persistent, protocolLogger, userDataDir) {
        return __async(this, null, function* () {
          try {
            return yield this._innerLaunch(progress, options, persistent, protocolLogger, userDataDir);
          } catch (error) {
            const errorMessage = typeof error === "object" && typeof error.message === "string" ? error.message : "";
            if (errorMessage.includes("Inconsistency detected by ld.so")) {
              progress.log(`<restarting browser due to hitting race condition in glibc>`);
              return this._innerLaunch(progress, options, persistent, protocolLogger, userDataDir);
            }
            throw error;
          }
        });
      }
      _innerLaunch(progress, options, persistent, protocolLogger, userDataDir) {
        return __async(this, null, function* () {
          options.proxy = options.proxy ? (0, _browserContext.normalizeProxySettings)(options.proxy) : void 0;
          const browserLogsCollector = new _debugLogger.RecentLogsCollector();
          const {
            browserProcess,
            artifactsDir,
            transport
          } = yield this._launchProcess(progress, options, !!persistent, browserLogsCollector, userDataDir);
          if (options.__testHookBeforeCreateBrowser)
            yield options.__testHookBeforeCreateBrowser();
          const browserOptions = __spreadProps(__spreadValues({}, this._playwrightOptions), {
            name: this._name,
            isChromium: this._name === "chromium",
            channel: options.channel,
            slowMo: options.slowMo,
            persistent,
            headful: !options.headless,
            artifactsDir,
            downloadsPath: options.downloadsPath || artifactsDir,
            tracesDir: options.tracesDir || artifactsDir,
            browserProcess,
            customExecutablePath: options.executablePath,
            proxy: options.proxy,
            protocolLogger,
            browserLogsCollector,
            wsEndpoint: options.useWebSocket ? transport.wsEndpoint : void 0
          });
          if (persistent)
            (0, _browserContext.validateBrowserContextOptions)(persistent, browserOptions);
          copyTestHooks(options, browserOptions);
          const browser = yield this._connectToTransport(transport, browserOptions);
          if (persistent && !options.ignoreAllDefaultArgs)
            yield browser._defaultContext._loadDefaultContext(progress);
          return browser;
        });
      }
      _launchProcess(progress, options, isPersistent, browserLogsCollector, userDataDir) {
        return __async(this, null, function* () {
          var _options$args;
          const {
            ignoreDefaultArgs,
            ignoreAllDefaultArgs,
            args = [],
            executablePath = null,
            handleSIGINT = true,
            handleSIGTERM = true,
            handleSIGHUP = true
          } = options;
          const env = options.env ? (0, _processLauncher.envArrayToObject)(options.env) : process.env;
          const tempDirectories = [];
          if (options.downloadsPath)
            yield _fs.default.promises.mkdir(options.downloadsPath, {
              recursive: true
            });
          if (options.tracesDir)
            yield _fs.default.promises.mkdir(options.tracesDir, {
              recursive: true
            });
          const artifactsDir = yield _fs.default.promises.mkdtemp(_path.default.join(os.tmpdir(), "playwright-artifacts-"));
          tempDirectories.push(artifactsDir);
          if (userDataDir) {
            if (!(yield (0, _fileUtils.existsAsync)(userDataDir)))
              yield _fs.default.promises.mkdir(userDataDir, {
                recursive: true,
                mode: 448
              });
          } else {
            userDataDir = yield _fs.default.promises.mkdtemp(_path.default.join(os.tmpdir(), `playwright_${this._name}dev_profile-`));
            tempDirectories.push(userDataDir);
          }
          const browserArguments = [];
          if (ignoreAllDefaultArgs)
            browserArguments.push(...args);
          else if (ignoreDefaultArgs)
            browserArguments.push(...this._defaultArgs(options, isPersistent, userDataDir).filter((arg) => ignoreDefaultArgs.indexOf(arg) === -1));
          else
            browserArguments.push(...this._defaultArgs(options, isPersistent, userDataDir));
          let executable;
          if (executablePath) {
            if (!(yield (0, _fileUtils.existsAsync)(executablePath)))
              throw new Error(`Failed to launch ${this._name} because executable doesn't exist at ${executablePath}`);
            executable = executablePath;
          } else {
            const registryExecutable = _registry.registry.findExecutable(options.channel || this._name);
            if (!registryExecutable || registryExecutable.browserName !== this._name)
              throw new Error(`Unsupported ${this._name} channel "${options.channel}"`);
            executable = registryExecutable.executablePathOrDie(this._playwrightOptions.sdkLanguage);
            yield registryExecutable.validateHostRequirements(this._playwrightOptions.sdkLanguage);
          }
          let wsEndpointCallback;
          const shouldWaitForWSListening = options.useWebSocket || ((_options$args = options.args) === null || _options$args === void 0 ? void 0 : _options$args.some((a) => a.startsWith("--remote-debugging-port")));
          const waitForWSEndpoint = shouldWaitForWSListening ? new Promise((f) => wsEndpointCallback = f) : void 0;
          let transport = void 0;
          let browserProcess = void 0;
          const {
            launchedProcess,
            gracefullyClose,
            kill
          } = yield (0, _processLauncher.launchProcess)({
            command: executable,
            args: browserArguments,
            env: this._amendEnvironment(env, userDataDir, executable, browserArguments),
            handleSIGINT,
            handleSIGTERM,
            handleSIGHUP,
            log: (message) => {
              if (wsEndpointCallback) {
                const match = message.match(/DevTools listening on (.*)/);
                if (match)
                  wsEndpointCallback(match[1]);
              }
              progress.log(message);
              browserLogsCollector.log(message);
            },
            stdio: "pipe",
            tempDirectories,
            attemptToGracefullyClose: () => __async(this, null, function* () {
              if (options.__testHookGracefullyClose)
                yield options.__testHookGracefullyClose();
              this._attemptToGracefullyCloseBrowser(transport);
            }),
            onExit: (exitCode, signal) => {
              if (browserProcess && browserProcess.onclose)
                browserProcess.onclose(exitCode, signal);
            }
          });
          function closeOrKill(timeout) {
            return __async(this, null, function* () {
              let timer;
              try {
                yield Promise.race([gracefullyClose(), new Promise((resolve, reject) => timer = setTimeout(reject, timeout))]);
              } catch (ignored) {
                yield kill().catch((ignored2) => {
                });
              } finally {
                clearTimeout(timer);
              }
            });
          }
          browserProcess = {
            onclose: void 0,
            process: launchedProcess,
            close: () => closeOrKill(options.__testHookBrowserCloseTimeout || _timeoutSettings.DEFAULT_TIMEOUT),
            kill
          };
          progress.cleanupWhenAborted(() => closeOrKill(progress.timeUntilDeadline()));
          let wsEndpoint;
          if (shouldWaitForWSListening)
            wsEndpoint = yield waitForWSEndpoint;
          if (options.useWebSocket) {
            transport = yield _transport.WebSocketTransport.connect(progress, wsEndpoint);
          } else {
            const stdio = launchedProcess.stdio;
            transport = new _pipeTransport.PipeTransport(stdio[3], stdio[4]);
          }
          return {
            browserProcess,
            artifactsDir,
            transport
          };
        });
      }
      connectOverCDP(metadata, endpointURL, options, timeout) {
        return __async(this, null, function* () {
          throw new Error("CDP connections are only supported by Chromium");
        });
      }
      _launchWithSeleniumHub(progress, hubUrl, options) {
        return __async(this, null, function* () {
          throw new Error("Connecting to SELENIUM_REMOTE_URL is only supported by Chromium");
        });
      }
      _validateLaunchOptions(options) {
        const {
          devtools = false
        } = options;
        let {
          headless = !devtools,
          downloadsPath,
          proxy
        } = options;
        if ((0, _utils.debugMode)())
          headless = false;
        if (downloadsPath && !_path.default.isAbsolute(downloadsPath))
          downloadsPath = _path.default.join(process.cwd(), downloadsPath);
        if (this._playwrightOptions.socksProxyPort)
          proxy = {
            server: `socks5://127.0.0.1:${this._playwrightOptions.socksProxyPort}`
          };
        return __spreadProps(__spreadValues({}, options), {
          devtools,
          headless,
          downloadsPath,
          proxy
        });
      }
    };
    exports2.BrowserType = BrowserType;
    function copyTestHooks(from, to) {
      for (const [key, value] of Object.entries(from)) {
        if (key.startsWith("__testHook"))
          to[key] = value;
      }
    }
  }
});

// node_modules/playwright-core/lib/server/chromium/crDevTools.js
var require_crDevTools = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/crDevTools.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CRDevTools = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var kBindingName = "__pw_devtools__";
    var CRDevTools = class {
      constructor(preferencesPath) {
        this._preferencesPath = void 0;
        this._prefs = void 0;
        this._savePromise = void 0;
        this.__testHookOnBinding = void 0;
        this._preferencesPath = preferencesPath;
        this._savePromise = Promise.resolve();
      }
      install(session) {
        session.on("Runtime.bindingCalled", (event) => __async(this, null, function* () {
          if (event.name !== kBindingName)
            return;
          const parsed = JSON.parse(event.payload);
          let result = void 0;
          if (this.__testHookOnBinding)
            this.__testHookOnBinding(parsed);
          if (parsed.method === "getPreferences") {
            if (this._prefs === void 0) {
              try {
                const json = yield _fs.default.promises.readFile(this._preferencesPath, "utf8");
                this._prefs = JSON.parse(json);
              } catch (e) {
                this._prefs = {};
              }
            }
            result = this._prefs;
          } else if (parsed.method === "setPreference") {
            this._prefs[parsed.params[0]] = parsed.params[1];
            this._save();
          } else if (parsed.method === "removePreference") {
            delete this._prefs[parsed.params[0]];
            this._save();
          } else if (parsed.method === "clearPreferences") {
            this._prefs = {};
            this._save();
          }
          session.send("Runtime.evaluate", {
            expression: `window.DevToolsAPI.embedderMessageAck(${parsed.id}, ${JSON.stringify(result)})`,
            contextId: event.executionContextId
          }).catch((e) => null);
        }));
        Promise.all([session.send("Runtime.enable"), session.send("Runtime.addBinding", {
          name: kBindingName
        }), session.send("Page.enable"), session.send("Page.addScriptToEvaluateOnNewDocument", {
          source: `
        (() => {
          const init = () => {
            // Lazy init happens when InspectorFrontendHost is initialized.
            // At this point DevToolsHost is ready to be used.
            const host = window.DevToolsHost;
            const old = host.sendMessageToEmbedder.bind(host);
            host.sendMessageToEmbedder = message => {
              if (['getPreferences', 'setPreference', 'removePreference', 'clearPreferences'].includes(JSON.parse(message).method))
                window.${kBindingName}(message);
              else
                old(message);
            };
          };
          let value;
          Object.defineProperty(window, 'InspectorFrontendHost', {
            configurable: true,
            enumerable: true,
            get() { return value; },
            set(v) { value = v; init(); },
          });
        })()
      `
        }), session.send("Runtime.runIfWaitingForDebugger")]).catch((e) => null);
      }
      _save() {
        this._savePromise = this._savePromise.then(() => __async(this, null, function* () {
          yield _fs.default.promises.writeFile(this._preferencesPath, JSON.stringify(this._prefs)).catch((e) => null);
        }));
      }
    };
    exports2.CRDevTools = CRDevTools;
  }
});

// node_modules/playwright-core/lib/server/chromium/chromium.js
var require_chromium = __commonJS({
  "node_modules/playwright-core/lib/server/chromium/chromium.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Chromium = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var _os = _interopRequireDefault(require("os"));
    var _path = _interopRequireDefault(require("path"));
    var _crBrowser = require_crBrowser();
    var _processLauncher = require_processLauncher();
    var _crConnection = require_crConnection();
    var _stackTrace = require_stackTrace();
    var _browserType = require_browserType();
    var _transport = require_transport2();
    var _crDevTools = require_crDevTools();
    var _browser = require_browser3();
    var _netUtils = require_netUtils();
    var _userAgent = require_userAgent();
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _debugLogger = require_debugLogger();
    var _progress = require_progress2();
    var _timeoutSettings = require_timeoutSettings();
    var _helper = require_helper();
    var _http = _interopRequireDefault(require("http"));
    var _https = _interopRequireDefault(require("https"));
    var _registry = require_registry();
    var _manualPromise = require_manualPromise();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ARTIFACTS_FOLDER = _path.default.join(_os.default.tmpdir(), "playwright-artifacts-");
    var Chromium = class extends _browserType.BrowserType {
      constructor(playwrightOptions) {
        super("chromium", playwrightOptions);
        this._devtools = void 0;
        if ((0, _utils.debugMode)())
          this._devtools = this._createDevTools();
      }
      connectOverCDP(metadata, endpointURL, options, timeout) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this);
          controller.setLogName("browser");
          return controller.run((progress) => __async(this, null, function* () {
            return yield this._connectOverCDPInternal(progress, endpointURL, options);
          }), _timeoutSettings.TimeoutSettings.timeout({
            timeout
          }));
        });
      }
      _connectOverCDPInternal(progress, endpointURL, options, onClose) {
        return __async(this, null, function* () {
          let headersMap;
          if (options.headers)
            headersMap = (0, _utils.headersArrayToObject)(options.headers, false);
          if (!headersMap)
            headersMap = {
              "User-Agent": (0, _userAgent.getUserAgent)()
            };
          else if (headersMap && !Object.keys(headersMap).some((key) => key.toLowerCase() === "user-agent"))
            headersMap["User-Agent"] = (0, _userAgent.getUserAgent)();
          const artifactsDir = yield _fs.default.promises.mkdtemp(ARTIFACTS_FOLDER);
          const wsEndpoint = yield urlToWSEndpoint(progress, endpointURL);
          progress.throwIfAborted();
          const chromeTransport = yield _transport.WebSocketTransport.connect(progress, wsEndpoint, headersMap);
          const cleanedUp = new _manualPromise.ManualPromise();
          const doCleanup = () => __async(this, null, function* () {
            yield (0, _fileUtils.removeFolders)([artifactsDir]);
            yield onClose === null || onClose === void 0 ? void 0 : onClose();
            cleanedUp.resolve();
          });
          const doClose = () => __async(this, null, function* () {
            yield chromeTransport.closeAndWait();
            yield cleanedUp;
          });
          const browserProcess = {
            close: doClose,
            kill: doClose
          };
          const browserOptions = __spreadProps(__spreadValues({}, this._playwrightOptions), {
            slowMo: options.slowMo,
            name: "chromium",
            isChromium: true,
            persistent: {
              noDefaultViewport: true
            },
            browserProcess,
            protocolLogger: _helper.helper.debugProtocolLogger(),
            browserLogsCollector: new _debugLogger.RecentLogsCollector(),
            artifactsDir,
            downloadsPath: artifactsDir,
            tracesDir: artifactsDir,
            proxy: {
              server: "per-context"
            }
          });
          progress.throwIfAborted();
          const browser = yield _crBrowser.CRBrowser.connect(chromeTransport, browserOptions);
          browser.on(_browser.Browser.Events.Disconnected, doCleanup);
          return browser;
        });
      }
      _createDevTools() {
        const directory = _registry.registry.findExecutable("chromium").directory;
        return directory ? new _crDevTools.CRDevTools(_path.default.join(directory, "devtools-preferences.json")) : void 0;
      }
      _connectToTransport(transport, options) {
        return __async(this, null, function* () {
          let devtools = this._devtools;
          if (options.__testHookForDevTools) {
            devtools = this._createDevTools();
            yield options.__testHookForDevTools(devtools);
          }
          return _crBrowser.CRBrowser.connect(transport, options, devtools);
        });
      }
      _rewriteStartupError(error) {
        if (error.message.includes("Missing X server"))
          return (0, _stackTrace.rewriteErrorMessage)(error, "\n" + (0, _utils.wrapInASCIIBox)(_browserType.kNoXServerRunningError, 1));
        if (!error.message.includes("crbug.com/357670") && !error.message.includes("No usable sandbox!") && !error.message.includes("crbug.com/638180"))
          return error;
        return (0, _stackTrace.rewriteErrorMessage)(error, [`Chromium sandboxing failed!`, `================================`, `To workaround sandboxing issues, do either of the following:`, `  - (preferred): Configure environment to support sandboxing: https://playwright.dev/docs/troubleshooting`, `  - (alternative): Launch Chromium without sandbox using 'chromiumSandbox: false' option`, `================================`, ``].join("\n"));
      }
      _amendEnvironment(env, userDataDir, executable, browserArguments) {
        return env;
      }
      _attemptToGracefullyCloseBrowser(transport) {
        const message = {
          method: "Browser.close",
          id: _crConnection.kBrowserCloseMessageId,
          params: {}
        };
        transport.send(message);
      }
      _launchWithSeleniumHub(progress, hubUrl, options) {
        return __async(this, null, function* () {
          if (!hubUrl.endsWith("/"))
            hubUrl = hubUrl + "/";
          const args = this._innerDefaultArgs(options);
          args.push("--remote-debugging-port=0");
          const isEdge = options.channel && options.channel.startsWith("msedge");
          let desiredCapabilities = {
            "browserName": isEdge ? "MicrosoftEdge" : "chrome",
            [isEdge ? "ms:edgeOptions" : "goog:chromeOptions"]: {
              args
            }
          };
          try {
            if (process.env.SELENIUM_REMOTE_CAPABILITIES) {
              const parsed = JSON.parse(process.env.SELENIUM_REMOTE_CAPABILITIES);
              desiredCapabilities = __spreadValues(__spreadValues({}, desiredCapabilities), parsed);
              progress.log(`<selenium> using additional capabilities "${process.env.SELENIUM_REMOTE_CAPABILITIES}"`);
            }
          } catch (e) {
            progress.log(`<selenium> ignoring additional capabilities "${process.env.SELENIUM_REMOTE_CAPABILITIES}": ${e}`);
          }
          progress.log(`<selenium> connecting to ${hubUrl}`);
          const response = yield (0, _netUtils.fetchData)({
            url: hubUrl + "session",
            method: "POST",
            data: JSON.stringify({
              desiredCapabilities,
              capabilities: {
                alwaysMatch: desiredCapabilities
              }
            }),
            timeout: progress.timeUntilDeadline()
          }, seleniumErrorHandler);
          const value = JSON.parse(response).value;
          const sessionId = value.sessionId;
          progress.log(`<selenium> connected to sessionId=${sessionId}`);
          const disconnectFromSelenium = () => __async(this, null, function* () {
            progress.log(`<selenium> disconnecting from sessionId=${sessionId}`);
            yield (0, _netUtils.fetchData)({
              url: hubUrl + "session/" + sessionId,
              method: "DELETE"
            }).catch((error) => progress.log(`<error disconnecting from selenium>: ${error}`));
            progress.log(`<selenium> disconnected from sessionId=${sessionId}`);
            _processLauncher.gracefullyCloseSet.delete(disconnectFromSelenium);
          });
          _processLauncher.gracefullyCloseSet.add(disconnectFromSelenium);
          try {
            const capabilities = value.capabilities;
            let endpointURL;
            if (capabilities["se:cdp"]) {
              progress.log(`<selenium> using selenium v4`);
              const endpointURLString = addProtocol(capabilities["se:cdp"]);
              endpointURL = new URL(endpointURLString);
              if (endpointURL.hostname === "localhost" || endpointURL.hostname === "127.0.0.1")
                endpointURL.hostname = new URL(hubUrl).hostname;
              progress.log(`<selenium> retrieved endpoint ${endpointURL.toString()} for sessionId=${sessionId}`);
            } else {
              progress.log(`<selenium> using selenium v3`);
              const maybeChromeOptions = capabilities["goog:chromeOptions"];
              const chromeOptions = maybeChromeOptions && typeof maybeChromeOptions === "object" ? maybeChromeOptions : void 0;
              const debuggerAddress = chromeOptions && typeof chromeOptions.debuggerAddress === "string" ? chromeOptions.debuggerAddress : void 0;
              const chromeOptionsURL = typeof maybeChromeOptions === "string" ? maybeChromeOptions : void 0;
              const endpointURLString = addProtocol(debuggerAddress || chromeOptionsURL);
              progress.log(`<selenium> retrieved endpoint ${endpointURLString} for sessionId=${sessionId}`);
              endpointURL = new URL(endpointURLString);
              if (endpointURL.hostname === "localhost" || endpointURL.hostname === "127.0.0.1") {
                const sessionInfoUrl = new URL(hubUrl).origin + "/grid/api/testsession?session=" + sessionId;
                try {
                  const sessionResponse = yield (0, _netUtils.fetchData)({
                    url: sessionInfoUrl,
                    method: "GET",
                    timeout: progress.timeUntilDeadline()
                  }, seleniumErrorHandler);
                  const proxyId = JSON.parse(sessionResponse).proxyId;
                  endpointURL.hostname = new URL(proxyId).hostname;
                  progress.log(`<selenium> resolved endpoint ip ${endpointURL.toString()} for sessionId=${sessionId}`);
                } catch (e) {
                  progress.log(`<selenium> unable to resolve endpoint ip for sessionId=${sessionId}, running in standalone?`);
                }
              }
            }
            return yield this._connectOverCDPInternal(progress, endpointURL.toString(), {
              slowMo: options.slowMo
            }, disconnectFromSelenium);
          } catch (e) {
            yield disconnectFromSelenium();
            throw e;
          }
        });
      }
      _defaultArgs(options, isPersistent, userDataDir) {
        const chromeArguments = this._innerDefaultArgs(options);
        chromeArguments.push(`--user-data-dir=${userDataDir}`);
        if (options.useWebSocket)
          chromeArguments.push("--remote-debugging-port=0");
        else
          chromeArguments.push("--remote-debugging-pipe");
        if (isPersistent)
          chromeArguments.push("about:blank");
        else
          chromeArguments.push("--no-startup-window");
        return chromeArguments;
      }
      _innerDefaultArgs(options) {
        const {
          args = [],
          proxy
        } = options;
        const userDataDirArg = args.find((arg) => arg.startsWith("--user-data-dir"));
        if (userDataDirArg)
          throw new Error("Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --user-data-dir argument");
        if (args.find((arg) => arg.startsWith("--remote-debugging-pipe")))
          throw new Error("Playwright manages remote debugging connection itself.");
        if (args.find((arg) => !arg.startsWith("-")))
          throw new Error("Arguments can not specify page to be opened");
        const chromeArguments = [...DEFAULT_ARGS];
        if (_os.default.platform() === "darwin")
          chromeArguments.push("--enable-use-zoom-for-dsf=false");
        if (options.devtools)
          chromeArguments.push("--auto-open-devtools-for-tabs");
        if (options.headless) {
          chromeArguments.push("--headless", "--hide-scrollbars", "--mute-audio", "--blink-settings=primaryHoverType=2,availableHoverTypes=2,primaryPointerType=4,availablePointerTypes=4");
        }
        if (options.chromiumSandbox !== true)
          chromeArguments.push("--no-sandbox");
        if (proxy) {
          const proxyURL = new URL(proxy.server);
          const isSocks = proxyURL.protocol === "socks5:";
          if (isSocks && !this._playwrightOptions.socksProxyPort) {
            chromeArguments.push(`--host-resolver-rules="MAP * ~NOTFOUND , EXCLUDE ${proxyURL.hostname}"`);
          }
          chromeArguments.push(`--proxy-server=${proxy.server}`);
          const proxyBypassRules = [];
          if (this._playwrightOptions.socksProxyPort)
            proxyBypassRules.push("<-loopback>");
          if (proxy.bypass)
            proxyBypassRules.push(...proxy.bypass.split(",").map((t) => t.trim()).map((t) => t.startsWith(".") ? "*" + t : t));
          if (!process.env.PLAYWRIGHT_DISABLE_FORCED_CHROMIUM_PROXIED_LOOPBACK && !proxyBypassRules.includes("<-loopback>"))
            proxyBypassRules.push("<-loopback>");
          if (proxyBypassRules.length > 0)
            chromeArguments.push(`--proxy-bypass-list=${proxyBypassRules.join(";")}`);
        }
        chromeArguments.push(...args);
        return chromeArguments;
      }
    };
    exports2.Chromium = Chromium;
    var DEFAULT_ARGS = [
      "--disable-background-networking",
      "--enable-features=NetworkService,NetworkServiceInProcess",
      "--disable-background-timer-throttling",
      "--disable-backgrounding-occluded-windows",
      "--disable-breakpad",
      "--disable-client-side-phishing-detection",
      "--disable-component-extensions-with-background-pages",
      "--disable-default-apps",
      "--disable-dev-shm-usage",
      "--disable-extensions",
      "--disable-features=ImprovedCookieControls,LazyFrameLoading,GlobalMediaControls,DestroyProfileOnBrowserClose,MediaRouter,AcceptCHFrame,AutoExpandDetailsElement,CertificateTransparencyComponentUpdater",
      "--allow-pre-commit-input",
      "--disable-hang-monitor",
      "--disable-ipc-flooding-protection",
      "--disable-popup-blocking",
      "--disable-prompt-on-repost",
      "--disable-renderer-backgrounding",
      "--disable-sync",
      "--force-color-profile=srgb",
      "--metrics-recording-only",
      "--no-first-run",
      "--enable-automation",
      "--password-store=basic",
      "--use-mock-keychain",
      "--no-service-autorun",
      "--export-tagged-pdf"
    ];
    function urlToWSEndpoint(progress, endpointURL) {
      return __async(this, null, function* () {
        if (endpointURL.startsWith("ws"))
          return endpointURL;
        progress.log(`<ws preparing> retrieving websocket url from ${endpointURL}`);
        const httpURL = endpointURL.endsWith("/") ? `${endpointURL}json/version/` : `${endpointURL}/json/version/`;
        const request = endpointURL.startsWith("https") ? _https.default : _http.default;
        const json = yield new Promise((resolve, reject) => {
          request.get(httpURL, (resp) => {
            if (resp.statusCode < 200 || resp.statusCode >= 400) {
              reject(new Error(`Unexpected status ${resp.statusCode} when connecting to ${httpURL}.
This does not look like a DevTools server, try connecting via ws://.`));
            }
            let data = "";
            resp.on("data", (chunk) => data += chunk);
            resp.on("end", () => resolve(data));
          }).on("error", reject);
        });
        return JSON.parse(json).webSocketDebuggerUrl;
      });
    }
    function seleniumErrorHandler(params, response) {
      return __async(this, null, function* () {
        const body = yield (0, _utils.streamToString)(response);
        let message = body;
        try {
          const json = JSON.parse(body);
          message = json.value.localizedMessage || json.value.message;
        } catch (e) {
        }
        return new Error(`Error connecting to Selenium at ${params.url}: ${message}`);
      });
    }
    function addProtocol(url) {
      if (!["ws://", "wss://", "http://", "https://"].some((protocol) => url.startsWith(protocol)))
        return "http://" + url;
      return url;
    }
  }
});

// node_modules/electron/index.js
var require_electron = __commonJS({
  "node_modules/electron/index.js"(exports2, module2) {
    var fs = require("fs");
    var path = require("path");
    var pathFile = path.join(__dirname, "path.txt");
    function getElectronPath() {
      let executablePath;
      if (fs.existsSync(pathFile)) {
        executablePath = fs.readFileSync(pathFile, "utf-8");
      }
      if (process.env.ELECTRON_OVERRIDE_DIST_PATH) {
        return path.join(process.env.ELECTRON_OVERRIDE_DIST_PATH, executablePath || "electron");
      }
      if (executablePath) {
        return path.join(__dirname, "dist", executablePath);
      } else {
        throw new Error("Electron failed to install correctly, please delete node_modules/electron and try installing again");
      }
    }
    module2.exports = getElectronPath();
  }
});

// node_modules/playwright-core/lib/server/electron/electron.js
var require_electron2 = __commonJS({
  "node_modules/playwright-core/lib/server/electron/electron.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ElectronApplication = exports2.Electron = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var _os = _interopRequireDefault(require("os"));
    var _path = _interopRequireDefault(require("path"));
    var _crBrowser = require_crBrowser();
    var _crConnection = require_crConnection();
    var _crExecutionContext = require_crExecutionContext();
    var js = _interopRequireWildcard(require_javascript());
    var _timeoutSettings = require_timeoutSettings();
    var _utils = require_utils();
    var _transport = require_transport2();
    var _processLauncher = require_processLauncher();
    var _browserContext = require_browserContext();
    var _progress = require_progress2();
    var _helper = require_helper();
    var _eventsHelper = require_eventsHelper();
    var readline = _interopRequireWildcard(require("readline"));
    var _debugLogger = require_debugLogger();
    var _instrumentation = require_instrumentation();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ARTIFACTS_FOLDER = _path.default.join(_os.default.tmpdir(), "playwright-artifacts-");
    var ElectronApplication = class extends _instrumentation.SdkObject {
      constructor(parent, browser, nodeConnection, process2) {
        super(parent, "electron-app");
        this._browserContext = void 0;
        this._nodeConnection = void 0;
        this._nodeSession = void 0;
        this._nodeExecutionContext = void 0;
        this._nodeElectronHandlePromise = void 0;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
        this._process = void 0;
        this._process = process2;
        this._browserContext = browser._defaultContext;
        this._browserContext.on(_browserContext.BrowserContext.Events.Close, () => {
          Promise.resolve().then(() => this.emit(ElectronApplication.Events.Close));
        });
        this._nodeConnection = nodeConnection;
        this._nodeSession = nodeConnection.rootSession;
        this._nodeElectronHandlePromise = new Promise((f) => {
          this._nodeSession.on("Runtime.executionContextCreated", (event) => __async(this, null, function* () {
            if (event.context.auxData && event.context.auxData.isDefault) {
              this._nodeExecutionContext = new js.ExecutionContext(this, new _crExecutionContext.CRExecutionContext(this._nodeSession, event.context));
              f(yield js.evaluate(this._nodeExecutionContext, false, `process.mainModule.require('electron')`));
            }
          }));
        });
        this._browserContext.setCustomCloseHandler(() => __async(this, null, function* () {
          const electronHandle = yield this._nodeElectronHandlePromise;
          yield electronHandle.evaluate(({
            app
          }) => app.quit());
        }));
        this._nodeSession.send("Runtime.enable", {}).catch((e) => {
        });
      }
      process() {
        return this._process;
      }
      context() {
        return this._browserContext;
      }
      close() {
        return __async(this, null, function* () {
          const progressController = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), this);
          const closed = progressController.run((progress) => _helper.helper.waitForEvent(progress, this, ElectronApplication.Events.Close).promise);
          yield this._browserContext.close((0, _instrumentation.serverSideCallMetadata)());
          this._nodeConnection.close();
          yield closed;
        });
      }
      browserWindow(page) {
        return __async(this, null, function* () {
          const targetId = page._delegate._targetId;
          const electronHandle = yield this._nodeElectronHandlePromise;
          return yield electronHandle.evaluateHandle(({
            BrowserWindow,
            webContents
          }, targetId2) => {
            const wc = webContents.fromDevToolsTargetId(targetId2);
            return BrowserWindow.fromWebContents(wc);
          }, targetId);
        });
      }
    };
    exports2.ElectronApplication = ElectronApplication;
    ElectronApplication.Events = {
      Close: "close"
    };
    var Electron = class extends _instrumentation.SdkObject {
      constructor(playwrightOptions) {
        super(playwrightOptions.rootSdkObject, "electron");
        this._playwrightOptions = void 0;
        this._playwrightOptions = playwrightOptions;
      }
      launch(options) {
        return __async(this, null, function* () {
          const {
            args = []
          } = options;
          const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), this);
          controller.setLogName("browser");
          return controller.run((progress) => __async(this, null, function* () {
            let app = void 0;
            const electronArguments = ["--inspect=0", "--remote-debugging-port=0", ...args];
            if (_os.default.platform() === "linux") {
              const runningAsRoot = process.geteuid && process.geteuid() === 0;
              if (runningAsRoot && electronArguments.indexOf("--no-sandbox") === -1)
                electronArguments.push("--no-sandbox");
            }
            const artifactsDir = yield _fs.default.promises.mkdtemp(ARTIFACTS_FOLDER);
            const browserLogsCollector = new _debugLogger.RecentLogsCollector();
            const env = options.env ? (0, _processLauncher.envArrayToObject)(options.env) : process.env;
            let command;
            if (options.executablePath) {
              command = options.executablePath;
            } else {
              try {
                command = require_electron();
              } catch (error) {
                if ((error === null || error === void 0 ? void 0 : error.code) === "MODULE_NOT_FOUND") {
                  throw new Error("\n" + (0, _utils.wrapInASCIIBox)(["Electron executablePath not found!", "Please install it using `npm install -D electron` or set the executablePath to your Electron executable."].join("\n"), 1));
                }
                throw error;
              }
            }
            delete env.NODE_OPTIONS;
            const {
              launchedProcess,
              gracefullyClose,
              kill
            } = yield (0, _processLauncher.launchProcess)({
              command,
              args: electronArguments,
              env,
              log: (message) => {
                progress.log(message);
                browserLogsCollector.log(message);
              },
              stdio: "pipe",
              cwd: options.cwd,
              tempDirectories: [artifactsDir],
              attemptToGracefullyClose: () => app.close(),
              handleSIGINT: true,
              handleSIGTERM: true,
              handleSIGHUP: true,
              onExit: () => {
              }
            });
            const waitForXserverError = new Promise((resolve, reject) => __async(this, null, function* () {
              waitForLine(progress, launchedProcess, /Unable to open X display/).then(() => reject(new Error(["Unable to open X display!", `================================`, "Most likely this is because there is no X server available.", "Use 'xvfb-run' on Linux to launch your tests with an emulated display server.", "For example: 'xvfb-run npm run test:e2e'", `================================`, progress.metadata.log].join("\n")))).catch(() => {
              });
            }));
            const nodeMatch = yield waitForLine(progress, launchedProcess, /^Debugger listening on (ws:\/\/.*)$/);
            const nodeTransport = yield _transport.WebSocketTransport.connect(progress, nodeMatch[1]);
            const nodeConnection = new _crConnection.CRConnection(nodeTransport, _helper.helper.debugProtocolLogger(), browserLogsCollector);
            waitForLine(progress, launchedProcess, /Waiting for the debugger to disconnect\.\.\./).then(() => {
              nodeTransport.close();
            }).catch(() => {
            });
            const chromeMatch = yield Promise.race([waitForLine(progress, launchedProcess, /^DevTools listening on (ws:\/\/.*)$/), waitForXserverError]);
            const chromeTransport = yield _transport.WebSocketTransport.connect(progress, chromeMatch[1]);
            const browserProcess = {
              onclose: void 0,
              process: launchedProcess,
              close: gracefullyClose,
              kill
            };
            const contextOptions = __spreadProps(__spreadValues({}, options), {
              noDefaultViewport: true
            });
            const browserOptions = __spreadProps(__spreadValues({}, this._playwrightOptions), {
              name: "electron",
              isChromium: true,
              headful: true,
              persistent: contextOptions,
              browserProcess,
              protocolLogger: _helper.helper.debugProtocolLogger(),
              browserLogsCollector,
              artifactsDir,
              downloadsPath: artifactsDir,
              tracesDir: artifactsDir
            });
            (0, _browserContext.validateBrowserContextOptions)(contextOptions, browserOptions);
            const browser = yield _crBrowser.CRBrowser.connect(chromeTransport, browserOptions);
            app = new ElectronApplication(this, browser, nodeConnection, launchedProcess);
            return app;
          }), _timeoutSettings.TimeoutSettings.timeout(options));
        });
      }
    };
    exports2.Electron = Electron;
    function waitForLine(progress, process2, regex) {
      return new Promise((resolve, reject) => {
        const rl = readline.createInterface({
          input: process2.stderr
        });
        const failError = new Error("Process failed to launch!");
        const listeners = [
          _eventsHelper.eventsHelper.addEventListener(rl, "line", onLine),
          _eventsHelper.eventsHelper.addEventListener(rl, "close", reject.bind(null, failError)),
          _eventsHelper.eventsHelper.addEventListener(process2, "exit", reject.bind(null, failError)),
          _eventsHelper.eventsHelper.addEventListener(process2, "error", reject.bind(null, failError))
        ];
        progress.cleanupWhenAborted(cleanup);
        function onLine(line) {
          const match = line.match(regex);
          if (!match)
            return;
          cleanup();
          resolve(match);
        }
        function cleanup() {
          _eventsHelper.eventsHelper.removeEventListeners(listeners);
        }
      });
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/ffConnection.js
var require_ffConnection = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.kBrowserCloseMessageId = exports2.FFSessionEvents = exports2.FFSession = exports2.FFConnection = exports2.ConnectionEvents = void 0;
    var _events = require("events");
    var _utils = require_utils();
    var _stackTrace = require_stackTrace();
    var _debugLogger = require_debugLogger();
    var _helper = require_helper();
    var _protocolError = require_protocolError();
    var ConnectionEvents = {
      Disconnected: Symbol("Disconnected")
    };
    exports2.ConnectionEvents = ConnectionEvents;
    var kBrowserCloseMessageId = -9999;
    exports2.kBrowserCloseMessageId = kBrowserCloseMessageId;
    var FFConnection = class extends _events.EventEmitter {
      constructor(transport, protocolLogger, browserLogsCollector) {
        super();
        this._lastId = void 0;
        this._callbacks = void 0;
        this._transport = void 0;
        this._protocolLogger = void 0;
        this._browserLogsCollector = void 0;
        this._sessions = void 0;
        this._closed = void 0;
        this.on = void 0;
        this.addListener = void 0;
        this.off = void 0;
        this.removeListener = void 0;
        this.once = void 0;
        this.setMaxListeners(0);
        this._transport = transport;
        this._protocolLogger = protocolLogger;
        this._browserLogsCollector = browserLogsCollector;
        this._lastId = 0;
        this._callbacks = /* @__PURE__ */ new Map();
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this._sessions = /* @__PURE__ */ new Map();
        this._closed = false;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      send(method, params) {
        return __async(this, null, function* () {
          this._checkClosed(method);
          const id = this.nextMessageId();
          this._rawSend({
            id,
            method,
            params
          });
          return new Promise((resolve, reject) => {
            this._callbacks.set(id, {
              resolve,
              reject,
              error: new _protocolError.ProtocolError(false),
              method
            });
          });
        });
      }
      nextMessageId() {
        return ++this._lastId;
      }
      _checkClosed(method) {
        if (this._closed)
          throw new _protocolError.ProtocolError(true, `${method}): Browser closed.` + _helper.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs()));
      }
      _rawSend(message) {
        this._protocolLogger("send", message);
        this._transport.send(message);
      }
      _onMessage(message) {
        return __async(this, null, function* () {
          this._protocolLogger("receive", message);
          if (message.id === kBrowserCloseMessageId)
            return;
          if (message.sessionId) {
            const session = this._sessions.get(message.sessionId);
            if (session)
              session.dispatchMessage(message);
          } else if (message.id) {
            const callback = this._callbacks.get(message.id);
            if (callback) {
              this._callbacks.delete(message.id);
              if (message.error)
                callback.reject(createProtocolError(callback.error, callback.method, message.error));
              else
                callback.resolve(message.result);
            }
          } else {
            Promise.resolve().then(() => this.emit(message.method, message.params));
          }
        });
      }
      _onClose() {
        this._closed = true;
        this._transport.onmessage = void 0;
        this._transport.onclose = void 0;
        const formattedBrowserLogs = _helper.helper.formatBrowserLogs(this._browserLogsCollector.recentLogs());
        for (const session of this._sessions.values())
          session.dispose();
        this._sessions.clear();
        for (const callback of this._callbacks.values()) {
          const error = (0, _stackTrace.rewriteErrorMessage)(callback.error, `Protocol error (${callback.method}): Browser closed.` + formattedBrowserLogs);
          error.sessionClosed = true;
          callback.reject(error);
        }
        this._callbacks.clear();
        Promise.resolve().then(() => this.emit(ConnectionEvents.Disconnected));
      }
      close() {
        if (!this._closed)
          this._transport.close();
      }
      createSession(sessionId) {
        const session = new FFSession(this, sessionId, (message) => this._rawSend(__spreadProps(__spreadValues({}, message), {
          sessionId
        })));
        this._sessions.set(sessionId, session);
        return session;
      }
    };
    exports2.FFConnection = FFConnection;
    var FFSessionEvents = {
      Disconnected: Symbol("Disconnected")
    };
    exports2.FFSessionEvents = FFSessionEvents;
    var FFSession = class extends _events.EventEmitter {
      constructor(connection, sessionId, rawSend) {
        super();
        this._connection = void 0;
        this._disposed = false;
        this._callbacks = void 0;
        this._sessionId = void 0;
        this._rawSend = void 0;
        this._crashed = false;
        this.on = void 0;
        this.addListener = void 0;
        this.off = void 0;
        this.removeListener = void 0;
        this.once = void 0;
        this.setMaxListeners(0);
        this._callbacks = /* @__PURE__ */ new Map();
        this._connection = connection;
        this._sessionId = sessionId;
        this._rawSend = rawSend;
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      markAsCrashed() {
        this._crashed = true;
      }
      send(method, params) {
        return __async(this, null, function* () {
          if (this._crashed)
            throw new _protocolError.ProtocolError(true, "Target crashed");
          this._connection._checkClosed(method);
          if (this._disposed)
            throw new _protocolError.ProtocolError(true, "Target closed");
          const id = this._connection.nextMessageId();
          this._rawSend({
            method,
            params,
            id
          });
          return new Promise((resolve, reject) => {
            this._callbacks.set(id, {
              resolve,
              reject,
              error: new _protocolError.ProtocolError(false),
              method
            });
          });
        });
      }
      sendMayFail(method, params) {
        return this.send(method, params).catch((error) => _debugLogger.debugLogger.log("error", error));
      }
      dispatchMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
          const callback = this._callbacks.get(object.id);
          this._callbacks.delete(object.id);
          if (object.error)
            callback.reject(createProtocolError(callback.error, callback.method, object.error));
          else
            callback.resolve(object.result);
        } else {
          (0, _utils.assert)(!object.id);
          Promise.resolve().then(() => this.emit(object.method, object.params));
        }
      }
      dispose() {
        for (const callback of this._callbacks.values()) {
          callback.error.sessionClosed = true;
          callback.reject((0, _stackTrace.rewriteErrorMessage)(callback.error, "Target closed"));
        }
        this._callbacks.clear();
        this._disposed = true;
        this._connection._sessions.delete(this._sessionId);
        Promise.resolve().then(() => this.emit(FFSessionEvents.Disconnected));
      }
    };
    exports2.FFSession = FFSession;
    function createProtocolError(error, method, protocolError) {
      let message = `Protocol error (${method}): ${protocolError.message}`;
      if ("data" in protocolError)
        message += ` ${protocolError.data}`;
      return (0, _stackTrace.rewriteErrorMessage)(error, message);
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/ffAccessibility.js
var require_ffAccessibility = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffAccessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getAccessibilityTree = getAccessibilityTree;
    function getAccessibilityTree(session, needle) {
      return __async(this, null, function* () {
        const objectId = needle ? needle._objectId : void 0;
        const {
          tree
        } = yield session.send("Accessibility.getFullAXTree", {
          objectId
        });
        const axNode = new FFAXNode(tree);
        return {
          tree: axNode,
          needle: needle ? axNode._findNeedle() : null
        };
      });
    }
    var FFRoleToARIARole = new Map(Object.entries({
      "pushbutton": "button",
      "checkbutton": "checkbox",
      "editcombobox": "combobox",
      "content deletion": "deletion",
      "footnote": "doc-footnote",
      "non-native document": "document",
      "grouping": "group",
      "graphic": "img",
      "content insertion": "insertion",
      "animation": "marquee",
      "flat equation": "math",
      "menupopup": "menu",
      "check menu item": "menuitemcheckbox",
      "radio menu item": "menuitemradio",
      "listbox option": "option",
      "radiobutton": "radio",
      "statusbar": "status",
      "pagetab": "tab",
      "pagetablist": "tablist",
      "propertypage": "tabpanel",
      "entry": "textbox",
      "outline": "tree",
      "tree table": "treegrid",
      "outlineitem": "treeitem"
    }));
    var FFAXNode = class {
      constructor(payload) {
        this._children = void 0;
        this._payload = void 0;
        this._editable = void 0;
        this._richlyEditable = void 0;
        this._focusable = void 0;
        this._expanded = void 0;
        this._name = void 0;
        this._role = void 0;
        this._cachedHasFocusableChild = void 0;
        this._payload = payload;
        this._children = (payload.children || []).map((x) => new FFAXNode(x));
        this._editable = !!payload.editable;
        this._richlyEditable = this._editable && payload.tag !== "textarea" && payload.tag !== "input";
        this._focusable = !!payload.focusable;
        this._expanded = !!payload.expanded;
        this._name = this._payload.name;
        this._role = this._payload.role;
      }
      _isPlainTextField() {
        if (this._richlyEditable)
          return false;
        if (this._editable)
          return true;
        return this._role === "entry";
      }
      _isTextOnlyObject() {
        const role = this._role;
        return role === "text leaf" || role === "text" || role === "statictext";
      }
      _hasFocusableChild() {
        if (this._cachedHasFocusableChild === void 0) {
          this._cachedHasFocusableChild = false;
          for (const child of this._children) {
            if (child._focusable || child._hasFocusableChild()) {
              this._cachedHasFocusableChild = true;
              break;
            }
          }
        }
        return this._cachedHasFocusableChild;
      }
      children() {
        return this._children;
      }
      _findNeedle() {
        if (this._payload.foundObject)
          return this;
        for (const child of this._children) {
          const found = child._findNeedle();
          if (found)
            return found;
        }
        return null;
      }
      isLeafNode() {
        if (!this._children.length)
          return true;
        if (this._isPlainTextField() || this._isTextOnlyObject())
          return true;
        switch (this._role) {
          case "graphic":
          case "scrollbar":
          case "slider":
          case "separator":
          case "progressbar":
            return true;
          default:
            break;
        }
        if (this._hasFocusableChild())
          return false;
        if (this._focusable && this._role !== "document" && this._name)
          return true;
        if (this._role === "heading" && this._name)
          return true;
        return false;
      }
      isControl() {
        switch (this._role) {
          case "checkbutton":
          case "check menu item":
          case "check rich option":
          case "combobox":
          case "combobox option":
          case "color chooser":
          case "listbox":
          case "listbox option":
          case "listbox rich option":
          case "popup menu":
          case "menupopup":
          case "menuitem":
          case "menubar":
          case "button":
          case "pushbutton":
          case "radiobutton":
          case "radio menuitem":
          case "scrollbar":
          case "slider":
          case "spinbutton":
          case "switch":
          case "pagetab":
          case "entry":
          case "tree table":
            return true;
          default:
            return false;
        }
      }
      isInteresting(insideControl) {
        if (this._focusable || this._richlyEditable)
          return true;
        if (this.isControl())
          return true;
        if (insideControl)
          return false;
        return this.isLeafNode() && !!this._name.trim();
      }
      serialize() {
        const node = {
          role: FFRoleToARIARole.get(this._role) || this._role,
          name: this._name || ""
        };
        const userStringProperties = ["name", "description", "roledescription", "valuetext", "keyshortcuts"];
        for (const userStringProperty of userStringProperties) {
          if (!(userStringProperty in this._payload))
            continue;
          node[userStringProperty] = this._payload[userStringProperty];
        }
        const booleanProperties = ["disabled", "expanded", "focused", "modal", "multiline", "multiselectable", "readonly", "required", "selected"];
        for (const booleanProperty of booleanProperties) {
          if (this._role === "document" && booleanProperty === "focused")
            continue;
          const value = this._payload[booleanProperty];
          if (!value)
            continue;
          node[booleanProperty] = value;
        }
        const numericalProperties = ["level"];
        for (const numericalProperty of numericalProperties) {
          if (!(numericalProperty in this._payload))
            continue;
          node[numericalProperty] = this._payload[numericalProperty];
        }
        const tokenProperties = ["autocomplete", "haspopup", "invalid", "orientation"];
        for (const tokenProperty of tokenProperties) {
          const value = this._payload[tokenProperty];
          if (!value || value === "false")
            continue;
          node[tokenProperty] = value;
        }
        const axNode = node;
        axNode.valueString = this._payload.value;
        if ("checked" in this._payload)
          axNode.checked = this._payload.checked === true ? "checked" : this._payload.checked === "mixed" ? "mixed" : "unchecked";
        if ("pressed" in this._payload)
          axNode.pressed = this._payload.pressed === true ? "pressed" : "released";
        return axNode;
      }
    };
  }
});

// node_modules/playwright-core/lib/server/firefox/ffExecutionContext.js
var require_ffExecutionContext = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffExecutionContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FFExecutionContext = void 0;
    var js = _interopRequireWildcard(require_javascript());
    var _stackTrace = require_stackTrace();
    var _utilityScriptSerializers = require_utilityScriptSerializers();
    var _protocolError = require_protocolError();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FFExecutionContext = class {
      constructor(session, executionContextId) {
        this._session = void 0;
        this._executionContextId = void 0;
        this._session = session;
        this._executionContextId = executionContextId;
      }
      rawEvaluateJSON(expression) {
        return __async(this, null, function* () {
          const payload = yield this._session.send("Runtime.evaluate", {
            expression,
            returnByValue: true,
            executionContextId: this._executionContextId
          }).catch(rewriteError);
          checkException(payload.exceptionDetails);
          return payload.result.value;
        });
      }
      rawEvaluateHandle(expression) {
        return __async(this, null, function* () {
          const payload = yield this._session.send("Runtime.evaluate", {
            expression,
            returnByValue: false,
            executionContextId: this._executionContextId
          }).catch(rewriteError);
          checkException(payload.exceptionDetails);
          return payload.result.objectId;
        });
      }
      rawCallFunctionNoReply(func, ...args) {
        this._session.send("Runtime.callFunction", {
          functionDeclaration: func.toString(),
          args: args.map((a) => a instanceof js.JSHandle ? {
            objectId: a._objectId
          } : {
            value: a
          }),
          returnByValue: true,
          executionContextId: this._executionContextId
        }).catch(() => {
        });
      }
      evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        return __async(this, null, function* () {
          const payload = yield this._session.send("Runtime.callFunction", {
            functionDeclaration: expression,
            args: [{
              objectId: utilityScript._objectId,
              value: void 0
            }, ...values.map((value) => ({
              value
            })), ...objectIds.map((objectId) => ({
              objectId,
              value: void 0
            }))],
            returnByValue,
            executionContextId: this._executionContextId
          }).catch(rewriteError);
          checkException(payload.exceptionDetails);
          if (returnByValue)
            return (0, _utilityScriptSerializers.parseEvaluationResultValue)(payload.result.value);
          return utilityScript._context.createHandle(payload.result);
        });
      }
      getProperties(context, objectId) {
        return __async(this, null, function* () {
          const response = yield this._session.send("Runtime.getObjectProperties", {
            executionContextId: this._executionContextId,
            objectId
          });
          const result = /* @__PURE__ */ new Map();
          for (const property of response.properties)
            result.set(property.name, context.createHandle(property.value));
          return result;
        });
      }
      createHandle(context, remoteObject) {
        return new js.JSHandle(context, remoteObject.subtype || remoteObject.type || "", renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
      }
      releaseHandle(objectId) {
        return __async(this, null, function* () {
          yield this._session.send("Runtime.disposeObject", {
            executionContextId: this._executionContextId,
            objectId
          });
        });
      }
    };
    exports2.FFExecutionContext = FFExecutionContext;
    function checkException(exceptionDetails) {
      if (!exceptionDetails)
        return;
      if (exceptionDetails.value)
        throw new js.JavaScriptErrorInEvaluate(JSON.stringify(exceptionDetails.value));
      else
        throw new js.JavaScriptErrorInEvaluate(exceptionDetails.text + (exceptionDetails.stack ? "\n" + exceptionDetails.stack : ""));
    }
    function rewriteError(error) {
      if (error.message.includes("cyclic object value") || error.message.includes("Object is not serializable"))
        return {
          result: {
            type: "undefined",
            value: void 0
          }
        };
      if (error instanceof TypeError && error.message.startsWith("Converting circular structure to JSON"))
        (0, _stackTrace.rewriteErrorMessage)(error, error.message + " Are you passing a nested JSHandle?");
      if (!js.isJavaScriptErrorInEvaluate(error) && !(0, _protocolError.isSessionClosedError)(error))
        throw new Error("Execution context was destroyed, most likely because of a navigation.");
      throw error;
    }
    function potentiallyUnserializableValue(remoteObject) {
      const value = remoteObject.value;
      const unserializableValue = remoteObject.unserializableValue;
      return unserializableValue ? js.parseUnserializableValue(unserializableValue) : value;
    }
    function renderPreview(object) {
      if (object.type === "undefined")
        return "undefined";
      if (object.unserializableValue)
        return String(object.unserializableValue);
      if (object.type === "symbol")
        return "Symbol()";
      if (object.subtype === "regexp")
        return "RegExp";
      if (object.subtype === "weakmap")
        return "WeakMap";
      if (object.subtype === "weakset")
        return "WeakSet";
      if (object.subtype)
        return object.subtype[0].toUpperCase() + object.subtype.slice(1);
      if ("value" in object)
        return String(object.value);
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/ffInput.js
var require_ffInput = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffInput.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RawTouchscreenImpl = exports2.RawMouseImpl = exports2.RawKeyboardImpl = void 0;
    function toModifiersMask(modifiers) {
      let mask = 0;
      if (modifiers.has("Alt"))
        mask |= 1;
      if (modifiers.has("Control"))
        mask |= 2;
      if (modifiers.has("Shift"))
        mask |= 4;
      if (modifiers.has("Meta"))
        mask |= 8;
      return mask;
    }
    function toButtonNumber(button) {
      if (button === "left")
        return 0;
      if (button === "middle")
        return 1;
      if (button === "right")
        return 2;
      return 0;
    }
    function toButtonsMask(buttons) {
      let mask = 0;
      if (buttons.has("left"))
        mask |= 1;
      if (buttons.has("right"))
        mask |= 2;
      if (buttons.has("middle"))
        mask |= 4;
      return mask;
    }
    var RawKeyboardImpl = class {
      constructor(client) {
        this._client = void 0;
        this._client = client;
      }
      keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2, autoRepeat, text) {
        return __async(this, null, function* () {
          if (code === "MetaLeft")
            code = "OSLeft";
          if (code === "MetaRight")
            code = "OSRight";
          if (text === "\r")
            text = "";
          yield this._client.send("Page.dispatchKeyEvent", {
            type: "keydown",
            keyCode: keyCodeWithoutLocation,
            code,
            key,
            repeat: autoRepeat,
            location: location2,
            text
          });
        });
      }
      keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2) {
        return __async(this, null, function* () {
          if (code === "MetaLeft")
            code = "OSLeft";
          if (code === "MetaRight")
            code = "OSRight";
          yield this._client.send("Page.dispatchKeyEvent", {
            type: "keyup",
            key,
            keyCode: keyCodeWithoutLocation,
            code,
            location: location2,
            repeat: false
          });
        });
      }
      sendText(text) {
        return __async(this, null, function* () {
          yield this._client.send("Page.insertText", {
            text
          });
        });
      }
    };
    exports2.RawKeyboardImpl = RawKeyboardImpl;
    var RawMouseImpl = class {
      constructor(client) {
        this._client = void 0;
        this._page = void 0;
        this._client = client;
      }
      move(x, y, button, buttons, modifiers, forClick) {
        return __async(this, null, function* () {
          yield this._client.send("Page.dispatchMouseEvent", {
            type: "mousemove",
            button: 0,
            buttons: toButtonsMask(buttons),
            x: Math.floor(x),
            y: Math.floor(y),
            modifiers: toModifiersMask(modifiers)
          });
        });
      }
      down(x, y, button, buttons, modifiers, clickCount) {
        return __async(this, null, function* () {
          yield this._client.send("Page.dispatchMouseEvent", {
            type: "mousedown",
            button: toButtonNumber(button),
            buttons: toButtonsMask(buttons),
            x: Math.floor(x),
            y: Math.floor(y),
            modifiers: toModifiersMask(modifiers),
            clickCount
          });
        });
      }
      up(x, y, button, buttons, modifiers, clickCount) {
        return __async(this, null, function* () {
          yield this._client.send("Page.dispatchMouseEvent", {
            type: "mouseup",
            button: toButtonNumber(button),
            buttons: toButtonsMask(buttons),
            x: Math.floor(x),
            y: Math.floor(y),
            modifiers: toModifiersMask(modifiers),
            clickCount
          });
        });
      }
      wheel(x, y, buttons, modifiers, deltaX, deltaY) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(`new Promise(requestAnimationFrame)`, false, false, "utility");
          yield this._client.send("Page.dispatchWheelEvent", {
            deltaX,
            deltaY,
            x: Math.floor(x),
            y: Math.floor(y),
            deltaZ: 0,
            modifiers: toModifiersMask(modifiers)
          });
        });
      }
      setPage(page) {
        this._page = page;
      }
    };
    exports2.RawMouseImpl = RawMouseImpl;
    var RawTouchscreenImpl = class {
      constructor(client) {
        this._client = void 0;
        this._client = client;
      }
      tap(x, y, modifiers) {
        return __async(this, null, function* () {
          yield this._client.send("Page.dispatchTapEvent", {
            x,
            y,
            modifiers: toModifiersMask(modifiers)
          });
        });
      }
    };
    exports2.RawTouchscreenImpl = RawTouchscreenImpl;
  }
});

// node_modules/playwright-core/lib/server/firefox/ffNetworkManager.js
var require_ffNetworkManager = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffNetworkManager.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FFNetworkManager = void 0;
    var _eventsHelper = require_eventsHelper();
    var network = _interopRequireWildcard(require_network());
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FFNetworkManager = class {
      constructor(session, page) {
        this._session = void 0;
        this._requests = void 0;
        this._page = void 0;
        this._eventListeners = void 0;
        this._session = session;
        this._requests = /* @__PURE__ */ new Map();
        this._page = page;
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(session, "Network.requestWillBeSent", this._onRequestWillBeSent.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.responseReceived", this._onResponseReceived.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestFinished", this._onRequestFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestFailed", this._onRequestFailed.bind(this))];
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
      }
      setRequestInterception(enabled) {
        return __async(this, null, function* () {
          yield this._session.send("Network.setRequestInterception", {
            enabled
          });
        });
      }
      _onRequestWillBeSent(event) {
        const redirectedFrom = event.redirectedFrom ? this._requests.get(event.redirectedFrom) || null : null;
        const frame = redirectedFrom ? redirectedFrom.request.frame() : event.frameId ? this._page._frameManager.frame(event.frameId) : null;
        if (!frame)
          return;
        if (redirectedFrom)
          this._requests.delete(redirectedFrom._id);
        const request = new InterceptableRequest(frame, redirectedFrom, event);
        let route;
        if (event.isIntercepted)
          route = new FFRouteImpl(this._session, request);
        this._requests.set(request._id, request);
        this._page._frameManager.requestStarted(request.request, route);
      }
      _onResponseReceived(event) {
        var _event$securityDetail, _event$securityDetail2, _event$securityDetail3, _event$securityDetail4, _event$securityDetail5;
        const request = this._requests.get(event.requestId);
        if (!request)
          return;
        const getResponseBody = () => __async(this, null, function* () {
          const response2 = yield this._session.send("Network.getResponseBody", {
            requestId: request._id
          });
          if (response2.evicted)
            throw new Error(`Response body for ${request.request.method()} ${request.request.url()} was evicted!`);
          return Buffer.from(response2.base64body, "base64");
        });
        const startTime = event.timing.startTime;
        function relativeToStart(time) {
          if (!time)
            return -1;
          return (time - startTime) / 1e3;
        }
        const timing = {
          startTime: startTime / 1e3,
          domainLookupStart: relativeToStart(event.timing.domainLookupStart),
          domainLookupEnd: relativeToStart(event.timing.domainLookupEnd),
          connectStart: relativeToStart(event.timing.connectStart),
          secureConnectionStart: relativeToStart(event.timing.secureConnectionStart),
          connectEnd: relativeToStart(event.timing.connectEnd),
          requestStart: relativeToStart(event.timing.requestStart),
          responseStart: relativeToStart(event.timing.responseStart)
        };
        const response = new network.Response(request.request, event.status, event.statusText, parseMultivalueHeaders(event.headers), timing, getResponseBody);
        if (event !== null && event !== void 0 && event.remoteIPAddress && typeof (event === null || event === void 0 ? void 0 : event.remotePort) === "number") {
          response._serverAddrFinished({
            ipAddress: event.remoteIPAddress,
            port: event.remotePort
          });
        } else {
          response._serverAddrFinished();
        }
        response._securityDetailsFinished({
          protocol: event === null || event === void 0 ? void 0 : (_event$securityDetail = event.securityDetails) === null || _event$securityDetail === void 0 ? void 0 : _event$securityDetail.protocol,
          subjectName: event === null || event === void 0 ? void 0 : (_event$securityDetail2 = event.securityDetails) === null || _event$securityDetail2 === void 0 ? void 0 : _event$securityDetail2.subjectName,
          issuer: event === null || event === void 0 ? void 0 : (_event$securityDetail3 = event.securityDetails) === null || _event$securityDetail3 === void 0 ? void 0 : _event$securityDetail3.issuer,
          validFrom: event === null || event === void 0 ? void 0 : (_event$securityDetail4 = event.securityDetails) === null || _event$securityDetail4 === void 0 ? void 0 : _event$securityDetail4.validFrom,
          validTo: event === null || event === void 0 ? void 0 : (_event$securityDetail5 = event.securityDetails) === null || _event$securityDetail5 === void 0 ? void 0 : _event$securityDetail5.validTo
        });
        this._page._frameManager.requestReceivedResponse(response);
      }
      _onRequestFinished(event) {
        const request = this._requests.get(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        request.request.responseSize.transferSize = event.transferSize;
        const isRedirected = response.status() >= 300 && response.status() <= 399;
        const responseEndTime = event.responseEndTime ? event.responseEndTime / 1e3 - response.timing().startTime : -1;
        if (isRedirected) {
          response._requestFinished(responseEndTime);
        } else {
          this._requests.delete(request._id);
          response._requestFinished(responseEndTime);
        }
        if (event.protocolVersion)
          response._setHttpVersion(event.protocolVersion);
        this._page._frameManager.reportRequestFinished(request.request, response);
      }
      _onRequestFailed(event) {
        const request = this._requests.get(event.requestId);
        if (!request)
          return;
        this._requests.delete(request._id);
        const response = request.request._existingResponse();
        if (response)
          response._requestFinished(-1);
        request.request._setFailureText(event.errorCode);
        this._page._frameManager.requestFailed(request.request, event.errorCode === "NS_BINDING_ABORTED");
      }
    };
    exports2.FFNetworkManager = FFNetworkManager;
    var causeToResourceType = {
      TYPE_INVALID: "other",
      TYPE_OTHER: "other",
      TYPE_SCRIPT: "script",
      TYPE_IMAGE: "image",
      TYPE_STYLESHEET: "stylesheet",
      TYPE_OBJECT: "other",
      TYPE_DOCUMENT: "document",
      TYPE_SUBDOCUMENT: "document",
      TYPE_REFRESH: "document",
      TYPE_XBL: "other",
      TYPE_PING: "other",
      TYPE_XMLHTTPREQUEST: "xhr",
      TYPE_OBJECT_SUBREQUEST: "other",
      TYPE_DTD: "other",
      TYPE_FONT: "font",
      TYPE_MEDIA: "media",
      TYPE_WEBSOCKET: "websocket",
      TYPE_CSP_REPORT: "other",
      TYPE_XSLT: "other",
      TYPE_BEACON: "other",
      TYPE_FETCH: "fetch",
      TYPE_IMAGESET: "images",
      TYPE_WEB_MANIFEST: "manifest"
    };
    var internalCauseToResourceType = {
      TYPE_INTERNAL_EVENTSOURCE: "eventsource"
    };
    var InterceptableRequest = class {
      constructor(frame, redirectedFrom, payload) {
        this.request = void 0;
        this._id = void 0;
        this._redirectedTo = void 0;
        this._id = payload.requestId;
        if (redirectedFrom)
          redirectedFrom._redirectedTo = this;
        let postDataBuffer = null;
        if (payload.postData)
          postDataBuffer = Buffer.from(payload.postData, "base64");
        this.request = new network.Request(frame, redirectedFrom ? redirectedFrom.request : null, payload.navigationId, payload.url, internalCauseToResourceType[payload.internalCause] || causeToResourceType[payload.cause] || "other", payload.method, postDataBuffer, payload.headers);
      }
      _finalRequest() {
        let request = this;
        while (request._redirectedTo)
          request = request._redirectedTo;
        return request;
      }
    };
    var FFRouteImpl = class {
      constructor(session, request) {
        this._request = void 0;
        this._session = void 0;
        this._session = session;
        this._request = request;
      }
      continue(request, overrides) {
        return __async(this, null, function* () {
          yield this._session.sendMayFail("Network.resumeInterceptedRequest", {
            requestId: this._request._id,
            url: overrides.url,
            method: overrides.method,
            headers: overrides.headers,
            postData: overrides.postData ? Buffer.from(overrides.postData).toString("base64") : void 0
          });
        });
      }
      fulfill(response) {
        return __async(this, null, function* () {
          const base64body = response.isBase64 ? response.body : Buffer.from(response.body).toString("base64");
          yield this._session.sendMayFail("Network.fulfillInterceptedRequest", {
            requestId: this._request._id,
            status: response.status,
            statusText: network.STATUS_TEXTS[String(response.status)] || "",
            headers: response.headers,
            base64body
          });
        });
      }
      abort(errorCode) {
        return __async(this, null, function* () {
          yield this._session.sendMayFail("Network.abortInterceptedRequest", {
            requestId: this._request._id,
            errorCode
          });
        });
      }
    };
    function parseMultivalueHeaders(headers) {
      const result = [];
      for (const header of headers) {
        const separator = header.name.toLowerCase() === "set-cookie" ? "\n" : ",";
        const tokens = header.value.split(separator).map((s) => s.trim());
        for (const token of tokens)
          result.push({
            name: header.name,
            value: token
          });
      }
      return result;
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/ffPage.js
var require_ffPage = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffPage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.UTILITY_WORLD_NAME = exports2.FFPage = void 0;
    var dialog = _interopRequireWildcard(require_dialog());
    var dom = _interopRequireWildcard(require_dom());
    var _eventsHelper = require_eventsHelper();
    var _utils = require_utils();
    var _page = require_page();
    var _ffAccessibility = require_ffAccessibility();
    var _ffConnection = require_ffConnection();
    var _ffExecutionContext = require_ffExecutionContext();
    var _ffInput = require_ffInput();
    var _ffNetworkManager = require_ffNetworkManager();
    var _stackTrace = require_stackTrace();
    var _debugLogger = require_debugLogger();
    var _manualPromise = require_manualPromise();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var UTILITY_WORLD_NAME = "__playwright_utility_world__";
    exports2.UTILITY_WORLD_NAME = UTILITY_WORLD_NAME;
    var FFPage = class {
      constructor(session, browserContext, opener) {
        this.cspErrorsAsynchronousForInlineScipts = true;
        this.rawMouse = void 0;
        this.rawKeyboard = void 0;
        this.rawTouchscreen = void 0;
        this._session = void 0;
        this._page = void 0;
        this._networkManager = void 0;
        this._browserContext = void 0;
        this._pagePromise = new _manualPromise.ManualPromise();
        this._initializedPage = null;
        this._initializationFailed = false;
        this._opener = void 0;
        this._contextIdToContext = void 0;
        this._eventListeners = void 0;
        this._workers = /* @__PURE__ */ new Map();
        this._screencastId = void 0;
        this._initScripts = [];
        this._session = session;
        this._opener = opener;
        this.rawKeyboard = new _ffInput.RawKeyboardImpl(session);
        this.rawMouse = new _ffInput.RawMouseImpl(session);
        this.rawTouchscreen = new _ffInput.RawTouchscreenImpl(session);
        this._contextIdToContext = /* @__PURE__ */ new Map();
        this._browserContext = browserContext;
        this._page = new _page.Page(this, browserContext);
        this.rawMouse.setPage(this._page);
        this._networkManager = new _ffNetworkManager.FFNetworkManager(session, this._page);
        this._page.on(_page.Page.Events.FrameDetached, (frame) => this._removeContextsForFrame(frame));
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._session, "Page.eventFired", this._onEventFired.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameAttached", this._onFrameAttached.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameDetached", this._onFrameDetached.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.navigationAborted", this._onNavigationAborted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.navigationCommitted", this._onNavigationCommitted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.navigationStarted", this._onNavigationStarted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.sameDocumentNavigation", this._onSameDocumentNavigation.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Runtime.executionContextCreated", this._onExecutionContextCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Runtime.executionContextDestroyed", this._onExecutionContextDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.linkClicked", (event) => this._onLinkClicked(event.phase)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.uncaughtError", this._onUncaughtError.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Runtime.console", this._onConsole.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.dialogOpened", this._onDialogOpened.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.bindingCalled", this._onBindingCalled.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.fileChooserOpened", this._onFileChooserOpened.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.workerCreated", this._onWorkerCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.workerDestroyed", this._onWorkerDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.dispatchMessageFromWorker", this._onDispatchMessageFromWorker.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.crashed", this._onCrashed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.videoRecordingStarted", this._onVideoRecordingStarted.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.webSocketCreated", this._onWebSocketCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.webSocketClosed", this._onWebSocketClosed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.webSocketFrameReceived", this._onWebSocketFrameReceived.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.webSocketFrameSent", this._onWebSocketFrameSent.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.screencastFrame", this._onScreencastFrame.bind(this))];
        session.once(_ffConnection.FFSessionEvents.Disconnected, () => {
          this._markAsError(new Error("Page closed"));
          this._page._didDisconnect();
        });
        this._session.once("Page.ready", () => __async(this, null, function* () {
          yield this._page.initOpener(this._opener);
          if (this._initializationFailed)
            return;
          this._initializedPage = this._page;
          this._page.reportAsNew();
          this._pagePromise.resolve(this._page);
        }));
        this.addInitScript("", UTILITY_WORLD_NAME).catch((e) => this._markAsError(e));
      }
      potentiallyUninitializedPage() {
        return this._page;
      }
      _markAsError(error) {
        return __async(this, null, function* () {
          if (this._initializationFailed)
            return;
          this._initializationFailed = true;
          if (!this._initializedPage) {
            yield this._page.initOpener(this._opener);
            this._page.reportAsNew(error);
            this._pagePromise.resolve(error);
          }
        });
      }
      pageOrError() {
        return __async(this, null, function* () {
          return this._pagePromise;
        });
      }
      _onWebSocketCreated(event) {
        this._page._frameManager.onWebSocketCreated(webSocketId(event.frameId, event.wsid), event.requestURL);
        this._page._frameManager.onWebSocketRequest(webSocketId(event.frameId, event.wsid));
      }
      _onWebSocketClosed(event) {
        if (event.error)
          this._page._frameManager.webSocketError(webSocketId(event.frameId, event.wsid), event.error);
        this._page._frameManager.webSocketClosed(webSocketId(event.frameId, event.wsid));
      }
      _onWebSocketFrameReceived(event) {
        this._page._frameManager.webSocketFrameReceived(webSocketId(event.frameId, event.wsid), event.opcode, event.data);
      }
      _onWebSocketFrameSent(event) {
        this._page._frameManager.onWebSocketFrameSent(webSocketId(event.frameId, event.wsid), event.opcode, event.data);
      }
      _onExecutionContextCreated(payload) {
        const {
          executionContextId,
          auxData
        } = payload;
        const frame = this._page._frameManager.frame(auxData.frameId);
        if (!frame)
          return;
        const delegate = new _ffExecutionContext.FFExecutionContext(this._session, executionContextId);
        let worldName = null;
        if (auxData.name === UTILITY_WORLD_NAME)
          worldName = "utility";
        else if (!auxData.name)
          worldName = "main";
        const context = new dom.FrameExecutionContext(delegate, frame, worldName);
        context[contextDelegateSymbol] = delegate;
        if (worldName)
          frame._contextCreated(worldName, context);
        this._contextIdToContext.set(executionContextId, context);
      }
      _onExecutionContextDestroyed(payload) {
        const {
          executionContextId
        } = payload;
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
          return;
        this._contextIdToContext.delete(executionContextId);
        context.frame._contextDestroyed(context);
      }
      _removeContextsForFrame(frame) {
        for (const [contextId, context] of this._contextIdToContext) {
          if (context.frame === frame)
            this._contextIdToContext.delete(contextId);
        }
      }
      _onLinkClicked(phase) {
        if (phase === "before")
          this._page._frameManager.frameWillPotentiallyRequestNavigation();
        else
          this._page._frameManager.frameDidPotentiallyRequestNavigation();
      }
      _onNavigationStarted(params) {
        this._page._frameManager.frameRequestedNavigation(params.frameId, params.navigationId);
      }
      _onNavigationAborted(params) {
        this._page._frameManager.frameAbortedNavigation(params.frameId, params.errorText, params.navigationId);
      }
      _onNavigationCommitted(params) {
        for (const [workerId, worker] of this._workers) {
          if (worker.frameId === params.frameId)
            this._onWorkerDestroyed({
              workerId
            });
        }
        this._page._frameManager.frameCommittedNewDocumentNavigation(params.frameId, params.url, params.name || "", params.navigationId || "", false);
      }
      _onSameDocumentNavigation(params) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(params.frameId, params.url);
      }
      _onFrameAttached(params) {
        this._page._frameManager.frameAttached(params.frameId, params.parentFrameId);
      }
      _onFrameDetached(params) {
        this._page._frameManager.frameDetached(params.frameId);
      }
      _onEventFired(payload) {
        const {
          frameId,
          name
        } = payload;
        if (name === "load")
          this._page._frameManager.frameLifecycleEvent(frameId, "load");
        if (name === "DOMContentLoaded")
          this._page._frameManager.frameLifecycleEvent(frameId, "domcontentloaded");
      }
      _onUncaughtError(params) {
        const {
          name,
          message
        } = (0, _stackTrace.splitErrorMessage)(params.message);
        const error = new Error(message);
        error.stack = params.message + "\n" + params.stack.split("\n").filter(Boolean).map((a) => a.replace(/([^@]*)@(.*)/, "    at $1 ($2)")).join("\n");
        error.name = name;
        this._page.firePageError(error);
      }
      _onConsole(payload) {
        const {
          type,
          args,
          executionContextId,
          location: location2
        } = payload;
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
          return;
        this._page._addConsoleMessage(type, args.map((arg) => context.createHandle(arg)), location2);
      }
      _onDialogOpened(params) {
        this._page.emit(_page.Page.Events.Dialog, new dialog.Dialog(this._page, params.type, params.message, (accept, promptText) => __async(this, null, function* () {
          yield this._session.sendMayFail("Page.handleDialog", {
            dialogId: params.dialogId,
            accept,
            promptText
          });
        }), params.defaultValue));
      }
      _onBindingCalled(event) {
        return __async(this, null, function* () {
          const pageOrError = yield this.pageOrError();
          if (!(pageOrError instanceof Error)) {
            const context = this._contextIdToContext.get(event.executionContextId);
            if (context)
              yield this._page._onBindingCalled(event.payload, context);
          }
        });
      }
      _onFileChooserOpened(payload) {
        return __async(this, null, function* () {
          const {
            executionContextId,
            element
          } = payload;
          const context = this._contextIdToContext.get(executionContextId);
          if (!context)
            return;
          const handle = context.createHandle(element).asElement();
          yield this._page._onFileChooserOpened(handle);
        });
      }
      _onWorkerCreated(event) {
        return __async(this, null, function* () {
          const workerId = event.workerId;
          const worker = new _page.Worker(this._page, event.url);
          const workerSession = new _ffConnection.FFSession(this._session._connection, workerId, (message) => {
            this._session.send("Page.sendMessageToWorker", {
              frameId: event.frameId,
              workerId,
              message: JSON.stringify(message)
            }).catch((e) => {
              workerSession.dispatchMessage({
                id: message.id,
                method: "",
                params: {},
                error: {
                  message: e.message,
                  data: void 0
                }
              });
            });
          });
          this._workers.set(workerId, {
            session: workerSession,
            frameId: event.frameId
          });
          this._page._addWorker(workerId, worker);
          workerSession.once("Runtime.executionContextCreated", (event2) => {
            worker._createExecutionContext(new _ffExecutionContext.FFExecutionContext(workerSession, event2.executionContextId));
          });
          workerSession.on("Runtime.console", (event2) => {
            const {
              type,
              args,
              location: location2
            } = event2;
            const context = worker._existingExecutionContext;
            this._page._addConsoleMessage(type, args.map((arg) => context.createHandle(arg)), location2);
          });
        });
      }
      _onWorkerDestroyed(event) {
        const workerId = event.workerId;
        const worker = this._workers.get(workerId);
        if (!worker)
          return;
        worker.session.dispose();
        this._workers.delete(workerId);
        this._page._removeWorker(workerId);
      }
      _onDispatchMessageFromWorker(event) {
        return __async(this, null, function* () {
          const worker = this._workers.get(event.workerId);
          if (!worker)
            return;
          worker.session.dispatchMessage(JSON.parse(event.message));
        });
      }
      _onCrashed(event) {
        return __async(this, null, function* () {
          this._session.markAsCrashed();
          this._page._didCrash();
        });
      }
      _onVideoRecordingStarted(event) {
        this._browserContext._browser._videoStarted(this._browserContext, event.screencastId, event.file, this.pageOrError());
      }
      exposeBinding(binding) {
        return __async(this, null, function* () {
          yield this._session.send("Page.addBinding", {
            name: binding.name,
            script: binding.source
          });
        });
      }
      removeExposedBindings() {
        return __async(this, null, function* () {
        });
      }
      didClose() {
        this._session.dispose();
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        this._networkManager.dispose();
        this._page._didClose();
      }
      navigateFrame(frame, url, referer) {
        return __async(this, null, function* () {
          const response = yield this._session.send("Page.navigate", {
            url,
            referer,
            frameId: frame._id
          });
          return {
            newDocumentId: response.navigationId || void 0
          };
        });
      }
      updateExtraHTTPHeaders() {
        return __async(this, null, function* () {
          yield this._session.send("Network.setExtraHTTPHeaders", {
            headers: this._page._state.extraHTTPHeaders || []
          });
        });
      }
      setEmulatedSize(emulatedSize) {
        return __async(this, null, function* () {
          (0, _utils.assert)(this._page._state.emulatedSize === emulatedSize);
          yield this._session.send("Page.setViewportSize", {
            viewportSize: {
              width: emulatedSize.viewport.width,
              height: emulatedSize.viewport.height
            }
          });
        });
      }
      bringToFront() {
        return __async(this, null, function* () {
          yield this._session.send("Page.bringToFront", {});
        });
      }
      updateEmulateMedia() {
        return __async(this, null, function* () {
          const colorScheme = this._page._state.colorScheme === null ? void 0 : this._page._state.colorScheme;
          const reducedMotion = this._page._state.reducedMotion === null ? void 0 : this._page._state.reducedMotion;
          const forcedColors = this._page._state.forcedColors === null ? void 0 : this._page._state.forcedColors;
          yield this._session.send("Page.setEmulatedMedia", {
            type: this._page._state.mediaType === null ? "" : this._page._state.mediaType,
            colorScheme,
            reducedMotion,
            forcedColors
          });
        });
      }
      updateRequestInterception() {
        return __async(this, null, function* () {
          yield this._networkManager.setRequestInterception(this._page._needsRequestInterception());
        });
      }
      setFileChooserIntercepted(enabled) {
        return __async(this, null, function* () {
          yield this._session.send("Page.setInterceptFileChooserDialog", {
            enabled
          }).catch((e) => {
          });
        });
      }
      reload() {
        return __async(this, null, function* () {
          yield this._session.send("Page.reload", {
            frameId: this._page.mainFrame()._id
          });
        });
      }
      goBack() {
        return __async(this, null, function* () {
          const {
            success
          } = yield this._session.send("Page.goBack", {
            frameId: this._page.mainFrame()._id
          });
          return success;
        });
      }
      goForward() {
        return __async(this, null, function* () {
          const {
            success
          } = yield this._session.send("Page.goForward", {
            frameId: this._page.mainFrame()._id
          });
          return success;
        });
      }
      addInitScript(script, worldName) {
        return __async(this, null, function* () {
          this._initScripts.push({
            script,
            worldName
          });
          yield this._session.send("Page.setInitScripts", {
            scripts: this._initScripts
          });
        });
      }
      removeInitScripts() {
        return __async(this, null, function* () {
          this._initScripts = [];
          yield this._session.send("Page.setInitScripts", {
            scripts: []
          });
        });
      }
      closePage(runBeforeUnload) {
        return __async(this, null, function* () {
          yield this._session.send("Page.close", {
            runBeforeUnload
          });
        });
      }
      setBackgroundColor(color) {
        return __async(this, null, function* () {
          if (color)
            throw new Error("Not implemented");
        });
      }
      takeScreenshot(progress, format, documentRect, viewportRect, quality, fitsViewport, scale) {
        return __async(this, null, function* () {
          if (!documentRect) {
            const scrollOffset = yield this._page.mainFrame().waitForFunctionValueInUtility(progress, () => ({
              x: window.scrollX,
              y: window.scrollY
            }));
            documentRect = {
              x: viewportRect.x + scrollOffset.x,
              y: viewportRect.y + scrollOffset.y,
              width: viewportRect.width,
              height: viewportRect.height
            };
          }
          progress.throwIfAborted();
          const {
            data
          } = yield this._session.send("Page.screenshot", {
            mimeType: "image/" + format,
            clip: documentRect,
            omitDeviceScaleFactor: scale === "css"
          });
          return Buffer.from(data, "base64");
        });
      }
      getContentFrame(handle) {
        return __async(this, null, function* () {
          const {
            contentFrameId
          } = yield this._session.send("Page.describeNode", {
            frameId: handle._context.frame._id,
            objectId: handle._objectId
          });
          if (!contentFrameId)
            return null;
          return this._page._frameManager.frame(contentFrameId);
        });
      }
      getOwnerFrame(handle) {
        return __async(this, null, function* () {
          const {
            ownerFrameId
          } = yield this._session.send("Page.describeNode", {
            frameId: handle._context.frame._id,
            objectId: handle._objectId
          });
          return ownerFrameId || null;
        });
      }
      isElementHandle(remoteObject) {
        return remoteObject.subtype === "node";
      }
      getBoundingBox(handle) {
        return __async(this, null, function* () {
          const quads = yield this.getContentQuads(handle);
          if (!quads || !quads.length)
            return null;
          let minX = Infinity;
          let maxX = -Infinity;
          let minY = Infinity;
          let maxY = -Infinity;
          for (const quad of quads) {
            for (const point of quad) {
              minX = Math.min(minX, point.x);
              maxX = Math.max(maxX, point.x);
              minY = Math.min(minY, point.y);
              maxY = Math.max(maxY, point.y);
            }
          }
          return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
          };
        });
      }
      scrollRectIntoViewIfNeeded(handle, rect) {
        return __async(this, null, function* () {
          return yield this._session.send("Page.scrollIntoViewIfNeeded", {
            frameId: handle._context.frame._id,
            objectId: handle._objectId,
            rect
          }).then(() => "done").catch((e) => {
            if (e instanceof Error && e.message.includes("Node is detached from document"))
              return "error:notconnected";
            if (e instanceof Error && e.message.includes("Node does not have a layout object"))
              return "error:notvisible";
            throw e;
          });
        });
      }
      setScreencastOptions(options) {
        return __async(this, null, function* () {
          if (options) {
            const {
              screencastId
            } = yield this._session.send("Page.startScreencast", options);
            this._screencastId = screencastId;
          } else {
            yield this._session.send("Page.stopScreencast");
          }
        });
      }
      _onScreencastFrame(event) {
        if (!this._screencastId)
          return;
        const screencastId = this._screencastId;
        this._page.throttleScreencastFrameAck(() => {
          this._session.send("Page.screencastFrameAck", {
            screencastId
          }).catch((e) => _debugLogger.debugLogger.log("error", e));
        });
        const buffer = Buffer.from(event.data, "base64");
        this._page.emit(_page.Page.Events.ScreencastFrame, {
          buffer,
          width: event.deviceWidth,
          height: event.deviceHeight
        });
      }
      rafCountForStablePosition() {
        return 1;
      }
      getContentQuads(handle) {
        return __async(this, null, function* () {
          const result = yield this._session.sendMayFail("Page.getContentQuads", {
            frameId: handle._context.frame._id,
            objectId: handle._objectId
          });
          if (!result)
            return null;
          return result.quads.map((quad) => [quad.p1, quad.p2, quad.p3, quad.p4]);
        });
      }
      setInputFiles(handle, files) {
        return __async(this, null, function* () {
          yield handle.evaluateInUtility(([injected, node, files2]) => injected.setInputFiles(node, files2), files);
        });
      }
      setInputFilePaths(handle, files) {
        return __async(this, null, function* () {
          yield Promise.all([this._session.send("Page.setFileInputFiles", {
            frameId: handle._context.frame._id,
            objectId: handle._objectId,
            files
          }), handle.dispatchEvent("input"), handle.dispatchEvent("change")]);
        });
      }
      adoptElementHandle(handle, to) {
        return __async(this, null, function* () {
          const result = yield this._session.send("Page.adoptNode", {
            frameId: handle._context.frame._id,
            objectId: handle._objectId,
            executionContextId: to[contextDelegateSymbol]._executionContextId
          });
          if (!result.remoteObject)
            throw new Error(dom.kUnableToAdoptErrorMessage);
          return to.createHandle(result.remoteObject);
        });
      }
      getAccessibilityTree(needle) {
        return __async(this, null, function* () {
          return (0, _ffAccessibility.getAccessibilityTree)(this._session, needle);
        });
      }
      inputActionEpilogue() {
        return __async(this, null, function* () {
        });
      }
      getFrameElement(frame) {
        return __async(this, null, function* () {
          const parent = frame.parentFrame();
          if (!parent)
            throw new Error("Frame has been detached.");
          const info = this._page.parseSelector("frame,iframe");
          const handles = yield this._page.selectors._queryAll(parent, info);
          const items = yield Promise.all(handles.map((handle) => __async(this, null, function* () {
            const frame2 = yield handle.contentFrame().catch((e) => null);
            return {
              handle,
              frame: frame2
            };
          })));
          const result = items.find((item) => item.frame === frame);
          items.map((item) => item === result ? Promise.resolve() : item.handle.dispose());
          if (!result)
            throw new Error("Frame has been detached.");
          return result.handle;
        });
      }
    };
    exports2.FFPage = FFPage;
    function webSocketId(frameId, wsid) {
      return `${frameId}---${wsid}`;
    }
    var contextDelegateSymbol = Symbol("delegate");
  }
});

// node_modules/playwright-core/lib/server/firefox/ffBrowser.js
var require_ffBrowser = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/ffBrowser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FFBrowserContext = exports2.FFBrowser = void 0;
    var _errors = require_errors();
    var _utils = require_utils();
    var _browser = require_browser3();
    var _browserContext = require_browserContext();
    var network = _interopRequireWildcard(require_network());
    var _ffConnection = require_ffConnection();
    var _ffPage = require_ffPage();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var FFBrowser = class extends _browser.Browser {
      static connect(transport, options) {
        return __async(this, null, function* () {
          const connection = new _ffConnection.FFConnection(transport, options.protocolLogger, options.browserLogsCollector);
          const browser = new FFBrowser(connection, options);
          if (options.__testHookOnConnectToBrowser)
            yield options.__testHookOnConnectToBrowser();
          const promises = [connection.send("Browser.enable", {
            attachToDefaultContext: !!options.persistent
          }), browser._initVersion()];
          if (options.persistent) {
            browser._defaultContext = new FFBrowserContext(browser, void 0, options.persistent);
            promises.push(browser._defaultContext._initialize());
          }
          if (options.proxy)
            promises.push(browser._connection.send("Browser.setBrowserProxy", toJugglerProxyOptions(options.proxy)));
          yield Promise.all(promises);
          return browser;
        });
      }
      constructor(connection, options) {
        super(options);
        this._connection = void 0;
        this._ffPages = void 0;
        this._contexts = void 0;
        this._version = "";
        this._userAgent = "";
        this._connection = connection;
        this._ffPages = /* @__PURE__ */ new Map();
        this._contexts = /* @__PURE__ */ new Map();
        this._connection.on(_ffConnection.ConnectionEvents.Disconnected, () => this._onDisconnect());
        this._connection.on("Browser.attachedToTarget", this._onAttachedToTarget.bind(this));
        this._connection.on("Browser.detachedFromTarget", this._onDetachedFromTarget.bind(this));
        this._connection.on("Browser.downloadCreated", this._onDownloadCreated.bind(this));
        this._connection.on("Browser.downloadFinished", this._onDownloadFinished.bind(this));
        this._connection.on("Browser.videoRecordingFinished", this._onVideoRecordingFinished.bind(this));
      }
      _initVersion() {
        return __async(this, null, function* () {
          const result = yield this._connection.send("Browser.getInfo");
          this._version = result.version.substring(result.version.indexOf("/") + 1);
          this._userAgent = result.userAgent;
        });
      }
      isConnected() {
        return !this._connection._closed;
      }
      doCreateNewContext(options) {
        return __async(this, null, function* () {
          if (options.isMobile)
            throw new Error("options.isMobile is not supported in Firefox");
          const {
            browserContextId
          } = yield this._connection.send("Browser.createBrowserContext", {
            removeOnDetach: true
          });
          const context = new FFBrowserContext(this, browserContextId, options);
          yield context._initialize();
          this._contexts.set(browserContextId, context);
          return context;
        });
      }
      contexts() {
        return Array.from(this._contexts.values());
      }
      version() {
        return this._version;
      }
      userAgent() {
        return this._userAgent;
      }
      _onDetachedFromTarget(payload) {
        const ffPage = this._ffPages.get(payload.targetId);
        this._ffPages.delete(payload.targetId);
        ffPage.didClose();
      }
      _onAttachedToTarget(payload) {
        const {
          targetId,
          browserContextId,
          openerId,
          type
        } = payload.targetInfo;
        (0, _utils.assert)(type === "page");
        const context = browserContextId ? this._contexts.get(browserContextId) : this._defaultContext;
        (0, _utils.assert)(context, `Unknown context id:${browserContextId}, _defaultContext: ${this._defaultContext}`);
        const session = this._connection.createSession(payload.sessionId);
        const opener = openerId ? this._ffPages.get(openerId) : null;
        const ffPage = new _ffPage.FFPage(session, context, opener);
        this._ffPages.set(targetId, ffPage);
      }
      _onDownloadCreated(payload) {
        const ffPage = this._ffPages.get(payload.pageTargetId);
        (0, _utils.assert)(ffPage);
        if (!ffPage)
          return;
        let originPage = ffPage._initializedPage;
        if (!originPage) {
          ffPage._markAsError(new Error("Starting new page download"));
          if (ffPage._opener)
            originPage = ffPage._opener._initializedPage;
        }
        if (!originPage)
          return;
        this._downloadCreated(originPage, payload.uuid, payload.url, payload.suggestedFileName);
      }
      _onDownloadFinished(payload) {
        const error = payload.canceled ? "canceled" : payload.error;
        this._downloadFinished(payload.uuid, error);
      }
      _onVideoRecordingFinished(payload) {
        var _this$_takeVideo;
        (_this$_takeVideo = this._takeVideo(payload.screencastId)) === null || _this$_takeVideo === void 0 ? void 0 : _this$_takeVideo.reportFinished();
      }
      _onDisconnect() {
        for (const video of this._idToVideo.values())
          video.artifact.reportFinished(_errors.kBrowserClosedError);
        this._idToVideo.clear();
        this._didClose();
      }
    };
    exports2.FFBrowser = FFBrowser;
    var FFBrowserContext = class extends _browserContext.BrowserContext {
      constructor(browser, browserContextId, options) {
        super(browser, options, browserContextId);
      }
      _initialize() {
        var __superGet = (key) => super[key];
        return __async(this, null, function* () {
          (0, _utils.assert)(!this._ffPages().length);
          const browserContextId = this._browserContextId;
          const promises = [__superGet("_initialize").call(this)];
          promises.push(this._browser._connection.send("Browser.setDownloadOptions", {
            browserContextId,
            downloadOptions: {
              behavior: this._options.acceptDownloads ? "saveToDisk" : "cancel",
              downloadsDir: this._browser.options.downloadsPath
            }
          }));
          if (this._options.viewport) {
            const viewport = {
              viewportSize: {
                width: this._options.viewport.width,
                height: this._options.viewport.height
              },
              deviceScaleFactor: this._options.deviceScaleFactor || 1
            };
            promises.push(this._browser._connection.send("Browser.setDefaultViewport", {
              browserContextId,
              viewport
            }));
          }
          if (this._options.hasTouch)
            promises.push(this._browser._connection.send("Browser.setTouchOverride", {
              browserContextId,
              hasTouch: true
            }));
          if (this._options.userAgent)
            promises.push(this._browser._connection.send("Browser.setUserAgentOverride", {
              browserContextId,
              userAgent: this._options.userAgent
            }));
          if (this._options.bypassCSP)
            promises.push(this._browser._connection.send("Browser.setBypassCSP", {
              browserContextId,
              bypassCSP: true
            }));
          if (this._options.ignoreHTTPSErrors)
            promises.push(this._browser._connection.send("Browser.setIgnoreHTTPSErrors", {
              browserContextId,
              ignoreHTTPSErrors: true
            }));
          if (this._options.javaScriptEnabled === false)
            promises.push(this._browser._connection.send("Browser.setJavaScriptDisabled", {
              browserContextId,
              javaScriptDisabled: true
            }));
          if (this._options.locale)
            promises.push(this._browser._connection.send("Browser.setLocaleOverride", {
              browserContextId,
              locale: this._options.locale
            }));
          if (this._options.timezoneId)
            promises.push(this._browser._connection.send("Browser.setTimezoneOverride", {
              browserContextId,
              timezoneId: this._options.timezoneId
            }));
          if (this._options.permissions)
            promises.push(this.grantPermissions(this._options.permissions));
          if (this._options.extraHTTPHeaders || this._options.locale)
            promises.push(this.setExtraHTTPHeaders(this._options.extraHTTPHeaders || []));
          if (this._options.httpCredentials)
            promises.push(this.setHTTPCredentials(this._options.httpCredentials));
          if (this._options.geolocation)
            promises.push(this.setGeolocation(this._options.geolocation));
          if (this._options.offline)
            promises.push(this.setOffline(this._options.offline));
          promises.push(this._browser._connection.send("Browser.setColorScheme", {
            browserContextId,
            colorScheme: this._options.colorScheme !== void 0 ? this._options.colorScheme : "light"
          }));
          promises.push(this._browser._connection.send("Browser.setReducedMotion", {
            browserContextId,
            reducedMotion: this._options.reducedMotion !== void 0 ? this._options.reducedMotion : "no-preference"
          }));
          promises.push(this._browser._connection.send("Browser.setForcedColors", {
            browserContextId,
            forcedColors: this._options.forcedColors !== void 0 ? this._options.forcedColors : "none"
          }));
          if (this._options.recordVideo) {
            promises.push(this._ensureVideosPath().then(() => {
              return this._browser._connection.send("Browser.setVideoRecordingOptions", {
                options: __spreadProps(__spreadValues({}, this._options.recordVideo.size), {
                  dir: this._options.recordVideo.dir
                }),
                browserContextId: this._browserContextId
              });
            }));
          }
          if (this._options.proxy) {
            promises.push(this._browser._connection.send("Browser.setContextProxy", __spreadValues({
              browserContextId: this._browserContextId
            }, toJugglerProxyOptions(this._options.proxy))));
          }
          yield Promise.all(promises);
        });
      }
      _ffPages() {
        return Array.from(this._browser._ffPages.values()).filter((ffPage) => ffPage._browserContext === this);
      }
      pages() {
        return this._ffPages().map((ffPage) => ffPage._initializedPage).filter((pageOrNull) => !!pageOrNull);
      }
      newPageDelegate() {
        return __async(this, null, function* () {
          (0, _browserContext.assertBrowserContextIsNotOwned)(this);
          const {
            targetId
          } = yield this._browser._connection.send("Browser.newPage", {
            browserContextId: this._browserContextId
          }).catch((e) => {
            if (e.message.includes("Failed to override timezone"))
              throw new Error(`Invalid timezone ID: ${this._options.timezoneId}`);
            throw e;
          });
          return this._browser._ffPages.get(targetId);
        });
      }
      doGetCookies(urls) {
        return __async(this, null, function* () {
          const {
            cookies
          } = yield this._browser._connection.send("Browser.getCookies", {
            browserContextId: this._browserContextId
          });
          return network.filterCookies(cookies.map((c) => {
            const copy = __spreadValues({}, c);
            delete copy.size;
            delete copy.session;
            return copy;
          }), urls);
        });
      }
      addCookies(cookies) {
        return __async(this, null, function* () {
          const cc = network.rewriteCookies(cookies).map((c) => __spreadProps(__spreadValues({}, c), {
            expires: c.expires && c.expires !== -1 ? c.expires : void 0
          }));
          yield this._browser._connection.send("Browser.setCookies", {
            browserContextId: this._browserContextId,
            cookies: cc
          });
        });
      }
      clearCookies() {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.clearCookies", {
            browserContextId: this._browserContextId
          });
        });
      }
      doGrantPermissions(origin, permissions) {
        return __async(this, null, function* () {
          const webPermissionToProtocol = /* @__PURE__ */ new Map([["geolocation", "geo"], ["persistent-storage", "persistent-storage"], ["push", "push"], ["notifications", "desktop-notification"]]);
          const filtered = permissions.map((permission) => {
            const protocolPermission = webPermissionToProtocol.get(permission);
            if (!protocolPermission)
              throw new Error("Unknown permission: " + permission);
            return protocolPermission;
          });
          yield this._browser._connection.send("Browser.grantPermissions", {
            origin,
            browserContextId: this._browserContextId,
            permissions: filtered
          });
        });
      }
      doClearPermissions() {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.resetPermissions", {
            browserContextId: this._browserContextId
          });
        });
      }
      setGeolocation(geolocation) {
        return __async(this, null, function* () {
          (0, _browserContext.verifyGeolocation)(geolocation);
          this._options.geolocation = geolocation;
          yield this._browser._connection.send("Browser.setGeolocationOverride", {
            browserContextId: this._browserContextId,
            geolocation: geolocation || null
          });
        });
      }
      setExtraHTTPHeaders(headers) {
        return __async(this, null, function* () {
          this._options.extraHTTPHeaders = headers;
          let allHeaders = this._options.extraHTTPHeaders;
          if (this._options.locale)
            allHeaders = network.mergeHeaders([allHeaders, network.singleHeader("Accept-Language", this._options.locale)]);
          yield this._browser._connection.send("Browser.setExtraHTTPHeaders", {
            browserContextId: this._browserContextId,
            headers: allHeaders
          });
        });
      }
      setOffline(offline) {
        return __async(this, null, function* () {
          this._options.offline = offline;
          yield this._browser._connection.send("Browser.setOnlineOverride", {
            browserContextId: this._browserContextId,
            override: offline ? "offline" : "online"
          });
        });
      }
      doSetHTTPCredentials(httpCredentials) {
        return __async(this, null, function* () {
          this._options.httpCredentials = httpCredentials;
          yield this._browser._connection.send("Browser.setHTTPCredentials", {
            browserContextId: this._browserContextId,
            credentials: httpCredentials || null
          });
        });
      }
      doAddInitScript(source) {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.setInitScripts", {
            browserContextId: this._browserContextId,
            scripts: this.initScripts.map((script) => ({
              script
            }))
          });
        });
      }
      doRemoveInitScripts() {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.setInitScripts", {
            browserContextId: this._browserContextId,
            scripts: []
          });
        });
      }
      doExposeBinding(binding) {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.addBinding", {
            browserContextId: this._browserContextId,
            name: binding.name,
            script: binding.source
          });
        });
      }
      doRemoveExposedBindings() {
        return __async(this, null, function* () {
        });
      }
      doUpdateRequestInterception() {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.setRequestInterception", {
            browserContextId: this._browserContextId,
            enabled: !!this._requestInterceptor
          });
        });
      }
      onClosePersistent() {
      }
      doClose() {
        return __async(this, null, function* () {
          (0, _utils.assert)(this._browserContextId);
          yield this._browser._connection.send("Browser.removeBrowserContext", {
            browserContextId: this._browserContextId
          });
          this._browser._contexts.delete(this._browserContextId);
        });
      }
      cancelDownload(uuid) {
        return __async(this, null, function* () {
          yield this._browser._connection.send("Browser.cancelDownload", {
            uuid
          });
        });
      }
    };
    exports2.FFBrowserContext = FFBrowserContext;
    function toJugglerProxyOptions(proxy) {
      const proxyServer = new URL(proxy.server);
      let port = parseInt(proxyServer.port, 10);
      let type = "http";
      if (proxyServer.protocol === "socks5:")
        type = "socks";
      else if (proxyServer.protocol === "socks4:")
        type = "socks4";
      else if (proxyServer.protocol === "https:")
        type = "https";
      if (proxyServer.port === "") {
        if (proxyServer.protocol === "http:")
          port = 80;
        else if (proxyServer.protocol === "https:")
          port = 443;
      }
      return {
        type,
        bypass: proxy.bypass ? proxy.bypass.split(",").map((domain) => domain.trim()) : [],
        host: proxyServer.hostname,
        port,
        username: proxy.username,
        password: proxy.password
      };
    }
  }
});

// node_modules/playwright-core/lib/server/firefox/firefox.js
var require_firefox = __commonJS({
  "node_modules/playwright-core/lib/server/firefox/firefox.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Firefox = void 0;
    var os = _interopRequireWildcard(require("os"));
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var _ffBrowser = require_ffBrowser();
    var _ffConnection = require_ffConnection();
    var _browserType = require_browserType();
    var _stackTrace = require_stackTrace();
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Firefox = class extends _browserType.BrowserType {
      constructor(playwrightOptions) {
        super("firefox", playwrightOptions);
      }
      _connectToTransport(transport, options) {
        return _ffBrowser.FFBrowser.connect(transport, options);
      }
      _rewriteStartupError(error) {
        if (error.message.includes("no DISPLAY environment variable specified"))
          return (0, _stackTrace.rewriteErrorMessage)(error, "\n" + (0, _utils.wrapInASCIIBox)(_browserType.kNoXServerRunningError, 1));
        return error;
      }
      _amendEnvironment(env, userDataDir, executable, browserArguments) {
        if (!_path.default.isAbsolute(os.homedir()))
          throw new Error(`Cannot launch Firefox with relative home directory. Did you set ${os.platform() === "win32" ? "USERPROFILE" : "HOME"} to a relative path?`);
        if (os.platform() === "linux") {
          return __spreadProps(__spreadValues({}, env), {
            LD_LIBRARY_PATH: `${_path.default.dirname(executable)}:${process.env.LD_LIBRARY_PATH}`
          });
        }
        return env;
      }
      _attemptToGracefullyCloseBrowser(transport) {
        const message = {
          method: "Browser.close",
          params: {},
          id: _ffConnection.kBrowserCloseMessageId
        };
        transport.send(message);
      }
      _defaultArgs(options, isPersistent, userDataDir) {
        const {
          args = [],
          headless
        } = options;
        const userDataDirArg = args.find((arg) => arg.startsWith("-profile") || arg.startsWith("--profile"));
        if (userDataDirArg)
          throw new Error("Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --profile argument");
        if (args.find((arg) => arg.startsWith("-juggler")))
          throw new Error("Use the port parameter instead of -juggler argument");
        const firefoxUserPrefs = isPersistent ? void 0 : options.firefoxUserPrefs;
        if (firefoxUserPrefs) {
          const lines = [];
          for (const [name, value] of Object.entries(firefoxUserPrefs))
            lines.push(`user_pref(${JSON.stringify(name)}, ${JSON.stringify(value)});`);
          _fs.default.writeFileSync(_path.default.join(userDataDir, "user.js"), lines.join("\n"));
        }
        const firefoxArguments = ["-no-remote"];
        if (headless) {
          firefoxArguments.push("-headless");
        } else {
          firefoxArguments.push("-wait-for-browser");
          firefoxArguments.push("-foreground");
        }
        firefoxArguments.push(`-profile`, userDataDir);
        firefoxArguments.push("-juggler-pipe");
        firefoxArguments.push(...args);
        if (isPersistent)
          firefoxArguments.push("about:blank");
        else
          firefoxArguments.push("-silent");
        return firefoxArguments;
      }
    };
    exports2.Firefox = Firefox;
  }
});

// node_modules/playwright-core/lib/server/selectors.js
var require_selectors = __commonJS({
  "node_modules/playwright-core/lib/server/selectors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Selectors = void 0;
    var _selectorParser = require_selectorParser();
    var _utils = require_utils();
    var Selectors = class {
      constructor() {
        this._builtinEngines = void 0;
        this._builtinEnginesInMainWorld = void 0;
        this._engines = void 0;
        this.guid = `selectors@${(0, _utils.createGuid)()}`;
        this._builtinEngines = /* @__PURE__ */ new Set(["css", "css:light", "xpath", "xpath:light", "_react", "_vue", "text", "text:light", "id", "id:light", "data-testid", "data-testid:light", "data-test-id", "data-test-id:light", "data-test", "data-test:light", "nth", "visible", "control", "has"]);
        this._builtinEnginesInMainWorld = /* @__PURE__ */ new Set(["_react", "_vue"]);
        this._engines = /* @__PURE__ */ new Map();
      }
      register(name, source, contentScript = false) {
        return __async(this, null, function* () {
          if (!name.match(/^[a-zA-Z_0-9-]+$/))
            throw new Error("Selector engine name may only contain [a-zA-Z0-9_] characters");
          if (this._builtinEngines.has(name) || name === "zs" || name === "zs:light")
            throw new Error(`"${name}" is a predefined selector engine`);
          if (this._engines.has(name))
            throw new Error(`"${name}" selector engine has been already registered`);
          this._engines.set(name, {
            source,
            contentScript
          });
        });
      }
      unregisterAll() {
        this._engines.clear();
      }
      query(frame, info, scope) {
        return __async(this, null, function* () {
          const context = yield frame._context(info.world);
          const injectedScript = yield context.injectedScript();
          const handle = yield injectedScript.evaluateHandle((injected, {
            parsed,
            scope: scope2,
            strict
          }) => {
            return injected.querySelector(parsed, scope2 || document, strict);
          }, {
            parsed: info.parsed,
            scope,
            strict: info.strict
          });
          const elementHandle = handle.asElement();
          if (!elementHandle) {
            handle.dispose();
            return null;
          }
          const mainContext = yield frame._mainContext();
          return this._adoptIfNeeded(elementHandle, mainContext);
        });
      }
      _queryArrayInMainWorld(frame, info, scope) {
        return __async(this, null, function* () {
          const context = yield frame._mainContext();
          const injectedScript = yield context.injectedScript();
          const arrayHandle = yield injectedScript.evaluateHandle((injected, {
            parsed,
            scope: scope2
          }) => {
            return injected.querySelectorAll(parsed, scope2 || document);
          }, {
            parsed: info.parsed,
            scope
          });
          return arrayHandle;
        });
      }
      _queryCount(frame, info, scope) {
        return __async(this, null, function* () {
          const context = yield frame._context(info.world);
          const injectedScript = yield context.injectedScript();
          return yield injectedScript.evaluate((injected, {
            parsed,
            scope: scope2
          }) => {
            return injected.querySelectorAll(parsed, scope2 || document).length;
          }, {
            parsed: info.parsed,
            scope
          });
        });
      }
      _queryAll(frame, selector, scope, adoptToMain) {
        return __async(this, null, function* () {
          const info = typeof selector === "string" ? frame._page.parseSelector(selector) : selector;
          const context = yield frame._context(info.world);
          const injectedScript = yield context.injectedScript();
          const arrayHandle = yield injectedScript.evaluateHandle((injected, {
            parsed,
            scope: scope2
          }) => {
            return injected.querySelectorAll(parsed, scope2 || document);
          }, {
            parsed: info.parsed,
            scope
          });
          const properties = yield arrayHandle.getProperties();
          arrayHandle.dispose();
          const targetContext = adoptToMain ? yield frame._mainContext() : context;
          const result = [];
          for (const property of properties.values()) {
            const elementHandle = property.asElement();
            if (elementHandle)
              result.push(this._adoptIfNeeded(elementHandle, targetContext));
            else
              property.dispose();
          }
          return Promise.all(result);
        });
      }
      _adoptIfNeeded(handle, context) {
        return __async(this, null, function* () {
          if (handle._context === context)
            return handle;
          const adopted = handle._page._delegate.adoptElementHandle(handle, context);
          handle.dispose();
          return adopted;
        });
      }
      parseSelector(selector, strict) {
        if ((0, _utils.experimentalFeaturesEnabled)())
          this._builtinEngines.add("role");
        const parsed = typeof selector === "string" ? (0, _selectorParser.parseSelector)(selector) : selector;
        let needsMainWorld = false;
        for (const name of (0, _selectorParser.allEngineNames)(parsed)) {
          const custom = this._engines.get(name);
          if (!custom && !this._builtinEngines.has(name))
            throw new _selectorParser.InvalidSelectorError(`Unknown engine "${name}" while parsing selector ${(0, _selectorParser.stringifySelector)(parsed)}`);
          if (custom && !custom.contentScript)
            needsMainWorld = true;
          if (this._builtinEnginesInMainWorld.has(name))
            needsMainWorld = true;
        }
        return {
          parsed,
          world: needsMainWorld ? "main" : "utility",
          strict
        };
      }
    };
    exports2.Selectors = Selectors;
  }
});

// node_modules/playwright-core/lib/server/webkit/wkConnection.js
var require_wkConnection = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKSession = exports2.WKConnection = void 0;
    exports2.createProtocolError = createProtocolError;
    exports2.kPageProxyMessageReceived = exports2.kBrowserCloseMessageId = void 0;
    var _events = require("events");
    var _utils = require_utils();
    var _stackTrace = require_stackTrace();
    var _debugLogger = require_debugLogger();
    var _helper = require_helper();
    var _errors = require_errors();
    var _protocolError = require_protocolError();
    var kBrowserCloseMessageId = -9999;
    exports2.kBrowserCloseMessageId = kBrowserCloseMessageId;
    var kPageProxyMessageReceived = "kPageProxyMessageReceived";
    exports2.kPageProxyMessageReceived = kPageProxyMessageReceived;
    var WKConnection = class {
      constructor(transport, onDisconnect, protocolLogger, browserLogsCollector) {
        this._transport = void 0;
        this._onDisconnect = void 0;
        this._protocolLogger = void 0;
        this._browserLogsCollector = void 0;
        this._lastId = 0;
        this._closed = false;
        this.browserSession = void 0;
        this._transport = transport;
        this._transport.onmessage = this._dispatchMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this._onDisconnect = onDisconnect;
        this._protocolLogger = protocolLogger;
        this._browserLogsCollector = browserLogsCollector;
        this.browserSession = new WKSession(this, "", _errors.kBrowserClosedError, (message) => {
          this.rawSend(message);
        });
      }
      nextMessageId() {
        return ++this._lastId;
      }
      rawSend(message) {
        this._protocolLogger("send", message);
        this._transport.send(message);
      }
      _dispatchMessage(message) {
        this._protocolLogger("receive", message);
        if (message.id === kBrowserCloseMessageId)
          return;
        if (message.pageProxyId) {
          const payload = {
            message,
            pageProxyId: message.pageProxyId
          };
          this.browserSession.dispatchMessage({
            method: kPageProxyMessageReceived,
            params: payload
          });
          return;
        }
        this.browserSession.dispatchMessage(message);
      }
      _onClose() {
        this._closed = true;
        this._transport.onmessage = void 0;
        this._transport.onclose = void 0;
        this.browserSession.dispose(true);
        this._onDisconnect();
      }
      isClosed() {
        return this._closed;
      }
      close() {
        if (!this._closed)
          this._transport.close();
      }
    };
    exports2.WKConnection = WKConnection;
    var WKSession = class extends _events.EventEmitter {
      constructor(connection, sessionId, errorText, rawSend) {
        super();
        this.connection = void 0;
        this.errorText = void 0;
        this.sessionId = void 0;
        this._disposed = false;
        this._rawSend = void 0;
        this._callbacks = /* @__PURE__ */ new Map();
        this._crashed = false;
        this.on = void 0;
        this.addListener = void 0;
        this.off = void 0;
        this.removeListener = void 0;
        this.once = void 0;
        this.setMaxListeners(0);
        this.connection = connection;
        this.sessionId = sessionId;
        this._rawSend = rawSend;
        this.errorText = errorText;
        this.on = super.on;
        this.off = super.removeListener;
        this.addListener = super.addListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      send(method, params) {
        return __async(this, null, function* () {
          if (this._crashed)
            throw new _protocolError.ProtocolError(true, "Target crashed");
          if (this._disposed)
            throw new _protocolError.ProtocolError(true, `Target closed`);
          const id = this.connection.nextMessageId();
          const messageObj = {
            id,
            method,
            params
          };
          this._rawSend(messageObj);
          return new Promise((resolve, reject) => {
            this._callbacks.set(id, {
              resolve,
              reject,
              error: new _protocolError.ProtocolError(false),
              method
            });
          });
        });
      }
      sendMayFail(method, params) {
        return this.send(method, params).catch((error) => _debugLogger.debugLogger.log("error", error));
      }
      markAsCrashed() {
        this._crashed = true;
      }
      isDisposed() {
        return this._disposed;
      }
      dispose(disconnected) {
        if (disconnected)
          this.errorText = "Browser closed." + _helper.helper.formatBrowserLogs(this.connection._browserLogsCollector.recentLogs());
        for (const callback of this._callbacks.values()) {
          callback.error.sessionClosed = true;
          callback.reject((0, _stackTrace.rewriteErrorMessage)(callback.error, this.errorText));
        }
        this._callbacks.clear();
        this._disposed = true;
      }
      dispatchMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
          const callback = this._callbacks.get(object.id);
          this._callbacks.delete(object.id);
          if (object.error)
            callback.reject(createProtocolError(callback.error, callback.method, object.error));
          else
            callback.resolve(object.result);
        } else if (object.id && !object.error) {
          (0, _utils.assert)(this.isDisposed());
        } else {
          Promise.resolve().then(() => this.emit(object.method, object.params));
        }
      }
    };
    exports2.WKSession = WKSession;
    function createProtocolError(error, method, protocolError) {
      let message = `Protocol error (${method}): ${protocolError.message}`;
      if ("data" in protocolError)
        message += ` ${JSON.stringify(protocolError.data)}`;
      return (0, _stackTrace.rewriteErrorMessage)(error, message);
    }
  }
});

// node_modules/pngjs/lib/chunkstream.js
var require_chunkstream = __commonJS({
  "node_modules/pngjs/lib/chunkstream.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream");
    var ChunkStream = module2.exports = function() {
      Stream.call(this);
      this._buffers = [];
      this._buffered = 0;
      this._reads = [];
      this._paused = false;
      this._encoding = "utf8";
      this.writable = true;
    };
    util.inherits(ChunkStream, Stream);
    ChunkStream.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
      process.nextTick(function() {
        this._process();
        if (this._paused && this._reads && this._reads.length > 0) {
          this._paused = false;
          this.emit("drain");
        }
      }.bind(this));
    };
    ChunkStream.prototype.write = function(data, encoding) {
      if (!this.writable) {
        this.emit("error", new Error("Stream not writable"));
        return false;
      }
      let dataBuffer;
      if (Buffer.isBuffer(data)) {
        dataBuffer = data;
      } else {
        dataBuffer = Buffer.from(data, encoding || this._encoding);
      }
      this._buffers.push(dataBuffer);
      this._buffered += dataBuffer.length;
      this._process();
      if (this._reads && this._reads.length === 0) {
        this._paused = true;
      }
      return this.writable && !this._paused;
    };
    ChunkStream.prototype.end = function(data, encoding) {
      if (data) {
        this.write(data, encoding);
      }
      this.writable = false;
      if (!this._buffers) {
        return;
      }
      if (this._buffers.length === 0) {
        this._end();
      } else {
        this._buffers.push(null);
        this._process();
      }
    };
    ChunkStream.prototype.destroySoon = ChunkStream.prototype.end;
    ChunkStream.prototype._end = function() {
      if (this._reads.length > 0) {
        this.emit("error", new Error("Unexpected end of input"));
      }
      this.destroy();
    };
    ChunkStream.prototype.destroy = function() {
      if (!this._buffers) {
        return;
      }
      this.writable = false;
      this._reads = null;
      this._buffers = null;
      this.emit("close");
    };
    ChunkStream.prototype._processReadAllowingLess = function(read) {
      this._reads.shift();
      let smallerBuf = this._buffers[0];
      if (smallerBuf.length > read.length) {
        this._buffered -= read.length;
        this._buffers[0] = smallerBuf.slice(read.length);
        read.func.call(this, smallerBuf.slice(0, read.length));
      } else {
        this._buffered -= smallerBuf.length;
        this._buffers.shift();
        read.func.call(this, smallerBuf);
      }
    };
    ChunkStream.prototype._processRead = function(read) {
      this._reads.shift();
      let pos = 0;
      let count = 0;
      let data = Buffer.alloc(read.length);
      while (pos < read.length) {
        let buf = this._buffers[count++];
        let len = Math.min(buf.length, read.length - pos);
        buf.copy(data, pos, 0, len);
        pos += len;
        if (len !== buf.length) {
          this._buffers[--count] = buf.slice(len);
        }
      }
      if (count > 0) {
        this._buffers.splice(0, count);
      }
      this._buffered -= read.length;
      read.func.call(this, data);
    };
    ChunkStream.prototype._process = function() {
      try {
        while (this._buffered > 0 && this._reads && this._reads.length > 0) {
          let read = this._reads[0];
          if (read.allowLess) {
            this._processReadAllowingLess(read);
          } else if (this._buffered >= read.length) {
            this._processRead(read);
          } else {
            break;
          }
        }
        if (this._buffers && !this.writable) {
          this._end();
        }
      } catch (ex) {
        this.emit("error", ex);
      }
    };
  }
});

// node_modules/pngjs/lib/interlace.js
var require_interlace = __commonJS({
  "node_modules/pngjs/lib/interlace.js"(exports2) {
    "use strict";
    var imagePasses = [
      {
        x: [0],
        y: [0]
      },
      {
        x: [4],
        y: [0]
      },
      {
        x: [0, 4],
        y: [4]
      },
      {
        x: [2, 6],
        y: [0, 4]
      },
      {
        x: [0, 2, 4, 6],
        y: [2, 6]
      },
      {
        x: [1, 3, 5, 7],
        y: [0, 2, 4, 6]
      },
      {
        x: [0, 1, 2, 3, 4, 5, 6, 7],
        y: [1, 3, 5, 7]
      }
    ];
    exports2.getImagePasses = function(width, height) {
      let images = [];
      let xLeftOver = width % 8;
      let yLeftOver = height % 8;
      let xRepeats = (width - xLeftOver) / 8;
      let yRepeats = (height - yLeftOver) / 8;
      for (let i = 0; i < imagePasses.length; i++) {
        let pass = imagePasses[i];
        let passWidth = xRepeats * pass.x.length;
        let passHeight = yRepeats * pass.y.length;
        for (let j = 0; j < pass.x.length; j++) {
          if (pass.x[j] < xLeftOver) {
            passWidth++;
          } else {
            break;
          }
        }
        for (let j = 0; j < pass.y.length; j++) {
          if (pass.y[j] < yLeftOver) {
            passHeight++;
          } else {
            break;
          }
        }
        if (passWidth > 0 && passHeight > 0) {
          images.push({ width: passWidth, height: passHeight, index: i });
        }
      }
      return images;
    };
    exports2.getInterlaceIterator = function(width) {
      return function(x, y, pass) {
        let outerXLeftOver = x % imagePasses[pass].x.length;
        let outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver];
        let outerYLeftOver = y % imagePasses[pass].y.length;
        let outerY = (y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver];
        return outerX * 4 + outerY * width * 4;
      };
    };
  }
});

// node_modules/pngjs/lib/paeth-predictor.js
var require_paeth_predictor = __commonJS({
  "node_modules/pngjs/lib/paeth-predictor.js"(exports2, module2) {
    "use strict";
    module2.exports = function paethPredictor(left, above, upLeft) {
      let paeth = left + above - upLeft;
      let pLeft = Math.abs(paeth - left);
      let pAbove = Math.abs(paeth - above);
      let pUpLeft = Math.abs(paeth - upLeft);
      if (pLeft <= pAbove && pLeft <= pUpLeft) {
        return left;
      }
      if (pAbove <= pUpLeft) {
        return above;
      }
      return upLeft;
    };
  }
});

// node_modules/pngjs/lib/filter-parse.js
var require_filter_parse = __commonJS({
  "node_modules/pngjs/lib/filter-parse.js"(exports2, module2) {
    "use strict";
    var interlaceUtils = require_interlace();
    var paethPredictor = require_paeth_predictor();
    function getByteWidth(width, bpp, depth) {
      let byteWidth = width * bpp;
      if (depth !== 8) {
        byteWidth = Math.ceil(byteWidth / (8 / depth));
      }
      return byteWidth;
    }
    var Filter = module2.exports = function(bitmapInfo, dependencies) {
      let width = bitmapInfo.width;
      let height = bitmapInfo.height;
      let interlace = bitmapInfo.interlace;
      let bpp = bitmapInfo.bpp;
      let depth = bitmapInfo.depth;
      this.read = dependencies.read;
      this.write = dependencies.write;
      this.complete = dependencies.complete;
      this._imageIndex = 0;
      this._images = [];
      if (interlace) {
        let passes = interlaceUtils.getImagePasses(width, height);
        for (let i = 0; i < passes.length; i++) {
          this._images.push({
            byteWidth: getByteWidth(passes[i].width, bpp, depth),
            height: passes[i].height,
            lineIndex: 0
          });
        }
      } else {
        this._images.push({
          byteWidth: getByteWidth(width, bpp, depth),
          height,
          lineIndex: 0
        });
      }
      if (depth === 8) {
        this._xComparison = bpp;
      } else if (depth === 16) {
        this._xComparison = bpp * 2;
      } else {
        this._xComparison = 1;
      }
    };
    Filter.prototype.start = function() {
      this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
    };
    Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        unfilteredLine[x] = rawByte + f1Left;
      }
    };
    Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
      let lastLine = this._lastLine;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f2Up = lastLine ? lastLine[x] : 0;
        unfilteredLine[x] = rawByte + f2Up;
      }
    };
    Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      let lastLine = this._lastLine;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f3Up = lastLine ? lastLine[x] : 0;
        let f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        let f3Add = Math.floor((f3Left + f3Up) / 2);
        unfilteredLine[x] = rawByte + f3Add;
      }
    };
    Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
      let xComparison = this._xComparison;
      let xBiggerThan = xComparison - 1;
      let lastLine = this._lastLine;
      for (let x = 0; x < byteWidth; x++) {
        let rawByte = rawData[1 + x];
        let f4Up = lastLine ? lastLine[x] : 0;
        let f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
        let f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0;
        let f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
        unfilteredLine[x] = rawByte + f4Add;
      }
    };
    Filter.prototype._reverseFilterLine = function(rawData) {
      let filter = rawData[0];
      let unfilteredLine;
      let currentImage = this._images[this._imageIndex];
      let byteWidth = currentImage.byteWidth;
      if (filter === 0) {
        unfilteredLine = rawData.slice(1, byteWidth + 1);
      } else {
        unfilteredLine = Buffer.alloc(byteWidth);
        switch (filter) {
          case 1:
            this._unFilterType1(rawData, unfilteredLine, byteWidth);
            break;
          case 2:
            this._unFilterType2(rawData, unfilteredLine, byteWidth);
            break;
          case 3:
            this._unFilterType3(rawData, unfilteredLine, byteWidth);
            break;
          case 4:
            this._unFilterType4(rawData, unfilteredLine, byteWidth);
            break;
          default:
            throw new Error("Unrecognised filter type - " + filter);
        }
      }
      this.write(unfilteredLine);
      currentImage.lineIndex++;
      if (currentImage.lineIndex >= currentImage.height) {
        this._lastLine = null;
        this._imageIndex++;
        currentImage = this._images[this._imageIndex];
      } else {
        this._lastLine = unfilteredLine;
      }
      if (currentImage) {
        this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this));
      } else {
        this._lastLine = null;
        this.complete();
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-async.js
var require_filter_parse_async = __commonJS({
  "node_modules/pngjs/lib/filter-parse-async.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var ChunkStream = require_chunkstream();
    var Filter = require_filter_parse();
    var FilterAsync = module2.exports = function(bitmapInfo) {
      ChunkStream.call(this);
      let buffers = [];
      let that = this;
      this._filter = new Filter(bitmapInfo, {
        read: this.read.bind(this),
        write: function(buffer) {
          buffers.push(buffer);
        },
        complete: function() {
          that.emit("complete", Buffer.concat(buffers));
        }
      });
      this._filter.start();
    };
    util.inherits(FilterAsync, ChunkStream);
  }
});

// node_modules/pngjs/lib/constants.js
var require_constants4 = __commonJS({
  "node_modules/pngjs/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10],
      TYPE_IHDR: 1229472850,
      TYPE_IEND: 1229278788,
      TYPE_IDAT: 1229209940,
      TYPE_PLTE: 1347179589,
      TYPE_tRNS: 1951551059,
      TYPE_gAMA: 1732332865,
      COLORTYPE_GRAYSCALE: 0,
      COLORTYPE_PALETTE: 1,
      COLORTYPE_COLOR: 2,
      COLORTYPE_ALPHA: 4,
      COLORTYPE_PALETTE_COLOR: 3,
      COLORTYPE_COLOR_ALPHA: 6,
      COLORTYPE_TO_BPP_MAP: {
        0: 1,
        2: 3,
        3: 1,
        4: 2,
        6: 4
      },
      GAMMA_DIVISION: 1e5
    };
  }
});

// node_modules/pngjs/lib/crc.js
var require_crc = __commonJS({
  "node_modules/pngjs/lib/crc.js"(exports2, module2) {
    "use strict";
    var crcTable = [];
    (function() {
      for (let i = 0; i < 256; i++) {
        let currentCrc = i;
        for (let j = 0; j < 8; j++) {
          if (currentCrc & 1) {
            currentCrc = 3988292384 ^ currentCrc >>> 1;
          } else {
            currentCrc = currentCrc >>> 1;
          }
        }
        crcTable[i] = currentCrc;
      }
    })();
    var CrcCalculator = module2.exports = function() {
      this._crc = -1;
    };
    CrcCalculator.prototype.write = function(data) {
      for (let i = 0; i < data.length; i++) {
        this._crc = crcTable[(this._crc ^ data[i]) & 255] ^ this._crc >>> 8;
      }
      return true;
    };
    CrcCalculator.prototype.crc32 = function() {
      return this._crc ^ -1;
    };
    CrcCalculator.crc32 = function(buf) {
      let crc = -1;
      for (let i = 0; i < buf.length; i++) {
        crc = crcTable[(crc ^ buf[i]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    };
  }
});

// node_modules/pngjs/lib/parser.js
var require_parser = __commonJS({
  "node_modules/pngjs/lib/parser.js"(exports2, module2) {
    "use strict";
    var constants = require_constants4();
    var CrcCalculator = require_crc();
    var Parser = module2.exports = function(options, dependencies) {
      this._options = options;
      options.checkCRC = options.checkCRC !== false;
      this._hasIHDR = false;
      this._hasIEND = false;
      this._emittedHeadersFinished = false;
      this._palette = [];
      this._colorType = 0;
      this._chunks = {};
      this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this);
      this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this);
      this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this);
      this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this);
      this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this);
      this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this);
      this.read = dependencies.read;
      this.error = dependencies.error;
      this.metadata = dependencies.metadata;
      this.gamma = dependencies.gamma;
      this.transColor = dependencies.transColor;
      this.palette = dependencies.palette;
      this.parsed = dependencies.parsed;
      this.inflateData = dependencies.inflateData;
      this.finished = dependencies.finished;
      this.simpleTransparency = dependencies.simpleTransparency;
      this.headersFinished = dependencies.headersFinished || function() {
      };
    };
    Parser.prototype.start = function() {
      this.read(constants.PNG_SIGNATURE.length, this._parseSignature.bind(this));
    };
    Parser.prototype._parseSignature = function(data) {
      let signature = constants.PNG_SIGNATURE;
      for (let i = 0; i < signature.length; i++) {
        if (data[i] !== signature[i]) {
          this.error(new Error("Invalid file signature"));
          return;
        }
      }
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._parseChunkBegin = function(data) {
      let length = data.readUInt32BE(0);
      let type = data.readUInt32BE(4);
      let name = "";
      for (let i = 4; i < 8; i++) {
        name += String.fromCharCode(data[i]);
      }
      let ancillary = Boolean(data[4] & 32);
      if (!this._hasIHDR && type !== constants.TYPE_IHDR) {
        this.error(new Error("Expected IHDR on beggining"));
        return;
      }
      this._crc = new CrcCalculator();
      this._crc.write(Buffer.from(name));
      if (this._chunks[type]) {
        return this._chunks[type](length);
      }
      if (!ancillary) {
        this.error(new Error("Unsupported critical chunk type " + name));
        return;
      }
      this.read(length + 4, this._skipChunk.bind(this));
    };
    Parser.prototype._skipChunk = function() {
      this.read(8, this._parseChunkBegin.bind(this));
    };
    Parser.prototype._handleChunkEnd = function() {
      this.read(4, this._parseChunkEnd.bind(this));
    };
    Parser.prototype._parseChunkEnd = function(data) {
      let fileCrc = data.readInt32BE(0);
      let calcCrc = this._crc.crc32();
      if (this._options.checkCRC && calcCrc !== fileCrc) {
        this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc));
        return;
      }
      if (!this._hasIEND) {
        this.read(8, this._parseChunkBegin.bind(this));
      }
    };
    Parser.prototype._handleIHDR = function(length) {
      this.read(length, this._parseIHDR.bind(this));
    };
    Parser.prototype._parseIHDR = function(data) {
      this._crc.write(data);
      let width = data.readUInt32BE(0);
      let height = data.readUInt32BE(4);
      let depth = data[8];
      let colorType = data[9];
      let compr = data[10];
      let filter = data[11];
      let interlace = data[12];
      if (depth !== 8 && depth !== 4 && depth !== 2 && depth !== 1 && depth !== 16) {
        this.error(new Error("Unsupported bit depth " + depth));
        return;
      }
      if (!(colorType in constants.COLORTYPE_TO_BPP_MAP)) {
        this.error(new Error("Unsupported color type"));
        return;
      }
      if (compr !== 0) {
        this.error(new Error("Unsupported compression method"));
        return;
      }
      if (filter !== 0) {
        this.error(new Error("Unsupported filter method"));
        return;
      }
      if (interlace !== 0 && interlace !== 1) {
        this.error(new Error("Unsupported interlace method"));
        return;
      }
      this._colorType = colorType;
      let bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];
      this._hasIHDR = true;
      this.metadata({
        width,
        height,
        depth,
        interlace: Boolean(interlace),
        palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
        color: Boolean(colorType & constants.COLORTYPE_COLOR),
        alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
        bpp,
        colorType
      });
      this._handleChunkEnd();
    };
    Parser.prototype._handlePLTE = function(length) {
      this.read(length, this._parsePLTE.bind(this));
    };
    Parser.prototype._parsePLTE = function(data) {
      this._crc.write(data);
      let entries = Math.floor(data.length / 3);
      for (let i = 0; i < entries; i++) {
        this._palette.push([data[i * 3], data[i * 3 + 1], data[i * 3 + 2], 255]);
      }
      this.palette(this._palette);
      this._handleChunkEnd();
    };
    Parser.prototype._handleTRNS = function(length) {
      this.simpleTransparency();
      this.read(length, this._parseTRNS.bind(this));
    };
    Parser.prototype._parseTRNS = function(data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
        if (this._palette.length === 0) {
          this.error(new Error("Transparency chunk must be after palette"));
          return;
        }
        if (data.length > this._palette.length) {
          this.error(new Error("More transparent colors than palette size"));
          return;
        }
        for (let i = 0; i < data.length; i++) {
          this._palette[i][3] = data[i];
        }
        this.palette(this._palette);
      }
      if (this._colorType === constants.COLORTYPE_GRAYSCALE) {
        this.transColor([data.readUInt16BE(0)]);
      }
      if (this._colorType === constants.COLORTYPE_COLOR) {
        this.transColor([
          data.readUInt16BE(0),
          data.readUInt16BE(2),
          data.readUInt16BE(4)
        ]);
      }
      this._handleChunkEnd();
    };
    Parser.prototype._handleGAMA = function(length) {
      this.read(length, this._parseGAMA.bind(this));
    };
    Parser.prototype._parseGAMA = function(data) {
      this._crc.write(data);
      this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION);
      this._handleChunkEnd();
    };
    Parser.prototype._handleIDAT = function(length) {
      if (!this._emittedHeadersFinished) {
        this._emittedHeadersFinished = true;
        this.headersFinished();
      }
      this.read(-length, this._parseIDAT.bind(this, length));
    };
    Parser.prototype._parseIDAT = function(length, data) {
      this._crc.write(data);
      if (this._colorType === constants.COLORTYPE_PALETTE_COLOR && this._palette.length === 0) {
        throw new Error("Expected palette not found");
      }
      this.inflateData(data);
      let leftOverLength = length - data.length;
      if (leftOverLength > 0) {
        this._handleIDAT(leftOverLength);
      } else {
        this._handleChunkEnd();
      }
    };
    Parser.prototype._handleIEND = function(length) {
      this.read(length, this._parseIEND.bind(this));
    };
    Parser.prototype._parseIEND = function(data) {
      this._crc.write(data);
      this._hasIEND = true;
      this._handleChunkEnd();
      if (this.finished) {
        this.finished();
      }
    };
  }
});

// node_modules/pngjs/lib/bitmapper.js
var require_bitmapper = __commonJS({
  "node_modules/pngjs/lib/bitmapper.js"(exports2) {
    "use strict";
    var interlaceUtils = require_interlace();
    var pixelBppMapper = [
      function() {
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos === data.length) {
          throw new Error("Ran out of data");
        }
        let pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 1 >= data.length) {
          throw new Error("Ran out of data");
        }
        let pixel = data[rawPos];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = data[rawPos + 1];
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 2 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = 255;
      },
      function(pxData, data, pxPos, rawPos) {
        if (rawPos + 3 >= data.length) {
          throw new Error("Ran out of data");
        }
        pxData[pxPos] = data[rawPos];
        pxData[pxPos + 1] = data[rawPos + 1];
        pxData[pxPos + 2] = data[rawPos + 2];
        pxData[pxPos + 3] = data[rawPos + 3];
      }
    ];
    var pixelBppCustomMapper = [
      function() {
      },
      function(pxData, pixelData, pxPos, maxBit) {
        let pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        let pixel = pixelData[0];
        pxData[pxPos] = pixel;
        pxData[pxPos + 1] = pixel;
        pxData[pxPos + 2] = pixel;
        pxData[pxPos + 3] = pixelData[1];
      },
      function(pxData, pixelData, pxPos, maxBit) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = maxBit;
      },
      function(pxData, pixelData, pxPos) {
        pxData[pxPos] = pixelData[0];
        pxData[pxPos + 1] = pixelData[1];
        pxData[pxPos + 2] = pixelData[2];
        pxData[pxPos + 3] = pixelData[3];
      }
    ];
    function bitRetriever(data, depth) {
      let leftOver = [];
      let i = 0;
      function split() {
        if (i === data.length) {
          throw new Error("Ran out of data");
        }
        let byte = data[i];
        i++;
        let byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1;
        switch (depth) {
          default:
            throw new Error("unrecognised depth");
          case 16:
            byte2 = data[i];
            i++;
            leftOver.push((byte << 8) + byte2);
            break;
          case 4:
            byte2 = byte & 15;
            byte1 = byte >> 4;
            leftOver.push(byte1, byte2);
            break;
          case 2:
            byte4 = byte & 3;
            byte3 = byte >> 2 & 3;
            byte2 = byte >> 4 & 3;
            byte1 = byte >> 6 & 3;
            leftOver.push(byte1, byte2, byte3, byte4);
            break;
          case 1:
            byte8 = byte & 1;
            byte7 = byte >> 1 & 1;
            byte6 = byte >> 2 & 1;
            byte5 = byte >> 3 & 1;
            byte4 = byte >> 4 & 1;
            byte3 = byte >> 5 & 1;
            byte2 = byte >> 6 & 1;
            byte1 = byte >> 7 & 1;
            leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
            break;
        }
      }
      return {
        get: function(count) {
          while (leftOver.length < count) {
            split();
          }
          let returner = leftOver.slice(0, count);
          leftOver = leftOver.slice(count);
          return returner;
        },
        resetAfterLine: function() {
          leftOver.length = 0;
        },
        end: function() {
          if (i !== data.length) {
            throw new Error("extra data found");
          }
        }
      };
    }
    function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
      let imageWidth = image.width;
      let imageHeight = image.height;
      let imagePass = image.index;
      for (let y = 0; y < imageHeight; y++) {
        for (let x = 0; x < imageWidth; x++) {
          let pxPos = getPxPos(x, y, imagePass);
          pixelBppMapper[bpp](pxData, data, pxPos, rawPos);
          rawPos += bpp;
        }
      }
      return rawPos;
    }
    function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
      let imageWidth = image.width;
      let imageHeight = image.height;
      let imagePass = image.index;
      for (let y = 0; y < imageHeight; y++) {
        for (let x = 0; x < imageWidth; x++) {
          let pixelData = bits.get(bpp);
          let pxPos = getPxPos(x, y, imagePass);
          pixelBppCustomMapper[bpp](pxData, pixelData, pxPos, maxBit);
        }
        bits.resetAfterLine();
      }
    }
    exports2.dataToBitMap = function(data, bitmapInfo) {
      let width = bitmapInfo.width;
      let height = bitmapInfo.height;
      let depth = bitmapInfo.depth;
      let bpp = bitmapInfo.bpp;
      let interlace = bitmapInfo.interlace;
      let bits;
      if (depth !== 8) {
        bits = bitRetriever(data, depth);
      }
      let pxData;
      if (depth <= 8) {
        pxData = Buffer.alloc(width * height * 4);
      } else {
        pxData = new Uint16Array(width * height * 4);
      }
      let maxBit = Math.pow(2, depth) - 1;
      let rawPos = 0;
      let images;
      let getPxPos;
      if (interlace) {
        images = interlaceUtils.getImagePasses(width, height);
        getPxPos = interlaceUtils.getInterlaceIterator(width, height);
      } else {
        let nonInterlacedPxPos = 0;
        getPxPos = function() {
          let returner = nonInterlacedPxPos;
          nonInterlacedPxPos += 4;
          return returner;
        };
        images = [{ width, height }];
      }
      for (let imageIndex = 0; imageIndex < images.length; imageIndex++) {
        if (depth === 8) {
          rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos);
        } else {
          mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
        }
      }
      if (depth === 8) {
        if (rawPos !== data.length) {
          throw new Error("extra data found");
        }
      } else {
        bits.end();
      }
      return pxData;
    };
  }
});

// node_modules/pngjs/lib/format-normaliser.js
var require_format_normaliser = __commonJS({
  "node_modules/pngjs/lib/format-normaliser.js"(exports2, module2) {
    "use strict";
    function dePalette(indata, outdata, width, height, palette) {
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let color = palette[indata[pxPos]];
          if (!color) {
            throw new Error("index " + indata[pxPos] + " not in palette");
          }
          for (let i = 0; i < 4; i++) {
            outdata[pxPos + i] = color[i];
          }
          pxPos += 4;
        }
      }
    }
    function replaceTransparentColor(indata, outdata, width, height, transColor) {
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let makeTrans = false;
          if (transColor.length === 1) {
            if (transColor[0] === indata[pxPos]) {
              makeTrans = true;
            }
          } else if (transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2]) {
            makeTrans = true;
          }
          if (makeTrans) {
            for (let i = 0; i < 4; i++) {
              outdata[pxPos + i] = 0;
            }
          }
          pxPos += 4;
        }
      }
    }
    function scaleDepth(indata, outdata, width, height, depth) {
      let maxOutSample = 255;
      let maxInSample = Math.pow(2, depth) - 1;
      let pxPos = 0;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          for (let i = 0; i < 4; i++) {
            outdata[pxPos + i] = Math.floor(indata[pxPos + i] * maxOutSample / maxInSample + 0.5);
          }
          pxPos += 4;
        }
      }
    }
    module2.exports = function(indata, imageData, skipRescale = false) {
      let depth = imageData.depth;
      let width = imageData.width;
      let height = imageData.height;
      let colorType = imageData.colorType;
      let transColor = imageData.transColor;
      let palette = imageData.palette;
      let outdata = indata;
      if (colorType === 3) {
        dePalette(indata, outdata, width, height, palette);
      } else {
        if (transColor) {
          replaceTransparentColor(indata, outdata, width, height, transColor);
        }
        if (depth !== 8 && !skipRescale) {
          if (depth === 16) {
            outdata = Buffer.alloc(width * height * 4);
          }
          scaleDepth(indata, outdata, width, height, depth);
        }
      }
      return outdata;
    };
  }
});

// node_modules/pngjs/lib/parser-async.js
var require_parser_async = __commonJS({
  "node_modules/pngjs/lib/parser-async.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var zlib = require("zlib");
    var ChunkStream = require_chunkstream();
    var FilterAsync = require_filter_parse_async();
    var Parser = require_parser();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    var ParserAsync = module2.exports = function(options) {
      ChunkStream.call(this);
      this._parser = new Parser(options, {
        read: this.read.bind(this),
        error: this._handleError.bind(this),
        metadata: this._handleMetaData.bind(this),
        gamma: this.emit.bind(this, "gamma"),
        palette: this._handlePalette.bind(this),
        transColor: this._handleTransColor.bind(this),
        finished: this._finished.bind(this),
        inflateData: this._inflateData.bind(this),
        simpleTransparency: this._simpleTransparency.bind(this),
        headersFinished: this._headersFinished.bind(this)
      });
      this._options = options;
      this.writable = true;
      this._parser.start();
    };
    util.inherits(ParserAsync, ChunkStream);
    ParserAsync.prototype._handleError = function(err) {
      this.emit("error", err);
      this.writable = false;
      this.destroy();
      if (this._inflate && this._inflate.destroy) {
        this._inflate.destroy();
      }
      if (this._filter) {
        this._filter.destroy();
        this._filter.on("error", function() {
        });
      }
      this.errord = true;
    };
    ParserAsync.prototype._inflateData = function(data) {
      if (!this._inflate) {
        if (this._bitmapInfo.interlace) {
          this._inflate = zlib.createInflate();
          this._inflate.on("error", this.emit.bind(this, "error"));
          this._filter.on("complete", this._complete.bind(this));
          this._inflate.pipe(this._filter);
        } else {
          let rowSize = (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3) + 1;
          let imageSize = rowSize * this._bitmapInfo.height;
          let chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);
          this._inflate = zlib.createInflate({ chunkSize });
          let leftToInflate = imageSize;
          let emitError = this.emit.bind(this, "error");
          this._inflate.on("error", function(err) {
            if (!leftToInflate) {
              return;
            }
            emitError(err);
          });
          this._filter.on("complete", this._complete.bind(this));
          let filterWrite = this._filter.write.bind(this._filter);
          this._inflate.on("data", function(chunk) {
            if (!leftToInflate) {
              return;
            }
            if (chunk.length > leftToInflate) {
              chunk = chunk.slice(0, leftToInflate);
            }
            leftToInflate -= chunk.length;
            filterWrite(chunk);
          });
          this._inflate.on("end", this._filter.end.bind(this._filter));
        }
      }
      this._inflate.write(data);
    };
    ParserAsync.prototype._handleMetaData = function(metaData) {
      this._metaData = metaData;
      this._bitmapInfo = Object.create(metaData);
      this._filter = new FilterAsync(this._bitmapInfo);
    };
    ParserAsync.prototype._handleTransColor = function(transColor) {
      this._bitmapInfo.transColor = transColor;
    };
    ParserAsync.prototype._handlePalette = function(palette) {
      this._bitmapInfo.palette = palette;
    };
    ParserAsync.prototype._simpleTransparency = function() {
      this._metaData.alpha = true;
    };
    ParserAsync.prototype._headersFinished = function() {
      this.emit("metadata", this._metaData);
    };
    ParserAsync.prototype._finished = function() {
      if (this.errord) {
        return;
      }
      if (!this._inflate) {
        this.emit("error", "No Inflate block");
      } else {
        this._inflate.end();
      }
    };
    ParserAsync.prototype._complete = function(filteredData) {
      if (this.errord) {
        return;
      }
      let normalisedBitmapData;
      try {
        let bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo);
        normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo, this._options.skipRescale);
        bitmapData = null;
      } catch (ex) {
        this._handleError(ex);
        return;
      }
      this.emit("parsed", normalisedBitmapData);
    };
  }
});

// node_modules/pngjs/lib/bitpacker.js
var require_bitpacker = __commonJS({
  "node_modules/pngjs/lib/bitpacker.js"(exports2, module2) {
    "use strict";
    var constants = require_constants4();
    module2.exports = function(dataIn, width, height, options) {
      let outHasAlpha = [constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA].indexOf(options.colorType) !== -1;
      if (options.colorType === options.inputColorType) {
        let bigEndian = function() {
          let buffer = new ArrayBuffer(2);
          new DataView(buffer).setInt16(0, 256, true);
          return new Int16Array(buffer)[0] !== 256;
        }();
        if (options.bitDepth === 8 || options.bitDepth === 16 && bigEndian) {
          return dataIn;
        }
      }
      let data = options.bitDepth !== 16 ? dataIn : new Uint16Array(dataIn.buffer);
      let maxValue = 255;
      let inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];
      if (inBpp === 4 && !options.inputHasAlpha) {
        inBpp = 3;
      }
      let outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];
      if (options.bitDepth === 16) {
        maxValue = 65535;
        outBpp *= 2;
      }
      let outData = Buffer.alloc(width * height * outBpp);
      let inIndex = 0;
      let outIndex = 0;
      let bgColor = options.bgColor || {};
      if (bgColor.red === void 0) {
        bgColor.red = maxValue;
      }
      if (bgColor.green === void 0) {
        bgColor.green = maxValue;
      }
      if (bgColor.blue === void 0) {
        bgColor.blue = maxValue;
      }
      function getRGBA() {
        let red;
        let green;
        let blue;
        let alpha = maxValue;
        switch (options.inputColorType) {
          case constants.COLORTYPE_COLOR_ALPHA:
            alpha = data[inIndex + 3];
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_COLOR:
            red = data[inIndex];
            green = data[inIndex + 1];
            blue = data[inIndex + 2];
            break;
          case constants.COLORTYPE_ALPHA:
            alpha = data[inIndex + 1];
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          case constants.COLORTYPE_GRAYSCALE:
            red = data[inIndex];
            green = red;
            blue = red;
            break;
          default:
            throw new Error("input color type:" + options.inputColorType + " is not supported at present");
        }
        if (options.inputHasAlpha) {
          if (!outHasAlpha) {
            alpha /= maxValue;
            red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue);
            green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue);
            blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue);
          }
        }
        return { red, green, blue, alpha };
      }
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let rgba = getRGBA(data, inIndex);
          switch (options.colorType) {
            case constants.COLORTYPE_COLOR_ALPHA:
            case constants.COLORTYPE_COLOR:
              if (options.bitDepth === 8) {
                outData[outIndex] = rgba.red;
                outData[outIndex + 1] = rgba.green;
                outData[outIndex + 2] = rgba.blue;
                if (outHasAlpha) {
                  outData[outIndex + 3] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(rgba.red, outIndex);
                outData.writeUInt16BE(rgba.green, outIndex + 2);
                outData.writeUInt16BE(rgba.blue, outIndex + 4);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 6);
                }
              }
              break;
            case constants.COLORTYPE_ALPHA:
            case constants.COLORTYPE_GRAYSCALE: {
              let grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
              if (options.bitDepth === 8) {
                outData[outIndex] = grayscale;
                if (outHasAlpha) {
                  outData[outIndex + 1] = rgba.alpha;
                }
              } else {
                outData.writeUInt16BE(grayscale, outIndex);
                if (outHasAlpha) {
                  outData.writeUInt16BE(rgba.alpha, outIndex + 2);
                }
              }
              break;
            }
            default:
              throw new Error("unrecognised color Type " + options.colorType);
          }
          inIndex += inBpp;
          outIndex += outBpp;
        }
      }
      return outData;
    };
  }
});

// node_modules/pngjs/lib/filter-pack.js
var require_filter_pack = __commonJS({
  "node_modules/pngjs/lib/filter-pack.js"(exports2, module2) {
    "use strict";
    var paethPredictor = require_paeth_predictor();
    function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (let x = 0; x < byteWidth; x++) {
        rawData[rawPos + x] = pxData[pxPos + x];
      }
    }
    function filterSumNone(pxData, pxPos, byteWidth) {
      let sum = 0;
      let length = pxPos + byteWidth;
      for (let i = pxPos; i < length; i++) {
        sum += Math.abs(pxData[i]);
      }
      return sum;
    }
    function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let val = pxData[pxPos + x] - left;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumSub(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let val = pxData[pxPos + x] - left;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
      for (let x = 0; x < byteWidth; x++) {
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let val = pxData[pxPos + x] - up;
        rawData[rawPos + x] = val;
      }
    }
    function filterSumUp(pxData, pxPos, byteWidth) {
      let sum = 0;
      let length = pxPos + byteWidth;
      for (let x = pxPos; x < length; x++) {
        let up = pxPos > 0 ? pxData[x - byteWidth] : 0;
        let val = pxData[x] - up;
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let val = pxData[pxPos + x] - (left + up >> 1);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let val = pxData[pxPos + x] - (left + up >> 1);
        sum += Math.abs(val);
      }
      return sum;
    }
    function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
        rawData[rawPos + x] = val;
      }
    }
    function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
      let sum = 0;
      for (let x = 0; x < byteWidth; x++) {
        let left = x >= bpp ? pxData[pxPos + x - bpp] : 0;
        let up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0;
        let upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0;
        let val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
        sum += Math.abs(val);
      }
      return sum;
    }
    var filters = {
      0: filterNone,
      1: filterSub,
      2: filterUp,
      3: filterAvg,
      4: filterPaeth
    };
    var filterSums = {
      0: filterSumNone,
      1: filterSumSub,
      2: filterSumUp,
      3: filterSumAvg,
      4: filterSumPaeth
    };
    module2.exports = function(pxData, width, height, options, bpp) {
      let filterTypes;
      if (!("filterType" in options) || options.filterType === -1) {
        filterTypes = [0, 1, 2, 3, 4];
      } else if (typeof options.filterType === "number") {
        filterTypes = [options.filterType];
      } else {
        throw new Error("unrecognised filter types");
      }
      if (options.bitDepth === 16) {
        bpp *= 2;
      }
      let byteWidth = width * bpp;
      let rawPos = 0;
      let pxPos = 0;
      let rawData = Buffer.alloc((byteWidth + 1) * height);
      let sel = filterTypes[0];
      for (let y = 0; y < height; y++) {
        if (filterTypes.length > 1) {
          let min = Infinity;
          for (let i = 0; i < filterTypes.length; i++) {
            let sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
            if (sum < min) {
              sel = filterTypes[i];
              min = sum;
            }
          }
        }
        rawData[rawPos] = sel;
        rawPos++;
        filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp);
        rawPos += byteWidth;
        pxPos += byteWidth;
      }
      return rawData;
    };
  }
});

// node_modules/pngjs/lib/packer.js
var require_packer = __commonJS({
  "node_modules/pngjs/lib/packer.js"(exports2, module2) {
    "use strict";
    var constants = require_constants4();
    var CrcStream = require_crc();
    var bitPacker = require_bitpacker();
    var filter = require_filter_pack();
    var zlib = require("zlib");
    var Packer = module2.exports = function(options) {
      this._options = options;
      options.deflateChunkSize = options.deflateChunkSize || 32 * 1024;
      options.deflateLevel = options.deflateLevel != null ? options.deflateLevel : 9;
      options.deflateStrategy = options.deflateStrategy != null ? options.deflateStrategy : 3;
      options.inputHasAlpha = options.inputHasAlpha != null ? options.inputHasAlpha : true;
      options.deflateFactory = options.deflateFactory || zlib.createDeflate;
      options.bitDepth = options.bitDepth || 8;
      options.colorType = typeof options.colorType === "number" ? options.colorType : constants.COLORTYPE_COLOR_ALPHA;
      options.inputColorType = typeof options.inputColorType === "number" ? options.inputColorType : constants.COLORTYPE_COLOR_ALPHA;
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options.colorType) === -1) {
        throw new Error("option color type:" + options.colorType + " is not supported at present");
      }
      if ([
        constants.COLORTYPE_GRAYSCALE,
        constants.COLORTYPE_COLOR,
        constants.COLORTYPE_COLOR_ALPHA,
        constants.COLORTYPE_ALPHA
      ].indexOf(options.inputColorType) === -1) {
        throw new Error("option input color type:" + options.inputColorType + " is not supported at present");
      }
      if (options.bitDepth !== 8 && options.bitDepth !== 16) {
        throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
      }
    };
    Packer.prototype.getDeflateOptions = function() {
      return {
        chunkSize: this._options.deflateChunkSize,
        level: this._options.deflateLevel,
        strategy: this._options.deflateStrategy
      };
    };
    Packer.prototype.createDeflate = function() {
      return this._options.deflateFactory(this.getDeflateOptions());
    };
    Packer.prototype.filterData = function(data, width, height) {
      let packedData = bitPacker(data, width, height, this._options);
      let bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
      let filteredData = filter(packedData, width, height, this._options, bpp);
      return filteredData;
    };
    Packer.prototype._packChunk = function(type, data) {
      let len = data ? data.length : 0;
      let buf = Buffer.alloc(len + 12);
      buf.writeUInt32BE(len, 0);
      buf.writeUInt32BE(type, 4);
      if (data) {
        data.copy(buf, 8);
      }
      buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4);
      return buf;
    };
    Packer.prototype.packGAMA = function(gamma) {
      let buf = Buffer.alloc(4);
      buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0);
      return this._packChunk(constants.TYPE_gAMA, buf);
    };
    Packer.prototype.packIHDR = function(width, height) {
      let buf = Buffer.alloc(13);
      buf.writeUInt32BE(width, 0);
      buf.writeUInt32BE(height, 4);
      buf[8] = this._options.bitDepth;
      buf[9] = this._options.colorType;
      buf[10] = 0;
      buf[11] = 0;
      buf[12] = 0;
      return this._packChunk(constants.TYPE_IHDR, buf);
    };
    Packer.prototype.packIDAT = function(data) {
      return this._packChunk(constants.TYPE_IDAT, data);
    };
    Packer.prototype.packIEND = function() {
      return this._packChunk(constants.TYPE_IEND, null);
    };
  }
});

// node_modules/pngjs/lib/packer-async.js
var require_packer_async = __commonJS({
  "node_modules/pngjs/lib/packer-async.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream");
    var constants = require_constants4();
    var Packer = require_packer();
    var PackerAsync = module2.exports = function(opt) {
      Stream.call(this);
      let options = opt || {};
      this._packer = new Packer(options);
      this._deflate = this._packer.createDeflate();
      this.readable = true;
    };
    util.inherits(PackerAsync, Stream);
    PackerAsync.prototype.pack = function(data, width, height, gamma) {
      this.emit("data", Buffer.from(constants.PNG_SIGNATURE));
      this.emit("data", this._packer.packIHDR(width, height));
      if (gamma) {
        this.emit("data", this._packer.packGAMA(gamma));
      }
      let filteredData = this._packer.filterData(data, width, height);
      this._deflate.on("error", this.emit.bind(this, "error"));
      this._deflate.on("data", function(compressedData) {
        this.emit("data", this._packer.packIDAT(compressedData));
      }.bind(this));
      this._deflate.on("end", function() {
        this.emit("data", this._packer.packIEND());
        this.emit("end");
      }.bind(this));
      this._deflate.end(filteredData);
    };
  }
});

// node_modules/pngjs/lib/sync-inflate.js
var require_sync_inflate = __commonJS({
  "node_modules/pngjs/lib/sync-inflate.js"(exports2, module2) {
    "use strict";
    var assert = require("assert").ok;
    var zlib = require("zlib");
    var util = require("util");
    var kMaxLength = require("buffer").kMaxLength;
    function Inflate(opts) {
      if (!(this instanceof Inflate)) {
        return new Inflate(opts);
      }
      if (opts && opts.chunkSize < zlib.Z_MIN_CHUNK) {
        opts.chunkSize = zlib.Z_MIN_CHUNK;
      }
      zlib.Inflate.call(this, opts);
      this._offset = this._offset === void 0 ? this._outOffset : this._offset;
      this._buffer = this._buffer || this._outBuffer;
      if (opts && opts.maxLength != null) {
        this._maxLength = opts.maxLength;
      }
    }
    function createInflate(opts) {
      return new Inflate(opts);
    }
    function _close(engine, callback) {
      if (callback) {
        process.nextTick(callback);
      }
      if (!engine._handle) {
        return;
      }
      engine._handle.close();
      engine._handle = null;
    }
    Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
      if (typeof asyncCb === "function") {
        return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
      }
      let self2 = this;
      let availInBefore = chunk && chunk.length;
      let availOutBefore = this._chunkSize - this._offset;
      let leftToInflate = this._maxLength;
      let inOff = 0;
      let buffers = [];
      let nread = 0;
      let error;
      this.on("error", function(err) {
        error = err;
      });
      function handleChunk(availInAfter, availOutAfter) {
        if (self2._hadError) {
          return;
        }
        let have = availOutBefore - availOutAfter;
        assert(have >= 0, "have should not go down");
        if (have > 0) {
          let out = self2._buffer.slice(self2._offset, self2._offset + have);
          self2._offset += have;
          if (out.length > leftToInflate) {
            out = out.slice(0, leftToInflate);
          }
          buffers.push(out);
          nread += out.length;
          leftToInflate -= out.length;
          if (leftToInflate === 0) {
            return false;
          }
        }
        if (availOutAfter === 0 || self2._offset >= self2._chunkSize) {
          availOutBefore = self2._chunkSize;
          self2._offset = 0;
          self2._buffer = Buffer.allocUnsafe(self2._chunkSize);
        }
        if (availOutAfter === 0) {
          inOff += availInBefore - availInAfter;
          availInBefore = availInAfter;
          return true;
        }
        return false;
      }
      assert(this._handle, "zlib binding closed");
      let res;
      do {
        res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
        res = res || this._writeState;
      } while (!this._hadError && handleChunk(res[0], res[1]));
      if (this._hadError) {
        throw error;
      }
      if (nread >= kMaxLength) {
        _close(this);
        throw new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
      }
      let buf = Buffer.concat(buffers, nread);
      _close(this);
      return buf;
    };
    util.inherits(Inflate, zlib.Inflate);
    function zlibBufferSync(engine, buffer) {
      if (typeof buffer === "string") {
        buffer = Buffer.from(buffer);
      }
      if (!(buffer instanceof Buffer)) {
        throw new TypeError("Not a string or buffer");
      }
      let flushFlag = engine._finishFlushFlag;
      if (flushFlag == null) {
        flushFlag = zlib.Z_FINISH;
      }
      return engine._processChunk(buffer, flushFlag);
    }
    function inflateSync(buffer, opts) {
      return zlibBufferSync(new Inflate(opts), buffer);
    }
    module2.exports = exports2 = inflateSync;
    exports2.Inflate = Inflate;
    exports2.createInflate = createInflate;
    exports2.inflateSync = inflateSync;
  }
});

// node_modules/pngjs/lib/sync-reader.js
var require_sync_reader = __commonJS({
  "node_modules/pngjs/lib/sync-reader.js"(exports2, module2) {
    "use strict";
    var SyncReader = module2.exports = function(buffer) {
      this._buffer = buffer;
      this._reads = [];
    };
    SyncReader.prototype.read = function(length, callback) {
      this._reads.push({
        length: Math.abs(length),
        allowLess: length < 0,
        func: callback
      });
    };
    SyncReader.prototype.process = function() {
      while (this._reads.length > 0 && this._buffer.length) {
        let read = this._reads[0];
        if (this._buffer.length && (this._buffer.length >= read.length || read.allowLess)) {
          this._reads.shift();
          let buf = this._buffer;
          this._buffer = buf.slice(read.length);
          read.func.call(this, buf.slice(0, read.length));
        } else {
          break;
        }
      }
      if (this._reads.length > 0) {
        throw new Error("There are some read requests waitng on finished stream");
      }
      if (this._buffer.length > 0) {
        throw new Error("unrecognised content at end of stream");
      }
    };
  }
});

// node_modules/pngjs/lib/filter-parse-sync.js
var require_filter_parse_sync = __commonJS({
  "node_modules/pngjs/lib/filter-parse-sync.js"(exports2) {
    "use strict";
    var SyncReader = require_sync_reader();
    var Filter = require_filter_parse();
    exports2.process = function(inBuffer, bitmapInfo) {
      let outBuffers = [];
      let reader = new SyncReader(inBuffer);
      let filter = new Filter(bitmapInfo, {
        read: reader.read.bind(reader),
        write: function(bufferPart) {
          outBuffers.push(bufferPart);
        },
        complete: function() {
        }
      });
      filter.start();
      reader.process();
      return Buffer.concat(outBuffers);
    };
  }
});

// node_modules/pngjs/lib/parser-sync.js
var require_parser_sync = __commonJS({
  "node_modules/pngjs/lib/parser-sync.js"(exports2, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib = require("zlib");
    var inflateSync = require_sync_inflate();
    if (!zlib.deflateSync) {
      hasSyncZlib = false;
    }
    var SyncReader = require_sync_reader();
    var FilterSync = require_filter_parse_sync();
    var Parser = require_parser();
    var bitmapper = require_bitmapper();
    var formatNormaliser = require_format_normaliser();
    module2.exports = function(buffer, options) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      let err;
      function handleError(_err_) {
        err = _err_;
      }
      let metaData;
      function handleMetaData(_metaData_) {
        metaData = _metaData_;
      }
      function handleTransColor(transColor) {
        metaData.transColor = transColor;
      }
      function handlePalette(palette) {
        metaData.palette = palette;
      }
      function handleSimpleTransparency() {
        metaData.alpha = true;
      }
      let gamma;
      function handleGamma(_gamma_) {
        gamma = _gamma_;
      }
      let inflateDataList = [];
      function handleInflateData(inflatedData2) {
        inflateDataList.push(inflatedData2);
      }
      let reader = new SyncReader(buffer);
      let parser = new Parser(options, {
        read: reader.read.bind(reader),
        error: handleError,
        metadata: handleMetaData,
        gamma: handleGamma,
        palette: handlePalette,
        transColor: handleTransColor,
        inflateData: handleInflateData,
        simpleTransparency: handleSimpleTransparency
      });
      parser.start();
      reader.process();
      if (err) {
        throw err;
      }
      let inflateData = Buffer.concat(inflateDataList);
      inflateDataList.length = 0;
      let inflatedData;
      if (metaData.interlace) {
        inflatedData = zlib.inflateSync(inflateData);
      } else {
        let rowSize = (metaData.width * metaData.bpp * metaData.depth + 7 >> 3) + 1;
        let imageSize = rowSize * metaData.height;
        inflatedData = inflateSync(inflateData, {
          chunkSize: imageSize,
          maxLength: imageSize
        });
      }
      inflateData = null;
      if (!inflatedData || !inflatedData.length) {
        throw new Error("bad png - invalid inflate data response");
      }
      let unfilteredData = FilterSync.process(inflatedData, metaData);
      inflateData = null;
      let bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
      unfilteredData = null;
      let normalisedBitmapData = formatNormaliser(bitmapData, metaData, options.skipRescale);
      metaData.data = normalisedBitmapData;
      metaData.gamma = gamma || 0;
      return metaData;
    };
  }
});

// node_modules/pngjs/lib/packer-sync.js
var require_packer_sync = __commonJS({
  "node_modules/pngjs/lib/packer-sync.js"(exports2, module2) {
    "use strict";
    var hasSyncZlib = true;
    var zlib = require("zlib");
    if (!zlib.deflateSync) {
      hasSyncZlib = false;
    }
    var constants = require_constants4();
    var Packer = require_packer();
    module2.exports = function(metaData, opt) {
      if (!hasSyncZlib) {
        throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
      }
      let options = opt || {};
      let packer = new Packer(options);
      let chunks = [];
      chunks.push(Buffer.from(constants.PNG_SIGNATURE));
      chunks.push(packer.packIHDR(metaData.width, metaData.height));
      if (metaData.gamma) {
        chunks.push(packer.packGAMA(metaData.gamma));
      }
      let filteredData = packer.filterData(metaData.data, metaData.width, metaData.height);
      let compressedData = zlib.deflateSync(filteredData, packer.getDeflateOptions());
      filteredData = null;
      if (!compressedData || !compressedData.length) {
        throw new Error("bad png - invalid compressed data response");
      }
      chunks.push(packer.packIDAT(compressedData));
      chunks.push(packer.packIEND());
      return Buffer.concat(chunks);
    };
  }
});

// node_modules/pngjs/lib/png-sync.js
var require_png_sync = __commonJS({
  "node_modules/pngjs/lib/png-sync.js"(exports2) {
    "use strict";
    var parse = require_parser_sync();
    var pack = require_packer_sync();
    exports2.read = function(buffer, options) {
      return parse(buffer, options || {});
    };
    exports2.write = function(png, options) {
      return pack(png, options);
    };
  }
});

// node_modules/pngjs/lib/png.js
var require_png = __commonJS({
  "node_modules/pngjs/lib/png.js"(exports2) {
    "use strict";
    var util = require("util");
    var Stream = require("stream");
    var Parser = require_parser_async();
    var Packer = require_packer_async();
    var PNGSync = require_png_sync();
    var PNG = exports2.PNG = function(options) {
      Stream.call(this);
      options = options || {};
      this.width = options.width | 0;
      this.height = options.height | 0;
      this.data = this.width > 0 && this.height > 0 ? Buffer.alloc(4 * this.width * this.height) : null;
      if (options.fill && this.data) {
        this.data.fill(0);
      }
      this.gamma = 0;
      this.readable = this.writable = true;
      this._parser = new Parser(options);
      this._parser.on("error", this.emit.bind(this, "error"));
      this._parser.on("close", this._handleClose.bind(this));
      this._parser.on("metadata", this._metadata.bind(this));
      this._parser.on("gamma", this._gamma.bind(this));
      this._parser.on("parsed", function(data) {
        this.data = data;
        this.emit("parsed", data);
      }.bind(this));
      this._packer = new Packer(options);
      this._packer.on("data", this.emit.bind(this, "data"));
      this._packer.on("end", this.emit.bind(this, "end"));
      this._parser.on("close", this._handleClose.bind(this));
      this._packer.on("error", this.emit.bind(this, "error"));
    };
    util.inherits(PNG, Stream);
    PNG.sync = PNGSync;
    PNG.prototype.pack = function() {
      if (!this.data || !this.data.length) {
        this.emit("error", "No data provided");
        return this;
      }
      process.nextTick(function() {
        this._packer.pack(this.data, this.width, this.height, this.gamma);
      }.bind(this));
      return this;
    };
    PNG.prototype.parse = function(data, callback) {
      if (callback) {
        let onParsed, onError;
        onParsed = function(parsedData) {
          this.removeListener("error", onError);
          this.data = parsedData;
          callback(null, this);
        }.bind(this);
        onError = function(err) {
          this.removeListener("parsed", onParsed);
          callback(err, null);
        }.bind(this);
        this.once("parsed", onParsed);
        this.once("error", onError);
      }
      this.end(data);
      return this;
    };
    PNG.prototype.write = function(data) {
      this._parser.write(data);
      return true;
    };
    PNG.prototype.end = function(data) {
      this._parser.end(data);
    };
    PNG.prototype._metadata = function(metadata) {
      this.width = metadata.width;
      this.height = metadata.height;
      this.emit("metadata", metadata);
    };
    PNG.prototype._gamma = function(gamma) {
      this.gamma = gamma;
    };
    PNG.prototype._handleClose = function() {
      if (!this._parser.writable && !this._packer.readable) {
        this.emit("close");
      }
    };
    PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
      srcX |= 0;
      srcY |= 0;
      width |= 0;
      height |= 0;
      deltaX |= 0;
      deltaY |= 0;
      if (srcX > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) {
        throw new Error("bitblt reading outside image");
      }
      if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) {
        throw new Error("bitblt writing outside image");
      }
      for (let y = 0; y < height; y++) {
        src.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src.width + srcX << 2, (srcY + y) * src.width + srcX + width << 2);
      }
    };
    PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
      PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY);
      return this;
    };
    PNG.adjustGamma = function(src) {
      if (src.gamma) {
        for (let y = 0; y < src.height; y++) {
          for (let x = 0; x < src.width; x++) {
            let idx = src.width * y + x << 2;
            for (let i = 0; i < 3; i++) {
              let sample = src.data[idx + i] / 255;
              sample = Math.pow(sample, 1 / 2.2 / src.gamma);
              src.data[idx + i] = Math.round(sample * 255);
            }
          }
        }
        src.gamma = 0;
      }
    };
    PNG.prototype.adjustGamma = function() {
      PNG.adjustGamma(this);
    };
  }
});

// node_modules/playwright-core/lib/server/webkit/wkAccessibility.js
var require_wkAccessibility = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkAccessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getAccessibilityTree = getAccessibilityTree;
    function getAccessibilityTree(session, needle) {
      return __async(this, null, function* () {
        const objectId = needle ? needle._objectId : void 0;
        const {
          axNode
        } = yield session.send("Page.accessibilitySnapshot", {
          objectId
        });
        const tree = new WKAXNode(axNode);
        return {
          tree,
          needle: needle ? tree._findNeedle() : null
        };
      });
    }
    var WKRoleToARIARole = new Map(Object.entries({
      "TextField": "textbox"
    }));
    var WKUnhelpfulRoleDescriptions = new Map(Object.entries({
      "WebArea": "HTML content",
      "Summary": "summary",
      "DescriptionList": "description list",
      "ImageMap": "image map",
      "ListMarker": "list marker",
      "Video": "video playback",
      "Mark": "highlighted",
      "contentinfo": "content information",
      "Details": "details",
      "DescriptionListDetail": "description",
      "DescriptionListTerm": "term",
      "alertdialog": "web alert dialog",
      "dialog": "web dialog",
      "status": "application status",
      "tabpanel": "tab panel",
      "application": "web application"
    }));
    var WKAXNode = class {
      constructor(payload) {
        this._payload = void 0;
        this._children = void 0;
        this._payload = payload;
        this._children = [];
        for (const payload2 of this._payload.children || [])
          this._children.push(new WKAXNode(payload2));
      }
      children() {
        return this._children;
      }
      _findNeedle() {
        if (this._payload.found)
          return this;
        for (const child of this._children) {
          const found = child._findNeedle();
          if (found)
            return found;
        }
        return null;
      }
      isControl() {
        switch (this._payload.role) {
          case "button":
          case "checkbox":
          case "ColorWell":
          case "combobox":
          case "DisclosureTriangle":
          case "listbox":
          case "menu":
          case "menubar":
          case "menuitem":
          case "menuitemcheckbox":
          case "menuitemradio":
          case "radio":
          case "scrollbar":
          case "searchbox":
          case "slider":
          case "spinbutton":
          case "switch":
          case "tab":
          case "textbox":
          case "TextField":
          case "tree":
            return true;
          default:
            return false;
        }
      }
      _isTextControl() {
        switch (this._payload.role) {
          case "combobox":
          case "searchfield":
          case "textbox":
          case "TextField":
            return true;
        }
        return false;
      }
      _name() {
        if (this._payload.role === "text")
          return this._payload.value || "";
        return this._payload.name || "";
      }
      isInteresting(insideControl) {
        const {
          role,
          focusable
        } = this._payload;
        const name = this._name();
        if (role === "ScrollArea")
          return false;
        if (role === "WebArea")
          return true;
        if (focusable || role === "MenuListOption")
          return true;
        if (this.isControl())
          return true;
        if (insideControl)
          return false;
        return this.isLeafNode() && !!name;
      }
      _hasRendundantTextChild() {
        if (this._children.length !== 1)
          return false;
        const child = this._children[0];
        return child._payload.role === "text" && this._payload.name === child._payload.value;
      }
      isLeafNode() {
        if (!this._children.length)
          return true;
        if (this._isTextControl())
          return true;
        if (this._hasRendundantTextChild())
          return true;
        return false;
      }
      serialize() {
        const node = {
          role: WKRoleToARIARole.get(this._payload.role) || this._payload.role,
          name: this._name()
        };
        if ("description" in this._payload && this._payload.description !== node.name)
          node.description = this._payload.description;
        if ("roledescription" in this._payload) {
          const roledescription = this._payload.roledescription;
          if (roledescription !== this._payload.role && WKUnhelpfulRoleDescriptions.get(this._payload.role) !== roledescription)
            node.roledescription = roledescription;
        }
        if ("value" in this._payload && this._payload.role !== "text") {
          if (typeof this._payload.value === "string")
            node.valueString = this._payload.value;
          else if (typeof this._payload.value === "number")
            node.valueNumber = this._payload.value;
        }
        if ("checked" in this._payload)
          node.checked = this._payload.checked === "true" ? "checked" : this._payload.checked === "false" ? "unchecked" : "mixed";
        if ("pressed" in this._payload)
          node.pressed = this._payload.pressed === "true" ? "pressed" : this._payload.pressed === "false" ? "released" : "mixed";
        const userStringProperties = ["keyshortcuts", "valuetext"];
        for (const userStringProperty of userStringProperties) {
          if (!(userStringProperty in this._payload))
            continue;
          node[userStringProperty] = this._payload[userStringProperty];
        }
        const booleanProperties = ["disabled", "expanded", "focused", "modal", "multiline", "multiselectable", "readonly", "required", "selected"];
        for (const booleanProperty of booleanProperties) {
          if (booleanProperty === "focused" && (this._payload.role === "WebArea" || this._payload.role === "ScrollArea"))
            continue;
          const value = this._payload[booleanProperty];
          if (!value)
            continue;
          node[booleanProperty] = value;
        }
        const numericalProperties = ["level", "valuemax", "valuemin"];
        for (const numericalProperty of numericalProperties) {
          if (!(numericalProperty in this._payload))
            continue;
          node[numericalProperty] = this._payload[numericalProperty];
        }
        const tokenProperties = ["autocomplete", "haspopup", "invalid"];
        for (const tokenProperty of tokenProperties) {
          const value = this._payload[tokenProperty];
          if (!value || value === "false")
            continue;
          node[tokenProperty] = value;
        }
        const orientationIsApplicable = /* @__PURE__ */ new Set(["ScrollArea", "scrollbar", "listbox", "combobox", "menu", "tree", "separator", "slider", "tablist", "toolbar"]);
        if (this._payload.orientation && orientationIsApplicable.has(this._payload.role))
          node.orientation = this._payload.orientation;
        return node;
      }
    };
  }
});

// node_modules/playwright-core/lib/server/webkit/wkExecutionContext.js
var require_wkExecutionContext = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkExecutionContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKExecutionContext = void 0;
    var js = _interopRequireWildcard(require_javascript());
    var _utilityScriptSerializers = require_utilityScriptSerializers();
    var _protocolError = require_protocolError();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var WKExecutionContext = class {
      constructor(session, contextId) {
        this._session = void 0;
        this._contextId = void 0;
        this._session = session;
        this._contextId = contextId;
      }
      rawEvaluateJSON(expression) {
        return __async(this, null, function* () {
          try {
            const response = yield this._session.send("Runtime.evaluate", {
              expression,
              contextId: this._contextId,
              returnByValue: true
            });
            if (response.wasThrown)
              throw new js.JavaScriptErrorInEvaluate(response.result.description);
            return response.result.value;
          } catch (error) {
            throw rewriteError(error);
          }
        });
      }
      rawEvaluateHandle(expression) {
        return __async(this, null, function* () {
          try {
            const response = yield this._session.send("Runtime.evaluate", {
              expression,
              contextId: this._contextId,
              returnByValue: false
            });
            if (response.wasThrown)
              throw new js.JavaScriptErrorInEvaluate(response.result.description);
            return response.result.objectId;
          } catch (error) {
            throw rewriteError(error);
          }
        });
      }
      rawCallFunctionNoReply(func, ...args) {
        this._session.send("Runtime.callFunctionOn", {
          functionDeclaration: func.toString(),
          objectId: args.find((a) => a instanceof js.JSHandle)._objectId,
          arguments: args.map((a) => a instanceof js.JSHandle ? {
            objectId: a._objectId
          } : {
            value: a
          }),
          returnByValue: true,
          emulateUserGesture: true
        }).catch(() => {
        });
      }
      evaluateWithArguments(expression, returnByValue, utilityScript, values, objectIds) {
        return __async(this, null, function* () {
          try {
            const response = yield this._session.send("Runtime.callFunctionOn", {
              functionDeclaration: expression,
              objectId: utilityScript._objectId,
              arguments: [{
                objectId: utilityScript._objectId
              }, ...values.map((value) => ({
                value
              })), ...objectIds.map((objectId) => ({
                objectId
              }))],
              returnByValue,
              emulateUserGesture: true,
              awaitPromise: true
            });
            if (response.wasThrown)
              throw new js.JavaScriptErrorInEvaluate(response.result.description);
            if (returnByValue)
              return (0, _utilityScriptSerializers.parseEvaluationResultValue)(response.result.value);
            return utilityScript._context.createHandle(response.result);
          } catch (error) {
            throw rewriteError(error);
          }
        });
      }
      getProperties(context, objectId) {
        return __async(this, null, function* () {
          const response = yield this._session.send("Runtime.getProperties", {
            objectId,
            ownProperties: true
          });
          const result = /* @__PURE__ */ new Map();
          for (const property of response.properties) {
            if (!property.enumerable || !property.value)
              continue;
            result.set(property.name, context.createHandle(property.value));
          }
          return result;
        });
      }
      createHandle(context, remoteObject) {
        const isPromise = remoteObject.className === "Promise";
        return new js.JSHandle(context, isPromise ? "promise" : remoteObject.subtype || remoteObject.type, renderPreview(remoteObject), remoteObject.objectId, potentiallyUnserializableValue(remoteObject));
      }
      releaseHandle(objectId) {
        return __async(this, null, function* () {
          yield this._session.send("Runtime.releaseObject", {
            objectId
          });
        });
      }
    };
    exports2.WKExecutionContext = WKExecutionContext;
    function potentiallyUnserializableValue(remoteObject) {
      const value = remoteObject.value;
      const isUnserializable = remoteObject.type === "number" && ["NaN", "-Infinity", "Infinity", "-0"].includes(remoteObject.description);
      return isUnserializable ? js.parseUnserializableValue(remoteObject.description) : value;
    }
    function rewriteError(error) {
      if (!js.isJavaScriptErrorInEvaluate(error) && !(0, _protocolError.isSessionClosedError)(error))
        return new Error("Execution context was destroyed, most likely because of a navigation.");
      return error;
    }
    function renderPreview(object) {
      if (object.type === "undefined")
        return "undefined";
      if ("value" in object)
        return String(object.value);
      if (object.description === "Object" && object.preview) {
        const tokens = [];
        for (const {
          name,
          value
        } of object.preview.properties)
          tokens.push(`${name}: ${value}`);
        return `{${tokens.join(", ")}}`;
      }
      if (object.subtype === "array" && object.preview) {
        const result = [];
        for (const {
          name,
          value
        } of object.preview.properties)
          result[+name] = value;
        return "[" + String(result) + "]";
      }
      return object.description;
    }
  }
});

// node_modules/playwright-core/lib/server/webkit/wkInput.js
var require_wkInput = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkInput.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RawTouchscreenImpl = exports2.RawMouseImpl = exports2.RawKeyboardImpl = void 0;
    var input = _interopRequireWildcard(require_input());
    var _macEditingCommands = require_macEditingCommands();
    var _utils = require_utils();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function toModifiersMask(modifiers) {
      let mask = 0;
      if (modifiers.has("Shift"))
        mask |= 1;
      if (modifiers.has("Control"))
        mask |= 2;
      if (modifiers.has("Alt"))
        mask |= 4;
      if (modifiers.has("Meta"))
        mask |= 8;
      return mask;
    }
    function toButtonsMask(buttons) {
      let mask = 0;
      if (buttons.has("left"))
        mask |= 1;
      if (buttons.has("right"))
        mask |= 2;
      if (buttons.has("middle"))
        mask |= 4;
      return mask;
    }
    var RawKeyboardImpl = class {
      constructor(session) {
        this._pageProxySession = void 0;
        this._session = void 0;
        this._pageProxySession = session;
      }
      setSession(session) {
        this._session = session;
      }
      keydown(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2, autoRepeat, text) {
        return __async(this, null, function* () {
          const parts = [];
          for (const modifier of ["Shift", "Control", "Alt", "Meta"]) {
            if (modifiers.has(modifier))
              parts.push(modifier);
          }
          parts.push(code);
          const shortcut = parts.join("+");
          let commands = _macEditingCommands.macEditingCommands[shortcut];
          if ((0, _utils.isString)(commands))
            commands = [commands];
          yield this._pageProxySession.send("Input.dispatchKeyEvent", {
            type: "keyDown",
            modifiers: toModifiersMask(modifiers),
            windowsVirtualKeyCode: keyCode,
            code,
            key,
            text,
            unmodifiedText: text,
            autoRepeat,
            macCommands: commands,
            isKeypad: location2 === input.keypadLocation
          });
        });
      }
      keyup(modifiers, code, keyCode, keyCodeWithoutLocation, key, location2) {
        return __async(this, null, function* () {
          yield this._pageProxySession.send("Input.dispatchKeyEvent", {
            type: "keyUp",
            modifiers: toModifiersMask(modifiers),
            key,
            windowsVirtualKeyCode: keyCode,
            code,
            isKeypad: location2 === input.keypadLocation
          });
        });
      }
      sendText(text) {
        return __async(this, null, function* () {
          yield this._session.send("Page.insertText", {
            text
          });
        });
      }
    };
    exports2.RawKeyboardImpl = RawKeyboardImpl;
    var RawMouseImpl = class {
      constructor(session) {
        this._pageProxySession = void 0;
        this._session = void 0;
        this._page = void 0;
        this._pageProxySession = session;
      }
      setSession(session) {
        this._session = session;
      }
      move(x, y, button, buttons, modifiers, forClick) {
        return __async(this, null, function* () {
          yield this._pageProxySession.send("Input.dispatchMouseEvent", {
            type: "move",
            button,
            buttons: toButtonsMask(buttons),
            x,
            y,
            modifiers: toModifiersMask(modifiers)
          });
        });
      }
      down(x, y, button, buttons, modifiers, clickCount) {
        return __async(this, null, function* () {
          yield this._pageProxySession.send("Input.dispatchMouseEvent", {
            type: "down",
            button,
            buttons: toButtonsMask(buttons),
            x,
            y,
            modifiers: toModifiersMask(modifiers),
            clickCount
          });
        });
      }
      up(x, y, button, buttons, modifiers, clickCount) {
        return __async(this, null, function* () {
          yield this._pageProxySession.send("Input.dispatchMouseEvent", {
            type: "up",
            button,
            buttons: toButtonsMask(buttons),
            x,
            y,
            modifiers: toModifiersMask(modifiers),
            clickCount
          });
        });
      }
      wheel(x, y, buttons, modifiers, deltaX, deltaY) {
        return __async(this, null, function* () {
          var _this$_page;
          if ((_this$_page = this._page) !== null && _this$_page !== void 0 && _this$_page._browserContext._options.isMobile)
            throw new Error("Mouse wheel is not supported in mobile WebKit");
          yield this._session.send("Page.updateScrollingState");
          yield this._page.mainFrame().evaluateExpression(`new Promise(requestAnimationFrame)`, false, false, "utility");
          yield this._pageProxySession.send("Input.dispatchWheelEvent", {
            x,
            y,
            deltaX,
            deltaY,
            modifiers: toModifiersMask(modifiers)
          });
        });
      }
      setPage(page) {
        this._page = page;
      }
    };
    exports2.RawMouseImpl = RawMouseImpl;
    var RawTouchscreenImpl = class {
      constructor(session) {
        this._pageProxySession = void 0;
        this._pageProxySession = session;
      }
      tap(x, y, modifiers) {
        return __async(this, null, function* () {
          yield this._pageProxySession.send("Input.dispatchTapEvent", {
            x,
            y,
            modifiers: toModifiersMask(modifiers)
          });
        });
      }
    };
    exports2.RawTouchscreenImpl = RawTouchscreenImpl;
  }
});

// node_modules/playwright-core/lib/server/webkit/wkInterceptableRequest.js
var require_wkInterceptableRequest = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkInterceptableRequest.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKRouteImpl = exports2.WKInterceptableRequest = void 0;
    var network = _interopRequireWildcard(require_network());
    var _utils = require_utils();
    var _manualPromise = require_manualPromise();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var errorReasons = {
      "aborted": "Cancellation",
      "accessdenied": "AccessControl",
      "addressunreachable": "General",
      "blockedbyclient": "Cancellation",
      "blockedbyresponse": "General",
      "connectionaborted": "General",
      "connectionclosed": "General",
      "connectionfailed": "General",
      "connectionrefused": "General",
      "connectionreset": "General",
      "internetdisconnected": "General",
      "namenotresolved": "General",
      "timedout": "Timeout",
      "failed": "General"
    };
    var WKInterceptableRequest = class {
      constructor(session, route, frame, event, redirectedFrom, documentId) {
        this._session = void 0;
        this.request = void 0;
        this._requestId = void 0;
        this._timestamp = void 0;
        this._wallTime = void 0;
        this._route = void 0;
        this._redirectedFrom = void 0;
        this._session = session;
        this._requestId = event.requestId;
        this._route = route;
        this._redirectedFrom = redirectedFrom;
        const resourceType = event.type ? event.type.toLowerCase() : redirectedFrom ? redirectedFrom.request.resourceType() : "other";
        let postDataBuffer = null;
        this._timestamp = event.timestamp;
        this._wallTime = event.walltime * 1e3;
        if (event.request.postData)
          postDataBuffer = Buffer.from(event.request.postData, "base64");
        this.request = new network.Request(frame, (redirectedFrom === null || redirectedFrom === void 0 ? void 0 : redirectedFrom.request) || null, documentId, event.request.url, resourceType, event.request.method, postDataBuffer, (0, _utils.headersObjectToArray)(event.request.headers));
      }
      _routeForRedirectChain() {
        let request = this;
        while (request._redirectedFrom)
          request = request._redirectedFrom;
        return request._route;
      }
      createResponse(responsePayload) {
        const getResponseBody = () => __async(this, null, function* () {
          const response = yield this._session.send("Network.getResponseBody", {
            requestId: this._requestId
          });
          return Buffer.from(response.body, response.base64Encoded ? "base64" : "utf8");
        });
        const timingPayload = responsePayload.timing;
        const timing = {
          startTime: this._wallTime,
          domainLookupStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupStart) : -1,
          domainLookupEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.domainLookupEnd) : -1,
          connectStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectStart) : -1,
          secureConnectionStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.secureConnectionStart) : -1,
          connectEnd: timingPayload ? wkMillisToRoundishMillis(timingPayload.connectEnd) : -1,
          requestStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.requestStart) : -1,
          responseStart: timingPayload ? wkMillisToRoundishMillis(timingPayload.responseStart) : -1
        };
        const setCookieSeparator = process.platform === "darwin" ? "," : "\n";
        return new network.Response(this.request, responsePayload.status, responsePayload.statusText, (0, _utils.headersObjectToArray)(responsePayload.headers, ",", setCookieSeparator), timing, getResponseBody);
      }
    };
    exports2.WKInterceptableRequest = WKInterceptableRequest;
    var WKRouteImpl = class {
      constructor(session, requestId) {
        this._session = void 0;
        this._requestId = void 0;
        this._requestInterceptedPromise = new _manualPromise.ManualPromise();
        this._session = session;
        this._requestId = requestId;
      }
      abort(errorCode) {
        return __async(this, null, function* () {
          const errorType = errorReasons[errorCode];
          (0, _utils.assert)(errorType, "Unknown error code: " + errorCode);
          yield this._requestInterceptedPromise;
          yield this._session.sendMayFail("Network.interceptRequestWithError", {
            requestId: this._requestId,
            errorType
          });
        });
      }
      fulfill(response) {
        return __async(this, null, function* () {
          if (300 <= response.status && response.status < 400)
            throw new Error("Cannot fulfill with redirect status: " + response.status);
          yield this._requestInterceptedPromise;
          let mimeType = response.isBase64 ? "application/octet-stream" : "text/plain";
          const headers = (0, _utils.headersArrayToObject)(response.headers, true);
          const contentType = headers["content-type"];
          if (contentType)
            mimeType = contentType.split(";")[0].trim();
          yield this._session.sendMayFail("Network.interceptRequestWithResponse", {
            requestId: this._requestId,
            status: response.status,
            statusText: network.STATUS_TEXTS[String(response.status)],
            mimeType,
            headers,
            base64Encoded: response.isBase64,
            content: response.body
          });
        });
      }
      continue(request, overrides) {
        return __async(this, null, function* () {
          yield this._requestInterceptedPromise;
          yield this._session.sendMayFail("Network.interceptWithRequest", {
            requestId: this._requestId,
            url: overrides.url,
            method: overrides.method,
            headers: overrides.headers ? (0, _utils.headersArrayToObject)(overrides.headers, false) : void 0,
            postData: overrides.postData ? Buffer.from(overrides.postData).toString("base64") : void 0
          });
        });
      }
    };
    exports2.WKRouteImpl = WKRouteImpl;
    function wkMillisToRoundishMillis(value) {
      if (value === -1e3)
        return -1;
      if (value <= 0) {
        return -1;
      }
      return (value * 1e3 | 0) / 1e3;
    }
  }
});

// node_modules/playwright-core/lib/server/webkit/wkProvisionalPage.js
var require_wkProvisionalPage = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkProvisionalPage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKProvisionalPage = void 0;
    var _eventsHelper = require_eventsHelper();
    var _utils = require_utils();
    var WKProvisionalPage = class {
      constructor(session, page) {
        this._session = void 0;
        this._wkPage = void 0;
        this._sessionListeners = [];
        this._mainFrameId = null;
        this.initializationPromise = void 0;
        this._session = session;
        this._wkPage = page;
        const overrideFrameId = (handler) => {
          return (payload) => {
            if (payload.frameId)
              payload.frameId = this._wkPage._page._frameManager.mainFrame()._id;
            handler(payload);
          };
        };
        const wkPage = this._wkPage;
        this._sessionListeners = [_eventsHelper.eventsHelper.addEventListener(session, "Network.requestWillBeSent", overrideFrameId((e) => wkPage._onRequestWillBeSent(session, e))), _eventsHelper.eventsHelper.addEventListener(session, "Network.requestIntercepted", overrideFrameId((e) => wkPage._onRequestIntercepted(session, e))), _eventsHelper.eventsHelper.addEventListener(session, "Network.responseReceived", overrideFrameId((e) => wkPage._onResponseReceived(e))), _eventsHelper.eventsHelper.addEventListener(session, "Network.loadingFinished", overrideFrameId((e) => wkPage._onLoadingFinished(e))), _eventsHelper.eventsHelper.addEventListener(session, "Network.loadingFailed", overrideFrameId((e) => wkPage._onLoadingFailed(e)))];
        this.initializationPromise = this._wkPage._initializeSession(session, true, ({
          frameTree
        }) => this._handleFrameTree(frameTree));
      }
      dispose() {
        _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
      }
      commit() {
        (0, _utils.assert)(this._mainFrameId);
        this._wkPage._onFrameAttached(this._mainFrameId, null);
      }
      _handleFrameTree(frameTree) {
        (0, _utils.assert)(!frameTree.frame.parentId);
        this._mainFrameId = frameTree.frame.id;
      }
    };
    exports2.WKProvisionalPage = WKProvisionalPage;
  }
});

// node_modules/playwright-core/lib/server/webkit/wkWorkers.js
var require_wkWorkers = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkWorkers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKWorkers = void 0;
    var _eventsHelper = require_eventsHelper();
    var _page = require_page();
    var _wkConnection = require_wkConnection();
    var _wkExecutionContext = require_wkExecutionContext();
    var WKWorkers = class {
      constructor(page) {
        this._sessionListeners = [];
        this._page = void 0;
        this._workerSessions = /* @__PURE__ */ new Map();
        this._page = page;
      }
      setSession(session) {
        _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
        this.clear();
        this._sessionListeners = [_eventsHelper.eventsHelper.addEventListener(session, "Worker.workerCreated", (event) => {
          const worker = new _page.Worker(this._page, event.url);
          const workerSession = new _wkConnection.WKSession(session.connection, event.workerId, "Most likely the worker has been closed.", (message) => {
            session.send("Worker.sendMessageToWorker", {
              workerId: event.workerId,
              message: JSON.stringify(message)
            }).catch((e) => {
              workerSession.dispatchMessage({
                id: message.id,
                error: {
                  message: e.message
                }
              });
            });
          });
          this._workerSessions.set(event.workerId, workerSession);
          worker._createExecutionContext(new _wkExecutionContext.WKExecutionContext(workerSession, void 0));
          this._page._addWorker(event.workerId, worker);
          workerSession.on("Console.messageAdded", (event2) => this._onConsoleMessage(worker, event2));
          Promise.all([workerSession.send("Runtime.enable"), workerSession.send("Console.enable"), session.send("Worker.initialized", {
            workerId: event.workerId
          })]).catch((e) => {
            this._page._removeWorker(event.workerId);
          });
        }), _eventsHelper.eventsHelper.addEventListener(session, "Worker.dispatchMessageFromWorker", (event) => {
          const workerSession = this._workerSessions.get(event.workerId);
          if (!workerSession)
            return;
          workerSession.dispatchMessage(JSON.parse(event.message));
        }), _eventsHelper.eventsHelper.addEventListener(session, "Worker.workerTerminated", (event) => {
          const workerSession = this._workerSessions.get(event.workerId);
          if (!workerSession)
            return;
          workerSession.dispose(false);
          this._workerSessions.delete(event.workerId);
          this._page._removeWorker(event.workerId);
        })];
      }
      clear() {
        this._page._clearWorkers();
        this._workerSessions.clear();
      }
      initializeSession(session) {
        return __async(this, null, function* () {
          yield session.send("Worker.enable");
        });
      }
      _onConsoleMessage(worker, event) {
        return __async(this, null, function* () {
          const {
            type,
            level,
            text,
            parameters,
            url,
            line: lineNumber,
            column: columnNumber
          } = event.message;
          let derivedType = type || "";
          if (type === "log")
            derivedType = level;
          else if (type === "timing")
            derivedType = "timeEnd";
          const handles = (parameters || []).map((p) => {
            return worker._existingExecutionContext.createHandle(p);
          });
          const location2 = {
            url: url || "",
            lineNumber: (lineNumber || 1) - 1,
            columnNumber: (columnNumber || 1) - 1
          };
          this._page._addConsoleMessage(derivedType, handles, location2, handles.length ? void 0 : text);
        });
      }
    };
    exports2.WKWorkers = WKWorkers;
  }
});

// node_modules/playwright-core/lib/server/webkit/wkPage.js
var require_wkPage = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkPage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKPage = void 0;
    var jpeg = _interopRequireWildcard(require_jpeg_js());
    var _path = _interopRequireDefault(require("path"));
    var png = _interopRequireWildcard(require_png());
    var _stackTrace = require_stackTrace();
    var _utils = require_utils();
    var _hostPlatform = require_hostPlatform();
    var dialog = _interopRequireWildcard(require_dialog());
    var dom = _interopRequireWildcard(require_dom());
    var _eventsHelper = require_eventsHelper();
    var _helper = require_helper();
    var network = _interopRequireWildcard(require_network());
    var _page = require_page();
    var _wkAccessibility = require_wkAccessibility();
    var _wkConnection = require_wkConnection();
    var _wkExecutionContext = require_wkExecutionContext();
    var _wkInput = require_wkInput();
    var _wkInterceptableRequest = require_wkInterceptableRequest();
    var _wkProvisionalPage = require_wkProvisionalPage();
    var _wkWorkers = require_wkWorkers();
    var _debugLogger = require_debugLogger();
    var _manualPromise = require_manualPromise();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var UTILITY_WORLD_NAME = "__playwright_utility_world__";
    var BINDING_CALL_MESSAGE = "__playwright_binding_call__";
    var WKPage = class {
      constructor(browserContext, pageProxySession, opener) {
        this.rawMouse = void 0;
        this.rawKeyboard = void 0;
        this.rawTouchscreen = void 0;
        this._session = void 0;
        this._provisionalPage = null;
        this._page = void 0;
        this._pagePromise = new _manualPromise.ManualPromise();
        this._pageProxySession = void 0;
        this._opener = void 0;
        this._requestIdToRequest = /* @__PURE__ */ new Map();
        this._workers = void 0;
        this._contextIdToContext = void 0;
        this._mainFrameContextId = void 0;
        this._sessionListeners = [];
        this._eventListeners = void 0;
        this._browserContext = void 0;
        this._initializedPage = null;
        this._firstNonInitialNavigationCommittedPromise = void 0;
        this._firstNonInitialNavigationCommittedFulfill = () => {
        };
        this._firstNonInitialNavigationCommittedReject = (e) => {
        };
        this._lastConsoleMessage = null;
        this._requestIdToResponseReceivedPayloadEvent = /* @__PURE__ */ new Map();
        this._nextWindowOpenPopupFeatures = void 0;
        this._recordingVideoFile = null;
        this._screencastGeneration = 0;
        this._interceptingFileChooser = false;
        this._pageProxySession = pageProxySession;
        this._opener = opener;
        this.rawKeyboard = new _wkInput.RawKeyboardImpl(pageProxySession);
        this.rawMouse = new _wkInput.RawMouseImpl(pageProxySession);
        this.rawTouchscreen = new _wkInput.RawTouchscreenImpl(pageProxySession);
        this._contextIdToContext = /* @__PURE__ */ new Map();
        this._page = new _page.Page(this, browserContext);
        this.rawMouse.setPage(this._page);
        this._workers = new _wkWorkers.WKWorkers(this._page);
        this._session = void 0;
        this._browserContext = browserContext;
        this._page.on(_page.Page.Events.FrameDetached, (frame) => this._removeContextsForFrame(frame, false));
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Target.targetCreated", this._onTargetCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Target.targetDestroyed", this._onTargetDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Target.dispatchMessageFromTarget", this._onDispatchMessageFromTarget.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Target.didCommitProvisionalTarget", this._onDidCommitProvisionalTarget.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Screencast.screencastFrame", this._onScreencastFrame.bind(this))];
        this._firstNonInitialNavigationCommittedPromise = new Promise((f, r) => {
          this._firstNonInitialNavigationCommittedFulfill = f;
          this._firstNonInitialNavigationCommittedReject = r;
        });
        if (opener && !browserContext._options.noDefaultViewport && opener._nextWindowOpenPopupFeatures) {
          const viewportSize = _helper.helper.getViewportSizeFromWindowFeatures(opener._nextWindowOpenPopupFeatures);
          opener._nextWindowOpenPopupFeatures = void 0;
          if (viewportSize)
            this._page._state.emulatedSize = {
              viewport: viewportSize,
              screen: viewportSize
            };
        }
      }
      potentiallyUninitializedPage() {
        return this._page;
      }
      _initializePageProxySession() {
        return __async(this, null, function* () {
          if (this._page._browserContext.isSettingStorageState())
            return;
          const promises = [this._pageProxySession.send("Dialog.enable"), this._pageProxySession.send("Emulation.setActiveAndFocused", {
            active: true
          })];
          const contextOptions = this._browserContext._options;
          if (contextOptions.javaScriptEnabled === false)
            promises.push(this._pageProxySession.send("Emulation.setJavaScriptEnabled", {
              enabled: false
            }));
          promises.push(this._updateViewport());
          promises.push(this.updateHttpCredentials());
          if (this._browserContext._permissions.size) {
            for (const [key, value] of this._browserContext._permissions)
              promises.push(this._grantPermissions(key, value));
          }
          if (this._browserContext._options.recordVideo) {
            const outputFile = _path.default.join(this._browserContext._options.recordVideo.dir, (0, _utils.createGuid)() + ".webm");
            promises.push(this._browserContext._ensureVideosPath().then(() => {
              return this._startVideo(__spreadProps(__spreadValues({}, this._browserContext._options.recordVideo.size), {
                outputFile
              }));
            }));
          }
          yield Promise.all(promises);
        });
      }
      _setSession(session) {
        _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
        this._session = session;
        this.rawKeyboard.setSession(session);
        this.rawMouse.setSession(session);
        this._addSessionListeners();
        this._workers.setSession(session);
      }
      _initializeSession(session, provisional, resourceTreeHandler) {
        return __async(this, null, function* () {
          yield this._initializeSessionMayThrow(session, resourceTreeHandler).catch((e) => {
            if (provisional && session.isDisposed())
              return;
            if (this._session === session)
              throw e;
          });
        });
      }
      _initializeSessionMayThrow(session, resourceTreeHandler) {
        return __async(this, null, function* () {
          const [, frameTree] = yield Promise.all([
            session.send("Page.enable"),
            session.send("Page.getResourceTree")
          ]);
          resourceTreeHandler(frameTree);
          const promises = [
            session.send("Runtime.enable"),
            session.send("Page.createUserWorld", {
              name: UTILITY_WORLD_NAME
            }).catch((_) => {
            }),
            session.send("Console.enable"),
            session.send("Network.enable"),
            this._workers.initializeSession(session)
          ];
          if (this._page._needsRequestInterception()) {
            promises.push(session.send("Network.setInterceptionEnabled", {
              enabled: true
            }));
            promises.push(session.send("Network.addInterception", {
              url: ".*",
              stage: "request",
              isRegex: true
            }));
          }
          if (this._page._browserContext.isSettingStorageState()) {
            yield Promise.all(promises);
            return;
          }
          const contextOptions = this._browserContext._options;
          if (contextOptions.userAgent)
            promises.push(session.send("Page.overrideUserAgent", {
              value: contextOptions.userAgent
            }));
          if (this._page._state.mediaType || this._page._state.colorScheme || this._page._state.reducedMotion)
            promises.push(WKPage._setEmulateMedia(session, this._page._state.mediaType, this._page._state.colorScheme, this._page._state.reducedMotion));
          const bootstrapScript = this._calculateBootstrapScript();
          if (bootstrapScript.length)
            promises.push(session.send("Page.setBootstrapScript", {
              source: bootstrapScript
            }));
          this._page.frames().map((frame) => frame.evaluateExpression(bootstrapScript, false, void 0).catch((e) => {
          }));
          if (contextOptions.bypassCSP)
            promises.push(session.send("Page.setBypassCSP", {
              enabled: true
            }));
          if (this._page._state.emulatedSize) {
            promises.push(session.send("Page.setScreenSizeOverride", {
              width: this._page._state.emulatedSize.screen.width,
              height: this._page._state.emulatedSize.screen.height
            }));
          }
          promises.push(this.updateEmulateMedia());
          promises.push(session.send("Network.setExtraHTTPHeaders", {
            headers: (0, _utils.headersArrayToObject)(this._calculateExtraHTTPHeaders(), false)
          }));
          if (contextOptions.offline)
            promises.push(session.send("Network.setEmulateOfflineState", {
              offline: true
            }));
          promises.push(session.send("Page.setTouchEmulationEnabled", {
            enabled: !!contextOptions.hasTouch
          }));
          if (contextOptions.timezoneId) {
            promises.push(session.send("Page.setTimeZone", {
              timeZone: contextOptions.timezoneId
            }).catch((e) => {
              throw new Error(`Invalid timezone ID: ${contextOptions.timezoneId}`);
            }));
          }
          if (this._interceptingFileChooser)
            promises.push(session.send("Page.setInterceptFileChooserDialog", {
              enabled: true
            }));
          promises.push(session.send("Page.overrideSetting", {
            setting: "DeviceOrientationEventEnabled",
            value: contextOptions.isMobile
          }));
          promises.push(session.send("Page.overrideSetting", {
            setting: "FullScreenEnabled",
            value: !contextOptions.isMobile
          }));
          promises.push(session.send("Page.overrideSetting", {
            setting: "NotificationsEnabled",
            value: !contextOptions.isMobile
          }));
          promises.push(session.send("Page.overrideSetting", {
            setting: "PointerLockEnabled",
            value: !contextOptions.isMobile
          }));
          promises.push(session.send("Page.overrideSetting", {
            setting: "InputTypeMonthEnabled",
            value: contextOptions.isMobile
          }));
          promises.push(session.send("Page.overrideSetting", {
            setting: "InputTypeWeekEnabled",
            value: contextOptions.isMobile
          }));
          yield Promise.all(promises);
        });
      }
      _onDidCommitProvisionalTarget(event) {
        const {
          oldTargetId,
          newTargetId
        } = event;
        (0, _utils.assert)(this._provisionalPage);
        (0, _utils.assert)(this._provisionalPage._session.sessionId === newTargetId, "Unknown new target: " + newTargetId);
        (0, _utils.assert)(this._session.sessionId === oldTargetId, "Unknown old target: " + oldTargetId);
        const newSession = this._provisionalPage._session;
        this._provisionalPage.commit();
        this._provisionalPage.dispose();
        this._provisionalPage = null;
        this._setSession(newSession);
      }
      _onTargetDestroyed(event) {
        const {
          targetId,
          crashed
        } = event;
        if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId) {
          this._provisionalPage._session.dispose(false);
          this._provisionalPage.dispose();
          this._provisionalPage = null;
        } else if (this._session.sessionId === targetId) {
          this._session.dispose(false);
          _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
          if (crashed) {
            this._session.markAsCrashed();
            this._page._didCrash();
          }
        }
      }
      didClose() {
        this._page._didClose();
      }
      dispose(disconnected) {
        this._pageProxySession.dispose(disconnected);
        _eventsHelper.eventsHelper.removeEventListeners(this._sessionListeners);
        _eventsHelper.eventsHelper.removeEventListeners(this._eventListeners);
        if (this._session)
          this._session.dispose(disconnected);
        if (this._provisionalPage) {
          this._provisionalPage._session.dispose(disconnected);
          this._provisionalPage.dispose();
          this._provisionalPage = null;
        }
        this._page._didDisconnect();
        this._firstNonInitialNavigationCommittedReject(new Error("Page closed"));
      }
      dispatchMessageToSession(message) {
        this._pageProxySession.dispatchMessage(message);
      }
      handleProvisionalLoadFailed(event) {
        if (!this._initializedPage) {
          this._firstNonInitialNavigationCommittedReject(new Error("Initial load failed"));
          return;
        }
        if (!this._provisionalPage)
          return;
        let errorText = event.error;
        if (errorText.includes("cancelled"))
          errorText += "; maybe frame was detached?";
        this._page._frameManager.frameAbortedNavigation(this._page.mainFrame()._id, errorText, event.loaderId);
      }
      handleWindowOpen(event) {
        (0, _utils.debugAssert)(!this._nextWindowOpenPopupFeatures);
        this._nextWindowOpenPopupFeatures = event.windowFeatures;
      }
      pageOrError() {
        return __async(this, null, function* () {
          return this._pagePromise;
        });
      }
      _onTargetCreated(event) {
        return __async(this, null, function* () {
          const {
            targetInfo
          } = event;
          const session = new _wkConnection.WKSession(this._pageProxySession.connection, targetInfo.targetId, `Target closed`, (message) => {
            this._pageProxySession.send("Target.sendMessageToTarget", {
              message: JSON.stringify(message),
              targetId: targetInfo.targetId
            }).catch((e) => {
              session.dispatchMessage({
                id: message.id,
                error: {
                  message: e.message
                }
              });
            });
          });
          (0, _utils.assert)(targetInfo.type === "page", "Only page targets are expected in WebKit, received: " + targetInfo.type);
          if (!targetInfo.isProvisional) {
            (0, _utils.assert)(!this._initializedPage);
            let pageOrError;
            try {
              this._setSession(session);
              yield Promise.all([this._initializePageProxySession(), this._initializeSession(session, false, ({
                frameTree
              }) => this._handleFrameTree(frameTree))]);
              pageOrError = this._page;
            } catch (e) {
              pageOrError = e;
            }
            if (targetInfo.isPaused)
              this._pageProxySession.sendMayFail("Target.resume", {
                targetId: targetInfo.targetId
              });
            if (pageOrError instanceof _page.Page && this._page.mainFrame().url() === "") {
              try {
                yield this._firstNonInitialNavigationCommittedPromise;
              } catch (e) {
                pageOrError = e;
              }
            } else {
              this._firstNonInitialNavigationCommittedPromise.catch(() => {
              });
            }
            yield this._page.initOpener(this._opener);
            this._initializedPage = pageOrError instanceof _page.Page ? pageOrError : null;
            this._page.reportAsNew(pageOrError instanceof _page.Page ? void 0 : pageOrError);
            this._pagePromise.resolve(pageOrError);
          } else {
            (0, _utils.assert)(targetInfo.isProvisional);
            (0, _utils.assert)(!this._provisionalPage);
            this._provisionalPage = new _wkProvisionalPage.WKProvisionalPage(session, this);
            if (targetInfo.isPaused) {
              this._provisionalPage.initializationPromise.then(() => {
                this._pageProxySession.sendMayFail("Target.resume", {
                  targetId: targetInfo.targetId
                });
              });
            }
          }
        });
      }
      _onDispatchMessageFromTarget(event) {
        const {
          targetId,
          message
        } = event;
        if (this._provisionalPage && this._provisionalPage._session.sessionId === targetId)
          this._provisionalPage._session.dispatchMessage(JSON.parse(message));
        else if (this._session.sessionId === targetId)
          this._session.dispatchMessage(JSON.parse(message));
        else
          throw new Error("Unknown target: " + targetId);
      }
      _addSessionListeners() {
        this._sessionListeners = [_eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameNavigated", (event) => this._onFrameNavigated(event.frame, false)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.navigatedWithinDocument", (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameAttached", (event) => this._onFrameAttached(event.frameId, event.parentFrameId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameDetached", (event) => this._onFrameDetached(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.willCheckNavigationPolicy", (event) => this._onWillCheckNavigationPolicy(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.didCheckNavigationPolicy", (event) => this._onDidCheckNavigationPolicy(event.frameId, event.cancel)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameScheduledNavigation", (event) => this._onFrameScheduledNavigation(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.frameStoppedLoading", (event) => this._onFrameStoppedLoading(event.frameId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.loadEventFired", (event) => this._onLifecycleEvent(event.frameId, "load")), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.domContentEventFired", (event) => this._onLifecycleEvent(event.frameId, "domcontentloaded")), _eventsHelper.eventsHelper.addEventListener(this._session, "Runtime.executionContextCreated", (event) => this._onExecutionContextCreated(event.context)), _eventsHelper.eventsHelper.addEventListener(this._session, "Console.messageAdded", (event) => this._onConsoleMessage(event)), _eventsHelper.eventsHelper.addEventListener(this._session, "Console.messageRepeatCountUpdated", (event) => this._onConsoleRepeatCountUpdated(event)), _eventsHelper.eventsHelper.addEventListener(this._pageProxySession, "Dialog.javascriptDialogOpening", (event) => this._onDialog(event)), _eventsHelper.eventsHelper.addEventListener(this._session, "Page.fileChooserOpened", (event) => this._onFileChooserOpened(event)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.requestWillBeSent", (e) => this._onRequestWillBeSent(this._session, e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.requestIntercepted", (e) => this._onRequestIntercepted(this._session, e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.responseReceived", (e) => this._onResponseReceived(e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.loadingFinished", (e) => this._onLoadingFinished(e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.loadingFailed", (e) => this._onLoadingFailed(e)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketCreated", (e) => this._page._frameManager.onWebSocketCreated(e.requestId, e.url)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketWillSendHandshakeRequest", (e) => this._page._frameManager.onWebSocketRequest(e.requestId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketHandshakeResponseReceived", (e) => this._page._frameManager.onWebSocketResponse(e.requestId, e.response.status, e.response.statusText)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketFrameSent", (e) => e.response.payloadData && this._page._frameManager.onWebSocketFrameSent(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketFrameReceived", (e) => e.response.payloadData && this._page._frameManager.webSocketFrameReceived(e.requestId, e.response.opcode, e.response.payloadData)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketClosed", (e) => this._page._frameManager.webSocketClosed(e.requestId)), _eventsHelper.eventsHelper.addEventListener(this._session, "Network.webSocketFrameError", (e) => this._page._frameManager.webSocketError(e.requestId, e.errorMessage))];
      }
      _updateState(method, params) {
        return __async(this, null, function* () {
          yield this._forAllSessions((session) => session.send(method, params).then());
        });
      }
      _forAllSessions(callback) {
        return __async(this, null, function* () {
          const sessions = [this._session];
          if (this._provisionalPage)
            sessions.push(this._provisionalPage._session);
          yield Promise.all(sessions.map((session) => callback(session).catch((e) => {
          })));
        });
      }
      _onWillCheckNavigationPolicy(frameId) {
        if (this._provisionalPage)
          return;
        this._page._frameManager.frameRequestedNavigation(frameId);
      }
      _onDidCheckNavigationPolicy(frameId, cancel) {
        if (!cancel)
          return;
        if (this._provisionalPage)
          return;
        this._page._frameManager.frameAbortedNavigation(frameId, "Navigation canceled by policy check");
      }
      _onFrameScheduledNavigation(frameId) {
        this._page._frameManager.frameRequestedNavigation(frameId);
      }
      _onFrameStoppedLoading(frameId) {
        this._page._frameManager.frameStoppedLoading(frameId);
      }
      _onLifecycleEvent(frameId, event) {
        this._page._frameManager.frameLifecycleEvent(frameId, event);
      }
      _handleFrameTree(frameTree) {
        this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId || null);
        this._onFrameNavigated(frameTree.frame, true);
        this._page._frameManager.frameLifecycleEvent(frameTree.frame.id, "domcontentloaded");
        this._page._frameManager.frameLifecycleEvent(frameTree.frame.id, "load");
        if (!frameTree.childFrames)
          return;
        for (const child of frameTree.childFrames)
          this._handleFrameTree(child);
      }
      _onFrameAttached(frameId, parentFrameId) {
        return this._page._frameManager.frameAttached(frameId, parentFrameId);
      }
      _onFrameNavigated(framePayload, initial) {
        const frame = this._page._frameManager.frame(framePayload.id);
        (0, _utils.assert)(frame);
        this._removeContextsForFrame(frame, true);
        if (!framePayload.parentId)
          this._workers.clear();
        this._page._frameManager.frameCommittedNewDocumentNavigation(framePayload.id, framePayload.url, framePayload.name || "", framePayload.loaderId, initial);
        if (!initial)
          this._firstNonInitialNavigationCommittedFulfill();
      }
      _onFrameNavigatedWithinDocument(frameId, url) {
        this._page._frameManager.frameCommittedSameDocumentNavigation(frameId, url);
      }
      _onFrameDetached(frameId) {
        this._page._frameManager.frameDetached(frameId);
      }
      _removeContextsForFrame(frame, notifyFrame) {
        for (const [contextId, context] of this._contextIdToContext) {
          if (context.frame === frame) {
            this._contextIdToContext.delete(contextId);
            if (notifyFrame)
              frame._contextDestroyed(context);
          }
        }
      }
      _onExecutionContextCreated(contextPayload) {
        if (this._contextIdToContext.has(contextPayload.id))
          return;
        const frame = this._page._frameManager.frame(contextPayload.frameId);
        if (!frame)
          return;
        const delegate = new _wkExecutionContext.WKExecutionContext(this._session, contextPayload.id);
        let worldName = null;
        if (contextPayload.type === "normal")
          worldName = "main";
        else if (contextPayload.type === "user" && contextPayload.name === UTILITY_WORLD_NAME)
          worldName = "utility";
        const context = new dom.FrameExecutionContext(delegate, frame, worldName);
        context[contextDelegateSymbol] = delegate;
        if (worldName)
          frame._contextCreated(worldName, context);
        if (contextPayload.type === "normal" && frame === this._page.mainFrame())
          this._mainFrameContextId = contextPayload.id;
        this._contextIdToContext.set(contextPayload.id, context);
      }
      navigateFrame(frame, url, referrer) {
        return __async(this, null, function* () {
          if (this._pageProxySession.isDisposed())
            throw new Error("Target closed");
          const pageProxyId = this._pageProxySession.sessionId;
          const result = yield this._pageProxySession.connection.browserSession.send("Playwright.navigate", {
            url,
            pageProxyId,
            frameId: frame._id,
            referrer
          });
          return {
            newDocumentId: result.loaderId
          };
        });
      }
      _onConsoleMessage(event) {
        const {
          type,
          level,
          text,
          parameters,
          url,
          line: lineNumber,
          column: columnNumber,
          source
        } = event.message;
        if (level === "debug" && parameters && parameters[0].value === BINDING_CALL_MESSAGE) {
          const parsedObjectId = JSON.parse(parameters[1].objectId);
          this.pageOrError().then((pageOrError) => {
            const context = this._contextIdToContext.get(parsedObjectId.injectedScriptId);
            if (!(pageOrError instanceof Error) && context)
              this._page._onBindingCalled(parameters[2].value, context);
          });
          return;
        }
        if (level === "error" && source === "javascript") {
          const {
            name,
            message
          } = (0, _stackTrace.splitErrorMessage)(text);
          let stack;
          if (event.message.stackTrace) {
            stack = text + "\n" + event.message.stackTrace.map((callFrame) => {
              return `    at ${callFrame.functionName || "unknown"} (${callFrame.url}:${callFrame.lineNumber}:${callFrame.columnNumber})`;
            }).join("\n");
          } else {
            stack = "";
          }
          const error = new Error(message);
          error.stack = stack;
          error.name = name;
          this._page.firePageError(error);
          return;
        }
        let derivedType = type || "";
        if (type === "log")
          derivedType = level;
        else if (type === "timing")
          derivedType = "timeEnd";
        const handles = [];
        for (const p of parameters || []) {
          let context;
          if (p.objectId) {
            const objectId = JSON.parse(p.objectId);
            context = this._contextIdToContext.get(objectId.injectedScriptId);
          } else {
            context = this._contextIdToContext.get(this._mainFrameContextId);
          }
          if (!context)
            return;
          handles.push(context.createHandle(p));
        }
        this._lastConsoleMessage = {
          derivedType,
          text,
          handles,
          count: 0,
          location: {
            url: url || "",
            lineNumber: (lineNumber || 1) - 1,
            columnNumber: (columnNumber || 1) - 1
          }
        };
        this._onConsoleRepeatCountUpdated({
          count: 1
        });
      }
      _onConsoleRepeatCountUpdated(event) {
        if (this._lastConsoleMessage) {
          const {
            derivedType,
            text,
            handles,
            count,
            location: location2
          } = this._lastConsoleMessage;
          for (let i = count; i < event.count; ++i)
            this._page._addConsoleMessage(derivedType, handles, location2, handles.length ? void 0 : text);
          this._lastConsoleMessage.count = event.count;
        }
      }
      _onDialog(event) {
        this._page.emit(_page.Page.Events.Dialog, new dialog.Dialog(this._page, event.type, event.message, (accept, promptText) => __async(this, null, function* () {
          yield this._pageProxySession.send("Dialog.handleJavaScriptDialog", {
            accept,
            promptText
          });
        }), event.defaultPrompt));
      }
      _onFileChooserOpened(event) {
        return __async(this, null, function* () {
          let handle;
          try {
            const context = yield this._page._frameManager.frame(event.frameId)._mainContext();
            handle = context.createHandle(event.element).asElement();
          } catch (e) {
            return;
          }
          yield this._page._onFileChooserOpened(handle);
        });
      }
      static _setEmulateMedia(session, mediaType, colorScheme, reducedMotion) {
        return __async(this, null, function* () {
          const promises = [];
          promises.push(session.send("Page.setEmulatedMedia", {
            media: mediaType || ""
          }));
          let appearance = void 0;
          switch (colorScheme) {
            case "light":
              appearance = "Light";
              break;
            case "dark":
              appearance = "Dark";
              break;
          }
          promises.push(session.send("Page.setForcedAppearance", {
            appearance
          }));
          let reducedMotionWk = void 0;
          switch (reducedMotion) {
            case "reduce":
              reducedMotionWk = "Reduce";
              break;
            case "no-preference":
              reducedMotionWk = "NoPreference";
              break;
          }
          promises.push(session.send("Page.setForcedReducedMotion", {
            reducedMotion: reducedMotionWk
          }));
          yield Promise.all(promises);
        });
      }
      updateExtraHTTPHeaders() {
        return __async(this, null, function* () {
          yield this._updateState("Network.setExtraHTTPHeaders", {
            headers: (0, _utils.headersArrayToObject)(this._calculateExtraHTTPHeaders(), false)
          });
        });
      }
      _calculateExtraHTTPHeaders() {
        const locale = this._browserContext._options.locale;
        const headers = network.mergeHeaders([this._browserContext._options.extraHTTPHeaders, this._page._state.extraHTTPHeaders, locale ? network.singleHeader("Accept-Language", locale) : void 0]);
        return headers;
      }
      updateEmulateMedia() {
        return __async(this, null, function* () {
          const colorScheme = this._page._state.colorScheme;
          const reducedMotion = this._page._state.reducedMotion;
          yield this._forAllSessions((session) => WKPage._setEmulateMedia(session, this._page._state.mediaType, colorScheme, reducedMotion));
        });
      }
      setEmulatedSize(emulatedSize) {
        return __async(this, null, function* () {
          (0, _utils.assert)(this._page._state.emulatedSize === emulatedSize);
          yield this._updateViewport();
        });
      }
      bringToFront() {
        return __async(this, null, function* () {
          this._pageProxySession.send("Target.activate", {
            targetId: this._session.sessionId
          });
        });
      }
      _updateViewport() {
        return __async(this, null, function* () {
          const options = this._browserContext._options;
          const deviceSize = this._page._state.emulatedSize;
          if (deviceSize === null)
            return;
          const viewportSize = deviceSize.viewport;
          const screenSize = deviceSize.screen;
          const promises = [this._pageProxySession.send("Emulation.setDeviceMetricsOverride", {
            width: viewportSize.width,
            height: viewportSize.height,
            fixedLayout: !!options.isMobile,
            deviceScaleFactor: options.deviceScaleFactor || 1
          }), this._session.send("Page.setScreenSizeOverride", {
            width: screenSize.width,
            height: screenSize.height
          })];
          if (options.isMobile) {
            const angle = viewportSize.width > viewportSize.height ? 90 : 0;
            promises.push(this._session.send("Page.setOrientationOverride", {
              angle
            }));
          }
          yield Promise.all(promises);
        });
      }
      updateRequestInterception() {
        return __async(this, null, function* () {
          const enabled = this._page._needsRequestInterception();
          yield Promise.all([this._updateState("Network.setInterceptionEnabled", {
            enabled
          }), this._updateState("Network.addInterception", {
            url: ".*",
            stage: "request",
            isRegex: true
          })]);
        });
      }
      updateOffline() {
        return __async(this, null, function* () {
          yield this._updateState("Network.setEmulateOfflineState", {
            offline: !!this._browserContext._options.offline
          });
        });
      }
      updateHttpCredentials() {
        return __async(this, null, function* () {
          const credentials = this._browserContext._options.httpCredentials || {
            username: "",
            password: ""
          };
          yield this._pageProxySession.send("Emulation.setAuthCredentials", {
            username: credentials.username,
            password: credentials.password
          });
        });
      }
      setFileChooserIntercepted(enabled) {
        return __async(this, null, function* () {
          this._interceptingFileChooser = enabled;
          yield this._session.send("Page.setInterceptFileChooserDialog", {
            enabled
          }).catch((e) => {
          });
        });
      }
      reload() {
        return __async(this, null, function* () {
          yield this._session.send("Page.reload");
        });
      }
      goBack() {
        return this._session.send("Page.goBack").then(() => true).catch((error) => {
          if (error instanceof Error && error.message.includes(`Protocol error (Page.goBack): Failed to go`))
            return false;
          throw error;
        });
      }
      goForward() {
        return this._session.send("Page.goForward").then(() => true).catch((error) => {
          if (error instanceof Error && error.message.includes(`Protocol error (Page.goForward): Failed to go`))
            return false;
          throw error;
        });
      }
      exposeBinding(binding) {
        return __async(this, null, function* () {
          yield this._updateBootstrapScript();
          yield this._evaluateBindingScript(binding);
        });
      }
      removeExposedBindings() {
        return __async(this, null, function* () {
          yield this._updateBootstrapScript();
        });
      }
      _evaluateBindingScript(binding) {
        return __async(this, null, function* () {
          const script = this._bindingToScript(binding);
          yield Promise.all(this._page.frames().map((frame) => frame.evaluateExpression(script, false, {}).catch((e) => {
          })));
        });
      }
      addInitScript(script) {
        return __async(this, null, function* () {
          yield this._updateBootstrapScript();
        });
      }
      removeInitScripts() {
        return __async(this, null, function* () {
          yield this._updateBootstrapScript();
        });
      }
      _bindingToScript(binding) {
        return `self.${binding.name} = (param) => console.debug('${BINDING_CALL_MESSAGE}', {}, param); ${binding.source}`;
      }
      _calculateBootstrapScript() {
        const scripts = [];
        if (!this._page.context()._options.isMobile) {
          scripts.push("delete window.orientation");
          scripts.push("delete window.ondevicemotion");
          scripts.push("delete window.ondeviceorientation");
        }
        for (const binding of this._page.allBindings())
          scripts.push(this._bindingToScript(binding));
        scripts.push(...this._browserContext.initScripts);
        scripts.push(...this._page.initScripts);
        return scripts.join(";\n");
      }
      _updateBootstrapScript() {
        return __async(this, null, function* () {
          yield this._updateState("Page.setBootstrapScript", {
            source: this._calculateBootstrapScript()
          });
        });
      }
      closePage(runBeforeUnload) {
        return __async(this, null, function* () {
          yield this._stopVideo();
          yield this._pageProxySession.sendMayFail("Target.close", {
            targetId: this._session.sessionId,
            runBeforeUnload
          });
        });
      }
      setBackgroundColor(color) {
        return __async(this, null, function* () {
          yield this._session.send("Page.setDefaultBackgroundColorOverride", {
            color
          });
        });
      }
      _toolbarHeight() {
        var _this$_page$_browserC;
        if ((_this$_page$_browserC = this._page._browserContext._browser) !== null && _this$_page$_browserC !== void 0 && _this$_page$_browserC.options.headful)
          return _hostPlatform.hostPlatform === "mac10.15" ? 55 : 59;
        return 0;
      }
      _startVideo(options) {
        return __async(this, null, function* () {
          (0, _utils.assert)(!this._recordingVideoFile);
          const {
            screencastId
          } = yield this._pageProxySession.send("Screencast.startVideo", {
            file: options.outputFile,
            width: options.width,
            height: options.height,
            toolbarHeight: this._toolbarHeight()
          });
          this._recordingVideoFile = options.outputFile;
          this._browserContext._browser._videoStarted(this._browserContext, screencastId, options.outputFile, this.pageOrError());
        });
      }
      _stopVideo() {
        return __async(this, null, function* () {
          if (!this._recordingVideoFile)
            return;
          yield this._pageProxySession.sendMayFail("Screencast.stopVideo");
          this._recordingVideoFile = null;
        });
      }
      takeScreenshot(progress, format, documentRect, viewportRect, quality, fitsViewport, scale) {
        return __async(this, null, function* () {
          const rect = documentRect || viewportRect;
          const result = yield this._session.send("Page.snapshotRect", __spreadProps(__spreadValues({}, rect), {
            coordinateSystem: documentRect ? "Page" : "Viewport",
            omitDeviceScaleFactor: scale === "css"
          }));
          const prefix = "data:image/png;base64,";
          let buffer = Buffer.from(result.dataURL.substr(prefix.length), "base64");
          if (format === "jpeg")
            buffer = jpeg.encode(png.PNG.sync.read(buffer), quality).data;
          return buffer;
        });
      }
      getContentFrame(handle) {
        return __async(this, null, function* () {
          const nodeInfo = yield this._session.send("DOM.describeNode", {
            objectId: handle._objectId
          });
          if (!nodeInfo.contentFrameId)
            return null;
          return this._page._frameManager.frame(nodeInfo.contentFrameId);
        });
      }
      getOwnerFrame(handle) {
        return __async(this, null, function* () {
          if (!handle._objectId)
            return null;
          const nodeInfo = yield this._session.send("DOM.describeNode", {
            objectId: handle._objectId
          });
          return nodeInfo.ownerFrameId || null;
        });
      }
      isElementHandle(remoteObject) {
        return remoteObject.subtype === "node";
      }
      getBoundingBox(handle) {
        return __async(this, null, function* () {
          const quads = yield this.getContentQuads(handle);
          if (!quads || !quads.length)
            return null;
          let minX = Infinity;
          let maxX = -Infinity;
          let minY = Infinity;
          let maxY = -Infinity;
          for (const quad of quads) {
            for (const point of quad) {
              minX = Math.min(minX, point.x);
              maxX = Math.max(maxX, point.x);
              minY = Math.min(minY, point.y);
              maxY = Math.max(maxY, point.y);
            }
          }
          return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
          };
        });
      }
      scrollRectIntoViewIfNeeded(handle, rect) {
        return __async(this, null, function* () {
          return yield this._session.send("DOM.scrollIntoViewIfNeeded", {
            objectId: handle._objectId,
            rect
          }).then(() => "done").catch((e) => {
            if (e instanceof Error && e.message.includes("Node does not have a layout object"))
              return "error:notvisible";
            if (e instanceof Error && e.message.includes("Node is detached from document"))
              return "error:notconnected";
            throw e;
          });
        });
      }
      setScreencastOptions(options) {
        return __async(this, null, function* () {
          if (options) {
            const so = __spreadProps(__spreadValues({}, options), {
              toolbarHeight: this._toolbarHeight()
            });
            const {
              generation
            } = yield this._pageProxySession.send("Screencast.startScreencast", so);
            this._screencastGeneration = generation;
          } else {
            yield this._pageProxySession.send("Screencast.stopScreencast");
          }
        });
      }
      _onScreencastFrame(event) {
        const generation = this._screencastGeneration;
        this._page.throttleScreencastFrameAck(() => {
          this._pageProxySession.send("Screencast.screencastFrameAck", {
            generation
          }).catch((e) => _debugLogger.debugLogger.log("error", e));
        });
        const buffer = Buffer.from(event.data, "base64");
        this._page.emit(_page.Page.Events.ScreencastFrame, {
          buffer,
          width: event.deviceWidth,
          height: event.deviceHeight
        });
      }
      rafCountForStablePosition() {
        return process.platform === "win32" ? 5 : 1;
      }
      getContentQuads(handle) {
        return __async(this, null, function* () {
          const result = yield this._session.sendMayFail("DOM.getContentQuads", {
            objectId: handle._objectId
          });
          if (!result)
            return null;
          return result.quads.map((quad) => [{
            x: quad[0],
            y: quad[1]
          }, {
            x: quad[2],
            y: quad[3]
          }, {
            x: quad[4],
            y: quad[5]
          }, {
            x: quad[6],
            y: quad[7]
          }]);
        });
      }
      setInputFiles(handle, files) {
        return __async(this, null, function* () {
          const objectId = handle._objectId;
          const protocolFiles = files.map((file) => ({
            name: file.name,
            type: file.mimeType,
            data: file.buffer
          }));
          yield this._session.send("DOM.setInputFiles", {
            objectId,
            files: protocolFiles
          });
        });
      }
      setInputFilePaths(handle, paths) {
        return __async(this, null, function* () {
          const pageProxyId = this._pageProxySession.sessionId;
          const objectId = handle._objectId;
          yield Promise.all([this._pageProxySession.connection.browserSession.send("Playwright.grantFileReadAccess", {
            pageProxyId,
            paths
          }), this._session.send("DOM.setInputFiles", {
            objectId,
            paths
          })]);
        });
      }
      adoptElementHandle(handle, to) {
        return __async(this, null, function* () {
          const result = yield this._session.sendMayFail("DOM.resolveNode", {
            objectId: handle._objectId,
            executionContextId: to[contextDelegateSymbol]._contextId
          });
          if (!result || result.object.subtype === "null")
            throw new Error(dom.kUnableToAdoptErrorMessage);
          return to.createHandle(result.object);
        });
      }
      getAccessibilityTree(needle) {
        return __async(this, null, function* () {
          return (0, _wkAccessibility.getAccessibilityTree)(this._session, needle);
        });
      }
      inputActionEpilogue() {
        return __async(this, null, function* () {
        });
      }
      getFrameElement(frame) {
        return __async(this, null, function* () {
          const parent = frame.parentFrame();
          if (!parent)
            throw new Error("Frame has been detached.");
          const info = this._page.parseSelector("frame,iframe");
          const handles = yield this._page.selectors._queryAll(parent, info);
          const items = yield Promise.all(handles.map((handle) => __async(this, null, function* () {
            const frame2 = yield handle.contentFrame().catch((e) => null);
            return {
              handle,
              frame: frame2
            };
          })));
          const result = items.find((item) => item.frame === frame);
          items.map((item) => item === result ? Promise.resolve() : item.handle.dispose());
          if (!result)
            throw new Error("Frame has been detached.");
          return result.handle;
        });
      }
      _onRequestWillBeSent(session, event) {
        if (event.request.url.startsWith("data:"))
          return;
        let redirectedFrom = null;
        if (event.redirectResponse) {
          const request2 = this._requestIdToRequest.get(event.requestId);
          if (request2) {
            this._handleRequestRedirect(request2, event.redirectResponse, event.timestamp);
            redirectedFrom = request2;
          }
        }
        const frame = redirectedFrom ? redirectedFrom.request.frame() : this._page._frameManager.frame(event.frameId);
        if (!frame)
          return;
        const isNavigationRequest = event.type === "Document";
        const documentId = isNavigationRequest ? event.loaderId : void 0;
        let route = null;
        if (this._page._needsRequestInterception() && !redirectedFrom)
          route = new _wkInterceptableRequest.WKRouteImpl(session, event.requestId);
        const request = new _wkInterceptableRequest.WKInterceptableRequest(session, route, frame, event, redirectedFrom, documentId);
        this._requestIdToRequest.set(event.requestId, request);
        this._page._frameManager.requestStarted(request.request, route || void 0);
      }
      _handleRequestRedirect(request, responsePayload, timestamp) {
        const response = request.createResponse(responsePayload);
        response._securityDetailsFinished();
        response._serverAddrFinished();
        response._requestFinished(responsePayload.timing ? _helper.helper.secondsToRoundishMillis(timestamp - request._timestamp) : -1);
        this._requestIdToRequest.delete(request._requestId);
        this._page._frameManager.requestReceivedResponse(response);
        this._page._frameManager.reportRequestFinished(request.request, response);
      }
      _onRequestIntercepted(session, event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request) {
          session.sendMayFail("Network.interceptRequestWithError", {
            errorType: "Cancellation",
            requestId: event.requestId
          });
          return;
        }
        if (!request._route) {
          session.sendMayFail("Network.interceptWithRequest", {
            requestId: request._requestId
          });
        } else {
          request._route._requestInterceptedPromise.resolve();
        }
      }
      _onResponseReceived(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        this._requestIdToResponseReceivedPayloadEvent.set(request._requestId, event);
        const response = request.createResponse(event.response);
        if (event.response.requestHeaders && Object.keys(event.response.requestHeaders).length) {
          const headers = __spreadValues({}, event.response.requestHeaders);
          if (!headers["host"])
            headers["Host"] = new URL(request.request.url()).host;
          request.request.setRawRequestHeaders((0, _utils.headersObjectToArray)(headers));
        }
        this._page._frameManager.requestReceivedResponse(response);
        if (response.status() === 204) {
          this._onLoadingFailed({
            requestId: event.requestId,
            errorText: "Aborted: 204 No Content",
            timestamp: event.timestamp
          });
        }
      }
      _onLoadingFinished(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response) {
          var _event$metrics, _event$metrics2, _event$metrics2$secur, _responseReceivedPayl, _responseReceivedPayl2, _responseReceivedPayl3, _responseReceivedPayl4, _responseReceivedPayl5, _responseReceivedPayl6, _event$metrics3, _event$metrics4, _event$metrics5;
          const responseReceivedPayload = this._requestIdToResponseReceivedPayloadEvent.get(request._requestId);
          response._serverAddrFinished(parseRemoteAddress(event === null || event === void 0 ? void 0 : (_event$metrics = event.metrics) === null || _event$metrics === void 0 ? void 0 : _event$metrics.remoteAddress));
          response._securityDetailsFinished({
            protocol: isLoadedSecurely(response.url(), response.timing()) ? (_event$metrics2 = event.metrics) === null || _event$metrics2 === void 0 ? void 0 : (_event$metrics2$secur = _event$metrics2.securityConnection) === null || _event$metrics2$secur === void 0 ? void 0 : _event$metrics2$secur.protocol : void 0,
            subjectName: responseReceivedPayload === null || responseReceivedPayload === void 0 ? void 0 : (_responseReceivedPayl = responseReceivedPayload.response.security) === null || _responseReceivedPayl === void 0 ? void 0 : (_responseReceivedPayl2 = _responseReceivedPayl.certificate) === null || _responseReceivedPayl2 === void 0 ? void 0 : _responseReceivedPayl2.subject,
            validFrom: responseReceivedPayload === null || responseReceivedPayload === void 0 ? void 0 : (_responseReceivedPayl3 = responseReceivedPayload.response.security) === null || _responseReceivedPayl3 === void 0 ? void 0 : (_responseReceivedPayl4 = _responseReceivedPayl3.certificate) === null || _responseReceivedPayl4 === void 0 ? void 0 : _responseReceivedPayl4.validFrom,
            validTo: responseReceivedPayload === null || responseReceivedPayload === void 0 ? void 0 : (_responseReceivedPayl5 = responseReceivedPayload.response.security) === null || _responseReceivedPayl5 === void 0 ? void 0 : (_responseReceivedPayl6 = _responseReceivedPayl5.certificate) === null || _responseReceivedPayl6 === void 0 ? void 0 : _responseReceivedPayl6.validUntil
          });
          if ((_event$metrics3 = event.metrics) !== null && _event$metrics3 !== void 0 && _event$metrics3.protocol)
            response._setHttpVersion(event.metrics.protocol);
          if ((_event$metrics4 = event.metrics) !== null && _event$metrics4 !== void 0 && _event$metrics4.responseBodyBytesReceived)
            request.request.responseSize.encodedBodySize = event.metrics.responseBodyBytesReceived;
          if ((_event$metrics5 = event.metrics) !== null && _event$metrics5 !== void 0 && _event$metrics5.responseHeaderBytesReceived)
            request.request.responseSize.responseHeadersSize = event.metrics.responseHeaderBytesReceived;
          response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        }
        this._requestIdToResponseReceivedPayloadEvent.delete(request._requestId);
        this._requestIdToRequest.delete(request._requestId);
        this._page._frameManager.reportRequestFinished(request.request, response);
      }
      _onLoadingFailed(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        const response = request.request._existingResponse();
        if (response) {
          response._serverAddrFinished();
          response._securityDetailsFinished();
          response._requestFinished(_helper.helper.secondsToRoundishMillis(event.timestamp - request._timestamp));
        }
        this._requestIdToRequest.delete(request._requestId);
        request.request._setFailureText(event.errorText);
        this._page._frameManager.requestFailed(request.request, event.errorText.includes("cancelled"));
      }
      _grantPermissions(origin, permissions) {
        return __async(this, null, function* () {
          const webPermissionToProtocol = /* @__PURE__ */ new Map([["geolocation", "geolocation"]]);
          const filtered = permissions.map((permission) => {
            const protocolPermission = webPermissionToProtocol.get(permission);
            if (!protocolPermission)
              throw new Error("Unknown permission: " + permission);
            return protocolPermission;
          });
          yield this._pageProxySession.send("Emulation.grantPermissions", {
            origin,
            permissions: filtered
          });
        });
      }
      _clearPermissions() {
        return __async(this, null, function* () {
          yield this._pageProxySession.send("Emulation.resetPermissions", {});
        });
      }
    };
    exports2.WKPage = WKPage;
    function parseRemoteAddress(value) {
      if (!value)
        return;
      try {
        const colon = value.lastIndexOf(":");
        const dot = value.lastIndexOf(".");
        if (dot < 0) {
          return {
            ipAddress: `[${value.slice(0, colon)}]`,
            port: +value.slice(colon + 1)
          };
        }
        if (colon > dot) {
          const [address, port] = value.split(":");
          return {
            ipAddress: address,
            port: +port
          };
        } else {
          const [address, port] = value.split(".");
          return {
            ipAddress: `[${address}]`,
            port: +port
          };
        }
      } catch (_) {
      }
    }
    function isLoadedSecurely(url, timing) {
      try {
        const u = new URL(url);
        if (u.protocol !== "https:" && u.protocol !== "wss:" && u.protocol !== "sftp:")
          return false;
        if (timing.secureConnectionStart === -1 && timing.connectStart !== -1)
          return false;
        return true;
      } catch (_) {
      }
    }
    var contextDelegateSymbol = Symbol("delegate");
  }
});

// node_modules/playwright-core/lib/server/webkit/wkBrowser.js
var require_wkBrowser = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/wkBrowser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WKBrowserContext = exports2.WKBrowser = void 0;
    var _browser = require_browser3();
    var _browserContext = require_browserContext();
    var _utils = require_utils();
    var _eventsHelper = require_eventsHelper();
    var network = _interopRequireWildcard(require_network());
    var _wkConnection = require_wkConnection();
    var _wkPage = require_wkPage();
    var _errors = require_errors();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var DEFAULT_USER_AGENT = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.4 Safari/605.1.15";
    var BROWSER_VERSION = "15.4";
    var WKBrowser = class extends _browser.Browser {
      static connect(transport, options) {
        return __async(this, null, function* () {
          const browser = new WKBrowser(transport, options);
          if (options.__testHookOnConnectToBrowser)
            yield options.__testHookOnConnectToBrowser();
          const promises = [browser._browserSession.send("Playwright.enable")];
          if (options.persistent) {
            browser._defaultContext = new WKBrowserContext(browser, void 0, options.persistent);
            promises.push(browser._defaultContext._initialize());
          }
          yield Promise.all(promises);
          return browser;
        });
      }
      constructor(transport, options) {
        super(options);
        this._connection = void 0;
        this._browserSession = void 0;
        this._contexts = /* @__PURE__ */ new Map();
        this._wkPages = /* @__PURE__ */ new Map();
        this._eventListeners = void 0;
        this._connection = new _wkConnection.WKConnection(transport, this._onDisconnect.bind(this), options.protocolLogger, options.browserLogsCollector);
        this._browserSession = this._connection.browserSession;
        this._eventListeners = [_eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.pageProxyCreated", this._onPageProxyCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.pageProxyDestroyed", this._onPageProxyDestroyed.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.provisionalLoadFailed", (event) => this._onProvisionalLoadFailed(event)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.windowOpen", (event) => this._onWindowOpen(event)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.downloadCreated", this._onDownloadCreated.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.downloadFilenameSuggested", this._onDownloadFilenameSuggested.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.downloadFinished", this._onDownloadFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, "Playwright.screencastFinished", this._onScreencastFinished.bind(this)), _eventsHelper.eventsHelper.addEventListener(this._browserSession, _wkConnection.kPageProxyMessageReceived, this._onPageProxyMessageReceived.bind(this))];
      }
      _onDisconnect() {
        for (const wkPage of this._wkPages.values())
          wkPage.dispose(true);
        for (const video of this._idToVideo.values())
          video.artifact.reportFinished(_errors.kBrowserClosedError);
        this._idToVideo.clear();
        this._didClose();
      }
      doCreateNewContext(options) {
        return __async(this, null, function* () {
          const createOptions = options.proxy ? {
            proxyServer: options.proxy.server,
            proxyBypassList: options.proxy.bypass
          } : void 0;
          const {
            browserContextId
          } = yield this._browserSession.send("Playwright.createContext", createOptions);
          options.userAgent = options.userAgent || DEFAULT_USER_AGENT;
          const context = new WKBrowserContext(this, browserContextId, options);
          yield context._initialize();
          this._contexts.set(browserContextId, context);
          return context;
        });
      }
      contexts() {
        return Array.from(this._contexts.values());
      }
      version() {
        return BROWSER_VERSION;
      }
      userAgent() {
        return DEFAULT_USER_AGENT;
      }
      _onDownloadCreated(payload) {
        const page = this._wkPages.get(payload.pageProxyId);
        if (!page)
          return;
        page._page._frameManager.frameAbortedNavigation(payload.frameId, "Download is starting");
        let originPage = page._initializedPage;
        if (!originPage) {
          page._firstNonInitialNavigationCommittedReject(new Error("Starting new page download"));
          if (page._opener)
            originPage = page._opener._initializedPage;
        }
        if (!originPage)
          return;
        this._downloadCreated(originPage, payload.uuid, payload.url);
      }
      _onDownloadFilenameSuggested(payload) {
        this._downloadFilenameSuggested(payload.uuid, payload.suggestedFilename);
      }
      _onDownloadFinished(payload) {
        this._downloadFinished(payload.uuid, payload.error);
      }
      _onScreencastFinished(payload) {
        var _this$_takeVideo;
        (_this$_takeVideo = this._takeVideo(payload.screencastId)) === null || _this$_takeVideo === void 0 ? void 0 : _this$_takeVideo.reportFinished();
      }
      _onPageProxyCreated(event) {
        const pageProxyId = event.pageProxyId;
        let context = null;
        if (event.browserContextId) {
          context = this._contexts.get(event.browserContextId) || null;
        }
        if (!context)
          context = this._defaultContext;
        if (!context)
          return;
        const pageProxySession = new _wkConnection.WKSession(this._connection, pageProxyId, `Target closed`, (message) => {
          this._connection.rawSend(__spreadProps(__spreadValues({}, message), {
            pageProxyId
          }));
        });
        const opener = event.openerId ? this._wkPages.get(event.openerId) : void 0;
        const wkPage = new _wkPage.WKPage(context, pageProxySession, opener || null);
        this._wkPages.set(pageProxyId, wkPage);
      }
      _onPageProxyDestroyed(event) {
        const pageProxyId = event.pageProxyId;
        const wkPage = this._wkPages.get(pageProxyId);
        if (!wkPage)
          return;
        wkPage.didClose();
        wkPage.dispose(false);
        this._wkPages.delete(pageProxyId);
      }
      _onPageProxyMessageReceived(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
          return;
        wkPage.dispatchMessageToSession(event.message);
      }
      _onProvisionalLoadFailed(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
          return;
        wkPage.handleProvisionalLoadFailed(event);
      }
      _onWindowOpen(event) {
        const wkPage = this._wkPages.get(event.pageProxyId);
        if (!wkPage)
          return;
        wkPage.handleWindowOpen(event);
      }
      isConnected() {
        return !this._connection.isClosed();
      }
    };
    exports2.WKBrowser = WKBrowser;
    var WKBrowserContext = class extends _browserContext.BrowserContext {
      constructor(browser, browserContextId, options) {
        super(browser, options, browserContextId);
        this._authenticateProxyViaHeader();
      }
      _initialize() {
        var __superGet = (key) => super[key];
        return __async(this, null, function* () {
          (0, _utils.assert)(!this._wkPages().length);
          const browserContextId = this._browserContextId;
          const promises = [__superGet("_initialize").call(this)];
          promises.push(this._browser._browserSession.send("Playwright.setDownloadBehavior", {
            behavior: this._options.acceptDownloads ? "allow" : "deny",
            downloadPath: this._browser.options.downloadsPath,
            browserContextId
          }));
          if (this._options.ignoreHTTPSErrors)
            promises.push(this._browser._browserSession.send("Playwright.setIgnoreCertificateErrors", {
              browserContextId,
              ignore: true
            }));
          if (this._options.locale)
            promises.push(this._browser._browserSession.send("Playwright.setLanguages", {
              browserContextId,
              languages: [this._options.locale]
            }));
          if (this._options.permissions)
            promises.push(this.grantPermissions(this._options.permissions));
          if (this._options.geolocation)
            promises.push(this.setGeolocation(this._options.geolocation));
          if (this._options.offline)
            promises.push(this.setOffline(this._options.offline));
          if (this._options.httpCredentials)
            promises.push(this.setHTTPCredentials(this._options.httpCredentials));
          yield Promise.all(promises);
        });
      }
      _wkPages() {
        return Array.from(this._browser._wkPages.values()).filter((wkPage) => wkPage._browserContext === this);
      }
      pages() {
        return this._wkPages().map((wkPage) => wkPage._initializedPage).filter((pageOrNull) => !!pageOrNull);
      }
      newPageDelegate() {
        return __async(this, null, function* () {
          (0, _browserContext.assertBrowserContextIsNotOwned)(this);
          const {
            pageProxyId
          } = yield this._browser._browserSession.send("Playwright.createPage", {
            browserContextId: this._browserContextId
          });
          return this._browser._wkPages.get(pageProxyId);
        });
      }
      doGetCookies(urls) {
        return __async(this, null, function* () {
          const {
            cookies
          } = yield this._browser._browserSession.send("Playwright.getAllCookies", {
            browserContextId: this._browserContextId
          });
          return network.filterCookies(cookies.map((c) => {
            const copy = __spreadValues({}, c);
            copy.expires = c.expires === -1 ? -1 : c.expires / 1e3;
            delete copy.session;
            return copy;
          }), urls);
        });
      }
      addCookies(cookies) {
        return __async(this, null, function* () {
          const cc = network.rewriteCookies(cookies).map((c) => __spreadProps(__spreadValues({}, c), {
            session: c.expires === -1 || c.expires === void 0,
            expires: c.expires && c.expires !== -1 ? c.expires * 1e3 : c.expires
          }));
          yield this._browser._browserSession.send("Playwright.setCookies", {
            cookies: cc,
            browserContextId: this._browserContextId
          });
        });
      }
      clearCookies() {
        return __async(this, null, function* () {
          yield this._browser._browserSession.send("Playwright.deleteAllCookies", {
            browserContextId: this._browserContextId
          });
        });
      }
      doGrantPermissions(origin, permissions) {
        return __async(this, null, function* () {
          yield Promise.all(this.pages().map((page) => page._delegate._grantPermissions(origin, permissions)));
        });
      }
      doClearPermissions() {
        return __async(this, null, function* () {
          yield Promise.all(this.pages().map((page) => page._delegate._clearPermissions()));
        });
      }
      setGeolocation(geolocation) {
        return __async(this, null, function* () {
          (0, _browserContext.verifyGeolocation)(geolocation);
          this._options.geolocation = geolocation;
          const payload = geolocation ? __spreadProps(__spreadValues({}, geolocation), {
            timestamp: Date.now()
          }) : void 0;
          yield this._browser._browserSession.send("Playwright.setGeolocationOverride", {
            browserContextId: this._browserContextId,
            geolocation: payload
          });
        });
      }
      setExtraHTTPHeaders(headers) {
        return __async(this, null, function* () {
          this._options.extraHTTPHeaders = headers;
          for (const page of this.pages())
            yield page._delegate.updateExtraHTTPHeaders();
        });
      }
      setOffline(offline) {
        return __async(this, null, function* () {
          this._options.offline = offline;
          for (const page of this.pages())
            yield page._delegate.updateOffline();
        });
      }
      doSetHTTPCredentials(httpCredentials) {
        return __async(this, null, function* () {
          this._options.httpCredentials = httpCredentials;
          for (const page of this.pages())
            yield page._delegate.updateHttpCredentials();
        });
      }
      doAddInitScript(source) {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate._updateBootstrapScript();
        });
      }
      doRemoveInitScripts() {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate._updateBootstrapScript();
        });
      }
      doExposeBinding(binding) {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.exposeBinding(binding);
        });
      }
      doRemoveExposedBindings() {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.removeExposedBindings();
        });
      }
      doUpdateRequestInterception() {
        return __async(this, null, function* () {
          for (const page of this.pages())
            yield page._delegate.updateRequestInterception();
        });
      }
      onClosePersistent() {
      }
      doClose() {
        return __async(this, null, function* () {
          (0, _utils.assert)(this._browserContextId);
          yield this._browser._browserSession.send("Playwright.deleteContext", {
            browserContextId: this._browserContextId
          });
          this._browser._contexts.delete(this._browserContextId);
        });
      }
      cancelDownload(uuid) {
        return __async(this, null, function* () {
          yield this._browser._browserSession.send("Playwright.cancelDownload", {
            uuid
          });
        });
      }
    };
    exports2.WKBrowserContext = WKBrowserContext;
  }
});

// node_modules/playwright-core/lib/server/webkit/webkit.js
var require_webkit = __commonJS({
  "node_modules/playwright-core/lib/server/webkit/webkit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WebKit = void 0;
    var _wkBrowser = require_wkBrowser();
    var _path = _interopRequireDefault(require("path"));
    var _wkConnection = require_wkConnection();
    var _browserType = require_browserType();
    var _stackTrace = require_stackTrace();
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var WebKit = class extends _browserType.BrowserType {
      constructor(playwrightOptions) {
        super("webkit", playwrightOptions);
      }
      _connectToTransport(transport, options) {
        return _wkBrowser.WKBrowser.connect(transport, options);
      }
      _amendEnvironment(env, userDataDir, executable, browserArguments) {
        return __spreadProps(__spreadValues({}, env), {
          CURL_COOKIE_JAR_PATH: _path.default.join(userDataDir, "cookiejar.db")
        });
      }
      _rewriteStartupError(error) {
        if (error.message.includes("cannot open display"))
          return (0, _stackTrace.rewriteErrorMessage)(error, "\n" + (0, _utils.wrapInASCIIBox)(_browserType.kNoXServerRunningError, 1));
        return error;
      }
      _attemptToGracefullyCloseBrowser(transport) {
        transport.send({
          method: "Playwright.close",
          params: {},
          id: _wkConnection.kBrowserCloseMessageId
        });
      }
      _defaultArgs(options, isPersistent, userDataDir) {
        const {
          args = [],
          proxy,
          headless
        } = options;
        const userDataDirArg = args.find((arg) => arg.startsWith("--user-data-dir"));
        if (userDataDirArg)
          throw new Error("Pass userDataDir parameter to `browserType.launchPersistentContext(userDataDir, ...)` instead of specifying --user-data-dir argument");
        if (args.find((arg) => !arg.startsWith("-")))
          throw new Error("Arguments can not specify page to be opened");
        const webkitArguments = ["--inspector-pipe"];
        if (process.platform === "win32")
          webkitArguments.push("--disable-accelerated-compositing");
        if (headless)
          webkitArguments.push("--headless");
        if (isPersistent)
          webkitArguments.push(`--user-data-dir=${userDataDir}`);
        else
          webkitArguments.push(`--no-startup-window`);
        if (proxy) {
          if (process.platform === "darwin") {
            webkitArguments.push(`--proxy=${proxy.server}`);
            if (proxy.bypass)
              webkitArguments.push(`--proxy-bypass-list=${proxy.bypass}`);
          } else if (process.platform === "linux") {
            webkitArguments.push(`--proxy=${proxy.server}`);
            if (proxy.bypass)
              webkitArguments.push(...proxy.bypass.split(",").map((t) => `--ignore-host=${t}`));
          } else if (process.platform === "win32") {
            webkitArguments.push(`--curl-proxy=${proxy.server}`);
            if (proxy.bypass)
              webkitArguments.push(`--curl-noproxy=${proxy.bypass}`);
          }
        }
        webkitArguments.push(...args);
        if (isPersistent)
          webkitArguments.push("about:blank");
        return webkitArguments;
      }
    };
    exports2.WebKit = WebKit;
  }
});

// node_modules/playwright-core/lib/server/playwright.js
var require_playwright = __commonJS({
  "node_modules/playwright-core/lib/server/playwright.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Playwright = void 0;
    exports2.createPlaywright = createPlaywright;
    var _android = require_android();
    var _backendAdb = require_backendAdb();
    var _chromium = require_chromium();
    var _electron = require_electron2();
    var _firefox = require_firefox();
    var _selectors = require_selectors();
    var _webkit = require_webkit();
    var _instrumentation = require_instrumentation();
    var _debugLogger = require_debugLogger();
    var Playwright = class extends _instrumentation.SdkObject {
      constructor(sdkLanguage, isInternalPlaywright) {
        super({
          attribution: {
            isInternalPlaywright
          },
          instrumentation: (0, _instrumentation.createInstrumentation)()
        }, void 0, "Playwright");
        this.selectors = void 0;
        this.chromium = void 0;
        this.android = void 0;
        this.electron = void 0;
        this.firefox = void 0;
        this.webkit = void 0;
        this.options = void 0;
        this._allPages = /* @__PURE__ */ new Set();
        this.instrumentation.addListener({
          onPageOpen: (page) => this._allPages.add(page),
          onPageClose: (page) => this._allPages.delete(page),
          onCallLog: (sdkObject, metadata, logName, message) => {
            _debugLogger.debugLogger.log(logName, message);
          }
        }, null);
        this.options = {
          rootSdkObject: this,
          selectors: new _selectors.Selectors(),
          sdkLanguage
        };
        this.chromium = new _chromium.Chromium(this.options);
        this.firefox = new _firefox.Firefox(this.options);
        this.webkit = new _webkit.WebKit(this.options);
        this.electron = new _electron.Electron(this.options);
        this.android = new _android.Android(new _backendAdb.AdbBackend(), this.options);
        this.selectors = this.options.selectors;
      }
      hideHighlight() {
        return __async(this, null, function* () {
          yield Promise.all([...this._allPages].map((p) => p.hideHighlight().catch(() => {
          })));
        });
      }
    };
    exports2.Playwright = Playwright;
    function createPlaywright(sdkLanguage, isInternalPlaywright = false) {
      return new Playwright(sdkLanguage, isInternalPlaywright);
    }
  }
});

// node_modules/playwright-core/lib/server/recorder/recorderApp.js
var require_recorderApp = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/recorderApp.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RecorderApp = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var _progress = require_progress2();
    var _events = require("events");
    var _instrumentation = require_instrumentation();
    var _utils = require_utils();
    var mime = _interopRequireWildcard(require_mime());
    var _crApp = require_crApp();
    var _registry = require_registry();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var RecorderApp = class extends _events.EventEmitter {
      constructor(page, wsEndpoint) {
        super();
        this._page = void 0;
        this.wsEndpoint = void 0;
        this.setMaxListeners(0);
        this._page = page;
        this.wsEndpoint = wsEndpoint;
      }
      close() {
        return __async(this, null, function* () {
          yield this._page.context().close((0, _instrumentation.serverSideCallMetadata)());
        });
      }
      _init() {
        return __async(this, null, function* () {
          yield (0, _crApp.installAppIcon)(this._page);
          yield this._page._setServerRequestInterceptor((route) => __async(this, null, function* () {
            if (route.request().url().startsWith("https://playwright/")) {
              const uri = route.request().url().substring("https://playwright/".length);
              const file = require.resolve("../../webpack/recorder/" + uri);
              const buffer = yield _fs.default.promises.readFile(file);
              yield route.fulfill({
                status: 200,
                headers: [{
                  name: "Content-Type",
                  value: mime.getType(_path.default.extname(file)) || "application/octet-stream"
                }],
                body: buffer.toString("base64"),
                isBase64: true
              });
              return;
            }
            yield route.continue();
          }));
          yield this._page.exposeBinding("dispatch", false, (_, data) => this.emit("event", data));
          this._page.once("close", () => {
            this.emit("close");
            this._page.context().close((0, _instrumentation.serverSideCallMetadata)()).catch(() => {
            });
          });
          const mainFrame = this._page.mainFrame();
          yield mainFrame.goto((0, _instrumentation.serverSideCallMetadata)(), "https://playwright/index.html");
        });
      }
      static open(sdkLanguage, headed) {
        return __async(this, null, function* () {
          if (process.env.PW_CODEGEN_NO_INSPECTOR)
            return new HeadlessRecorderApp();
          const recorderPlaywright = require_playwright().createPlaywright("javascript", true);
          const args = ["--app=data:text/html,", "--window-size=600,600", "--window-position=1020,10", "--test-type="];
          if (process.env.PWTEST_RECORDER_PORT)
            args.push(`--remote-debugging-port=${process.env.PWTEST_RECORDER_PORT}`);
          const context = yield recorderPlaywright.chromium.launchPersistentContext((0, _instrumentation.serverSideCallMetadata)(), "", {
            channel: (0, _registry.findChromiumChannel)(sdkLanguage),
            args,
            noDefaultViewport: true,
            ignoreDefaultArgs: ["--enable-automation"],
            headless: !!process.env.PWTEST_CLI_HEADLESS || (0, _utils.isUnderTest)() && !headed,
            useWebSocket: !!process.env.PWTEST_RECORDER_PORT
          });
          const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), context._browser);
          yield controller.run((progress) => __async(this, null, function* () {
            yield context._browser._defaultContext._loadDefaultContextAsIs(progress);
          }));
          const [page] = context.pages();
          const result = new RecorderApp(page, context._browser.options.wsEndpoint);
          yield result._init();
          return result;
        });
      }
      setMode(mode) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(((mode2) => {
            window.playwrightSetMode(mode2);
          }).toString(), true, mode, "main").catch(() => {
          });
        });
      }
      setFile(file) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(((file2) => {
            window.playwrightSetFile(file2);
          }).toString(), true, file, "main").catch(() => {
          });
        });
      }
      setPaused(paused) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(((paused2) => {
            window.playwrightSetPaused(paused2);
          }).toString(), true, paused, "main").catch(() => {
          });
        });
      }
      setSources(sources) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(((sources2) => {
            window.playwrightSetSources(sources2);
          }).toString(), true, sources, "main").catch(() => {
          });
          {
            if (process.env.PWTEST_CLI_EXIT && sources.length) {
              process.stdout.write("\n-------------8<-------------\n");
              process.stdout.write(sources[0].text);
              process.stdout.write("\n-------------8<-------------\n");
            }
          }
        });
      }
      setSelector(selector, focus) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(((arg) => {
            window.playwrightSetSelector(arg.selector, arg.focus);
          }).toString(), true, {
            selector,
            focus
          }, "main").catch(() => {
          });
        });
      }
      updateCallLogs(callLogs) {
        return __async(this, null, function* () {
          yield this._page.mainFrame().evaluateExpression(((callLogs2) => {
            window.playwrightUpdateLogs(callLogs2);
          }).toString(), true, callLogs, "main").catch(() => {
          });
        });
      }
      bringToFront() {
        return __async(this, null, function* () {
          yield this._page.bringToFront();
        });
      }
    };
    exports2.RecorderApp = RecorderApp;
    var HeadlessRecorderApp = class extends _events.EventEmitter {
      close() {
        return __async(this, null, function* () {
        });
      }
      setPaused(paused) {
        return __async(this, null, function* () {
        });
      }
      setMode(mode) {
        return __async(this, null, function* () {
        });
      }
      setFile(file) {
        return __async(this, null, function* () {
        });
      }
      setSelector(selector, focus) {
        return __async(this, null, function* () {
        });
      }
      updateCallLogs(callLogs) {
        return __async(this, null, function* () {
        });
      }
      bringToFront() {
      }
      setSources(sources) {
        return __async(this, null, function* () {
        });
      }
    };
  }
});

// node_modules/playwright-core/lib/server/recorder/recorderUtils.js
var require_recorderUtils = __commonJS({
  "node_modules/playwright-core/lib/server/recorder/recorderUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.metadataToCallLog = metadataToCallLog;
    function metadataToCallLog(metadata, status) {
      var _metadata$params, _metadata$params2;
      let title = metadata.apiName || metadata.method;
      if (metadata.method === "waitForEventInfo")
        title += `(${metadata.params.info.event})`;
      title = title.replace("object.expect", "expect");
      if (metadata.error)
        status = "error";
      const params = {
        url: (_metadata$params = metadata.params) === null || _metadata$params === void 0 ? void 0 : _metadata$params.url,
        selector: (_metadata$params2 = metadata.params) === null || _metadata$params2 === void 0 ? void 0 : _metadata$params2.selector
      };
      let duration = metadata.endTime ? metadata.endTime - metadata.startTime : void 0;
      if (typeof duration === "number" && metadata.pauseStartTime && metadata.pauseEndTime) {
        duration -= metadata.pauseEndTime - metadata.pauseStartTime;
        duration = Math.max(duration, 0);
      }
      const callLog = {
        id: metadata.id,
        messages: metadata.log,
        title,
        status,
        error: metadata.error,
        params,
        duration
      };
      return callLog;
    }
  }
});

// node_modules/playwright-core/lib/utils/timeoutRunner.js
var require_timeoutRunner = __commonJS({
  "node_modules/playwright-core/lib/utils/timeoutRunner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TimeoutRunnerError = exports2.TimeoutRunner = void 0;
    exports2.raceAgainstTimeout = raceAgainstTimeout;
    var _manualPromise = require_manualPromise();
    var _ = require_utils();
    var TimeoutRunnerError = class extends Error {
    };
    exports2.TimeoutRunnerError = TimeoutRunnerError;
    var TimeoutRunner = class {
      constructor(timeout) {
        this._running = void 0;
        this._timeout = void 0;
        this._elapsed = void 0;
        this._timeout = timeout;
        this._elapsed = 0;
      }
      run(cb) {
        return __async(this, null, function* () {
          const running = this._running = {
            lastElapsedSync: (0, _.monotonicTime)(),
            timer: void 0,
            timeoutPromise: new _manualPromise.ManualPromise()
          };
          try {
            const resultPromise = Promise.race([cb(), running.timeoutPromise]);
            this._updateTimeout(running, this._timeout);
            return yield resultPromise;
          } finally {
            this._updateTimeout(running, 0);
            if (this._running === running)
              this._running = void 0;
          }
        });
      }
      interrupt() {
        if (this._running)
          this._updateTimeout(this._running, -1);
      }
      elapsed() {
        this._syncElapsedAndStart();
        return this._elapsed;
      }
      updateTimeout(timeout, elapsed) {
        this._timeout = timeout;
        if (elapsed !== void 0) {
          this._syncElapsedAndStart();
          this._elapsed = elapsed;
        }
        if (this._running)
          this._updateTimeout(this._running, timeout);
      }
      _syncElapsedAndStart() {
        if (this._running) {
          const now = (0, _.monotonicTime)();
          this._elapsed += now - this._running.lastElapsedSync;
          this._running.lastElapsedSync = now;
        }
      }
      _updateTimeout(running, timeout) {
        if (running.timer) {
          clearTimeout(running.timer);
          running.timer = void 0;
        }
        this._syncElapsedAndStart();
        if (timeout === 0)
          return;
        timeout = timeout - this._elapsed;
        if (timeout <= 0)
          running.timeoutPromise.reject(new TimeoutRunnerError());
        else
          running.timer = setTimeout(() => running.timeoutPromise.reject(new TimeoutRunnerError()), timeout);
      }
    };
    exports2.TimeoutRunner = TimeoutRunner;
    function raceAgainstTimeout(cb, timeout) {
      return __async(this, null, function* () {
        const runner = new TimeoutRunner(timeout);
        try {
          return {
            result: yield runner.run(cb),
            timedOut: false
          };
        } catch (e) {
          if (e instanceof TimeoutRunnerError)
            return {
              timedOut: true
            };
          throw e;
        }
      });
    }
  }
});

// node_modules/playwright-core/lib/server/recorder.js
var require_recorder = __commonJS({
  "node_modules/playwright-core/lib/server/recorder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Recorder = void 0;
    var fs = _interopRequireWildcard(require("fs"));
    var _codeGenerator = require_codeGenerator();
    var _utils = require_utils3();
    var _page = require_page();
    var _frames = require_frames();
    var _browserContext = require_browserContext();
    var _java = require_java();
    var _javascript = require_javascript2();
    var _csharp = require_csharp();
    var _python = require_python();
    var recorderSource = _interopRequireWildcard(require_recorderSource());
    var consoleApiSource = _interopRequireWildcard(require_consoleApiSource());
    var _recorderApp = require_recorderApp();
    var _utils2 = require_utils();
    var _recorderUtils = require_recorderUtils();
    var _debugger = require_debugger();
    var _events = require("events");
    var _timeoutRunner = require_timeoutRunner();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var symbol = Symbol("RecorderSupplement");
    var Recorder = class {
      static showInspector(context) {
        Recorder.show(context, {}).catch(() => {
        });
      }
      static show(context, params = {}) {
        let recorderPromise = context[symbol];
        if (!recorderPromise) {
          const recorder = new Recorder(context, params);
          recorderPromise = recorder.install().then(() => recorder);
          context[symbol] = recorderPromise;
        }
        return recorderPromise;
      }
      constructor(context, params) {
        this._context = void 0;
        this._mode = void 0;
        this._highlightedSelector = "";
        this._recorderApp = null;
        this._currentCallsMetadata = /* @__PURE__ */ new Map();
        this._recorderSources = [];
        this._userSources = /* @__PURE__ */ new Map();
        this._allMetadatas = /* @__PURE__ */ new Map();
        this._debugger = void 0;
        this._contextRecorder = void 0;
        this._mode = params.startRecording ? "recording" : "none";
        this._contextRecorder = new ContextRecorder(context, params);
        this._context = context;
        this._debugger = _debugger.Debugger.lookup(context);
        context.instrumentation.addListener(this, context);
      }
      install() {
        return __async(this, null, function* () {
          const recorderApp = yield _recorderApp.RecorderApp.open(this._context._browser.options.sdkLanguage, !!this._context._browser.options.headful);
          this._recorderApp = recorderApp;
          recorderApp.once("close", () => {
            this._debugger.resume(false);
            this._recorderApp = null;
          });
          recorderApp.on("event", (data) => {
            if (data.event === "setMode") {
              this._setMode(data.params.mode);
              this._refreshOverlay();
              return;
            }
            if (data.event === "selectorUpdated") {
              this._highlightedSelector = data.params.selector;
              this._refreshOverlay();
              return;
            }
            if (data.event === "step") {
              this._debugger.resume(true);
              return;
            }
            if (data.event === "resume") {
              this._debugger.resume(false);
              return;
            }
            if (data.event === "pause") {
              this._debugger.pauseOnNextStatement();
              return;
            }
            if (data.event === "clear") {
              this._contextRecorder.clearScript();
              return;
            }
          });
          yield Promise.all([recorderApp.setMode(this._mode), recorderApp.setPaused(this._debugger.isPaused()), this._pushAllSources()]);
          this._context.once(_browserContext.BrowserContext.Events.Close, () => {
            this._contextRecorder.dispose();
            recorderApp.close().catch(() => {
            });
          });
          this._contextRecorder.on(ContextRecorder.Events.Change, (data) => {
            var _this$_recorderApp;
            this._recorderSources = data.sources;
            this._pushAllSources();
            (_this$_recorderApp = this._recorderApp) === null || _this$_recorderApp === void 0 ? void 0 : _this$_recorderApp.setFile(data.primaryFileName);
          });
          yield this._context.exposeBinding("_playwrightRecorderState", false, (source) => {
            let actionSelector = this._highlightedSelector;
            let actionPoint;
            for (const [metadata, sdkObject] of this._currentCallsMetadata) {
              if (source.page === sdkObject.attribution.page) {
                actionPoint = metadata.point || actionPoint;
                actionSelector = actionSelector || metadata.params.selector;
              }
            }
            const uiState = {
              mode: this._mode,
              actionPoint,
              actionSelector
            };
            return uiState;
          });
          yield this._context.exposeBinding("_playwrightRecorderSetSelector", false, (_, selector) => __async(this, null, function* () {
            var _this$_recorderApp2, _this$_recorderApp3;
            this._setMode("none");
            yield (_this$_recorderApp2 = this._recorderApp) === null || _this$_recorderApp2 === void 0 ? void 0 : _this$_recorderApp2.setSelector(selector, true);
            yield (_this$_recorderApp3 = this._recorderApp) === null || _this$_recorderApp3 === void 0 ? void 0 : _this$_recorderApp3.bringToFront();
          }));
          yield this._context.exposeBinding("_playwrightResume", false, () => {
            this._debugger.resume(false);
          });
          yield this._context.extendInjectedScript(consoleApiSource.source);
          yield this._contextRecorder.install();
          if (this._debugger.isPaused())
            this._pausedStateChanged();
          this._debugger.on(_debugger.Debugger.Events.PausedStateChanged, () => this._pausedStateChanged());
          this._context.recorderAppForTest = recorderApp;
        });
      }
      _pausedStateChanged() {
        var _this$_recorderApp4;
        for (const {
          metadata,
          sdkObject
        } of this._debugger.pausedDetails()) {
          if (!this._currentCallsMetadata.has(metadata))
            this.onBeforeCall(sdkObject, metadata);
        }
        (_this$_recorderApp4 = this._recorderApp) === null || _this$_recorderApp4 === void 0 ? void 0 : _this$_recorderApp4.setPaused(this._debugger.isPaused());
        this._updateUserSources();
        this.updateCallLog([...this._currentCallsMetadata.keys()]);
      }
      _setMode(mode) {
        var _this$_recorderApp5;
        this._mode = mode;
        (_this$_recorderApp5 = this._recorderApp) === null || _this$_recorderApp5 === void 0 ? void 0 : _this$_recorderApp5.setMode(this._mode);
        this._contextRecorder.setEnabled(this._mode === "recording");
        this._debugger.setMuted(this._mode === "recording");
        if (this._mode !== "none")
          this._context.pages()[0].bringToFront().catch(() => {
          });
      }
      _refreshOverlay() {
        for (const page of this._context.pages())
          page.mainFrame().evaluateExpression("window._playwrightRefreshOverlay()", false, void 0, "main").catch(() => {
          });
      }
      onBeforeCall(sdkObject, metadata) {
        return __async(this, null, function* () {
          if (this._mode === "recording")
            return;
          this._currentCallsMetadata.set(metadata, sdkObject);
          this._allMetadatas.set(metadata.id, metadata);
          this._updateUserSources();
          this.updateCallLog([metadata]);
          if (metadata.params && metadata.params.selector) {
            var _this$_recorderApp6;
            this._highlightedSelector = metadata.params.selector;
            (_this$_recorderApp6 = this._recorderApp) === null || _this$_recorderApp6 === void 0 ? void 0 : _this$_recorderApp6.setSelector(this._highlightedSelector).catch(() => {
            });
          }
        });
      }
      onAfterCall(sdkObject, metadata) {
        return __async(this, null, function* () {
          if (this._mode === "recording")
            return;
          if (!metadata.error)
            this._currentCallsMetadata.delete(metadata);
          this._updateUserSources();
          this.updateCallLog([metadata]);
        });
      }
      _updateUserSources() {
        var _this$_recorderApp7;
        for (const source of this._userSources.values()) {
          source.highlight = [];
          source.revealLine = void 0;
        }
        let fileToSelect = void 0;
        for (const metadata of this._currentCallsMetadata.keys()) {
          if (!metadata.stack || !metadata.stack[0])
            continue;
          const {
            file,
            line
          } = metadata.stack[0];
          let source = this._userSources.get(file);
          if (!source) {
            source = {
              file,
              text: this._readSource(file),
              highlight: [],
              language: languageForFile(file)
            };
            this._userSources.set(file, source);
          }
          if (line) {
            const paused = this._debugger.isPaused(metadata);
            source.highlight.push({
              line,
              type: metadata.error ? "error" : paused ? "paused" : "running"
            });
            source.revealLine = line;
            fileToSelect = source.file;
          }
        }
        this._pushAllSources();
        if (fileToSelect)
          (_this$_recorderApp7 = this._recorderApp) === null || _this$_recorderApp7 === void 0 ? void 0 : _this$_recorderApp7.setFile(fileToSelect);
      }
      _pushAllSources() {
        var _this$_recorderApp8;
        (_this$_recorderApp8 = this._recorderApp) === null || _this$_recorderApp8 === void 0 ? void 0 : _this$_recorderApp8.setSources([...this._recorderSources, ...this._userSources.values()]);
      }
      onBeforeInputAction(sdkObject, metadata) {
        return __async(this, null, function* () {
        });
      }
      onCallLog(sdkObject, metadata, logName, message) {
        return __async(this, null, function* () {
          this.updateCallLog([metadata]);
        });
      }
      updateCallLog(metadatas) {
        var _this$_recorderApp9;
        if (this._mode === "recording")
          return;
        const logs = [];
        for (const metadata of metadatas) {
          if (!metadata.method || metadata.internal)
            continue;
          let status = "done";
          if (this._currentCallsMetadata.has(metadata))
            status = "in-progress";
          if (this._debugger.isPaused(metadata))
            status = "paused";
          logs.push((0, _recorderUtils.metadataToCallLog)(metadata, status));
        }
        (_this$_recorderApp9 = this._recorderApp) === null || _this$_recorderApp9 === void 0 ? void 0 : _this$_recorderApp9.updateCallLogs(logs);
      }
      _readSource(fileName) {
        try {
          return fs.readFileSync(fileName, "utf-8");
        } catch (e) {
          return "// No source available";
        }
      }
    };
    exports2.Recorder = Recorder;
    var ContextRecorder = class extends _events.EventEmitter {
      constructor(context, params) {
        super();
        this._generator = void 0;
        this._pageAliases = /* @__PURE__ */ new Map();
        this._lastPopupOrdinal = 0;
        this._lastDialogOrdinal = 0;
        this._lastDownloadOrdinal = 0;
        this._timers = /* @__PURE__ */ new Set();
        this._context = void 0;
        this._params = void 0;
        this._recorderSources = void 0;
        this._context = context;
        this._params = params;
        const language = params.language || context._browser.options.sdkLanguage;
        const languages = /* @__PURE__ */ new Set([new _java.JavaLanguageGenerator(), new _javascript.JavaScriptLanguageGenerator(false), new _javascript.JavaScriptLanguageGenerator(true), new _python.PythonLanguageGenerator(false), new _python.PythonLanguageGenerator(true), new _csharp.CSharpLanguageGenerator()]);
        const primaryLanguage = [...languages].find((l) => l.id === language);
        if (!primaryLanguage)
          throw new Error(`
===============================
Unsupported language: '${language}'
===============================
`);
        languages.delete(primaryLanguage);
        const orderedLanguages = [primaryLanguage, ...languages];
        this._recorderSources = [];
        const generator = new _codeGenerator.CodeGenerator(context._browser.options.name, !!params.startRecording, params.launchOptions || {}, params.contextOptions || {}, params.device, params.saveStorage);
        const throttledOutputFile = params.outputFile ? new ThrottledFile(params.outputFile) : null;
        generator.on("change", () => {
          this._recorderSources = [];
          for (const languageGenerator of orderedLanguages) {
            const source = {
              file: languageGenerator.fileName,
              text: generator.generateText(languageGenerator),
              language: languageGenerator.highlighter,
              highlight: []
            };
            source.revealLine = source.text.split("\n").length - 1;
            this._recorderSources.push(source);
            if (languageGenerator === orderedLanguages[0])
              throttledOutputFile === null || throttledOutputFile === void 0 ? void 0 : throttledOutputFile.setContent(source.text);
          }
          this.emit(ContextRecorder.Events.Change, {
            sources: this._recorderSources,
            primaryFileName: primaryLanguage.fileName
          });
        });
        if (throttledOutputFile) {
          context.on(_browserContext.BrowserContext.Events.BeforeClose, () => {
            throttledOutputFile.flush();
          });
          process.on("exit", () => {
            throttledOutputFile.flush();
          });
        }
        this._generator = generator;
      }
      install() {
        return __async(this, null, function* () {
          this._context.on(_browserContext.BrowserContext.Events.Page, (page) => this._onPage(page));
          for (const page of this._context.pages())
            this._onPage(page);
          yield this._context.exposeBinding("_playwrightRecorderPerformAction", false, (source, action) => this._performAction(source.frame, action));
          yield this._context.exposeBinding("_playwrightRecorderRecordAction", false, (source, action) => this._recordAction(source.frame, action));
          yield this._context.extendInjectedScript(recorderSource.source);
        });
      }
      setEnabled(enabled) {
        this._generator.setEnabled(enabled);
      }
      dispose() {
        for (const timer of this._timers)
          clearTimeout(timer);
        this._timers.clear();
      }
      _onPage(page) {
        return __async(this, null, function* () {
          const frame = page.mainFrame();
          page.on("close", () => {
            this._generator.addAction({
              frame: this._describeMainFrame(page),
              committed: true,
              action: {
                name: "closePage",
                signals: []
              }
            });
            this._pageAliases.delete(page);
          });
          frame.on(_frames.Frame.Events.Navigation, () => this._onFrameNavigated(frame, page));
          page.on(_page.Page.Events.Download, () => this._onDownload(page));
          page.on(_page.Page.Events.Dialog, () => this._onDialog(page));
          const suffix = this._pageAliases.size ? String(++this._lastPopupOrdinal) : "";
          const pageAlias = "page" + suffix;
          this._pageAliases.set(page, pageAlias);
          if (page.opener()) {
            this._onPopup(page.opener(), page);
          } else {
            this._generator.addAction({
              frame: this._describeMainFrame(page),
              committed: true,
              action: {
                name: "openPage",
                url: page.mainFrame().url(),
                signals: []
              }
            });
          }
        });
      }
      clearScript() {
        this._generator.restart();
        if (!!this._params.startRecording) {
          for (const page of this._context.pages())
            this._onFrameNavigated(page.mainFrame(), page);
        }
      }
      _describeMainFrame(page) {
        return {
          pageAlias: this._pageAliases.get(page),
          isMainFrame: true,
          url: page.mainFrame().url()
        };
      }
      _describeFrame(frame) {
        return __async(this, null, function* () {
          const page = frame._page;
          const pageAlias = this._pageAliases.get(page);
          const chain = [];
          for (let ancestor = frame; ancestor; ancestor = ancestor.parentFrame())
            chain.push(ancestor);
          chain.reverse();
          if (chain.length === 1)
            return this._describeMainFrame(page);
          const hasUniqueName = page.frames().filter((f) => f.name() === frame.name()).length === 1;
          const fallback = {
            pageAlias,
            isMainFrame: false,
            url: frame.url(),
            name: frame.name() && hasUniqueName ? frame.name() : void 0
          };
          if (chain.length > 3)
            return fallback;
          const selectorPromises = [];
          for (let i = 0; i < chain.length - 1; i++)
            selectorPromises.push(this._findFrameSelector(chain[i + 1], chain[i]));
          const result = yield (0, _timeoutRunner.raceAgainstTimeout)(() => Promise.all(selectorPromises), 2e3);
          if (!result.timedOut && result.result.every((selector) => !!selector)) {
            return __spreadProps(__spreadValues({}, fallback), {
              selectorsChain: result.result
            });
          }
          return fallback;
        });
      }
      _findFrameSelector(frame, parent) {
        return __async(this, null, function* () {
          try {
            const frameElement = yield frame.frameElement();
            if (!frameElement)
              return;
            const utility = yield parent._utilityContext();
            const injected = yield utility.injectedScript();
            const selector = yield injected.evaluate((injected2, element) => injected2.generateSelector(element), frameElement);
            return selector;
          } catch (e) {
          }
        });
      }
      _performAction(frame, action) {
        return __async(this, null, function* () {
          this._generator.commitLastAction();
          const frameDescription = yield this._describeFrame(frame);
          const actionInContext = {
            frame: frameDescription,
            action
          };
          const perform = (action2, params, cb) => __async(this, null, function* () {
            const callMetadata = {
              id: `call@${(0, _utils2.createGuid)()}`,
              apiName: "frame." + action2,
              objectId: frame.guid,
              pageId: frame._page.guid,
              frameId: frame.guid,
              wallTime: Date.now(),
              startTime: (0, _utils2.monotonicTime)(),
              endTime: 0,
              type: "Frame",
              method: action2,
              params,
              log: [],
              snapshots: []
            };
            this._generator.willPerformAction(actionInContext);
            try {
              yield frame.instrumentation.onBeforeCall(frame, callMetadata);
              yield cb(callMetadata);
            } catch (e) {
              callMetadata.endTime = (0, _utils2.monotonicTime)();
              yield frame.instrumentation.onAfterCall(frame, callMetadata);
              this._generator.performedActionFailed(actionInContext);
              return;
            }
            callMetadata.endTime = (0, _utils2.monotonicTime)();
            yield frame.instrumentation.onAfterCall(frame, callMetadata);
            const timer = setTimeout(() => {
              actionInContext.committed = true;
              this._timers.delete(timer);
            }, 5e3);
            this._generator.didPerformAction(actionInContext);
            this._timers.add(timer);
          });
          const kActionTimeout = 5e3;
          if (action.name === "click") {
            const {
              options
            } = (0, _utils.toClickOptions)(action);
            yield perform("click", {
              selector: action.selector
            }, (callMetadata) => frame.click(callMetadata, action.selector, __spreadProps(__spreadValues({}, options), {
              timeout: kActionTimeout,
              strict: true
            })));
          }
          if (action.name === "press") {
            const modifiers = (0, _utils.toModifiers)(action.modifiers);
            const shortcut = [...modifiers, action.key].join("+");
            yield perform("press", {
              selector: action.selector,
              key: shortcut
            }, (callMetadata) => frame.press(callMetadata, action.selector, shortcut, {
              timeout: kActionTimeout,
              strict: true
            }));
          }
          if (action.name === "check")
            yield perform("check", {
              selector: action.selector
            }, (callMetadata) => frame.check(callMetadata, action.selector, {
              timeout: kActionTimeout,
              strict: true
            }));
          if (action.name === "uncheck")
            yield perform("uncheck", {
              selector: action.selector
            }, (callMetadata) => frame.uncheck(callMetadata, action.selector, {
              timeout: kActionTimeout,
              strict: true
            }));
          if (action.name === "select") {
            const values = action.options.map((value) => ({
              value
            }));
            yield perform("selectOption", {
              selector: action.selector,
              values
            }, (callMetadata) => frame.selectOption(callMetadata, action.selector, [], values, {
              timeout: kActionTimeout,
              strict: true
            }));
          }
        });
      }
      _recordAction(frame, action) {
        return __async(this, null, function* () {
          this._generator.commitLastAction();
          const frameDescription = yield this._describeFrame(frame);
          const actionInContext = {
            frame: frameDescription,
            action
          };
          this._generator.addAction(actionInContext);
        });
      }
      _onFrameNavigated(frame, page) {
        const pageAlias = this._pageAliases.get(page);
        this._generator.signal(pageAlias, frame, {
          name: "navigation",
          url: frame.url()
        });
      }
      _onPopup(page, popup) {
        const pageAlias = this._pageAliases.get(page);
        const popupAlias = this._pageAliases.get(popup);
        this._generator.signal(pageAlias, page.mainFrame(), {
          name: "popup",
          popupAlias
        });
      }
      _onDownload(page) {
        const pageAlias = this._pageAliases.get(page);
        this._generator.signal(pageAlias, page.mainFrame(), {
          name: "download",
          downloadAlias: String(++this._lastDownloadOrdinal)
        });
      }
      _onDialog(page) {
        const pageAlias = this._pageAliases.get(page);
        this._generator.signal(pageAlias, page.mainFrame(), {
          name: "dialog",
          dialogAlias: String(++this._lastDialogOrdinal)
        });
      }
    };
    ContextRecorder.Events = {
      Change: "change"
    };
    function languageForFile(file) {
      if (file.endsWith(".py"))
        return "python";
      if (file.endsWith(".java"))
        return "java";
      if (file.endsWith(".cs"))
        return "csharp";
      return "javascript";
    }
    var ThrottledFile = class {
      constructor(file) {
        this._file = void 0;
        this._timer = void 0;
        this._text = void 0;
        this._file = file;
      }
      setContent(text) {
        this._text = text;
        if (!this._timer)
          this._timer = setTimeout(() => this.flush(), 1e3);
      }
      flush() {
        if (this._timer) {
          clearTimeout(this._timer);
          this._timer = void 0;
        }
        if (this._text)
          fs.writeFileSync(this._file, this._text);
        this._text = void 0;
      }
    };
  }
});

// node_modules/playwright-core/lib/server/browserContext.js
var require_browserContext = __commonJS({
  "node_modules/playwright-core/lib/server/browserContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BrowserContext = void 0;
    exports2.assertBrowserContextIsNotOwned = assertBrowserContextIsNotOwned;
    exports2.normalizeProxySettings = normalizeProxySettings;
    exports2.validateBrowserContextOptions = validateBrowserContextOptions;
    exports2.verifyGeolocation = verifyGeolocation;
    var os = _interopRequireWildcard(require("os"));
    var _timeoutSettings = require_timeoutSettings();
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _helper = require_helper();
    var network = _interopRequireWildcard(require_network());
    var _page = require_page();
    var _path = _interopRequireDefault(require("path"));
    var _fs = _interopRequireDefault(require("fs"));
    var _instrumentation = require_instrumentation();
    var _debugger = require_debugger();
    var _tracing = require_tracing();
    var _harRecorder = require_harRecorder();
    var _recorder = require_recorder();
    var consoleApiSource = _interopRequireWildcard(require_consoleApiSource());
    var _fetch = require_fetch();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var BrowserContext = class extends _instrumentation.SdkObject {
      constructor(browser, options, browserContextId) {
        super(browser, "browser-context");
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
        this._pageBindings = /* @__PURE__ */ new Map();
        this._options = void 0;
        this._requestInterceptor = void 0;
        this._isPersistentContext = void 0;
        this._closedStatus = "open";
        this._closePromise = void 0;
        this._closePromiseFulfill = void 0;
        this._permissions = /* @__PURE__ */ new Map();
        this._downloads = /* @__PURE__ */ new Set();
        this._browser = void 0;
        this._browserContextId = void 0;
        this._selectors = void 0;
        this._origins = /* @__PURE__ */ new Set();
        this._harRecorder = void 0;
        this.tracing = void 0;
        this.fetchRequest = void 0;
        this._customCloseHandler = void 0;
        this._tempDirs = [];
        this._settingStorageState = false;
        this.initScripts = [];
        this.attribution.context = this;
        this._browser = browser;
        this._options = options;
        this._browserContextId = browserContextId;
        this._isPersistentContext = !browserContextId;
        this._closePromise = new Promise((fulfill) => this._closePromiseFulfill = fulfill);
        this.fetchRequest = new _fetch.BrowserContextAPIRequestContext(this);
        if (this._options.recordHar)
          this._harRecorder = new _harRecorder.HarRecorder(this, __spreadProps(__spreadValues({}, this._options.recordHar), {
            path: _path.default.join(this._browser.options.artifactsDir, `${(0, _utils.createGuid)()}.har`)
          }));
        this.tracing = new _tracing.Tracing(this, browser.options.tracesDir);
      }
      isPersistentContext() {
        return this._isPersistentContext;
      }
      setSelectors(selectors) {
        this._selectors = selectors;
      }
      selectors() {
        return this._selectors || this._browser.options.selectors;
      }
      _initialize() {
        return __async(this, null, function* () {
          if (this.attribution.isInternalPlaywright)
            return;
          const contextDebugger = new _debugger.Debugger(this);
          this.instrumentation.addListener(contextDebugger, this);
          if ((0, _utils.debugMode)() === "inspector")
            yield _recorder.Recorder.show(this, {
              pauseOnNextStatement: true
            });
          if (contextDebugger.isPaused())
            _recorder.Recorder.showInspector(this);
          contextDebugger.on(_debugger.Debugger.Events.PausedStateChanged, () => {
            _recorder.Recorder.showInspector(this);
          });
          if ((0, _utils.debugMode)() === "console")
            yield this.extendInjectedScript(consoleApiSource.source);
        });
      }
      _ensureVideosPath() {
        return __async(this, null, function* () {
          if (this._options.recordVideo)
            yield (0, _fileUtils.mkdirIfNeeded)(_path.default.join(this._options.recordVideo.dir, "dummy"));
        });
      }
      _browserClosed() {
        for (const page of this.pages())
          page._didClose();
        this._didCloseInternal();
      }
      _didCloseInternal() {
        if (this._closedStatus === "closed") {
          return;
        }
        this._closedStatus = "closed";
        this._deleteAllDownloads();
        this._downloads.clear();
        this.tracing.dispose();
        if (this._isPersistentContext)
          this.onClosePersistent();
        this._closePromiseFulfill(new Error("Context closed"));
        this.emit(BrowserContext.Events.Close);
      }
      cookies() {
        return __async(this, arguments, function* (urls = []) {
          if (urls && !Array.isArray(urls))
            urls = [urls];
          return yield this.doGetCookies(urls);
        });
      }
      setHTTPCredentials(httpCredentials) {
        return this.doSetHTTPCredentials(httpCredentials);
      }
      exposeBinding(name, needsHandle, playwrightBinding) {
        return __async(this, null, function* () {
          if (this._pageBindings.has(name))
            throw new Error(`Function "${name}" has been already registered`);
          for (const page of this.pages()) {
            if (page.getBinding(name))
              throw new Error(`Function "${name}" has been already registered in one of the pages`);
          }
          const binding = new _page.PageBinding(name, playwrightBinding, needsHandle);
          this._pageBindings.set(name, binding);
          yield this.doExposeBinding(binding);
        });
      }
      removeExposedBindings() {
        return __async(this, null, function* () {
          this._pageBindings.clear();
          yield this.doRemoveExposedBindings();
        });
      }
      grantPermissions(permissions, origin) {
        return __async(this, null, function* () {
          let resolvedOrigin = "*";
          if (origin) {
            const url = new URL(origin);
            resolvedOrigin = url.origin;
          }
          const existing = new Set(this._permissions.get(resolvedOrigin) || []);
          permissions.forEach((p) => existing.add(p));
          const list = [...existing.values()];
          this._permissions.set(resolvedOrigin, list);
          yield this.doGrantPermissions(resolvedOrigin, list);
        });
      }
      clearPermissions() {
        return __async(this, null, function* () {
          this._permissions.clear();
          yield this.doClearPermissions();
        });
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      _loadDefaultContextAsIs(progress) {
        return __async(this, null, function* () {
          if (!this.pages().length) {
            const waitForEvent = _helper.helper.waitForEvent(progress, this, BrowserContext.Events.Page);
            progress.cleanupWhenAborted(() => waitForEvent.dispose);
            const page = yield waitForEvent.promise;
            if (page._pageIsError)
              throw page._pageIsError;
          }
          const pages = this.pages();
          if (pages[0]._pageIsError)
            throw pages[0]._pageIsError;
          yield pages[0].mainFrame()._waitForLoadState(progress, "load");
          return pages;
        });
      }
      _loadDefaultContext(progress) {
        return __async(this, null, function* () {
          const pages = yield this._loadDefaultContextAsIs(progress);
          if (this._options.isMobile || this._options.locale) {
            const oldPage = pages[0];
            yield this.newPage(progress.metadata);
            yield oldPage.close(progress.metadata);
          }
        });
      }
      _authenticateProxyViaHeader() {
        const proxy = this._options.proxy || this._browser.options.proxy || {
          username: void 0,
          password: void 0
        };
        const {
          username,
          password
        } = proxy;
        if (username) {
          this._options.httpCredentials = {
            username,
            password
          };
          const token = Buffer.from(`${username}:${password}`).toString("base64");
          this._options.extraHTTPHeaders = network.mergeHeaders([this._options.extraHTTPHeaders, network.singleHeader("Proxy-Authorization", `Basic ${token}`)]);
        }
      }
      _authenticateProxyViaCredentials() {
        const proxy = this._options.proxy || this._browser.options.proxy;
        if (!proxy)
          return;
        const {
          username,
          password
        } = proxy;
        if (username)
          this._options.httpCredentials = {
            username,
            password: password || ""
          };
      }
      addInitScript(script) {
        return __async(this, null, function* () {
          this.initScripts.push(script);
          yield this.doAddInitScript(script);
        });
      }
      removeInitScripts() {
        return __async(this, null, function* () {
          this.initScripts.splice(0, this.initScripts.length);
          yield this.doRemoveInitScripts();
        });
      }
      setRequestInterceptor(handler) {
        return __async(this, null, function* () {
          this._requestInterceptor = handler;
          yield this.doUpdateRequestInterception();
        });
      }
      isClosingOrClosed() {
        return this._closedStatus !== "open";
      }
      _deleteAllDownloads() {
        return __async(this, null, function* () {
          yield Promise.all(Array.from(this._downloads).map((download) => download.artifact.deleteOnContextClose()));
        });
      }
      _deleteAllTempDirs() {
        return __async(this, null, function* () {
          yield Promise.all(this._tempDirs.map((dir) => __async(this, null, function* () {
            return yield _fs.default.promises.unlink(dir).catch((e) => {
            });
          })));
        });
      }
      setCustomCloseHandler(handler) {
        this._customCloseHandler = handler;
      }
      close(metadata) {
        return __async(this, null, function* () {
          if (this._closedStatus === "open") {
            var _this$_harRecorder;
            this.emit(BrowserContext.Events.BeforeClose);
            this._closedStatus = "closing";
            yield (_this$_harRecorder = this._harRecorder) === null || _this$_harRecorder === void 0 ? void 0 : _this$_harRecorder.flush();
            yield this.tracing.flush();
            const promises = [];
            for (const {
              context,
              artifact
            } of this._browser._idToVideo.values()) {
              if (context === this)
                promises.push(artifact.finishedPromise());
            }
            if (this._customCloseHandler) {
              yield this._customCloseHandler();
            } else if (this._isPersistentContext) {
              yield Promise.all(this.pages().map((page) => page.close(metadata)));
            } else {
              yield this.doClose();
            }
            promises.push(this._deleteAllDownloads());
            promises.push(this._deleteAllTempDirs());
            yield Promise.all(promises);
            if (this._customCloseHandler)
              return;
            if (this._isPersistentContext)
              yield this._browser.close();
            this._didCloseInternal();
          }
          yield this._closePromise;
        });
      }
      newPage(metadata) {
        return __async(this, null, function* () {
          const pageDelegate = yield this.newPageDelegate();
          if (metadata.isServerSide)
            pageDelegate.potentiallyUninitializedPage().markAsServerSideOnly();
          const pageOrError = yield pageDelegate.pageOrError();
          if (pageOrError instanceof _page.Page) {
            if (pageOrError.isClosed())
              throw new Error("Page has been closed.");
            return pageOrError;
          }
          throw pageOrError;
        });
      }
      addVisitedOrigin(origin) {
        this._origins.add(origin);
      }
      storageState() {
        return __async(this, null, function* () {
          const result = {
            cookies: yield this.cookies(),
            origins: []
          };
          if (this._origins.size) {
            const internalMetadata = (0, _instrumentation.serverSideCallMetadata)();
            const page = yield this.newPage(internalMetadata);
            yield page._setServerRequestInterceptor((handler) => {
              handler.fulfill({
                body: "<html></html>"
              }).catch(() => {
              });
            });
            for (const origin of this._origins) {
              const originStorage = {
                origin,
                localStorage: []
              };
              const frame = page.mainFrame();
              yield frame.goto(internalMetadata, origin);
              const storage = yield frame.evaluateExpression(`({
          localStorage: Object.keys(localStorage).map(name => ({ name, value: localStorage.getItem(name) })),
        })`, false, void 0, "utility");
              originStorage.localStorage = storage.localStorage;
              if (storage.localStorage.length)
                result.origins.push(originStorage);
            }
            yield page.close(internalMetadata);
          }
          return result;
        });
      }
      isSettingStorageState() {
        return this._settingStorageState;
      }
      setStorageState(metadata, state) {
        return __async(this, null, function* () {
          this._settingStorageState = true;
          try {
            if (state.cookies)
              yield this.addCookies(state.cookies);
            if (state.origins && state.origins.length) {
              const internalMetadata = (0, _instrumentation.serverSideCallMetadata)();
              const page = yield this.newPage(internalMetadata);
              yield page._setServerRequestInterceptor((handler) => {
                handler.fulfill({
                  body: "<html></html>"
                }).catch(() => {
                });
              });
              for (const originState of state.origins) {
                const frame = page.mainFrame();
                yield frame.goto(metadata, originState.origin);
                yield frame.evaluateExpression(`
            originState => {
              for (const { name, value } of (originState.localStorage || []))
                localStorage.setItem(name, value);
            }`, true, originState, "utility");
              }
              yield page.close(internalMetadata);
            }
          } finally {
            this._settingStorageState = false;
          }
        });
      }
      extendInjectedScript(source, arg) {
        return __async(this, null, function* () {
          const installInFrame = (frame) => frame.extendInjectedScript(source, arg).catch(() => {
          });
          const installInPage = (page) => {
            page.on(_page.Page.Events.InternalFrameNavigatedToNewDocument, installInFrame);
            return Promise.all(page.frames().map(installInFrame));
          };
          this.on(BrowserContext.Events.Page, installInPage);
          return Promise.all(this.pages().map(installInPage));
        });
      }
    };
    exports2.BrowserContext = BrowserContext;
    BrowserContext.Events = {
      Close: "close",
      Page: "page",
      Request: "request",
      Response: "response",
      RequestFailed: "requestfailed",
      RequestFinished: "requestfinished",
      BeforeClose: "beforeclose",
      VideoStarted: "videostarted"
    };
    function assertBrowserContextIsNotOwned(context) {
      for (const page of context.pages()) {
        if (page._ownedContext)
          throw new Error("Please use browser.newContext() for multi-page scripts that share the context.");
      }
    }
    function validateBrowserContextOptions(options, browserOptions) {
      if (options.noDefaultViewport && options.deviceScaleFactor !== void 0)
        throw new Error(`"deviceScaleFactor" option is not supported with null "viewport"`);
      if (options.noDefaultViewport && options.isMobile !== void 0)
        throw new Error(`"isMobile" option is not supported with null "viewport"`);
      if (options.acceptDownloads === void 0)
        options.acceptDownloads = true;
      if (!options.viewport && !options.noDefaultViewport)
        options.viewport = {
          width: 1280,
          height: 720
        };
      if (options.recordVideo) {
        if (!options.recordVideo.size) {
          if (options.noDefaultViewport) {
            options.recordVideo.size = {
              width: 800,
              height: 600
            };
          } else {
            const size = options.viewport;
            const scale = Math.min(1, 800 / Math.max(size.width, size.height));
            options.recordVideo.size = {
              width: Math.floor(size.width * scale),
              height: Math.floor(size.height * scale)
            };
          }
        }
        options.recordVideo.size.width &= ~1;
        options.recordVideo.size.height &= ~1;
      }
      if (options.proxy) {
        if (!browserOptions.proxy && browserOptions.isChromium && os.platform() === "win32")
          throw new Error(`Browser needs to be launched with the global proxy. If all contexts override the proxy, global proxy will be never used and can be any string, for example "launch({ proxy: { server: 'http://per-context' } })"`);
        options.proxy = normalizeProxySettings(options.proxy);
      }
      if ((0, _utils.debugMode)() === "inspector")
        options.bypassCSP = true;
      verifyGeolocation(options.geolocation);
    }
    function verifyGeolocation(geolocation) {
      if (!geolocation)
        return;
      geolocation.accuracy = geolocation.accuracy || 0;
      const {
        longitude,
        latitude,
        accuracy
      } = geolocation;
      if (longitude < -180 || longitude > 180)
        throw new Error(`geolocation.longitude: precondition -180 <= LONGITUDE <= 180 failed.`);
      if (latitude < -90 || latitude > 90)
        throw new Error(`geolocation.latitude: precondition -90 <= LATITUDE <= 90 failed.`);
      if (accuracy < 0)
        throw new Error(`geolocation.accuracy: precondition 0 <= ACCURACY failed.`);
    }
    function normalizeProxySettings(proxy) {
      let {
        server,
        bypass
      } = proxy;
      let url;
      try {
        url = new URL(server);
        if (!url.host || !url.protocol)
          url = new URL("http://" + server);
      } catch (e) {
        url = new URL("http://" + server);
      }
      if (url.protocol === "socks4:" && (proxy.username || proxy.password))
        throw new Error(`Socks4 proxy protocol does not support authentication`);
      if (url.protocol === "socks5:" && (proxy.username || proxy.password))
        throw new Error(`Browser does not support socks5 proxy authentication`);
      server = url.protocol + "//" + url.host;
      if (bypass)
        bypass = bypass.split(",").map((t) => t.trim()).join(",");
      return __spreadProps(__spreadValues({}, proxy), {
        server,
        bypass
      });
    }
  }
});

// node_modules/playwright-core/lib/server/cookieStore.js
var require_cookieStore = __commonJS({
  "node_modules/playwright-core/lib/server/cookieStore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CookieStore = void 0;
    exports2.domainMatches = domainMatches;
    var Cookie = class {
      constructor(data) {
        this._raw = void 0;
        this._raw = data;
      }
      name() {
        return this._raw.name;
      }
      matches(url) {
        if (this._raw.secure && url.protocol !== "https:" && url.hostname !== "localhost")
          return false;
        if (!domainMatches(url.hostname, this._raw.domain))
          return false;
        if (!pathMatches(url.pathname, this._raw.path))
          return false;
        return true;
      }
      equals(other) {
        return this._raw.name === other._raw.name && this._raw.domain === other._raw.domain && this._raw.path === other._raw.path;
      }
      networkCookie() {
        return this._raw;
      }
      updateExpiresFrom(other) {
        this._raw.expires = other._raw.expires;
      }
      expired() {
        if (this._raw.expires === -1)
          return false;
        return this._raw.expires * 1e3 < Date.now();
      }
    };
    var CookieStore = class {
      constructor() {
        this._nameToCookies = /* @__PURE__ */ new Map();
      }
      addCookies(cookies) {
        for (const cookie of cookies)
          this._addCookie(new Cookie(cookie));
      }
      cookies(url) {
        const result = [];
        for (const cookie of this._cookiesIterator()) {
          if (cookie.matches(url))
            result.push(cookie.networkCookie());
        }
        return result;
      }
      allCookies() {
        const result = [];
        for (const cookie of this._cookiesIterator())
          result.push(cookie.networkCookie());
        return result;
      }
      _addCookie(cookie) {
        if (cookie.expired())
          return;
        let set = this._nameToCookies.get(cookie.name());
        if (!set) {
          set = /* @__PURE__ */ new Set();
          this._nameToCookies.set(cookie.name(), set);
        }
        CookieStore.pruneExpired(set);
        for (const other of set) {
          if (other.equals(cookie)) {
            cookie.updateExpiresFrom(other);
            set.delete(other);
          }
        }
        set.add(cookie);
      }
      *_cookiesIterator() {
        for (const [name, cookies] of this._nameToCookies) {
          CookieStore.pruneExpired(cookies);
          for (const cookie of cookies)
            yield cookie;
          if (cookies.size === 0)
            this._nameToCookies.delete(name);
        }
      }
      static pruneExpired(cookies) {
        for (const cookie of cookies) {
          if (cookie.expired())
            cookies.delete(cookie);
        }
      }
    };
    exports2.CookieStore = CookieStore;
    function domainMatches(value, domain) {
      if (value === domain)
        return true;
      if (!domain.startsWith("."))
        return false;
      value = "." + value;
      return value.endsWith(domain);
    }
    function pathMatches(value, path) {
      if (value === path)
        return true;
      if (!value.endsWith("/"))
        value = value + "/";
      if (!path.endsWith("/"))
        path = path + "/";
      return value.startsWith(path);
    }
  }
});

// node_modules/playwright-core/lib/server/formData.js
var require_formData = __commonJS({
  "node_modules/playwright-core/lib/server/formData.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.MultipartFormData = void 0;
    var _mime = _interopRequireDefault(require_mime());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var MultipartFormData = class {
      constructor() {
        this._boundary = void 0;
        this._chunks = [];
        this._boundary = generateUniqueBoundaryString();
      }
      contentTypeHeader() {
        return `multipart/form-data; boundary=${this._boundary}`;
      }
      addField(name, value) {
        this._beginMultiPartHeader(name);
        this._finishMultiPartHeader();
        this._chunks.push(Buffer.from(value));
        this._finishMultiPartField();
      }
      addFileField(name, value) {
        this._beginMultiPartHeader(name);
        this._chunks.push(Buffer.from(`; filename="${value.name}"`));
        this._chunks.push(Buffer.from(`\r
content-type: ${value.mimeType || _mime.default.getType(value.name) || "application/octet-stream"}`));
        this._finishMultiPartHeader();
        this._chunks.push(Buffer.from(value.buffer, "base64"));
        this._finishMultiPartField();
      }
      finish() {
        this._addBoundary(true);
        return Buffer.concat(this._chunks);
      }
      _beginMultiPartHeader(name) {
        this._addBoundary();
        this._chunks.push(Buffer.from(`content-disposition: form-data; name="${name}"`));
      }
      _finishMultiPartHeader() {
        this._chunks.push(Buffer.from(`\r
\r
`));
      }
      _finishMultiPartField() {
        this._chunks.push(Buffer.from(`\r
`));
      }
      _addBoundary(isLastBoundary) {
        this._chunks.push(Buffer.from("--" + this._boundary));
        if (isLastBoundary)
          this._chunks.push(Buffer.from("--"));
        this._chunks.push(Buffer.from("\r\n"));
      }
    };
    exports2.MultipartFormData = MultipartFormData;
    var alphaNumericEncodingMap = [65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66];
    function generateUniqueBoundaryString() {
      const charCodes = [];
      for (let i = 0; i < 16; i++)
        charCodes.push(alphaNumericEncodingMap[Math.floor(Math.random() * alphaNumericEncodingMap.length)]);
      return "----WebKitFormBoundary" + String.fromCharCode(...charCodes);
    }
  }
});

// node_modules/playwright-core/lib/server/fetch.js
var require_fetch = __commonJS({
  "node_modules/playwright-core/lib/server/fetch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GlobalAPIRequestContext = exports2.BrowserContextAPIRequestContext = exports2.APIRequestContext = void 0;
    var http = _interopRequireWildcard(require("http"));
    var https = _interopRequireWildcard(require("https"));
    var _httpsProxyAgent = require_dist();
    var _socksProxyAgent = require_dist2();
    var _stream = require("stream");
    var _url = _interopRequireDefault(require("url"));
    var _zlib = _interopRequireDefault(require("zlib"));
    var _timeoutSettings = require_timeoutSettings();
    var _userAgent = require_userAgent();
    var _utils = require_utils();
    var _browserContext = require_browserContext();
    var _cookieStore = require_cookieStore();
    var _formData = require_formData();
    var _instrumentation = require_instrumentation();
    var _progress = require_progress2();
    var _tracing = require_tracing();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var APIRequestContext = class extends _instrumentation.SdkObject {
      static findResponseBody(guid) {
        for (const request of APIRequestContext.allInstances) {
          const body = request.fetchResponses.get(guid);
          if (body)
            return body;
        }
        return void 0;
      }
      constructor(parent) {
        super(parent, "fetchRequest");
        this.fetchResponses = /* @__PURE__ */ new Map();
        this.fetchLog = /* @__PURE__ */ new Map();
        APIRequestContext.allInstances.add(this);
      }
      _disposeImpl() {
        APIRequestContext.allInstances.delete(this);
        this.fetchResponses.clear();
        this.fetchLog.clear();
        this.emit(APIRequestContext.Events.Dispose);
      }
      disposeResponse(fetchUid) {
        this.fetchResponses.delete(fetchUid);
        this.fetchLog.delete(fetchUid);
      }
      _storeResponseBody(body) {
        const uid = (0, _utils.createGuid)();
        this.fetchResponses.set(uid, body);
        return uid;
      }
      fetch(params, metadata) {
        return __async(this, null, function* () {
          var _params$method;
          const headers = {};
          const defaults = this._defaultOptions();
          headers["user-agent"] = defaults.userAgent;
          headers["accept"] = "*/*";
          headers["accept-encoding"] = "gzip,deflate,br";
          if (defaults.extraHTTPHeaders) {
            for (const {
              name,
              value
            } of defaults.extraHTTPHeaders)
              headers[name.toLowerCase()] = value;
          }
          if (params.headers) {
            for (const {
              name,
              value
            } of params.headers)
              headers[name.toLowerCase()] = value;
          }
          const method = ((_params$method = params.method) === null || _params$method === void 0 ? void 0 : _params$method.toUpperCase()) || "GET";
          const proxy = defaults.proxy;
          let agent;
          if (proxy) {
            var _proxyOpts$protocol;
            const proxyOpts = _url.default.parse(proxy.server);
            if ((_proxyOpts$protocol = proxyOpts.protocol) !== null && _proxyOpts$protocol !== void 0 && _proxyOpts$protocol.startsWith("socks")) {
              agent = new _socksProxyAgent.SocksProxyAgent({
                host: proxyOpts.hostname,
                port: proxyOpts.port || void 0
              });
            } else {
              if (proxy.username)
                proxyOpts.auth = `${proxy.username}:${proxy.password || ""}`;
              agent = new _httpsProxyAgent.HttpsProxyAgent(proxyOpts);
            }
          }
          const timeout = defaults.timeoutSettings.timeout(params);
          const deadline = timeout && (0, _utils.monotonicTime)() + timeout;
          const options = {
            method,
            headers,
            agent,
            maxRedirects: 20,
            timeout,
            deadline
          };
          if (params.ignoreHTTPSErrors || defaults.ignoreHTTPSErrors)
            options.rejectUnauthorized = false;
          const requestUrl = new URL(params.url, defaults.baseURL);
          if (params.params) {
            for (const {
              name,
              value
            } of params.params)
              requestUrl.searchParams.set(name, value);
          }
          let postData;
          if (["POST", "PUT", "PATCH", "DELETE"].includes(method))
            postData = serializePostData(params, headers);
          else if (params.postData || params.jsonData || params.formData || params.multipartData)
            throw new Error(`Method ${method} does not accept post data`);
          if (postData)
            headers["content-length"] = String(postData.byteLength);
          const controller = new _progress.ProgressController(metadata, this);
          const fetchResponse = yield controller.run((progress) => {
            return this._sendRequest(progress, requestUrl, options, postData);
          });
          const fetchUid = this._storeResponseBody(fetchResponse.body);
          this.fetchLog.set(fetchUid, controller.metadata.log);
          if (params.failOnStatusCode && (fetchResponse.status < 200 || fetchResponse.status >= 400))
            throw new Error(`${fetchResponse.status} ${fetchResponse.statusText}`);
          return __spreadProps(__spreadValues({}, fetchResponse), {
            fetchUid
          });
        });
      }
      _parseSetCookieHeader(responseUrl, setCookie) {
        if (!setCookie)
          return [];
        const url = new URL(responseUrl);
        const defaultPath = "/" + url.pathname.substr(1).split("/").slice(0, -1).join("/");
        const cookies = [];
        for (const header of setCookie) {
          const cookie = parseCookie(header);
          if (!cookie)
            continue;
          if (!cookie.domain)
            cookie.domain = url.hostname;
          else
            (0, _utils.assert)(cookie.domain.startsWith("."));
          if (!(0, _cookieStore.domainMatches)(url.hostname, cookie.domain))
            continue;
          if (!cookie.path || !cookie.path.startsWith("/"))
            cookie.path = defaultPath;
          cookies.push(cookie);
        }
        return cookies;
      }
      _updateRequestCookieHeader(url, options) {
        return __async(this, null, function* () {
          if (options.headers["cookie"] !== void 0)
            return;
          const cookies = yield this._cookies(url);
          if (cookies.length) {
            const valueArray = cookies.map((c) => `${c.name}=${c.value}`);
            options.headers["cookie"] = valueArray.join("; ");
          }
        });
      }
      _sendRequest(progress, url, options, postData) {
        return __async(this, null, function* () {
          var _cookie;
          yield this._updateRequestCookieHeader(url, options);
          const requestCookies = ((_cookie = options.headers["cookie"]) === null || _cookie === void 0 ? void 0 : _cookie.split(";").map((p) => {
            const [name, value] = p.split("=").map((v) => v.trim());
            return {
              name,
              value
            };
          })) || [];
          const requestEvent = {
            url,
            method: options.method,
            headers: options.headers,
            cookies: requestCookies,
            postData
          };
          this.emit(APIRequestContext.Events.Request, requestEvent);
          return new Promise((fulfill, reject) => {
            const requestConstructor = (url.protocol === "https:" ? https : http).request;
            const request = requestConstructor(url, options, (response) => __async(this, null, function* () {
              const notifyRequestFinished = (body2) => {
                const requestFinishedEvent = {
                  requestEvent,
                  httpVersion: response.httpVersion,
                  statusCode: response.statusCode || 0,
                  statusMessage: response.statusMessage || "",
                  headers: response.headers,
                  rawHeaders: response.rawHeaders,
                  cookies,
                  body: body2
                };
                this.emit(APIRequestContext.Events.RequestFinished, requestFinishedEvent);
              };
              progress.log(`\u2190 ${response.statusCode} ${response.statusMessage}`);
              for (const [name, value] of Object.entries(response.headers))
                progress.log(`  ${name}: ${value}`);
              const cookies = this._parseSetCookieHeader(response.url || url.toString(), response.headers["set-cookie"]);
              if (cookies.length)
                yield this._addCookies(cookies);
              if (redirectStatus.includes(response.statusCode)) {
                if (!options.maxRedirects) {
                  reject(new Error("Max redirect count exceeded"));
                  request.destroy();
                  return;
                }
                const headers = __spreadValues({}, options.headers);
                delete headers[`cookie`];
                const status = response.statusCode;
                let method = options.method;
                if ((status === 301 || status === 302) && method === "POST" || status === 303 && !["GET", "HEAD"].includes(method)) {
                  method = "GET";
                  postData = void 0;
                  delete headers[`content-encoding`];
                  delete headers[`content-language`];
                  delete headers[`content-length`];
                  delete headers[`content-location`];
                  delete headers[`content-type`];
                }
                const redirectOptions = {
                  method,
                  headers,
                  agent: options.agent,
                  maxRedirects: options.maxRedirects - 1,
                  timeout: options.timeout,
                  deadline: options.deadline
                };
                if (options.rejectUnauthorized === false)
                  redirectOptions.rejectUnauthorized = false;
                if (response.headers.location) {
                  const locationURL = new URL(response.headers.location, url);
                  notifyRequestFinished();
                  fulfill(this._sendRequest(progress, locationURL, redirectOptions, postData));
                  request.destroy();
                  return;
                }
              }
              if (response.statusCode === 401 && !options.headers["authorization"]) {
                const auth = response.headers["www-authenticate"];
                const credentials = this._defaultOptions().httpCredentials;
                if (auth !== null && auth !== void 0 && auth.trim().startsWith("Basic") && credentials) {
                  const {
                    username,
                    password
                  } = credentials;
                  const encoded = Buffer.from(`${username || ""}:${password || ""}`).toString("base64");
                  options.headers["authorization"] = `Basic ${encoded}`;
                  notifyRequestFinished();
                  fulfill(this._sendRequest(progress, url, options, postData));
                  request.destroy();
                  return;
                }
              }
              response.on("aborted", () => reject(new Error("aborted")));
              const chunks = [];
              const notifyBodyFinished = () => {
                const body2 = Buffer.concat(chunks);
                notifyRequestFinished(body2);
                fulfill({
                  url: response.url || url.toString(),
                  status: response.statusCode || 0,
                  statusText: response.statusMessage || "",
                  headers: toHeadersArray(response.rawHeaders),
                  body: body2
                });
              };
              let body = response;
              let transform;
              const encoding = response.headers["content-encoding"];
              if (encoding === "gzip" || encoding === "x-gzip") {
                transform = _zlib.default.createGunzip({
                  flush: _zlib.default.constants.Z_SYNC_FLUSH,
                  finishFlush: _zlib.default.constants.Z_SYNC_FLUSH
                });
              } else if (encoding === "br") {
                transform = _zlib.default.createBrotliDecompress();
              } else if (encoding === "deflate") {
                transform = _zlib.default.createInflate();
              }
              if (transform) {
                const emptyStreamTransform = new SafeEmptyStreamTransform(notifyBodyFinished);
                body = (0, _stream.pipeline)(response, emptyStreamTransform, transform, (e) => {
                  if (e)
                    reject(new Error(`failed to decompress '${encoding}' encoding: ${e}`));
                });
              }
              body.on("data", (chunk) => chunks.push(chunk));
              body.on("end", notifyBodyFinished);
              body.on("error", reject);
            }));
            request.on("error", reject);
            const disposeListener = () => {
              reject(new Error("Request context disposed."));
              request.destroy();
            };
            this.on(APIRequestContext.Events.Dispose, disposeListener);
            request.on("close", () => this.off(APIRequestContext.Events.Dispose, disposeListener));
            progress.log(`\u2192 ${options.method} ${url.toString()}`);
            if (options.headers) {
              for (const [name, value] of Object.entries(options.headers))
                progress.log(`  ${name}: ${value}`);
            }
            if (options.deadline) {
              const rejectOnTimeout = () => {
                reject(new Error(`Request timed out after ${options.timeout}ms`));
                request.destroy();
              };
              const remaining = options.deadline - (0, _utils.monotonicTime)();
              if (remaining <= 0) {
                rejectOnTimeout();
                return;
              }
              request.setTimeout(remaining, rejectOnTimeout);
            }
            if (postData)
              request.write(postData);
            request.end();
          });
        });
      }
    };
    exports2.APIRequestContext = APIRequestContext;
    APIRequestContext.Events = {
      Dispose: "dispose",
      Request: "request",
      RequestFinished: "requestfinished"
    };
    APIRequestContext.allInstances = /* @__PURE__ */ new Set();
    var SafeEmptyStreamTransform = class extends _stream.Transform {
      constructor(onEmptyStreamCallback) {
        super();
        this._receivedSomeData = false;
        this._onEmptyStreamCallback = void 0;
        this._onEmptyStreamCallback = onEmptyStreamCallback;
      }
      _transform(chunk, encoding, callback) {
        this._receivedSomeData = true;
        callback(null, chunk);
      }
      _flush(callback) {
        if (this._receivedSomeData)
          callback(null);
        else
          this._onEmptyStreamCallback();
      }
    };
    var BrowserContextAPIRequestContext = class extends APIRequestContext {
      constructor(context) {
        super(context);
        this._context = void 0;
        this._context = context;
        context.once(_browserContext.BrowserContext.Events.Close, () => this._disposeImpl());
      }
      tracing() {
        return this._context.tracing;
      }
      dispose() {
        return __async(this, null, function* () {
          this.fetchResponses.clear();
        });
      }
      _defaultOptions() {
        return {
          userAgent: this._context._options.userAgent || this._context._browser.userAgent(),
          extraHTTPHeaders: this._context._options.extraHTTPHeaders,
          httpCredentials: this._context._options.httpCredentials,
          proxy: this._context._options.proxy || this._context._browser.options.proxy,
          timeoutSettings: this._context._timeoutSettings,
          ignoreHTTPSErrors: this._context._options.ignoreHTTPSErrors,
          baseURL: this._context._options.baseURL
        };
      }
      _addCookies(cookies) {
        return __async(this, null, function* () {
          yield this._context.addCookies(cookies);
        });
      }
      _cookies(url) {
        return __async(this, null, function* () {
          return yield this._context.cookies(url.toString());
        });
      }
      storageState() {
        return __async(this, null, function* () {
          return this._context.storageState();
        });
      }
    };
    exports2.BrowserContextAPIRequestContext = BrowserContextAPIRequestContext;
    var GlobalAPIRequestContext = class extends APIRequestContext {
      constructor(playwright, options) {
        super(playwright);
        this._cookieStore = new _cookieStore.CookieStore();
        this._options = void 0;
        this._origins = void 0;
        this._tracing = void 0;
        this.attribution.context = this;
        const timeoutSettings = new _timeoutSettings.TimeoutSettings();
        if (options.timeout !== void 0)
          timeoutSettings.setDefaultTimeout(options.timeout);
        const proxy = options.proxy;
        if (proxy !== null && proxy !== void 0 && proxy.server) {
          let url = proxy === null || proxy === void 0 ? void 0 : proxy.server.trim();
          if (!/^\w+:\/\//.test(url))
            url = "http://" + url;
          proxy.server = url;
        }
        if (options.storageState) {
          this._origins = options.storageState.origins;
          this._cookieStore.addCookies(options.storageState.cookies);
        }
        this._options = {
          baseURL: options.baseURL,
          userAgent: options.userAgent || (0, _userAgent.getUserAgent)(),
          extraHTTPHeaders: options.extraHTTPHeaders,
          ignoreHTTPSErrors: !!options.ignoreHTTPSErrors,
          httpCredentials: options.httpCredentials,
          proxy,
          timeoutSettings
        };
        this._tracing = new _tracing.Tracing(this, options.tracesDir);
      }
      tracing() {
        return this._tracing;
      }
      dispose() {
        return __async(this, null, function* () {
          yield this._tracing.flush();
          yield this._tracing.deleteTmpTracesDir();
          this._tracing.dispose();
          this._disposeImpl();
        });
      }
      _defaultOptions() {
        return this._options;
      }
      _addCookies(cookies) {
        return __async(this, null, function* () {
          this._cookieStore.addCookies(cookies);
        });
      }
      _cookies(url) {
        return __async(this, null, function* () {
          return this._cookieStore.cookies(url);
        });
      }
      storageState() {
        return __async(this, null, function* () {
          return {
            cookies: this._cookieStore.allCookies(),
            origins: this._origins || []
          };
        });
      }
    };
    exports2.GlobalAPIRequestContext = GlobalAPIRequestContext;
    function toHeadersArray(rawHeaders) {
      const result = [];
      for (let i = 0; i < rawHeaders.length; i += 2)
        result.push({
          name: rawHeaders[i],
          value: rawHeaders[i + 1]
        });
      return result;
    }
    var redirectStatus = [301, 302, 303, 307, 308];
    function parseCookie(header) {
      const pairs = header.split(";").filter((s) => s.trim().length > 0).map((p) => {
        let key = "";
        let value2 = "";
        const separatorPos = p.indexOf("=");
        if (separatorPos === -1) {
          key = p.trim();
        } else {
          key = p.slice(0, separatorPos).trim();
          value2 = p.slice(separatorPos + 1).trim();
        }
        return [key, value2];
      });
      if (!pairs.length)
        return null;
      const [name, value] = pairs[0];
      const cookie = {
        name,
        value,
        domain: "",
        path: "",
        expires: -1,
        httpOnly: false,
        secure: false,
        sameSite: "Lax"
      };
      for (let i = 1; i < pairs.length; i++) {
        const [name2, value2] = pairs[i];
        switch (name2.toLowerCase()) {
          case "expires":
            const expiresMs = +new Date(value2);
            if (isFinite(expiresMs))
              cookie.expires = expiresMs / 1e3;
            break;
          case "max-age":
            const maxAgeSec = parseInt(value2, 10);
            if (isFinite(maxAgeSec))
              cookie.expires = Date.now() / 1e3 + maxAgeSec;
            break;
          case "domain":
            cookie.domain = value2.toLocaleLowerCase() || "";
            if (cookie.domain && !cookie.domain.startsWith("."))
              cookie.domain = "." + cookie.domain;
            break;
          case "path":
            cookie.path = value2 || "";
            break;
          case "secure":
            cookie.secure = true;
            break;
          case "httponly":
            cookie.httpOnly = true;
            break;
        }
      }
      return cookie;
    }
    function isJsonParsable(value) {
      if (typeof value !== "string")
        return false;
      try {
        JSON.parse(value);
        return true;
      } catch (e) {
        if (e instanceof SyntaxError)
          return false;
        else
          throw e;
      }
    }
    function serializePostData(params, headers) {
      (0, _utils.assert)((params.postData ? 1 : 0) + (params.jsonData ? 1 : 0) + (params.formData ? 1 : 0) + (params.multipartData ? 1 : 0) <= 1, `Only one of 'data', 'form' or 'multipart' can be specified`);
      if (params.jsonData !== void 0) {
        var _contentType, _headers$_contentType;
        const json = isJsonParsable(params.jsonData) ? params.jsonData : JSON.stringify(params.jsonData);
        (_headers$_contentType = headers[_contentType = "content-type"]) !== null && _headers$_contentType !== void 0 ? _headers$_contentType : headers[_contentType] = "application/json";
        return Buffer.from(json, "utf8");
      } else if (params.formData) {
        var _contentType2, _headers$_contentType2;
        const searchParams = new URLSearchParams();
        for (const {
          name,
          value
        } of params.formData)
          searchParams.append(name, value);
        (_headers$_contentType2 = headers[_contentType2 = "content-type"]) !== null && _headers$_contentType2 !== void 0 ? _headers$_contentType2 : headers[_contentType2] = "application/x-www-form-urlencoded";
        return Buffer.from(searchParams.toString(), "utf8");
      } else if (params.multipartData) {
        var _contentType3, _headers$_contentType3;
        const formData = new _formData.MultipartFormData();
        for (const field of params.multipartData) {
          if (field.file)
            formData.addFileField(field.name, field.file);
          else if (field.value)
            formData.addField(field.name, field.value);
        }
        (_headers$_contentType3 = headers[_contentType3 = "content-type"]) !== null && _headers$_contentType3 !== void 0 ? _headers$_contentType3 : headers[_contentType3] = formData.contentTypeHeader();
        return formData.finish();
      } else if (params.postData !== void 0) {
        var _contentType4, _headers$_contentType4;
        (_headers$_contentType4 = headers[_contentType4 = "content-type"]) !== null && _headers$_contentType4 !== void 0 ? _headers$_contentType4 : headers[_contentType4] = "application/octet-stream";
        return Buffer.from(params.postData, "base64");
      }
      return void 0;
    }
  }
});

// node_modules/playwright-core/lib/common/socksProxy.js
var require_socksProxy = __commonJS({
  "node_modules/playwright-core/lib/common/socksProxy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SocksProxyHandler = exports2.SocksProxy = void 0;
    var _dns = _interopRequireDefault(require("dns"));
    var _events = _interopRequireDefault(require("events"));
    var _net = _interopRequireDefault(require("net"));
    var _util = _interopRequireDefault(require("util"));
    var _debugLogger = require_debugLogger();
    var _netUtils = require_netUtils();
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var dnsLookupAsync = _util.default.promisify(_dns.default.lookup);
    var SocksAuth;
    (function(SocksAuth2) {
      SocksAuth2[SocksAuth2["NO_AUTHENTICATION_REQUIRED"] = 0] = "NO_AUTHENTICATION_REQUIRED";
      SocksAuth2[SocksAuth2["GSSAPI"] = 1] = "GSSAPI";
      SocksAuth2[SocksAuth2["USERNAME_PASSWORD"] = 2] = "USERNAME_PASSWORD";
      SocksAuth2[SocksAuth2["NO_ACCEPTABLE_METHODS"] = 255] = "NO_ACCEPTABLE_METHODS";
    })(SocksAuth || (SocksAuth = {}));
    var SocksAddressType;
    (function(SocksAddressType2) {
      SocksAddressType2[SocksAddressType2["IPv4"] = 1] = "IPv4";
      SocksAddressType2[SocksAddressType2["FqName"] = 3] = "FqName";
      SocksAddressType2[SocksAddressType2["IPv6"] = 4] = "IPv6";
    })(SocksAddressType || (SocksAddressType = {}));
    var SocksCommand;
    (function(SocksCommand2) {
      SocksCommand2[SocksCommand2["CONNECT"] = 1] = "CONNECT";
      SocksCommand2[SocksCommand2["BIND"] = 2] = "BIND";
      SocksCommand2[SocksCommand2["UDP_ASSOCIATE"] = 3] = "UDP_ASSOCIATE";
    })(SocksCommand || (SocksCommand = {}));
    var SocksReply;
    (function(SocksReply2) {
      SocksReply2[SocksReply2["Succeeded"] = 0] = "Succeeded";
      SocksReply2[SocksReply2["GeneralServerFailure"] = 1] = "GeneralServerFailure";
      SocksReply2[SocksReply2["NotAllowedByRuleSet"] = 2] = "NotAllowedByRuleSet";
      SocksReply2[SocksReply2["NetworkUnreachable"] = 3] = "NetworkUnreachable";
      SocksReply2[SocksReply2["HostUnreachable"] = 4] = "HostUnreachable";
      SocksReply2[SocksReply2["ConnectionRefused"] = 5] = "ConnectionRefused";
      SocksReply2[SocksReply2["TtlExpired"] = 6] = "TtlExpired";
      SocksReply2[SocksReply2["CommandNotSupported"] = 7] = "CommandNotSupported";
      SocksReply2[SocksReply2["AddressTypeNotSupported"] = 8] = "AddressTypeNotSupported";
    })(SocksReply || (SocksReply = {}));
    var SocksConnection = class {
      constructor(uid, socket, client) {
        this._buffer = Buffer.from([]);
        this._offset = 0;
        this._fence = 0;
        this._fenceCallback = void 0;
        this._socket = void 0;
        this._boundOnData = void 0;
        this._uid = void 0;
        this._client = void 0;
        this._uid = uid;
        this._socket = socket;
        this._client = client;
        this._boundOnData = this._onData.bind(this);
        socket.on("data", this._boundOnData);
        socket.on("close", () => this._onClose());
        socket.on("end", () => this._onClose());
        socket.on("error", () => this._onClose());
        this._run().catch(() => this._socket.end());
      }
      _run() {
        return __async(this, null, function* () {
          (0, _utils.assert)(yield this._authenticate());
          const {
            command,
            host,
            port
          } = yield this._parseRequest();
          if (command !== SocksCommand.CONNECT) {
            this._writeBytes(Buffer.from([
              5,
              SocksReply.CommandNotSupported,
              0,
              1,
              0,
              0,
              0,
              0,
              0,
              0
            ]));
            return;
          }
          this._socket.off("data", this._boundOnData);
          this._client.onSocketRequested({
            uid: this._uid,
            host,
            port
          });
        });
      }
      _authenticate() {
        return __async(this, null, function* () {
          const version = yield this._readByte();
          (0, _utils.assert)(version === 5, "The VER field must be set to x05 for this version of the protocol, was " + version);
          const nMethods = yield this._readByte();
          (0, _utils.assert)(nMethods, "No authentication methods specified");
          const methods = yield this._readBytes(nMethods);
          for (const method of methods) {
            if (method === 0) {
              this._writeBytes(Buffer.from([version, method]));
              return true;
            }
          }
          this._writeBytes(Buffer.from([version, SocksAuth.NO_ACCEPTABLE_METHODS]));
          return false;
        });
      }
      _parseRequest() {
        return __async(this, null, function* () {
          const version = yield this._readByte();
          (0, _utils.assert)(version === 5, "The VER field must be set to x05 for this version of the protocol, was " + version);
          const command = yield this._readByte();
          yield this._readByte();
          const addressType = yield this._readByte();
          let host = "";
          switch (addressType) {
            case SocksAddressType.IPv4:
              host = (yield this._readBytes(4)).join(".");
              break;
            case SocksAddressType.FqName:
              const length = yield this._readByte();
              host = (yield this._readBytes(length)).toString();
              break;
            case SocksAddressType.IPv6:
              const bytes = yield this._readBytes(16);
              const tokens = [];
              for (let i = 0; i < 8; ++i)
                tokens.push(bytes.readUInt16BE(i * 2));
              host = tokens.join(":");
              break;
          }
          const port = (yield this._readBytes(2)).readUInt16BE(0);
          this._buffer = Buffer.from([]);
          this._offset = 0;
          this._fence = 0;
          return {
            command,
            host,
            port
          };
        });
      }
      _readByte() {
        return __async(this, null, function* () {
          const buffer = yield this._readBytes(1);
          return buffer[0];
        });
      }
      _readBytes(length) {
        return __async(this, null, function* () {
          this._fence = this._offset + length;
          if (!this._buffer || this._buffer.length < this._fence)
            yield new Promise((f) => this._fenceCallback = f);
          this._offset += length;
          return this._buffer.slice(this._offset - length, this._offset);
        });
      }
      _writeBytes(buffer) {
        if (this._socket.writable)
          this._socket.write(buffer);
      }
      _onClose() {
        this._client.onSocketClosed({
          uid: this._uid
        });
      }
      _onData(buffer) {
        this._buffer = Buffer.concat([this._buffer, buffer]);
        if (this._fenceCallback && this._buffer.length >= this._fence) {
          const callback = this._fenceCallback;
          this._fenceCallback = void 0;
          callback();
        }
      }
      socketConnected(host, port) {
        this._writeBytes(Buffer.from([
          5,
          SocksReply.Succeeded,
          0,
          1,
          ...parseIP(host),
          port << 8,
          port & 255
        ]));
        this._socket.on("data", (data) => this._client.onSocketData({
          uid: this._uid,
          data
        }));
      }
      socketFailed(errorCode) {
        const buffer = Buffer.from([
          5,
          0,
          0,
          1,
          ...parseIP("0.0.0.0"),
          0,
          0
        ]);
        switch (errorCode) {
          case "ENOENT":
          case "ENOTFOUND":
          case "ETIMEDOUT":
          case "EHOSTUNREACH":
            buffer[1] = SocksReply.HostUnreachable;
            break;
          case "ENETUNREACH":
            buffer[1] = SocksReply.NetworkUnreachable;
            break;
          case "ECONNREFUSED":
            buffer[1] = SocksReply.ConnectionRefused;
            break;
        }
        this._writeBytes(buffer);
        this._socket.end();
      }
      sendData(data) {
        this._socket.write(data);
      }
      end() {
        this._socket.end();
      }
      error(error) {
        this._socket.destroy(new Error(error));
      }
    };
    function parseIP(address) {
      if (!_net.default.isIPv4(address))
        throw new Error("IPv6 is not supported");
      return address.split(".", 4).map((t) => +t);
    }
    var SocksProxy = class extends _events.default {
      constructor() {
        super();
        this._server = void 0;
        this._connections = /* @__PURE__ */ new Map();
        this._server = new _net.default.Server((socket) => {
          const uid = (0, _utils.createGuid)();
          const connection = new SocksConnection(uid, socket, this);
          this._connections.set(uid, connection);
        });
      }
      listen(port) {
        return __async(this, null, function* () {
          return new Promise((f) => {
            this._server.listen(port, () => {
              const port2 = this._server.address().port;
              _debugLogger.debugLogger.log("proxy", `Starting socks proxy server on port ${port2}`);
              f(port2);
            });
          });
        });
      }
      close() {
        return __async(this, null, function* () {
          yield new Promise((f) => this._server.close(f));
        });
      }
      onSocketRequested(payload) {
        this.emit(SocksProxy.Events.SocksRequested, payload);
      }
      onSocketData(payload) {
        this.emit(SocksProxy.Events.SocksData, payload);
      }
      onSocketClosed(payload) {
        this.emit(SocksProxy.Events.SocksClosed, payload);
      }
      socketConnected({
        uid,
        host,
        port
      }) {
        var _this$_connections$ge;
        (_this$_connections$ge = this._connections.get(uid)) === null || _this$_connections$ge === void 0 ? void 0 : _this$_connections$ge.socketConnected(host, port);
      }
      socketFailed({
        uid,
        errorCode
      }) {
        var _this$_connections$ge2;
        (_this$_connections$ge2 = this._connections.get(uid)) === null || _this$_connections$ge2 === void 0 ? void 0 : _this$_connections$ge2.socketFailed(errorCode);
      }
      sendSocketData({
        uid,
        data
      }) {
        var _this$_connections$ge3;
        (_this$_connections$ge3 = this._connections.get(uid)) === null || _this$_connections$ge3 === void 0 ? void 0 : _this$_connections$ge3.sendData(data);
      }
      sendSocketEnd({
        uid
      }) {
        var _this$_connections$ge4;
        (_this$_connections$ge4 = this._connections.get(uid)) === null || _this$_connections$ge4 === void 0 ? void 0 : _this$_connections$ge4.end();
      }
      sendSocketError({
        uid,
        error
      }) {
        var _this$_connections$ge5;
        (_this$_connections$ge5 = this._connections.get(uid)) === null || _this$_connections$ge5 === void 0 ? void 0 : _this$_connections$ge5.error(error);
      }
    };
    exports2.SocksProxy = SocksProxy;
    SocksProxy.Events = {
      SocksRequested: "socksRequested",
      SocksData: "socksData",
      SocksClosed: "socksClosed"
    };
    var SocksProxyHandler = class extends _events.default {
      constructor(redirectPortForTest) {
        super();
        this._sockets = /* @__PURE__ */ new Map();
        this._redirectPortForTest = void 0;
        this._redirectPortForTest = redirectPortForTest;
      }
      cleanup() {
        for (const uid of this._sockets.keys())
          this.socketClosed({
            uid
          });
      }
      socketRequested(_0) {
        return __async(this, arguments, function* ({
          uid,
          host,
          port
        }) {
          if (host === "local.playwright")
            host = "localhost";
          try {
            if (this._redirectPortForTest)
              port = this._redirectPortForTest;
            const {
              address
            } = yield dnsLookupAsync(host);
            const socket = yield (0, _netUtils.createSocket)(address, port);
            socket.on("data", (data) => {
              const payload2 = {
                uid,
                data
              };
              this.emit(SocksProxyHandler.Events.SocksData, payload2);
            });
            socket.on("error", (error) => {
              const payload2 = {
                uid,
                error: error.message
              };
              this.emit(SocksProxyHandler.Events.SocksError, payload2);
              this._sockets.delete(uid);
            });
            socket.on("end", () => {
              const payload2 = {
                uid
              };
              this.emit(SocksProxyHandler.Events.SocksEnd, payload2);
              this._sockets.delete(uid);
            });
            const localAddress = socket.localAddress;
            const localPort = socket.localPort;
            this._sockets.set(uid, socket);
            const payload = {
              uid,
              host: localAddress,
              port: localPort
            };
            this.emit(SocksProxyHandler.Events.SocksConnected, payload);
          } catch (error) {
            const payload = {
              uid,
              errorCode: error.code
            };
            this.emit(SocksProxyHandler.Events.SocksFailed, payload);
          }
        });
      }
      sendSocketData({
        uid,
        data
      }) {
        var _this$_sockets$get;
        (_this$_sockets$get = this._sockets.get(uid)) === null || _this$_sockets$get === void 0 ? void 0 : _this$_sockets$get.write(data);
      }
      socketClosed({
        uid
      }) {
        var _this$_sockets$get2;
        (_this$_sockets$get2 = this._sockets.get(uid)) === null || _this$_sockets$get2 === void 0 ? void 0 : _this$_sockets$get2.destroy();
        this._sockets.delete(uid);
      }
    };
    exports2.SocksProxyHandler = SocksProxyHandler;
    SocksProxyHandler.Events = {
      SocksConnected: "socksConnected",
      SocksData: "socksData",
      SocksError: "socksError",
      SocksFailed: "socksFailed",
      SocksEnd: "socksEnd"
    };
  }
});

// node_modules/playwright-core/lib/server/dispatchers/jsHandleDispatcher.js
var require_jsHandleDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/jsHandleDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JSHandleDispatcher = void 0;
    exports2.parseArgument = parseArgument;
    exports2.parseValue = parseValue;
    exports2.serializeResult = serializeResult;
    var _dispatcher = require_dispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var _serializers = require_serializers();
    var JSHandleDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, jsHandle) {
        super(scope, jsHandle, jsHandle.asElement() ? "ElementHandle" : "JSHandle", {
          preview: jsHandle.toString()
        });
        this._type_JSHandle = true;
        jsHandle._setPreviewCallback((preview) => this._dispatchEvent("previewUpdated", {
          preview
        }));
      }
      evaluateExpression(params) {
        return __async(this, null, function* () {
          return {
            value: serializeResult(yield this._object.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, true, parseArgument(params.arg)))
          };
        });
      }
      evaluateExpressionHandle(params) {
        return __async(this, null, function* () {
          const jsHandle = yield this._object.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, false, parseArgument(params.arg));
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, jsHandle)
          };
        });
      }
      getProperty(params) {
        return __async(this, null, function* () {
          const jsHandle = yield this._object.getProperty(params.name);
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, jsHandle)
          };
        });
      }
      getPropertyList() {
        return __async(this, null, function* () {
          const map = yield this._object.getProperties();
          const properties = [];
          for (const [name, value] of map)
            properties.push({
              name,
              value: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, value)
            });
          return {
            properties
          };
        });
      }
      jsonValue() {
        return __async(this, null, function* () {
          return {
            value: serializeResult(yield this._object.jsonValue())
          };
        });
      }
      dispose() {
        return __async(this, null, function* () {
          yield this._object.dispose();
        });
      }
    };
    exports2.JSHandleDispatcher = JSHandleDispatcher;
    function parseArgument(arg) {
      return (0, _serializers.parseSerializedValue)(arg.value, arg.handles.map((a) => a._object));
    }
    function parseValue(v) {
      return (0, _serializers.parseSerializedValue)(v, []);
    }
    function serializeResult(arg) {
      return (0, _serializers.serializeValue)(arg, (value) => ({
        fallThrough: value
      }), /* @__PURE__ */ new Set());
    }
  }
});

// node_modules/playwright-core/lib/server/dispatchers/elementHandlerDispatcher.js
var require_elementHandlerDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/elementHandlerDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ElementHandleDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _jsHandleDispatcher = require_jsHandleDispatcher();
    var ElementHandleDispatcher = class extends _jsHandleDispatcher.JSHandleDispatcher {
      static from(scope, handle) {
        return (0, _dispatcher.existingDispatcher)(handle) || new ElementHandleDispatcher(scope, handle);
      }
      static fromNullable(scope, handle) {
        if (!handle)
          return void 0;
        return (0, _dispatcher.existingDispatcher)(handle) || new ElementHandleDispatcher(scope, handle);
      }
      static fromJSHandle(scope, handle) {
        const result = (0, _dispatcher.existingDispatcher)(handle);
        if (result)
          return result;
        return handle.asElement() ? new ElementHandleDispatcher(scope, handle.asElement()) : new _jsHandleDispatcher.JSHandleDispatcher(scope, handle);
      }
      constructor(scope, elementHandle) {
        super(scope, elementHandle);
        this._type_ElementHandle = true;
        this._elementHandle = void 0;
        this._elementHandle = elementHandle;
      }
      ownerFrame(params, metadata) {
        return __async(this, null, function* () {
          return {
            frame: (0, _dispatcher.lookupNullableDispatcher)(yield this._elementHandle.ownerFrame())
          };
        });
      }
      contentFrame(params, metadata) {
        return __async(this, null, function* () {
          return {
            frame: (0, _dispatcher.lookupNullableDispatcher)(yield this._elementHandle.contentFrame())
          };
        });
      }
      getAttribute(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._elementHandle.getAttribute(params.name);
          return {
            value: value === null ? void 0 : value
          };
        });
      }
      inputValue(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._elementHandle.inputValue();
          return {
            value
          };
        });
      }
      textContent(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._elementHandle.textContent();
          return {
            value: value === null ? void 0 : value
          };
        });
      }
      innerText(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.innerText()
          };
        });
      }
      innerHTML(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.innerHTML()
          };
        });
      }
      isChecked(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.isChecked()
          };
        });
      }
      isDisabled(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.isDisabled()
          };
        });
      }
      isEditable(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.isEditable()
          };
        });
      }
      isEnabled(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.isEnabled()
          };
        });
      }
      isHidden(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.isHidden()
          };
        });
      }
      isVisible(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._elementHandle.isVisible()
          };
        });
      }
      dispatchEvent(params, metadata) {
        return __async(this, null, function* () {
          yield this._elementHandle.dispatchEvent(params.type, (0, _jsHandleDispatcher.parseArgument)(params.eventInit));
        });
      }
      scrollIntoViewIfNeeded(params, metadata) {
        return __async(this, null, function* () {
          yield this._elementHandle.scrollIntoViewIfNeeded(metadata, params);
        });
      }
      hover(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.hover(metadata, params);
        });
      }
      click(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.click(metadata, params);
        });
      }
      dblclick(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.dblclick(metadata, params);
        });
      }
      tap(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.tap(metadata, params);
        });
      }
      selectOption(params, metadata) {
        return __async(this, null, function* () {
          const elements = (params.elements || []).map((e) => e._elementHandle);
          return {
            values: yield this._elementHandle.selectOption(metadata, elements, params.options || [], params)
          };
        });
      }
      fill(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.fill(metadata, params.value, params);
        });
      }
      selectText(params, metadata) {
        return __async(this, null, function* () {
          yield this._elementHandle.selectText(metadata, params);
        });
      }
      setInputFiles(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.setInputFiles(metadata, {
            files: params.files
          }, params);
        });
      }
      setInputFilePaths(params, metadata) {
        return __async(this, null, function* () {
          let {
            localPaths
          } = params;
          if (!localPaths) {
            if (!params.streams)
              throw new Error("Neither localPaths nor streams is specified");
            localPaths = params.streams.map((c) => c.path());
          }
          return yield this._elementHandle.setInputFiles(metadata, {
            localPaths
          }, params);
        });
      }
      focus(params, metadata) {
        return __async(this, null, function* () {
          yield this._elementHandle.focus(metadata);
        });
      }
      type(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.type(metadata, params.text, params);
        });
      }
      press(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.press(metadata, params.key, params);
        });
      }
      check(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.check(metadata, params);
        });
      }
      uncheck(params, metadata) {
        return __async(this, null, function* () {
          return yield this._elementHandle.uncheck(metadata, params);
        });
      }
      boundingBox(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._elementHandle.boundingBox();
          return {
            value: value || void 0
          };
        });
      }
      screenshot(params, metadata) {
        return __async(this, null, function* () {
          const mask = (params.mask || []).map(({
            frame,
            selector
          }) => ({
            frame: frame._object,
            selector
          }));
          return {
            binary: (yield this._elementHandle.screenshot(metadata, __spreadProps(__spreadValues({}, params), {
              mask
            }))).toString("base64")
          };
        });
      }
      querySelector(params, metadata) {
        return __async(this, null, function* () {
          const handle = yield this._elementHandle.querySelector(params.selector, params);
          return {
            element: ElementHandleDispatcher.fromNullable(this._scope, handle)
          };
        });
      }
      querySelectorAll(params, metadata) {
        return __async(this, null, function* () {
          const elements = yield this._elementHandle.querySelectorAll(params.selector);
          return {
            elements: elements.map((e) => ElementHandleDispatcher.from(this._scope, e))
          };
        });
      }
      evalOnSelector(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield this._elementHandle.evalOnSelectorAndWaitForSignals(params.selector, !!params.strict, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      evalOnSelectorAll(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield this._elementHandle.evalOnSelectorAllAndWaitForSignals(params.selector, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      waitForElementState(params, metadata) {
        return __async(this, null, function* () {
          yield this._elementHandle.waitForElementState(metadata, params.state, params);
        });
      }
      waitForSelector(params, metadata) {
        return __async(this, null, function* () {
          return {
            element: ElementHandleDispatcher.fromNullable(this._scope, yield this._elementHandle.waitForSelector(metadata, params.selector, params))
          };
        });
      }
    };
    exports2.ElementHandleDispatcher = ElementHandleDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/consoleMessageDispatcher.js
var require_consoleMessageDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/consoleMessageDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ConsoleMessageDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var ConsoleMessageDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, message) {
        super(scope, message, "ConsoleMessage", {
          type: message.type(),
          text: message.text(),
          args: message.args().map((a) => _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(scope, a)),
          location: message.location()
        });
        this._type_ConsoleMessage = true;
      }
    };
    exports2.ConsoleMessageDispatcher = ConsoleMessageDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/dialogDispatcher.js
var require_dialogDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/dialogDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DialogDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var DialogDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, dialog) {
        super(scope, dialog, "Dialog", {
          type: dialog.type(),
          message: dialog.message(),
          defaultValue: dialog.defaultValue()
        });
        this._type_Dialog = true;
      }
      accept(params) {
        return __async(this, null, function* () {
          yield this._object.accept(params.promptText);
        });
      }
      dismiss() {
        return __async(this, null, function* () {
          yield this._object.dismiss();
        });
      }
    };
    exports2.DialogDispatcher = DialogDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/streamDispatcher.js
var require_streamDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/streamDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.StreamDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _utils = require_utils();
    var StreamDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, stream) {
        super(scope, {
          guid: "stream@" + (0, _utils.createGuid)(),
          stream
        }, "Stream", {});
        this._type_Stream = true;
        this._ended = false;
        stream.once("end", () => this._ended = true);
        stream.once("error", () => this._ended = true);
      }
      read(params) {
        return __async(this, null, function* () {
          const stream = this._object.stream;
          if (this._ended)
            return {
              binary: ""
            };
          if (!stream.readableLength) {
            yield new Promise((fulfill, reject) => {
              stream.once("readable", fulfill);
              stream.once("end", fulfill);
              stream.once("error", reject);
            });
          }
          const buffer = stream.read(Math.min(stream.readableLength, params.size || stream.readableLength));
          return {
            binary: buffer ? buffer.toString("base64") : ""
          };
        });
      }
      close() {
        return __async(this, null, function* () {
          this._object.stream.destroy();
        });
      }
    };
    exports2.StreamDispatcher = StreamDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/artifactDispatcher.js
var require_artifactDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/artifactDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ArtifactDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _streamDispatcher = require_streamDispatcher();
    var _fs = _interopRequireDefault(require("fs"));
    var _fileUtils = require_fileUtils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var ArtifactDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, artifact) {
        super(scope, artifact, "Artifact", {
          absolutePath: artifact.localPath()
        });
        this._type_Artifact = true;
      }
      pathAfterFinished() {
        return __async(this, null, function* () {
          const path = yield this._object.localPathAfterFinished();
          return {
            value: path || void 0
          };
        });
      }
      saveAs(params) {
        return __async(this, null, function* () {
          return yield new Promise((resolve, reject) => {
            this._object.saveAs((localPath, error) => __async(this, null, function* () {
              if (error !== void 0) {
                reject(new Error(error));
                return;
              }
              try {
                yield (0, _fileUtils.mkdirIfNeeded)(params.path);
                yield _fs.default.promises.copyFile(localPath, params.path);
                resolve();
              } catch (e) {
                reject(e);
              }
            }));
          });
        });
      }
      saveAsStream() {
        return __async(this, null, function* () {
          return yield new Promise((resolve, reject) => {
            this._object.saveAs((localPath, error) => __async(this, null, function* () {
              if (error !== void 0) {
                reject(new Error(error));
                return;
              }
              try {
                const readable = _fs.default.createReadStream(localPath);
                const stream = new _streamDispatcher.StreamDispatcher(this._scope, readable);
                resolve({
                  stream
                });
                yield new Promise((resolve2) => {
                  readable.on("close", resolve2);
                  readable.on("end", resolve2);
                  readable.on("error", resolve2);
                });
              } catch (e) {
                reject(e);
              }
            }));
          });
        });
      }
      stream() {
        return __async(this, null, function* () {
          const fileName = yield this._object.localPathAfterFinished();
          if (!fileName)
            return {};
          const readable = _fs.default.createReadStream(fileName);
          return {
            stream: new _streamDispatcher.StreamDispatcher(this._scope, readable)
          };
        });
      }
      failure() {
        return __async(this, null, function* () {
          const error = yield this._object.failureError();
          return {
            error: error || void 0
          };
        });
      }
      cancel() {
        return __async(this, null, function* () {
          yield this._object.cancel();
        });
      }
      delete() {
        return __async(this, null, function* () {
          yield this._object.delete();
          this._dispose();
        });
      }
    };
    exports2.ArtifactDispatcher = ArtifactDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/tracingDispatcher.js
var require_tracingDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/tracingDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TracingDispatcher = void 0;
    var _tracing = require_tracing();
    var _artifactDispatcher = require_artifactDispatcher();
    var _dispatcher = require_dispatcher();
    var TracingDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, tracing) {
        const result = (0, _dispatcher.existingDispatcher)(tracing);
        return result || new TracingDispatcher(scope, tracing);
      }
      constructor(scope, tracing) {
        super(scope, tracing, "Tracing", {}, true);
        this._type_Tracing = true;
        tracing.on(_tracing.Tracing.Events.Dispose, () => this._dispose());
      }
      tracingStart(params) {
        return __async(this, null, function* () {
          yield this._object.start(params);
        });
      }
      tracingStartChunk(params) {
        return __async(this, null, function* () {
          yield this._object.startChunk(params);
        });
      }
      tracingStopChunk(params) {
        return __async(this, null, function* () {
          const {
            artifact,
            sourceEntries
          } = yield this._object.stopChunk(params);
          return {
            artifact: artifact ? new _artifactDispatcher.ArtifactDispatcher(this._scope, artifact) : void 0,
            sourceEntries
          };
        });
      }
      tracingStop(params) {
        return __async(this, null, function* () {
          yield this._object.stop();
        });
      }
    };
    exports2.TracingDispatcher = TracingDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/networkDispatchers.js
var require_networkDispatchers = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/networkDispatchers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WebSocketDispatcher = exports2.RouteDispatcher = exports2.ResponseDispatcher = exports2.RequestDispatcher = exports2.APIRequestContextDispatcher = void 0;
    var _fetch = require_fetch();
    var _network = require_network();
    var _dispatcher = require_dispatcher();
    var _frameDispatcher = require_frameDispatcher();
    var _tracingDispatcher = require_tracingDispatcher();
    var RequestDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, request) {
        const result = (0, _dispatcher.existingDispatcher)(request);
        return result || new RequestDispatcher(scope, request);
      }
      static fromNullable(scope, request) {
        return request ? RequestDispatcher.from(scope, request) : void 0;
      }
      constructor(scope, request) {
        const postData = request.postDataBuffer();
        super(scope, request, "Request", {
          frame: _frameDispatcher.FrameDispatcher.from(scope, request.frame()),
          url: request.url(),
          resourceType: request.resourceType(),
          method: request.method(),
          postData: postData === null ? void 0 : postData.toString("base64"),
          headers: request.headers(),
          isNavigationRequest: request.isNavigationRequest(),
          redirectedFrom: RequestDispatcher.fromNullable(scope, request.redirectedFrom())
        });
        this._type_Request = void 0;
        this._type_Request = true;
      }
      rawRequestHeaders(params) {
        return __async(this, null, function* () {
          return {
            headers: yield this._object.rawRequestHeaders()
          };
        });
      }
      response() {
        return __async(this, null, function* () {
          return {
            response: (0, _dispatcher.lookupNullableDispatcher)(yield this._object.response())
          };
        });
      }
    };
    exports2.RequestDispatcher = RequestDispatcher;
    var ResponseDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, response) {
        const result = (0, _dispatcher.existingDispatcher)(response);
        return result || new ResponseDispatcher(scope, response);
      }
      static fromNullable(scope, response) {
        return response ? ResponseDispatcher.from(scope, response) : void 0;
      }
      constructor(scope, response) {
        super(scope, response, "Response", {
          request: RequestDispatcher.from(scope, response.request()),
          url: response.url(),
          status: response.status(),
          statusText: response.statusText(),
          headers: response.headers(),
          timing: response.timing()
        });
        this._type_Response = true;
      }
      body() {
        return __async(this, null, function* () {
          return {
            binary: (yield this._object.body()).toString("base64")
          };
        });
      }
      securityDetails() {
        return __async(this, null, function* () {
          return {
            value: (yield this._object.securityDetails()) || void 0
          };
        });
      }
      serverAddr() {
        return __async(this, null, function* () {
          return {
            value: (yield this._object.serverAddr()) || void 0
          };
        });
      }
      rawResponseHeaders(params) {
        return __async(this, null, function* () {
          return {
            headers: yield this._object.rawResponseHeaders()
          };
        });
      }
      sizes(params) {
        return __async(this, null, function* () {
          return {
            sizes: yield this._object.sizes()
          };
        });
      }
    };
    exports2.ResponseDispatcher = ResponseDispatcher;
    var RouteDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, route) {
        const result = (0, _dispatcher.existingDispatcher)(route);
        return result || new RouteDispatcher(scope, route);
      }
      constructor(scope, route) {
        super(scope, route, "Route", {
          request: RequestDispatcher.from(scope, route.request())
        });
        this._type_Route = true;
      }
      continue(params, metadata) {
        return __async(this, null, function* () {
          yield this._object.continue({
            url: params.url,
            method: params.method,
            headers: params.headers,
            postData: params.postData !== void 0 ? Buffer.from(params.postData, "base64") : void 0
          });
        });
      }
      fulfill(params) {
        return __async(this, null, function* () {
          yield this._object.fulfill(params);
        });
      }
      abort(params) {
        return __async(this, null, function* () {
          yield this._object.abort(params.errorCode || "failed");
        });
      }
    };
    exports2.RouteDispatcher = RouteDispatcher;
    var WebSocketDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, webSocket) {
        super(scope, webSocket, "WebSocket", {
          url: webSocket.url()
        });
        this._type_EventTarget = true;
        this._type_WebSocket = true;
        webSocket.on(_network.WebSocket.Events.FrameSent, (event) => this._dispatchEvent("frameSent", event));
        webSocket.on(_network.WebSocket.Events.FrameReceived, (event) => this._dispatchEvent("frameReceived", event));
        webSocket.on(_network.WebSocket.Events.SocketError, (error) => this._dispatchEvent("socketError", {
          error
        }));
        webSocket.on(_network.WebSocket.Events.Close, () => this._dispatchEvent("close", {}));
      }
    };
    exports2.WebSocketDispatcher = WebSocketDispatcher;
    var APIRequestContextDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, request) {
        const result = (0, _dispatcher.existingDispatcher)(request);
        return result || new APIRequestContextDispatcher(scope, request);
      }
      static fromNullable(scope, request) {
        return request ? APIRequestContextDispatcher.from(scope, request) : void 0;
      }
      constructor(scope, request) {
        super(scope, request, "APIRequestContext", {
          tracing: _tracingDispatcher.TracingDispatcher.from(scope, request.tracing())
        }, true);
        this._type_APIRequestContext = true;
        request.once(_fetch.APIRequestContext.Events.Dispose, () => {
          if (!this._disposed)
            super._dispose();
        });
      }
      storageState(params) {
        return __async(this, null, function* () {
          return this._object.storageState();
        });
      }
      dispose(params) {
        return __async(this, null, function* () {
          yield this._object.dispose();
        });
      }
      fetch(params, metadata) {
        return __async(this, null, function* () {
          const fetchResponse = yield this._object.fetch(params, metadata);
          return {
            response: {
              url: fetchResponse.url,
              status: fetchResponse.status,
              statusText: fetchResponse.statusText,
              headers: fetchResponse.headers,
              fetchUid: fetchResponse.fetchUid
            }
          };
        });
      }
      fetchResponseBody(params, metadata) {
        return __async(this, null, function* () {
          const buffer = this._object.fetchResponses.get(params.fetchUid);
          return {
            binary: buffer ? buffer.toString("base64") : void 0
          };
        });
      }
      fetchLog(params, metadata) {
        return __async(this, null, function* () {
          const log = this._object.fetchLog.get(params.fetchUid) || [];
          return {
            log
          };
        });
      }
      disposeAPIResponse(params, metadata) {
        return __async(this, null, function* () {
          this._object.disposeResponse(params.fetchUid);
        });
      }
    };
    exports2.APIRequestContextDispatcher = APIRequestContextDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/frameDispatcher.js
var require_frameDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/frameDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FrameDispatcher = void 0;
    var _frames = require_frames();
    var _dispatcher = require_dispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var _jsHandleDispatcher = require_jsHandleDispatcher();
    var _networkDispatchers = require_networkDispatchers();
    var FrameDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, frame) {
        const result = (0, _dispatcher.existingDispatcher)(frame);
        return result || new FrameDispatcher(scope, frame);
      }
      static fromNullable(scope, frame) {
        if (!frame)
          return;
        return FrameDispatcher.from(scope, frame);
      }
      constructor(scope, frame) {
        super(scope, frame, "Frame", {
          url: frame.url(),
          name: frame.name(),
          parentFrame: FrameDispatcher.fromNullable(scope, frame.parentFrame()),
          loadStates: Array.from(frame._subtreeLifecycleEvents)
        });
        this._type_Frame = true;
        this._frame = void 0;
        this._frame = frame;
        frame.on(_frames.Frame.Events.AddLifecycle, (lifecycleEvent) => {
          this._dispatchEvent("loadstate", {
            add: lifecycleEvent
          });
        });
        frame.on(_frames.Frame.Events.RemoveLifecycle, (lifecycleEvent) => {
          this._dispatchEvent("loadstate", {
            remove: lifecycleEvent
          });
        });
        frame.on(_frames.Frame.Events.Navigation, (event) => {
          const params = {
            url: event.url,
            name: event.name,
            error: event.error ? event.error.message : void 0
          };
          if (event.newDocument)
            params.newDocument = {
              request: _networkDispatchers.RequestDispatcher.fromNullable(this._scope, event.newDocument.request || null)
            };
          this._dispatchEvent("navigated", params);
        });
      }
      goto(params, metadata) {
        return __async(this, null, function* () {
          return {
            response: (0, _dispatcher.lookupNullableDispatcher)(yield this._frame.goto(metadata, params.url, params))
          };
        });
      }
      frameElement() {
        return __async(this, null, function* () {
          return {
            element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, yield this._frame.frameElement())
          };
        });
      }
      evaluateExpression(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield this._frame.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg), "main"))
          };
        });
      }
      evaluateExpressionHandle(params, metadata) {
        return __async(this, null, function* () {
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, yield this._frame.evaluateExpressionHandleAndWaitForSignals(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg), "main"))
          };
        });
      }
      waitForSelector(params, metadata) {
        return __async(this, null, function* () {
          return {
            element: _elementHandlerDispatcher.ElementHandleDispatcher.fromNullable(this._scope, yield this._frame.waitForSelector(metadata, params.selector, params))
          };
        });
      }
      dispatchEvent(params, metadata) {
        return __async(this, null, function* () {
          return this._frame.dispatchEvent(metadata, params.selector, params.type, (0, _jsHandleDispatcher.parseArgument)(params.eventInit), params);
        });
      }
      evalOnSelector(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield this._frame.evalOnSelectorAndWaitForSignals(params.selector, !!params.strict, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      evalOnSelectorAll(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield this._frame.evalOnSelectorAllAndWaitForSignals(params.selector, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      querySelector(params, metadata) {
        return __async(this, null, function* () {
          return {
            element: _elementHandlerDispatcher.ElementHandleDispatcher.fromNullable(this._scope, yield this._frame.querySelector(params.selector, params))
          };
        });
      }
      querySelectorAll(params, metadata) {
        return __async(this, null, function* () {
          const elements = yield this._frame.querySelectorAll(params.selector);
          return {
            elements: elements.map((e) => _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, e))
          };
        });
      }
      queryCount(params) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.queryCount(params.selector)
          };
        });
      }
      content() {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.content()
          };
        });
      }
      setContent(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.setContent(metadata, params.html, params);
        });
      }
      addScriptTag(params, metadata) {
        return __async(this, null, function* () {
          return {
            element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, yield this._frame.addScriptTag(params))
          };
        });
      }
      addStyleTag(params, metadata) {
        return __async(this, null, function* () {
          return {
            element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, yield this._frame.addStyleTag(params))
          };
        });
      }
      click(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.click(metadata, params.selector, params);
        });
      }
      dblclick(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.dblclick(metadata, params.selector, params);
        });
      }
      dragAndDrop(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.dragAndDrop(metadata, params.source, params.target, params);
        });
      }
      tap(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.tap(metadata, params.selector, params);
        });
      }
      fill(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.fill(metadata, params.selector, params.value, params);
        });
      }
      focus(params, metadata) {
        return __async(this, null, function* () {
          yield this._frame.focus(metadata, params.selector, params);
        });
      }
      textContent(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._frame.textContent(metadata, params.selector, params);
          return {
            value: value === null ? void 0 : value
          };
        });
      }
      innerText(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.innerText(metadata, params.selector, params)
          };
        });
      }
      innerHTML(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.innerHTML(metadata, params.selector, params)
          };
        });
      }
      getAttribute(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._frame.getAttribute(metadata, params.selector, params.name, params);
          return {
            value: value === null ? void 0 : value
          };
        });
      }
      inputValue(params, metadata) {
        return __async(this, null, function* () {
          const value = yield this._frame.inputValue(metadata, params.selector, params);
          return {
            value
          };
        });
      }
      isChecked(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.isChecked(metadata, params.selector, params)
          };
        });
      }
      isDisabled(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.isDisabled(metadata, params.selector, params)
          };
        });
      }
      isEditable(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.isEditable(metadata, params.selector, params)
          };
        });
      }
      isEnabled(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.isEnabled(metadata, params.selector, params)
          };
        });
      }
      isHidden(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.isHidden(metadata, params.selector, params)
          };
        });
      }
      isVisible(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.isVisible(metadata, params.selector, params)
          };
        });
      }
      hover(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.hover(metadata, params.selector, params);
        });
      }
      selectOption(params, metadata) {
        return __async(this, null, function* () {
          const elements = (params.elements || []).map((e) => e._elementHandle);
          return {
            values: yield this._frame.selectOption(metadata, params.selector, elements, params.options || [], params)
          };
        });
      }
      setInputFiles(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.setInputFiles(metadata, params.selector, {
            files: params.files
          }, params);
        });
      }
      setInputFilePaths(params, metadata) {
        return __async(this, null, function* () {
          let {
            localPaths
          } = params;
          if (!localPaths) {
            if (!params.streams)
              throw new Error("Neither localPaths nor streams is specified");
            localPaths = params.streams.map((c) => c.path());
          }
          return yield this._frame.setInputFiles(metadata, params.selector, {
            localPaths
          }, params);
        });
      }
      type(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.type(metadata, params.selector, params.text, params);
        });
      }
      press(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.press(metadata, params.selector, params.key, params);
        });
      }
      check(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.check(metadata, params.selector, params);
        });
      }
      uncheck(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.uncheck(metadata, params.selector, params);
        });
      }
      waitForTimeout(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.waitForTimeout(metadata, params.timeout);
        });
      }
      waitForFunction(params, metadata) {
        return __async(this, null, function* () {
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, yield this._frame._waitForFunctionExpression(metadata, params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg), params))
          };
        });
      }
      title(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: yield this._frame.title()
          };
        });
      }
      highlight(params, metadata) {
        return __async(this, null, function* () {
          return yield this._frame.highlight(params.selector);
        });
      }
      expect(params, metadata) {
        return __async(this, null, function* () {
          const expectedValue = params.expectedValue ? (0, _jsHandleDispatcher.parseArgument)(params.expectedValue) : void 0;
          const result = yield this._frame.expect(metadata, params.selector, __spreadProps(__spreadValues({}, params), {
            expectedValue
          }));
          if (result.received !== void 0)
            result.received = (0, _jsHandleDispatcher.serializeResult)(result.received);
          if (result.matches === params.isNot)
            metadata.error = {
              error: {
                name: "Expect",
                message: "Expect failed"
              }
            };
          return result;
        });
      }
    };
    exports2.FrameDispatcher = FrameDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/pageDispatcher.js
var require_pageDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/pageDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WorkerDispatcher = exports2.PageDispatcher = exports2.BindingCallDispatcher = void 0;
    var _page = require_page();
    var _dispatcher = require_dispatcher();
    var _serializers = require_serializers();
    var _consoleMessageDispatcher = require_consoleMessageDispatcher();
    var _dialogDispatcher = require_dialogDispatcher();
    var _frameDispatcher = require_frameDispatcher();
    var _networkDispatchers = require_networkDispatchers();
    var _jsHandleDispatcher = require_jsHandleDispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var _artifactDispatcher = require_artifactDispatcher();
    var _utils = require_utils();
    var PageDispatcher = class extends _dispatcher.Dispatcher {
      static fromNullable(scope, page) {
        if (!page)
          return void 0;
        const result = (0, _dispatcher.existingDispatcher)(page);
        return result || new PageDispatcher(scope, page);
      }
      constructor(scope, page) {
        super(scope, page, "Page", {
          mainFrame: _frameDispatcher.FrameDispatcher.from(scope, page.mainFrame()),
          viewportSize: page.viewportSize() || void 0,
          isClosed: page.isClosed(),
          opener: PageDispatcher.fromNullable(scope, page.opener())
        }, true);
        this._type_EventTarget = true;
        this._type_Page = true;
        this._page = void 0;
        this._page = page;
        page.on(_page.Page.Events.Close, () => {
          this._dispatchEvent("close");
          this._dispose();
        });
        page.on(_page.Page.Events.Console, (message) => this._dispatchEvent("console", {
          message: new _consoleMessageDispatcher.ConsoleMessageDispatcher(this._scope, message)
        }));
        page.on(_page.Page.Events.Crash, () => this._dispatchEvent("crash"));
        page.on(_page.Page.Events.DOMContentLoaded, () => this._dispatchEvent("domcontentloaded"));
        page.on(_page.Page.Events.Dialog, (dialog) => this._dispatchEvent("dialog", {
          dialog: new _dialogDispatcher.DialogDispatcher(this._scope, dialog)
        }));
        page.on(_page.Page.Events.Download, (download) => {
          this._dispatchEvent("download", {
            url: download.url,
            suggestedFilename: download.suggestedFilename(),
            artifact: new _artifactDispatcher.ArtifactDispatcher(scope, download.artifact)
          });
        });
        this._page.on(_page.Page.Events.FileChooser, (fileChooser) => this._dispatchEvent("fileChooser", {
          element: _elementHandlerDispatcher.ElementHandleDispatcher.from(this._scope, fileChooser.element()),
          isMultiple: fileChooser.isMultiple()
        }));
        page.on(_page.Page.Events.FrameAttached, (frame) => this._onFrameAttached(frame));
        page.on(_page.Page.Events.FrameDetached, (frame) => this._onFrameDetached(frame));
        page.on(_page.Page.Events.Load, () => this._dispatchEvent("load"));
        page.on(_page.Page.Events.PageError, (error) => this._dispatchEvent("pageError", {
          error: (0, _serializers.serializeError)(error)
        }));
        page.on(_page.Page.Events.WebSocket, (webSocket) => this._dispatchEvent("webSocket", {
          webSocket: new _networkDispatchers.WebSocketDispatcher(this._scope, webSocket)
        }));
        page.on(_page.Page.Events.Worker, (worker) => this._dispatchEvent("worker", {
          worker: new WorkerDispatcher(this._scope, worker)
        }));
        page.on(_page.Page.Events.Video, (artifact) => this._dispatchEvent("video", {
          artifact: (0, _dispatcher.existingDispatcher)(artifact)
        }));
        if (page._video)
          this._dispatchEvent("video", {
            artifact: (0, _dispatcher.existingDispatcher)(page._video)
          });
        const frames = page._frameManager.frames();
        for (let i = 1; i < frames.length; i++)
          this._onFrameAttached(frames[i]);
      }
      page() {
        return this._page;
      }
      setDefaultNavigationTimeoutNoReply(params, metadata) {
        return __async(this, null, function* () {
          this._page.setDefaultNavigationTimeout(params.timeout);
        });
      }
      setDefaultTimeoutNoReply(params, metadata) {
        return __async(this, null, function* () {
          this._page.setDefaultTimeout(params.timeout);
        });
      }
      exposeBinding(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.exposeBinding(params.name, !!params.needsHandle, (source, ...args) => {
            const binding = new BindingCallDispatcher(this._scope, params.name, !!params.needsHandle, source, args);
            this._dispatchEvent("bindingCall", {
              binding
            });
            return binding.promise();
          });
        });
      }
      removeExposedBindings() {
        return __async(this, null, function* () {
          yield this._page.removeExposedBindings();
        });
      }
      setExtraHTTPHeaders(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.setExtraHTTPHeaders(params.headers);
        });
      }
      reload(params, metadata) {
        return __async(this, null, function* () {
          return {
            response: (0, _dispatcher.lookupNullableDispatcher)(yield this._page.reload(metadata, params))
          };
        });
      }
      goBack(params, metadata) {
        return __async(this, null, function* () {
          return {
            response: (0, _dispatcher.lookupNullableDispatcher)(yield this._page.goBack(metadata, params))
          };
        });
      }
      goForward(params, metadata) {
        return __async(this, null, function* () {
          return {
            response: (0, _dispatcher.lookupNullableDispatcher)(yield this._page.goForward(metadata, params))
          };
        });
      }
      emulateMedia(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.emulateMedia({
            media: params.media === "null" ? null : params.media,
            colorScheme: params.colorScheme === "null" ? null : params.colorScheme,
            reducedMotion: params.reducedMotion === "null" ? null : params.reducedMotion,
            forcedColors: params.forcedColors === "null" ? null : params.forcedColors
          });
        });
      }
      setViewportSize(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.setViewportSize(params.viewportSize);
        });
      }
      addInitScript(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.addInitScript(params.source);
        });
      }
      removeInitScripts() {
        return __async(this, null, function* () {
          yield this._page.removeInitScripts();
        });
      }
      setNetworkInterceptionEnabled(params, metadata) {
        return __async(this, null, function* () {
          if (!params.enabled) {
            yield this._page.setClientRequestInterceptor(void 0);
            return;
          }
          yield this._page.setClientRequestInterceptor((route, request) => {
            this._dispatchEvent("route", {
              route: _networkDispatchers.RouteDispatcher.from(this._scope, route),
              request: _networkDispatchers.RequestDispatcher.from(this._scope, request)
            });
          });
        });
      }
      expectScreenshot(params, metadata) {
        return __async(this, null, function* () {
          var _params$screenshotOpt, _result$diff, _result$actual, _result$previous;
          const mask = (((_params$screenshotOpt = params.screenshotOptions) === null || _params$screenshotOpt === void 0 ? void 0 : _params$screenshotOpt.mask) || []).map(({
            frame,
            selector
          }) => ({
            frame: frame._object,
            selector
          }));
          const locator = params.locator ? {
            frame: params.locator.frame._object,
            selector: params.locator.selector
          } : void 0;
          const expected = params.expected ? Buffer.from(params.expected, "base64") : void 0;
          const result = yield this._page.expectScreenshot(metadata, __spreadProps(__spreadValues({}, params), {
            expected,
            locator,
            screenshotOptions: __spreadProps(__spreadValues({}, params.screenshotOptions), {
              mask
            })
          }));
          return {
            diff: (_result$diff = result.diff) === null || _result$diff === void 0 ? void 0 : _result$diff.toString("base64"),
            errorMessage: result.errorMessage,
            actual: (_result$actual = result.actual) === null || _result$actual === void 0 ? void 0 : _result$actual.toString("base64"),
            previous: (_result$previous = result.previous) === null || _result$previous === void 0 ? void 0 : _result$previous.toString("base64"),
            log: result.log
          };
        });
      }
      screenshot(params, metadata) {
        return __async(this, null, function* () {
          const mask = (params.mask || []).map(({
            frame,
            selector
          }) => ({
            frame: frame._object,
            selector
          }));
          return {
            binary: (yield this._page.screenshot(metadata, __spreadProps(__spreadValues({}, params), {
              mask
            }))).toString("base64")
          };
        });
      }
      close(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.close(metadata, params);
        });
      }
      setFileChooserInterceptedNoReply(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.setFileChooserIntercepted(params.intercepted);
        });
      }
      keyboardDown(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.keyboard.down(params.key);
        });
      }
      keyboardUp(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.keyboard.up(params.key);
        });
      }
      keyboardInsertText(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.keyboard.insertText(params.text);
        });
      }
      keyboardType(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.keyboard.type(params.text, params);
        });
      }
      keyboardPress(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.keyboard.press(params.key, params);
        });
      }
      mouseMove(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.mouse.move(params.x, params.y, params);
        });
      }
      mouseDown(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.mouse.down(params);
        });
      }
      mouseUp(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.mouse.up(params);
        });
      }
      mouseClick(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.mouse.click(params.x, params.y, params);
        });
      }
      mouseWheel(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.mouse.wheel(params.deltaX, params.deltaY);
        });
      }
      touchscreenTap(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.touchscreen.tap(params.x, params.y);
        });
      }
      accessibilitySnapshot(params, metadata) {
        return __async(this, null, function* () {
          const rootAXNode = yield this._page.accessibility.snapshot({
            interestingOnly: params.interestingOnly,
            root: params.root ? params.root._elementHandle : void 0
          });
          return {
            rootAXNode: rootAXNode || void 0
          };
        });
      }
      pdf(params, metadata) {
        return __async(this, null, function* () {
          if (!this._page.pdf)
            throw new Error("PDF generation is only supported for Headless Chromium");
          const buffer = yield this._page.pdf(params);
          return {
            pdf: buffer.toString("base64")
          };
        });
      }
      bringToFront(params, metadata) {
        return __async(this, null, function* () {
          yield this._page.bringToFront();
        });
      }
      startJSCoverage(params, metadata) {
        return __async(this, null, function* () {
          const coverage = this._page.coverage;
          yield coverage.startJSCoverage(params);
        });
      }
      stopJSCoverage(params, metadata) {
        return __async(this, null, function* () {
          const coverage = this._page.coverage;
          return {
            entries: yield coverage.stopJSCoverage()
          };
        });
      }
      startCSSCoverage(params, metadata) {
        return __async(this, null, function* () {
          const coverage = this._page.coverage;
          yield coverage.startCSSCoverage(params);
        });
      }
      stopCSSCoverage(params, metadata) {
        return __async(this, null, function* () {
          const coverage = this._page.coverage;
          return {
            entries: yield coverage.stopCSSCoverage()
          };
        });
      }
      _onFrameAttached(frame) {
        this._dispatchEvent("frameAttached", {
          frame: _frameDispatcher.FrameDispatcher.from(this._scope, frame)
        });
      }
      _onFrameDetached(frame) {
        this._dispatchEvent("frameDetached", {
          frame: (0, _dispatcher.lookupDispatcher)(frame)
        });
      }
    };
    exports2.PageDispatcher = PageDispatcher;
    var WorkerDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, worker) {
        super(scope, worker, "Worker", {
          url: worker.url()
        });
        this._type_Worker = true;
        worker.on(_page.Worker.Events.Close, () => this._dispatchEvent("close"));
      }
      evaluateExpression(params, metadata) {
        return __async(this, null, function* () {
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield this._object.evaluateExpression(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      evaluateExpressionHandle(params, metadata) {
        return __async(this, null, function* () {
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, yield this._object.evaluateExpressionHandle(params.expression, params.isFunction, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
    };
    exports2.WorkerDispatcher = WorkerDispatcher;
    var BindingCallDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, name, needsHandle, source, args) {
        super(scope, {
          guid: "bindingCall@" + (0, _utils.createGuid)()
        }, "BindingCall", {
          frame: (0, _dispatcher.lookupDispatcher)(source.frame),
          name,
          args: needsHandle ? void 0 : args.map(_jsHandleDispatcher.serializeResult),
          handle: needsHandle ? _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(scope, args[0]) : void 0
        });
        this._type_BindingCall = true;
        this._resolve = void 0;
        this._reject = void 0;
        this._promise = void 0;
        this._promise = new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
      }
      promise() {
        return this._promise;
      }
      resolve(params, metadata) {
        return __async(this, null, function* () {
          this._resolve((0, _jsHandleDispatcher.parseArgument)(params.result));
        });
      }
      reject(params, metadata) {
        return __async(this, null, function* () {
          this._reject((0, _serializers.parseError)(params.error));
        });
      }
    };
    exports2.BindingCallDispatcher = BindingCallDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/cdpSessionDispatcher.js
var require_cdpSessionDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/cdpSessionDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CDPSessionDispatcher = void 0;
    var _crConnection = require_crConnection();
    var _dispatcher = require_dispatcher();
    var CDPSessionDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, crSession) {
        super(scope, crSession, "CDPSession", {}, true);
        this._type_CDPSession = true;
        crSession._eventListener = (method, params) => {
          this._dispatchEvent("event", {
            method,
            params
          });
        };
        crSession.on(_crConnection.CRSessionEvents.Disconnected, () => this._dispose());
      }
      send(params) {
        return __async(this, null, function* () {
          return {
            result: yield this._object.send(params.method, params.params)
          };
        });
      }
      detach() {
        return __async(this, null, function* () {
          return this._object.detach();
        });
      }
    };
    exports2.CDPSessionDispatcher = CDPSessionDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/writableStreamDispatcher.js
var require_writableStreamDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/writableStreamDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WritableStreamDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _utils = require_utils();
    var WritableStreamDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, stream) {
        super(scope, {
          guid: "writableStream@" + (0, _utils.createGuid)(),
          stream
        }, "WritableStream", {});
        this._type_WritableStream = true;
      }
      write(params) {
        return __async(this, null, function* () {
          const stream = this._object.stream;
          yield new Promise((fulfill, reject) => {
            stream.write(Buffer.from(params.binary, "base64"), (error) => {
              if (error)
                reject(error);
              else
                fulfill();
            });
          });
        });
      }
      close() {
        return __async(this, null, function* () {
          const stream = this._object.stream;
          yield new Promise((fulfill) => stream.end(fulfill));
        });
      }
      path() {
        return this._object.stream.path;
      }
    };
    exports2.WritableStreamDispatcher = WritableStreamDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/browserContextDispatcher.js
var require_browserContextDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/browserContextDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BrowserContextDispatcher = void 0;
    var _browserContext = require_browserContext();
    var _dispatcher = require_dispatcher();
    var _pageDispatcher = require_pageDispatcher();
    var _networkDispatchers = require_networkDispatchers();
    var _crBrowser = require_crBrowser();
    var _cdpSessionDispatcher = require_cdpSessionDispatcher();
    var _recorder = require_recorder();
    var _artifactDispatcher = require_artifactDispatcher();
    var _tracingDispatcher = require_tracingDispatcher();
    var fs = _interopRequireWildcard(require("fs"));
    var path = _interopRequireWildcard(require("path"));
    var _utils = require_utils();
    var _writableStreamDispatcher = require_writableStreamDispatcher();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var BrowserContextDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, context) {
        super(scope, context, "BrowserContext", {
          isChromium: context._browser.options.isChromium,
          APIRequestContext: _networkDispatchers.APIRequestContextDispatcher.from(scope, context.fetchRequest),
          tracing: _tracingDispatcher.TracingDispatcher.from(scope, context.tracing)
        }, true);
        this._type_EventTarget = true;
        this._type_BrowserContext = true;
        this._context = void 0;
        this._context = context;
        const onVideo = (artifact) => {
          const artifactDispatcher = new _artifactDispatcher.ArtifactDispatcher(scope, artifact);
          this._dispatchEvent("video", {
            artifact: artifactDispatcher
          });
        };
        context.on(_browserContext.BrowserContext.Events.VideoStarted, onVideo);
        for (const video of context._browser._idToVideo.values()) {
          if (video.context === context)
            onVideo(video.artifact);
        }
        for (const page of context.pages())
          this._dispatchEvent("page", {
            page: new _pageDispatcher.PageDispatcher(this._scope, page)
          });
        context.on(_browserContext.BrowserContext.Events.Page, (page) => this._dispatchEvent("page", {
          page: new _pageDispatcher.PageDispatcher(this._scope, page)
        }));
        context.on(_browserContext.BrowserContext.Events.Close, () => {
          this._dispatchEvent("close");
          this._dispose();
        });
        if (context._browser.options.name === "chromium") {
          for (const page of context.backgroundPages())
            this._dispatchEvent("backgroundPage", {
              page: new _pageDispatcher.PageDispatcher(this._scope, page)
            });
          context.on(_crBrowser.CRBrowserContext.CREvents.BackgroundPage, (page) => this._dispatchEvent("backgroundPage", {
            page: new _pageDispatcher.PageDispatcher(this._scope, page)
          }));
          for (const serviceWorker of context.serviceWorkers())
            this._dispatchEvent("serviceWorker", {
              worker: new _pageDispatcher.WorkerDispatcher(this._scope, serviceWorker)
            });
          context.on(_crBrowser.CRBrowserContext.CREvents.ServiceWorker, (serviceWorker) => this._dispatchEvent("serviceWorker", {
            worker: new _pageDispatcher.WorkerDispatcher(this._scope, serviceWorker)
          }));
        }
        context.on(_browserContext.BrowserContext.Events.Request, (request) => {
          return this._dispatchEvent("request", {
            request: _networkDispatchers.RequestDispatcher.from(this._scope, request),
            page: _pageDispatcher.PageDispatcher.fromNullable(this._scope, request.frame()._page.initializedOrUndefined())
          });
        });
        context.on(_browserContext.BrowserContext.Events.Response, (response) => this._dispatchEvent("response", {
          response: _networkDispatchers.ResponseDispatcher.from(this._scope, response),
          page: _pageDispatcher.PageDispatcher.fromNullable(this._scope, response.frame()._page.initializedOrUndefined())
        }));
        context.on(_browserContext.BrowserContext.Events.RequestFailed, (request) => this._dispatchEvent("requestFailed", {
          request: _networkDispatchers.RequestDispatcher.from(this._scope, request),
          failureText: request._failureText || void 0,
          responseEndTiming: request._responseEndTiming,
          page: _pageDispatcher.PageDispatcher.fromNullable(this._scope, request.frame()._page.initializedOrUndefined())
        }));
        context.on(_browserContext.BrowserContext.Events.RequestFinished, ({
          request,
          response
        }) => this._dispatchEvent("requestFinished", {
          request: _networkDispatchers.RequestDispatcher.from(scope, request),
          response: _networkDispatchers.ResponseDispatcher.fromNullable(scope, response),
          responseEndTiming: request._responseEndTiming,
          page: _pageDispatcher.PageDispatcher.fromNullable(this._scope, request.frame()._page.initializedOrUndefined())
        }));
      }
      createTempFile(params, metadata) {
        return __async(this, null, function* () {
          const dir = this._context._browser.options.artifactsDir;
          const tmpDir = path.join(dir, "upload-" + (0, _utils.createGuid)());
          yield fs.promises.mkdir(tmpDir);
          this._context._tempDirs.push(tmpDir);
          const file = fs.createWriteStream(path.join(tmpDir, params.name));
          return {
            writableStream: new _writableStreamDispatcher.WritableStreamDispatcher(this._scope, file)
          };
        });
      }
      setDefaultNavigationTimeoutNoReply(params) {
        return __async(this, null, function* () {
          this._context.setDefaultNavigationTimeout(params.timeout);
        });
      }
      setDefaultTimeoutNoReply(params) {
        return __async(this, null, function* () {
          this._context.setDefaultTimeout(params.timeout);
        });
      }
      exposeBinding(params) {
        return __async(this, null, function* () {
          yield this._context.exposeBinding(params.name, !!params.needsHandle, (source, ...args) => {
            const binding = new _pageDispatcher.BindingCallDispatcher(this._scope, params.name, !!params.needsHandle, source, args);
            this._dispatchEvent("bindingCall", {
              binding
            });
            return binding.promise();
          });
        });
      }
      removeExposedBindings() {
        return __async(this, null, function* () {
          yield this._context.removeExposedBindings();
        });
      }
      newPage(params, metadata) {
        return __async(this, null, function* () {
          return {
            page: (0, _dispatcher.lookupDispatcher)(yield this._context.newPage(metadata))
          };
        });
      }
      cookies(params) {
        return __async(this, null, function* () {
          return {
            cookies: yield this._context.cookies(params.urls)
          };
        });
      }
      addCookies(params) {
        return __async(this, null, function* () {
          yield this._context.addCookies(params.cookies);
        });
      }
      clearCookies() {
        return __async(this, null, function* () {
          yield this._context.clearCookies();
        });
      }
      grantPermissions(params) {
        return __async(this, null, function* () {
          yield this._context.grantPermissions(params.permissions, params.origin);
        });
      }
      clearPermissions() {
        return __async(this, null, function* () {
          yield this._context.clearPermissions();
        });
      }
      setGeolocation(params) {
        return __async(this, null, function* () {
          yield this._context.setGeolocation(params.geolocation);
        });
      }
      setExtraHTTPHeaders(params) {
        return __async(this, null, function* () {
          yield this._context.setExtraHTTPHeaders(params.headers);
        });
      }
      setOffline(params) {
        return __async(this, null, function* () {
          yield this._context.setOffline(params.offline);
        });
      }
      setHTTPCredentials(params) {
        return __async(this, null, function* () {
          yield this._context.setHTTPCredentials(params.httpCredentials);
        });
      }
      addInitScript(params) {
        return __async(this, null, function* () {
          yield this._context.addInitScript(params.source);
        });
      }
      removeInitScripts() {
        return __async(this, null, function* () {
          yield this._context.removeInitScripts();
        });
      }
      setNetworkInterceptionEnabled(params) {
        return __async(this, null, function* () {
          if (!params.enabled) {
            yield this._context.setRequestInterceptor(void 0);
            return;
          }
          yield this._context.setRequestInterceptor((route, request) => {
            this._dispatchEvent("route", {
              route: _networkDispatchers.RouteDispatcher.from(this._scope, route),
              request: _networkDispatchers.RequestDispatcher.from(this._scope, request)
            });
          });
        });
      }
      storageState(params, metadata) {
        return __async(this, null, function* () {
          return yield this._context.storageState();
        });
      }
      close(params, metadata) {
        return __async(this, null, function* () {
          yield this._context.close(metadata);
        });
      }
      recorderSupplementEnable(params) {
        return __async(this, null, function* () {
          yield _recorder.Recorder.show(this._context, params);
        });
      }
      pause(params, metadata) {
        return __async(this, null, function* () {
        });
      }
      newCDPSession(params) {
        return __async(this, null, function* () {
          if (!this._object._browser.options.isChromium)
            throw new Error(`CDP session is only available in Chromium`);
          if (!params.page && !params.frame || params.page && params.frame)
            throw new Error(`CDP session must be initiated with either Page or Frame, not none or both`);
          const crBrowserContext = this._object;
          return {
            session: new _cdpSessionDispatcher.CDPSessionDispatcher(this._scope, yield crBrowserContext.newCDPSession((params.page ? params.page : params.frame)._object))
          };
        });
      }
      harExport(params) {
        return __async(this, null, function* () {
          var _this$_context$_harRe;
          const artifact = yield (_this$_context$_harRe = this._context._harRecorder) === null || _this$_context$_harRe === void 0 ? void 0 : _this$_context$_harRe.export();
          if (!artifact)
            throw new Error("No HAR artifact. Ensure record.harPath is set.");
          return {
            artifact: new _artifactDispatcher.ArtifactDispatcher(this._scope, artifact)
          };
        });
      }
    };
    exports2.BrowserContextDispatcher = BrowserContextDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/androidDispatcher.js
var require_androidDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/androidDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AndroidSocketDispatcher = exports2.AndroidDispatcher = exports2.AndroidDeviceDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _android = require_android();
    var _browserContextDispatcher = require_browserContextDispatcher();
    var AndroidDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, android) {
        super(scope, android, "Android", {}, true);
        this._type_Android = true;
      }
      devices(params) {
        return __async(this, null, function* () {
          const devices = yield this._object.devices(params);
          return {
            devices: devices.map((d) => AndroidDeviceDispatcher.from(this._scope, d))
          };
        });
      }
      setDefaultTimeoutNoReply(params) {
        return __async(this, null, function* () {
          this._object.setDefaultTimeout(params.timeout);
        });
      }
    };
    exports2.AndroidDispatcher = AndroidDispatcher;
    var AndroidDeviceDispatcher = class extends _dispatcher.Dispatcher {
      static from(scope, device) {
        const result = (0, _dispatcher.existingDispatcher)(device);
        return result || new AndroidDeviceDispatcher(scope, device);
      }
      constructor(scope, device) {
        super(scope, device, "AndroidDevice", {
          model: device.model,
          serial: device.serial
        }, true);
        this._type_EventTarget = true;
        this._type_AndroidDevice = true;
        for (const webView of device.webViews())
          this._dispatchEvent("webViewAdded", {
            webView
          });
        device.on(_android.AndroidDevice.Events.WebViewAdded, (webView) => this._dispatchEvent("webViewAdded", {
          webView
        }));
        device.on(_android.AndroidDevice.Events.WebViewRemoved, (pid) => this._dispatchEvent("webViewRemoved", {
          pid
        }));
      }
      wait(params) {
        return __async(this, null, function* () {
          yield this._object.send("wait", params);
        });
      }
      fill(params) {
        return __async(this, null, function* () {
          yield this._object.send("click", {
            selector: params.selector
          });
          yield this._object.send("fill", params);
        });
      }
      tap(params) {
        return __async(this, null, function* () {
          yield this._object.send("click", params);
        });
      }
      drag(params) {
        return __async(this, null, function* () {
          yield this._object.send("drag", params);
        });
      }
      fling(params) {
        return __async(this, null, function* () {
          yield this._object.send("fling", params);
        });
      }
      longTap(params) {
        return __async(this, null, function* () {
          yield this._object.send("longClick", params);
        });
      }
      pinchClose(params) {
        return __async(this, null, function* () {
          yield this._object.send("pinchClose", params);
        });
      }
      pinchOpen(params) {
        return __async(this, null, function* () {
          yield this._object.send("pinchOpen", params);
        });
      }
      scroll(params) {
        return __async(this, null, function* () {
          yield this._object.send("scroll", params);
        });
      }
      swipe(params) {
        return __async(this, null, function* () {
          yield this._object.send("swipe", params);
        });
      }
      info(params) {
        return __async(this, null, function* () {
          return {
            info: yield this._object.send("info", params)
          };
        });
      }
      inputType(params) {
        return __async(this, null, function* () {
          const text = params.text;
          const keyCodes = [];
          for (let i = 0; i < text.length; ++i) {
            const code = keyMap.get(text[i].toUpperCase());
            if (code === void 0)
              throw new Error("No mapping for " + text[i] + " found");
            keyCodes.push(code);
          }
          yield Promise.all(keyCodes.map((keyCode) => this._object.send("inputPress", {
            keyCode
          })));
        });
      }
      inputPress(params) {
        return __async(this, null, function* () {
          if (!keyMap.has(params.key))
            throw new Error("Unknown key: " + params.key);
          yield this._object.send("inputPress", {
            keyCode: keyMap.get(params.key)
          });
        });
      }
      inputTap(params) {
        return __async(this, null, function* () {
          yield this._object.send("inputClick", params);
        });
      }
      inputSwipe(params) {
        return __async(this, null, function* () {
          yield this._object.send("inputSwipe", params);
        });
      }
      inputDrag(params) {
        return __async(this, null, function* () {
          yield this._object.send("inputDrag", params);
        });
      }
      screenshot(params) {
        return __async(this, null, function* () {
          return {
            binary: (yield this._object.screenshot()).toString("base64")
          };
        });
      }
      shell(params) {
        return __async(this, null, function* () {
          return {
            result: (yield this._object.shell(params.command)).toString("base64")
          };
        });
      }
      open(params, metadata) {
        return __async(this, null, function* () {
          const socket = yield this._object.open(params.command);
          return {
            socket: new AndroidSocketDispatcher(this._scope, socket)
          };
        });
      }
      installApk(params) {
        return __async(this, null, function* () {
          yield this._object.installApk(Buffer.from(params.file, "base64"), {
            args: params.args
          });
        });
      }
      push(params) {
        return __async(this, null, function* () {
          yield this._object.push(Buffer.from(params.file, "base64"), params.path, params.mode);
        });
      }
      launchBrowser(params) {
        return __async(this, null, function* () {
          const context = yield this._object.launchBrowser(params.pkg, params);
          return {
            context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, context)
          };
        });
      }
      close(params) {
        return __async(this, null, function* () {
          yield this._object.close();
        });
      }
      setDefaultTimeoutNoReply(params) {
        return __async(this, null, function* () {
          this._object.setDefaultTimeout(params.timeout);
        });
      }
      connectToWebView(params) {
        return __async(this, null, function* () {
          return {
            context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, yield this._object.connectToWebView(params.pid))
          };
        });
      }
    };
    exports2.AndroidDeviceDispatcher = AndroidDeviceDispatcher;
    var AndroidSocketDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, socket) {
        super(scope, socket, "AndroidSocket", {}, true);
        this._type_AndroidSocket = true;
        socket.on("data", (data) => this._dispatchEvent("data", {
          data: data.toString("base64")
        }));
        socket.on("close", () => {
          this._dispatchEvent("close");
          this._dispose();
        });
      }
      write(params, metadata) {
        return __async(this, null, function* () {
          yield this._object.write(Buffer.from(params.data, "base64"));
        });
      }
      close(params, metadata) {
        return __async(this, null, function* () {
          this._object.close();
        });
      }
    };
    exports2.AndroidSocketDispatcher = AndroidSocketDispatcher;
    var keyMap = /* @__PURE__ */ new Map([["Unknown", 0], ["SoftLeft", 1], ["SoftRight", 2], ["Home", 3], ["Back", 4], ["Call", 5], ["EndCall", 6], ["0", 7], ["1", 8], ["2", 9], ["3", 10], ["4", 11], ["5", 12], ["6", 13], ["7", 14], ["8", 15], ["9", 16], ["Star", 17], ["*", 17], ["Pound", 18], ["#", 18], ["DialUp", 19], ["DialDown", 20], ["DialLeft", 21], ["DialRight", 22], ["DialCenter", 23], ["VolumeUp", 24], ["VolumeDown", 25], ["Power", 26], ["Camera", 27], ["Clear", 28], ["A", 29], ["B", 30], ["C", 31], ["D", 32], ["E", 33], ["F", 34], ["G", 35], ["H", 36], ["I", 37], ["J", 38], ["K", 39], ["L", 40], ["M", 41], ["N", 42], ["O", 43], ["P", 44], ["Q", 45], ["R", 46], ["S", 47], ["T", 48], ["U", 49], ["V", 50], ["W", 51], ["X", 52], ["Y", 53], ["Z", 54], ["Comma", 55], [",", 55], ["Period", 56], [".", 56], ["AltLeft", 57], ["AltRight", 58], ["ShiftLeft", 59], ["ShiftRight", 60], ["Tab", 61], ["	", 61], ["Space", 62], [" ", 62], ["Sym", 63], ["Explorer", 64], ["Envelop", 65], ["Enter", 66], ["Del", 67], ["Grave", 68], ["Minus", 69], ["-", 69], ["Equals", 70], ["=", 70], ["LeftBracket", 71], ["(", 71], ["RightBracket", 72], [")", 72], ["Backslash", 73], ["\\", 73], ["Semicolon", 74], [";", 74], ["Apostrophe", 75], ["`", 75], ["Slash", 76], ["/", 76], ["At", 77], ["@", 77], ["Num", 78], ["HeadsetHook", 79], ["Focus", 80], ["Plus", 81], ["Menu", 82], ["Notification", 83], ["Search", 84], ["AppSwitch", 187], ["Assist", 219], ["Cut", 277], ["Copy", 278], ["Paste", 279]]);
  }
});

// node_modules/playwright-core/lib/server/dispatchers/browserDispatcher.js
var require_browserDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/browserDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ConnectedBrowserDispatcher = exports2.BrowserDispatcher = void 0;
    var _browser = require_browser3();
    var _browserContextDispatcher = require_browserContextDispatcher();
    var _cdpSessionDispatcher = require_cdpSessionDispatcher();
    var _dispatcher = require_dispatcher();
    var _instrumentation = require_instrumentation();
    var _browserContext = require_browserContext();
    var _selectors = require_selectors();
    var BrowserDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, browser) {
        super(scope, browser, "Browser", {
          version: browser.version(),
          name: browser.options.name
        }, true);
        this._type_Browser = true;
        browser.on(_browser.Browser.Events.Disconnected, () => this._didClose());
      }
      _didClose() {
        this._dispatchEvent("close");
        this._dispose();
      }
      newContext(params, metadata) {
        return __async(this, null, function* () {
          const context = yield this._object.newContext(metadata, params);
          return {
            context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, context)
          };
        });
      }
      close() {
        return __async(this, null, function* () {
          yield this._object.close();
        });
      }
      killForTests() {
        return __async(this, null, function* () {
          yield this._object.killForTests();
        });
      }
      newBrowserCDPSession() {
        return __async(this, null, function* () {
          if (!this._object.options.isChromium)
            throw new Error(`CDP session is only available in Chromium`);
          const crBrowser = this._object;
          return {
            session: new _cdpSessionDispatcher.CDPSessionDispatcher(this._scope, yield crBrowser.newBrowserCDPSession())
          };
        });
      }
      startTracing(params) {
        return __async(this, null, function* () {
          if (!this._object.options.isChromium)
            throw new Error(`Tracing is only available in Chromium`);
          const crBrowser = this._object;
          yield crBrowser.startTracing(params.page ? params.page._object : void 0, params);
        });
      }
      stopTracing() {
        return __async(this, null, function* () {
          if (!this._object.options.isChromium)
            throw new Error(`Tracing is only available in Chromium`);
          const crBrowser = this._object;
          const buffer = yield crBrowser.stopTracing();
          return {
            binary: buffer.toString("base64")
          };
        });
      }
    };
    exports2.BrowserDispatcher = BrowserDispatcher;
    var ConnectedBrowserDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, browser) {
        super(scope, browser, "Browser", {
          version: browser.version(),
          name: browser.options.name
        }, true);
        this._type_Browser = true;
        this._contexts = /* @__PURE__ */ new Set();
        this.selectors = void 0;
        this.selectors = new _selectors.Selectors();
      }
      newContext(params, metadata) {
        return __async(this, null, function* () {
          if (params.recordVideo)
            params.recordVideo.dir = this._object.options.artifactsDir;
          const context = yield this._object.newContext(metadata, params);
          this._contexts.add(context);
          context.setSelectors(this.selectors);
          context.on(_browserContext.BrowserContext.Events.Close, () => this._contexts.delete(context));
          return {
            context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, context)
          };
        });
      }
      close() {
        return __async(this, null, function* () {
        });
      }
      killForTests() {
        return __async(this, null, function* () {
        });
      }
      newBrowserCDPSession() {
        return __async(this, null, function* () {
          if (!this._object.options.isChromium)
            throw new Error(`CDP session is only available in Chromium`);
          const crBrowser = this._object;
          return {
            session: new _cdpSessionDispatcher.CDPSessionDispatcher(this._scope, yield crBrowser.newBrowserCDPSession())
          };
        });
      }
      startTracing(params) {
        return __async(this, null, function* () {
          if (!this._object.options.isChromium)
            throw new Error(`Tracing is only available in Chromium`);
          const crBrowser = this._object;
          yield crBrowser.startTracing(params.page ? params.page._object : void 0, params);
        });
      }
      stopTracing() {
        return __async(this, null, function* () {
          if (!this._object.options.isChromium)
            throw new Error(`Tracing is only available in Chromium`);
          const crBrowser = this._object;
          const buffer = yield crBrowser.stopTracing();
          return {
            binary: buffer.toString("base64")
          };
        });
      }
      cleanupContexts() {
        return __async(this, null, function* () {
          yield Promise.all(Array.from(this._contexts).map((context) => context.close((0, _instrumentation.serverSideCallMetadata)())));
        });
      }
    };
    exports2.ConnectedBrowserDispatcher = ConnectedBrowserDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/jsonPipeDispatcher.js
var require_jsonPipeDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/jsonPipeDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JsonPipeDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _utils = require_utils();
    var _serializers = require_serializers();
    var JsonPipeDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope) {
        super(scope, {
          guid: "jsonPipe@" + (0, _utils.createGuid)()
        }, "JsonPipe", {});
        this._type_JsonPipe = true;
      }
      send(params) {
        return __async(this, null, function* () {
          this.emit("message", params.message);
        });
      }
      close() {
        return __async(this, null, function* () {
          this.emit("close");
          if (!this._disposed) {
            this._dispatchEvent("closed", {});
            this._dispose();
          }
        });
      }
      dispatch(message) {
        if (!this._disposed)
          this._dispatchEvent("message", {
            message
          });
      }
      wasClosed(error) {
        if (!this._disposed) {
          const params = error ? {
            error: (0, _serializers.serializeError)(error)
          } : {};
          this._dispatchEvent("closed", params);
          this._dispose();
        }
      }
      dispose() {
        this._dispose();
      }
    };
    exports2.JsonPipeDispatcher = JsonPipeDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/browserTypeDispatcher.js
var require_browserTypeDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/browserTypeDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BrowserTypeDispatcher = void 0;
    var _browserDispatcher = require_browserDispatcher();
    var _dispatcher = require_dispatcher();
    var _browserContextDispatcher = require_browserContextDispatcher();
    var _jsonPipeDispatcher = require_jsonPipeDispatcher();
    var _userAgent = require_userAgent();
    var socks = _interopRequireWildcard(require_socksProxy());
    var _events = _interopRequireDefault(require("events"));
    var _progress = require_progress2();
    var _transport = require_transport2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var BrowserTypeDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, browserType) {
        super(scope, browserType, "BrowserType", {
          executablePath: browserType.executablePath(),
          name: browserType.name()
        }, true);
        this._type_BrowserType = true;
      }
      launch(params, metadata) {
        return __async(this, null, function* () {
          const browser = yield this._object.launch(metadata, params);
          return {
            browser: new _browserDispatcher.BrowserDispatcher(this._scope, browser)
          };
        });
      }
      launchPersistentContext(params, metadata) {
        return __async(this, null, function* () {
          const browserContext = yield this._object.launchPersistentContext(metadata, params.userDataDir, params);
          return {
            context: new _browserContextDispatcher.BrowserContextDispatcher(this._scope, browserContext)
          };
        });
      }
      connectOverCDP(params, metadata) {
        return __async(this, null, function* () {
          const browser = yield this._object.connectOverCDP(metadata, params.endpointURL, params, params.timeout);
          const browserDispatcher = new _browserDispatcher.BrowserDispatcher(this._scope, browser);
          return {
            browser: browserDispatcher,
            defaultContext: browser._defaultContext ? new _browserContextDispatcher.BrowserContextDispatcher(browserDispatcher._scope, browser._defaultContext) : void 0
          };
        });
      }
      connect(params, metadata) {
        return __async(this, null, function* () {
          const controller = new _progress.ProgressController(metadata, this._object);
          controller.setLogName("browser");
          return yield controller.run((progress) => __async(this, null, function* () {
            const paramsHeaders = Object.assign({
              "User-Agent": (0, _userAgent.getUserAgent)()
            }, params.headers || {});
            const transport = yield _transport.WebSocketTransport.connect(progress, params.wsEndpoint, paramsHeaders, true);
            let socksInterceptor;
            const pipe = new _jsonPipeDispatcher.JsonPipeDispatcher(this._scope);
            transport.onmessage = (json) => {
              var _socksInterceptor;
              if (json.method === "__create__" && json.params.type === "SocksSupport")
                socksInterceptor = new SocksInterceptor(transport, params.socksProxyRedirectPortForTest, json.params.guid);
              if ((_socksInterceptor = socksInterceptor) !== null && _socksInterceptor !== void 0 && _socksInterceptor.interceptMessage(json))
                return;
              const cb = () => {
                try {
                  pipe.dispatch(json);
                } catch (e) {
                  transport.close();
                }
              };
              if (params.slowMo)
                setTimeout(cb, params.slowMo);
              else
                cb();
            };
            pipe.on("message", (message) => {
              transport.send(message);
            });
            transport.onclose = () => {
              var _socksInterceptor2;
              (_socksInterceptor2 = socksInterceptor) === null || _socksInterceptor2 === void 0 ? void 0 : _socksInterceptor2.cleanup();
              pipe.wasClosed();
            };
            pipe.on("close", () => transport.close());
            return {
              pipe
            };
          }), params.timeout || 0);
        });
      }
    };
    exports2.BrowserTypeDispatcher = BrowserTypeDispatcher;
    var SocksInterceptor = class {
      constructor(transport, redirectPortForTest, socksSupportObjectGuid) {
        this._handler = void 0;
        this._channel = void 0;
        this._socksSupportObjectGuid = void 0;
        this._ids = /* @__PURE__ */ new Set();
        this._handler = new socks.SocksProxyHandler(redirectPortForTest);
        this._socksSupportObjectGuid = socksSupportObjectGuid;
        let lastId = -1;
        this._channel = new Proxy(new _events.default(), {
          get: (obj, prop) => {
            if (prop in obj || obj[prop] !== void 0 || typeof prop !== "string")
              return obj[prop];
            return (params) => {
              try {
                const id = --lastId;
                this._ids.add(id);
                transport.send({
                  id,
                  guid: socksSupportObjectGuid,
                  method: prop,
                  params,
                  metadata: {
                    stack: [],
                    apiName: "",
                    internal: true
                  }
                });
              } catch (e) {
              }
            };
          }
        });
        this._handler.on(socks.SocksProxyHandler.Events.SocksConnected, (payload) => this._channel.socksConnected(payload));
        this._handler.on(socks.SocksProxyHandler.Events.SocksData, (payload) => this._channel.socksData({
          uid: payload.uid,
          data: payload.data.toString("base64")
        }));
        this._handler.on(socks.SocksProxyHandler.Events.SocksError, (payload) => this._channel.socksError(payload));
        this._handler.on(socks.SocksProxyHandler.Events.SocksFailed, (payload) => this._channel.socksFailed(payload));
        this._handler.on(socks.SocksProxyHandler.Events.SocksEnd, (payload) => this._channel.socksEnd(payload));
        this._channel.on("socksRequested", (payload) => this._handler.socketRequested(payload));
        this._channel.on("socksClosed", (payload) => this._handler.socketClosed(payload));
        this._channel.on("socksData", (payload) => this._handler.sendSocketData({
          uid: payload.uid,
          data: Buffer.from(payload.data, "base64")
        }));
      }
      cleanup() {
        this._handler.cleanup();
      }
      interceptMessage(message) {
        if (this._ids.has(message.id)) {
          this._ids.delete(message.id);
          return true;
        }
        if (message.guid === this._socksSupportObjectGuid) {
          this._channel.emit(message.method, message.params);
          return true;
        }
        return false;
      }
    };
  }
});

// node_modules/playwright-core/lib/server/dispatchers/electronDispatcher.js
var require_electronDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/electronDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ElectronDispatcher = exports2.ElectronApplicationDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var _electron = require_electron2();
    var _browserContextDispatcher = require_browserContextDispatcher();
    var _jsHandleDispatcher = require_jsHandleDispatcher();
    var _elementHandlerDispatcher = require_elementHandlerDispatcher();
    var ElectronDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, electron) {
        super(scope, electron, "Electron", {}, true);
        this._type_Electron = true;
      }
      launch(params) {
        return __async(this, null, function* () {
          const electronApplication = yield this._object.launch(params);
          return {
            electronApplication: new ElectronApplicationDispatcher(this._scope, electronApplication)
          };
        });
      }
    };
    exports2.ElectronDispatcher = ElectronDispatcher;
    var ElectronApplicationDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, electronApplication) {
        super(scope, electronApplication, "ElectronApplication", {
          context: new _browserContextDispatcher.BrowserContextDispatcher(scope, electronApplication.context())
        }, true);
        this._type_EventTarget = true;
        this._type_ElectronApplication = true;
        electronApplication.on(_electron.ElectronApplication.Events.Close, () => {
          this._dispatchEvent("close");
          this._dispose();
        });
      }
      browserWindow(params) {
        return __async(this, null, function* () {
          const handle = yield this._object.browserWindow(params.page.page());
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, handle)
          };
        });
      }
      evaluateExpression(params) {
        return __async(this, null, function* () {
          const handle = yield this._object._nodeElectronHandlePromise;
          return {
            value: (0, _jsHandleDispatcher.serializeResult)(yield handle.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, true, (0, _jsHandleDispatcher.parseArgument)(params.arg)))
          };
        });
      }
      evaluateExpressionHandle(params) {
        return __async(this, null, function* () {
          const handle = yield this._object._nodeElectronHandlePromise;
          const result = yield handle.evaluateExpressionAndWaitForSignals(params.expression, params.isFunction, false, (0, _jsHandleDispatcher.parseArgument)(params.arg));
          return {
            handle: _elementHandlerDispatcher.ElementHandleDispatcher.fromJSHandle(this._scope, result)
          };
        });
      }
      close() {
        return __async(this, null, function* () {
          yield this._object.close();
        });
      }
    };
    exports2.ElectronApplicationDispatcher = ElectronApplicationDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/localUtilsDispatcher.js
var require_localUtilsDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/localUtilsDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LocalUtilsDispatcher = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var _yauzl = _interopRequireDefault(require_yauzl());
    var _yazl = _interopRequireDefault(require_yazl());
    var _manualPromise = require_manualPromise();
    var _utils = require_utils();
    var _dispatcher = require_dispatcher();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var LocalUtilsDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope) {
        super(scope, {
          guid: "localUtils@" + (0, _utils.createGuid)()
        }, "LocalUtils", {});
        this._type_LocalUtils = void 0;
        this._type_LocalUtils = true;
      }
      zip(params, metadata) {
        return __async(this, null, function* () {
          const promise = new _manualPromise.ManualPromise();
          const zipFile = new _yazl.default.ZipFile();
          zipFile.on("error", (error) => promise.reject(error));
          for (const entry of params.entries) {
            try {
              if (_fs.default.statSync(entry.value).isFile())
                zipFile.addFile(entry.value, entry.name);
            } catch (e) {
            }
          }
          if (!_fs.default.existsSync(params.zipFile)) {
            yield _fs.default.promises.mkdir(_path.default.dirname(params.zipFile), {
              recursive: true
            });
            zipFile.end(void 0, () => {
              zipFile.outputStream.pipe(_fs.default.createWriteStream(params.zipFile)).on("close", () => promise.resolve());
            });
            return promise;
          }
          const tempFile = params.zipFile + ".tmp";
          yield _fs.default.promises.rename(params.zipFile, tempFile);
          _yauzl.default.open(tempFile, (err, inZipFile) => {
            if (err) {
              promise.reject(err);
              return;
            }
            (0, _utils.assert)(inZipFile);
            let pendingEntries = inZipFile.entryCount;
            inZipFile.on("entry", (entry) => {
              inZipFile.openReadStream(entry, (err2, readStream) => {
                if (err2) {
                  promise.reject(err2);
                  return;
                }
                zipFile.addReadStream(readStream, entry.fileName);
                if (--pendingEntries === 0) {
                  zipFile.end(void 0, () => {
                    zipFile.outputStream.pipe(_fs.default.createWriteStream(params.zipFile)).on("close", () => {
                      _fs.default.promises.unlink(tempFile).then(() => {
                        promise.resolve();
                      });
                    });
                  });
                }
              });
            });
          });
          return promise;
        });
      }
    };
    exports2.LocalUtilsDispatcher = LocalUtilsDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/selectorsDispatcher.js
var require_selectorsDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/selectorsDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SelectorsDispatcher = void 0;
    var _dispatcher = require_dispatcher();
    var SelectorsDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, selectors) {
        super(scope, selectors, "Selectors", {});
        this._type_Selectors = true;
      }
      register(params) {
        return __async(this, null, function* () {
          yield this._object.register(params.name, params.source, params.contentScript);
        });
      }
    };
    exports2.SelectorsDispatcher = SelectorsDispatcher;
  }
});

// node_modules/playwright-core/lib/server/dispatchers/playwrightDispatcher.js
var require_playwrightDispatcher = __commonJS({
  "node_modules/playwright-core/lib/server/dispatchers/playwrightDispatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PlaywrightDispatcher = void 0;
    var _fetch = require_fetch();
    var _socksProxy = require_socksProxy();
    var _androidDispatcher = require_androidDispatcher();
    var _browserTypeDispatcher = require_browserTypeDispatcher();
    var _dispatcher = require_dispatcher();
    var _electronDispatcher = require_electronDispatcher();
    var _localUtilsDispatcher = require_localUtilsDispatcher();
    var _networkDispatchers = require_networkDispatchers();
    var _selectorsDispatcher = require_selectorsDispatcher();
    var _browserDispatcher = require_browserDispatcher();
    var _utils = require_utils();
    var PlaywrightDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, playwright, socksProxy, preLaunchedBrowser) {
        const descriptors = require_deviceDescriptors();
        const deviceDescriptors = Object.entries(descriptors).map(([name, descriptor]) => ({
          name,
          descriptor
        }));
        const browserDispatcher = preLaunchedBrowser ? new _browserDispatcher.ConnectedBrowserDispatcher(scope, preLaunchedBrowser) : void 0;
        super(scope, playwright, "Playwright", {
          chromium: new _browserTypeDispatcher.BrowserTypeDispatcher(scope, playwright.chromium),
          firefox: new _browserTypeDispatcher.BrowserTypeDispatcher(scope, playwright.firefox),
          webkit: new _browserTypeDispatcher.BrowserTypeDispatcher(scope, playwright.webkit),
          android: new _androidDispatcher.AndroidDispatcher(scope, playwright.android),
          electron: new _electronDispatcher.ElectronDispatcher(scope, playwright.electron),
          utils: new _localUtilsDispatcher.LocalUtilsDispatcher(scope),
          deviceDescriptors,
          selectors: new _selectorsDispatcher.SelectorsDispatcher(scope, (browserDispatcher === null || browserDispatcher === void 0 ? void 0 : browserDispatcher.selectors) || playwright.selectors),
          preLaunchedBrowser: browserDispatcher,
          socksSupport: socksProxy ? new SocksSupportDispatcher(scope, socksProxy) : void 0
        }, false);
        this._type_Playwright = void 0;
        this._browserDispatcher = void 0;
        this._type_Playwright = true;
        this._browserDispatcher = browserDispatcher;
      }
      newRequest(params, metadata) {
        return __async(this, null, function* () {
          const request = new _fetch.GlobalAPIRequestContext(this._object, params);
          return {
            request: _networkDispatchers.APIRequestContextDispatcher.from(this._scope, request)
          };
        });
      }
      hideHighlight(params, metadata) {
        return __async(this, null, function* () {
          yield this._object.hideHighlight();
        });
      }
      cleanup() {
        return __async(this, null, function* () {
          var _this$_browserDispatc;
          yield (_this$_browserDispatc = this._browserDispatcher) === null || _this$_browserDispatc === void 0 ? void 0 : _this$_browserDispatc.cleanupContexts();
        });
      }
    };
    exports2.PlaywrightDispatcher = PlaywrightDispatcher;
    var SocksSupportDispatcher = class extends _dispatcher.Dispatcher {
      constructor(scope, socksProxy) {
        super(scope, {
          guid: "socksSupport@" + (0, _utils.createGuid)()
        }, "SocksSupport", {});
        this._type_SocksSupport = void 0;
        this._socksProxy = void 0;
        this._type_SocksSupport = true;
        this._socksProxy = socksProxy;
        socksProxy.on(_socksProxy.SocksProxy.Events.SocksRequested, (payload) => this._dispatchEvent("socksRequested", payload));
        socksProxy.on(_socksProxy.SocksProxy.Events.SocksData, (payload) => this._dispatchEvent("socksData", {
          uid: payload.uid,
          data: payload.data.toString("base64")
        }));
        socksProxy.on(_socksProxy.SocksProxy.Events.SocksClosed, (payload) => this._dispatchEvent("socksClosed", payload));
      }
      socksConnected(params) {
        return __async(this, null, function* () {
          var _this$_socksProxy;
          (_this$_socksProxy = this._socksProxy) === null || _this$_socksProxy === void 0 ? void 0 : _this$_socksProxy.socketConnected(params);
        });
      }
      socksFailed(params) {
        return __async(this, null, function* () {
          var _this$_socksProxy2;
          (_this$_socksProxy2 = this._socksProxy) === null || _this$_socksProxy2 === void 0 ? void 0 : _this$_socksProxy2.socketFailed(params);
        });
      }
      socksData(params) {
        return __async(this, null, function* () {
          var _this$_socksProxy3;
          (_this$_socksProxy3 = this._socksProxy) === null || _this$_socksProxy3 === void 0 ? void 0 : _this$_socksProxy3.sendSocketData({
            uid: params.uid,
            data: Buffer.from(params.data, "base64")
          });
        });
      }
      socksError(params) {
        return __async(this, null, function* () {
          var _this$_socksProxy4;
          (_this$_socksProxy4 = this._socksProxy) === null || _this$_socksProxy4 === void 0 ? void 0 : _this$_socksProxy4.sendSocketError(params);
        });
      }
      socksEnd(params) {
        return __async(this, null, function* () {
          var _this$_socksProxy5;
          (_this$_socksProxy5 = this._socksProxy) === null || _this$_socksProxy5 === void 0 ? void 0 : _this$_socksProxy5.sendSocketEnd(params);
        });
      }
    };
  }
});

// node_modules/playwright-core/lib/server/index.js
var require_server = __commonJS({
  "node_modules/playwright-core/lib/server/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "DispatcherConnection", {
      enumerable: true,
      get: function() {
        return _dispatcher.DispatcherConnection;
      }
    });
    Object.defineProperty(exports2, "PlaywrightDispatcher", {
      enumerable: true,
      get: function() {
        return _playwrightDispatcher.PlaywrightDispatcher;
      }
    });
    Object.defineProperty(exports2, "Registry", {
      enumerable: true,
      get: function() {
        return _registry.Registry;
      }
    });
    Object.defineProperty(exports2, "Root", {
      enumerable: true,
      get: function() {
        return _dispatcher.Root;
      }
    });
    Object.defineProperty(exports2, "createPlaywright", {
      enumerable: true,
      get: function() {
        return _playwright.createPlaywright;
      }
    });
    Object.defineProperty(exports2, "installBrowsersForNpmInstall", {
      enumerable: true,
      get: function() {
        return _registry.installBrowsersForNpmInstall;
      }
    });
    Object.defineProperty(exports2, "installDefaultBrowsersForNpmInstall", {
      enumerable: true,
      get: function() {
        return _registry.installDefaultBrowsersForNpmInstall;
      }
    });
    Object.defineProperty(exports2, "registry", {
      enumerable: true,
      get: function() {
        return _registry.registry;
      }
    });
    Object.defineProperty(exports2, "registryDirectory", {
      enumerable: true,
      get: function() {
        return _registry.registryDirectory;
      }
    });
    Object.defineProperty(exports2, "writeDockerVersion", {
      enumerable: true,
      get: function() {
        return _registry.writeDockerVersion;
      }
    });
    var _registry = require_registry();
    var _dispatcher = require_dispatcher();
    var _playwrightDispatcher = require_playwrightDispatcher();
    var _playwright = require_playwright();
  }
});

// node_modules/playwright-core/lib/client/events.js
var require_events = __commonJS({
  "node_modules/playwright-core/lib/client/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Events = void 0;
    var Events = {
      AndroidDevice: {
        WebView: "webview",
        Close: "close"
      },
      AndroidSocket: {
        Data: "data",
        Close: "close"
      },
      AndroidWebView: {
        Close: "close"
      },
      Browser: {
        Disconnected: "disconnected"
      },
      BrowserContext: {
        Close: "close",
        Page: "page",
        BackgroundPage: "backgroundpage",
        ServiceWorker: "serviceworker",
        Request: "request",
        Response: "response",
        RequestFailed: "requestfailed",
        RequestFinished: "requestfinished"
      },
      BrowserServer: {
        Close: "close"
      },
      Page: {
        Close: "close",
        Crash: "crash",
        Console: "console",
        Dialog: "dialog",
        Download: "download",
        FileChooser: "filechooser",
        DOMContentLoaded: "domcontentloaded",
        PageError: "pageerror",
        Request: "request",
        Response: "response",
        RequestFailed: "requestfailed",
        RequestFinished: "requestfinished",
        FrameAttached: "frameattached",
        FrameDetached: "framedetached",
        FrameNavigated: "framenavigated",
        Load: "load",
        Popup: "popup",
        WebSocket: "websocket",
        Worker: "worker"
      },
      WebSocket: {
        Close: "close",
        Error: "socketerror",
        FrameReceived: "framereceived",
        FrameSent: "framesent"
      },
      Worker: {
        Close: "close"
      },
      ElectronApplication: {
        Close: "close",
        Window: "window"
      }
    };
    exports2.Events = Events;
  }
});

// node_modules/playwright-core/lib/client/accessibility.js
var require_accessibility2 = __commonJS({
  "node_modules/playwright-core/lib/client/accessibility.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Accessibility = void 0;
    function axNodeFromProtocol(axNode) {
      const result = __spreadProps(__spreadValues({}, axNode), {
        value: axNode.valueNumber !== void 0 ? axNode.valueNumber : axNode.valueString,
        checked: axNode.checked === "checked" ? true : axNode.checked === "unchecked" ? false : axNode.checked,
        pressed: axNode.pressed === "pressed" ? true : axNode.pressed === "released" ? false : axNode.pressed,
        children: axNode.children ? axNode.children.map(axNodeFromProtocol) : void 0
      });
      delete result.valueNumber;
      delete result.valueString;
      return result;
    }
    var Accessibility = class {
      constructor(channel) {
        this._channel = void 0;
        this._channel = channel;
      }
      snapshot() {
        return __async(this, arguments, function* (options = {}) {
          const root = options.root ? options.root._elementChannel : void 0;
          const result = yield this._channel.accessibilitySnapshot({
            interestingOnly: options.interestingOnly,
            root
          });
          return result.rootAXNode ? axNodeFromProtocol(result.rootAXNode) : null;
        });
      }
    };
    exports2.Accessibility = Accessibility;
  }
});

// node_modules/playwright-core/lib/utils/zones.js
var require_zones = __commonJS({
  "node_modules/playwright-core/lib/utils/zones.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.zones = void 0;
    var _stackTrace = require_stackTrace();
    var ZoneManager = class {
      constructor() {
        this.lastZoneId = 0;
        this._zones = /* @__PURE__ */ new Map();
      }
      run(type, data, func) {
        return __async(this, null, function* () {
          const zone = new Zone(this, ++this.lastZoneId, type, data);
          this._zones.set(zone.id, zone);
          return zone.run(func);
        });
      }
      zoneData(type, rawStack) {
        const stack = rawStack || (0, _stackTrace.captureRawStack)();
        for (const line of stack.split("\n")) {
          const index = line.indexOf("__PWZONE__[");
          if (index !== -1) {
            const zoneId = +line.substring(index + "__PWZONE__[".length, line.indexOf("]", index));
            const zone = this._zones.get(zoneId);
            if (zone && zone.type === type)
              return zone.data;
          }
        }
        return null;
      }
    };
    var Zone = class {
      constructor(manager, id, type, data) {
        this._manager = void 0;
        this.id = void 0;
        this.type = void 0;
        this.data = {};
        this._manager = manager;
        this.id = id;
        this.type = type;
        this.data = data;
      }
      run(func) {
        return __async(this, null, function* () {
          Object.defineProperty(func, "name", {
            value: `__PWZONE__[${this.id}]`
          });
          try {
            return yield func();
          } finally {
            this._manager._zones.delete(this.id);
          }
        });
      }
    };
    var zones = new ZoneManager();
    exports2.zones = zones;
  }
});

// node_modules/playwright-core/lib/client/channelOwner.js
var require_channelOwner = __commonJS({
  "node_modules/playwright-core/lib/client/channelOwner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ChannelOwner = void 0;
    exports2.renderCallWithParams = renderCallWithParams;
    var _events = require("events");
    var _validator = require_validator();
    var _debugLogger = require_debugLogger();
    var _stackTrace = require_stackTrace();
    var _utils = require_utils();
    var _zones = require_zones();
    var ChannelOwner = class extends _events.EventEmitter {
      constructor(parent, type, guid, initializer, instrumentation) {
        var _this$_parent;
        super();
        this._connection = void 0;
        this._parent = void 0;
        this._objects = /* @__PURE__ */ new Map();
        this._type = void 0;
        this._guid = void 0;
        this._channel = void 0;
        this._initializer = void 0;
        this._logger = void 0;
        this._instrumentation = void 0;
        this.setMaxListeners(0);
        this._connection = parent instanceof ChannelOwner ? parent._connection : parent;
        this._type = type;
        this._guid = guid;
        this._parent = parent instanceof ChannelOwner ? parent : void 0;
        this._instrumentation = instrumentation || ((_this$_parent = this._parent) === null || _this$_parent === void 0 ? void 0 : _this$_parent._instrumentation);
        this._connection._objects.set(guid, this);
        if (this._parent) {
          this._parent._objects.set(guid, this);
          this._logger = this._parent._logger;
        }
        this._channel = this._createChannel(new _events.EventEmitter());
        this._initializer = initializer;
      }
      _dispose() {
        if (this._parent)
          this._parent._objects.delete(this._guid);
        this._connection._objects.delete(this._guid);
        for (const object of [...this._objects.values()])
          object._dispose();
        this._objects.clear();
      }
      _debugScopeState() {
        return {
          _guid: this._guid,
          objects: Array.from(this._objects.values()).map((o) => o._debugScopeState())
        };
      }
      _createChannel(base) {
        const channel = new Proxy(base, {
          get: (obj, prop) => {
            if (prop === "debugScopeState")
              return (params) => this._connection.sendMessageToServer(this, prop, params, null);
            if (typeof prop === "string") {
              const validator = scheme[paramsName(this._type, prop)];
              if (validator) {
                return (params) => {
                  return this._wrapApiCall((apiZone) => {
                    const {
                      stackTrace,
                      csi,
                      callCookie
                    } = apiZone.reported ? {
                      csi: void 0,
                      callCookie: void 0,
                      stackTrace: null
                    } : apiZone;
                    apiZone.reported = true;
                    if (csi && stackTrace && stackTrace.apiName)
                      csi.onApiCallBegin(renderCallWithParams(stackTrace.apiName, params), stackTrace, callCookie);
                    return this._connection.sendMessageToServer(this, prop, validator(params, ""), stackTrace);
                  });
                };
              }
            }
            return obj[prop];
          }
        });
        channel._object = this;
        return channel;
      }
      _wrapApiCall(func, isInternal = false, customStackTrace) {
        return __async(this, null, function* () {
          const logger = this._logger;
          const stack = (0, _stackTrace.captureRawStack)();
          const apiZone = _zones.zones.zoneData("apiZone", stack);
          if (apiZone)
            return func(apiZone);
          const stackTrace = customStackTrace || (0, _stackTrace.captureStackTrace)(stack);
          if (isInternal)
            delete stackTrace.apiName;
          const csi = isInternal ? void 0 : this._instrumentation;
          const callCookie = {};
          const {
            apiName,
            frameTexts
          } = stackTrace;
          try {
            logApiCall(logger, `=> ${apiName} started`, isInternal);
            const apiZone2 = {
              stackTrace,
              isInternal,
              reported: false,
              csi,
              callCookie
            };
            const result = yield _zones.zones.run("apiZone", apiZone2, () => __async(this, null, function* () {
              return yield func(apiZone2);
            }));
            csi === null || csi === void 0 ? void 0 : csi.onApiCallEnd(callCookie);
            logApiCall(logger, `<= ${apiName} succeeded`, isInternal);
            return result;
          } catch (e) {
            const innerError = (process.env.PWDEBUGIMPL || (0, _utils.isUnderTest)()) && e.stack ? "\n<inner error>\n" + e.stack : "";
            e.message = apiName + ": " + e.message;
            e.stack = e.message + "\n" + frameTexts.join("\n") + innerError;
            csi === null || csi === void 0 ? void 0 : csi.onApiCallEnd(callCookie, e);
            logApiCall(logger, `<= ${apiName} failed`, isInternal);
            throw e;
          }
        });
      }
      _toImpl() {
        var _this$_connection$toI, _this$_connection;
        return (_this$_connection$toI = (_this$_connection = this._connection).toImpl) === null || _this$_connection$toI === void 0 ? void 0 : _this$_connection$toI.call(_this$_connection, this);
      }
      toJSON() {
        return {
          _type: this._type,
          _guid: this._guid
        };
      }
    };
    exports2.ChannelOwner = ChannelOwner;
    function logApiCall(logger, message, isNested) {
      if (isNested)
        return;
      if (logger && logger.isEnabled("api", "info"))
        logger.log("api", "info", message, [], {
          color: "cyan"
        });
      _debugLogger.debugLogger.log("api", message);
    }
    function paramsName(type, method) {
      return type + method[0].toUpperCase() + method.substring(1) + "Params";
    }
    var paramsToRender = ["url", "selector", "text", "key"];
    function renderCallWithParams(apiName, params) {
      const paramsArray = [];
      if (params) {
        for (const name of paramsToRender) {
          if (params[name])
            paramsArray.push(params[name]);
        }
      }
      const paramsText = paramsArray.length ? "(" + paramsArray.join(", ") + ")" : "";
      return apiName + paramsText;
    }
    var tChannel = (name) => {
      return (arg, path) => {
        if (arg._object instanceof ChannelOwner && (name === "*" || arg._object._type === name))
          return {
            guid: arg._object._guid
          };
        throw new _validator.ValidationError(`${path}: expected ${name}`);
      };
    };
    var scheme = (0, _validator.createScheme)(tChannel);
  }
});

// node_modules/playwright-core/lib/client/jsHandle.js
var require_jsHandle = __commonJS({
  "node_modules/playwright-core/lib/client/jsHandle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JSHandle = void 0;
    exports2.assertMaxArguments = assertMaxArguments;
    exports2.parseResult = parseResult;
    exports2.serializeArgument = serializeArgument;
    var _channelOwner = require_channelOwner();
    var _serializers = require_serializers();
    var JSHandle = class extends _channelOwner.ChannelOwner {
      static from(handle) {
        return handle._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._preview = void 0;
        this._preview = this._initializer.preview;
        this._channel.on("previewUpdated", ({
          preview
        }) => this._preview = preview);
      }
      evaluate(pageFunction, arg) {
        return __async(this, null, function* () {
          const result = yield this._channel.evaluateExpression({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: serializeArgument(arg)
          });
          return parseResult(result.value);
        });
      }
      evaluateHandle(pageFunction, arg) {
        return __async(this, null, function* () {
          const result = yield this._channel.evaluateExpressionHandle({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: serializeArgument(arg)
          });
          return JSHandle.from(result.handle);
        });
      }
      getProperty(propertyName) {
        return __async(this, null, function* () {
          const result = yield this._channel.getProperty({
            name: propertyName
          });
          return JSHandle.from(result.handle);
        });
      }
      getProperties() {
        return __async(this, null, function* () {
          const map = /* @__PURE__ */ new Map();
          for (const {
            name,
            value
          } of (yield this._channel.getPropertyList()).properties)
            map.set(name, JSHandle.from(value));
          return map;
        });
      }
      jsonValue() {
        return __async(this, null, function* () {
          return parseResult((yield this._channel.jsonValue()).value);
        });
      }
      asElement() {
        return null;
      }
      dispose() {
        return __async(this, null, function* () {
          return yield this._channel.dispose();
        });
      }
      toString() {
        return this._preview;
      }
    };
    exports2.JSHandle = JSHandle;
    function serializeArgument(arg) {
      const handles = [];
      const pushHandle = (channel) => {
        handles.push(channel);
        return handles.length - 1;
      };
      const value = (0, _serializers.serializeValue)(arg, (value2) => {
        if (value2 instanceof JSHandle)
          return {
            h: pushHandle(value2._channel)
          };
        return {
          fallThrough: value2
        };
      }, /* @__PURE__ */ new Set());
      return {
        value,
        handles
      };
    }
    function parseResult(value) {
      return (0, _serializers.parseSerializedValue)(value, void 0);
    }
    function assertMaxArguments(count, max) {
      if (count > max)
        throw new Error("Too many arguments. If you need to pass more than 1 argument to the function wrap them in an object.");
    }
  }
});

// node_modules/playwright-core/lib/client/consoleMessage.js
var require_consoleMessage = __commonJS({
  "node_modules/playwright-core/lib/client/consoleMessage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ConsoleMessage = void 0;
    var util = _interopRequireWildcard(require("util"));
    var _jsHandle = require_jsHandle();
    var _channelOwner = require_channelOwner();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var ConsoleMessage = class extends _channelOwner.ChannelOwner {
      static from(message) {
        return message._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      type() {
        return this._initializer.type;
      }
      text() {
        return this._initializer.text;
      }
      args() {
        return this._initializer.args.map(_jsHandle.JSHandle.from);
      }
      location() {
        return this._initializer.location;
      }
      [util.inspect.custom]() {
        return this.text();
      }
    };
    exports2.ConsoleMessage = ConsoleMessage;
  }
});

// node_modules/playwright-core/lib/client/dialog.js
var require_dialog2 = __commonJS({
  "node_modules/playwright-core/lib/client/dialog.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Dialog = void 0;
    var _channelOwner = require_channelOwner();
    var Dialog = class extends _channelOwner.ChannelOwner {
      static from(dialog) {
        return dialog._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      type() {
        return this._initializer.type;
      }
      message() {
        return this._initializer.message;
      }
      defaultValue() {
        return this._initializer.defaultValue;
      }
      accept(promptText) {
        return __async(this, null, function* () {
          yield this._channel.accept({
            promptText
          });
        });
      }
      dismiss() {
        return __async(this, null, function* () {
          yield this._channel.dismiss();
        });
      }
    };
    exports2.Dialog = Dialog;
  }
});

// node_modules/playwright-core/lib/client/download.js
var require_download3 = __commonJS({
  "node_modules/playwright-core/lib/client/download.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Download = void 0;
    var Download = class {
      constructor(page, url, suggestedFilename, artifact) {
        this._page = void 0;
        this._url = void 0;
        this._suggestedFilename = void 0;
        this._artifact = void 0;
        this._page = page;
        this._url = url;
        this._suggestedFilename = suggestedFilename;
        this._artifact = artifact;
      }
      page() {
        return this._page;
      }
      url() {
        return this._url;
      }
      suggestedFilename() {
        return this._suggestedFilename;
      }
      path() {
        return __async(this, null, function* () {
          return this._artifact.pathAfterFinished();
        });
      }
      saveAs(path) {
        return __async(this, null, function* () {
          return this._artifact.saveAs(path);
        });
      }
      failure() {
        return __async(this, null, function* () {
          return this._artifact.failure();
        });
      }
      createReadStream() {
        return __async(this, null, function* () {
          return this._artifact.createReadStream();
        });
      }
      cancel() {
        return __async(this, null, function* () {
          return this._artifact.cancel();
        });
      }
      delete() {
        return __async(this, null, function* () {
          return this._artifact.delete();
        });
      }
    };
    exports2.Download = Download;
  }
});

// node_modules/playwright-core/lib/client/locator.js
var require_locator = __commonJS({
  "node_modules/playwright-core/lib/client/locator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Locator = exports2.FrameLocator = void 0;
    var util = _interopRequireWildcard(require("util"));
    var _utils = require_utils();
    var _elementHandle = require_elementHandle();
    var _jsHandle = require_jsHandle();
    var _stringUtils = require_stringUtils();
    var _util$inspect$custom;
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    _util$inspect$custom = util.inspect.custom;
    var Locator = class {
      constructor(frame, selector, options) {
        this._frame = void 0;
        this._selector = void 0;
        this._frame = frame;
        this._selector = selector;
        if (options !== null && options !== void 0 && options.hasText) {
          const text = options.hasText;
          if ((0, _utils.isRegExp)(text))
            this._selector += ` >> :scope:text-matches(${(0, _stringUtils.escapeWithQuotes)(text.source, '"')}, "${text.flags}")`;
          else
            this._selector += ` >> :scope:has-text(${(0, _stringUtils.escapeWithQuotes)(text, '"')})`;
        }
        if (options !== null && options !== void 0 && options.has) {
          if (options.has._frame !== frame)
            throw new Error(`Inner "has" locator must belong to the same frame.`);
          this._selector += ` >> has=` + JSON.stringify(options.has._selector);
        }
      }
      _withElement(task, timeout) {
        return __async(this, null, function* () {
          timeout = this._frame.page()._timeoutSettings.timeout({
            timeout
          });
          const deadline = timeout ? (0, _utils.monotonicTime)() + timeout : 0;
          return this._frame._wrapApiCall(() => __async(this, null, function* () {
            const result = yield this._frame._channel.waitForSelector({
              selector: this._selector,
              strict: true,
              state: "attached",
              timeout
            });
            const handle = _elementHandle.ElementHandle.fromNullable(result.element);
            if (!handle)
              throw new Error(`Could not resolve ${this._selector} to DOM Element`);
            try {
              return yield task(handle, deadline ? deadline - (0, _utils.monotonicTime)() : 0);
            } finally {
              yield handle.dispose();
            }
          }));
        });
      }
      page() {
        return this._frame.page();
      }
      boundingBox(options) {
        return __async(this, null, function* () {
          return this._withElement((h) => h.boundingBox(), options === null || options === void 0 ? void 0 : options.timeout);
        });
      }
      check() {
        return __async(this, arguments, function* (options = {}) {
          return this._frame.check(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      click() {
        return __async(this, arguments, function* (options = {}) {
          return this._frame.click(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      dblclick() {
        return __async(this, arguments, function* (options = {}) {
          return this._frame.dblclick(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      dispatchEvent(_0) {
        return __async(this, arguments, function* (type, eventInit = {}, options) {
          return this._frame.dispatchEvent(this._selector, type, eventInit, __spreadValues({
            strict: true
          }, options));
        });
      }
      dragTo(_0) {
        return __async(this, arguments, function* (target, options = {}) {
          return this._frame.dragAndDrop(this._selector, target._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      evaluate(pageFunction, arg, options) {
        return __async(this, null, function* () {
          return this._withElement((h) => h.evaluate(pageFunction, arg), options === null || options === void 0 ? void 0 : options.timeout);
        });
      }
      evaluateAll(pageFunction, arg) {
        return __async(this, null, function* () {
          return this._frame.$$eval(this._selector, pageFunction, arg);
        });
      }
      evaluateHandle(pageFunction, arg, options) {
        return __async(this, null, function* () {
          return this._withElement((h) => h.evaluateHandle(pageFunction, arg), options === null || options === void 0 ? void 0 : options.timeout);
        });
      }
      fill(_0) {
        return __async(this, arguments, function* (value, options = {}) {
          return this._frame.fill(this._selector, value, __spreadValues({
            strict: true
          }, options));
        });
      }
      _highlight() {
        return __async(this, null, function* () {
          return this._frame._highlight(this._selector);
        });
      }
      highlight() {
        return __async(this, null, function* () {
          return this._frame._highlight(this._selector);
        });
      }
      locator(selector, options) {
        return new Locator(this._frame, this._selector + " >> " + selector, options);
      }
      frameLocator(selector) {
        return new FrameLocator(this._frame, this._selector + " >> " + selector);
      }
      elementHandle(options) {
        return __async(this, null, function* () {
          return yield this._frame.waitForSelector(this._selector, __spreadValues({
            strict: true,
            state: "attached"
          }, options));
        });
      }
      elementHandles() {
        return __async(this, null, function* () {
          return this._frame.$$(this._selector);
        });
      }
      first() {
        return new Locator(this._frame, this._selector + " >> nth=0");
      }
      last() {
        return new Locator(this._frame, this._selector + ` >> nth=-1`);
      }
      nth(index) {
        return new Locator(this._frame, this._selector + ` >> nth=${index}`);
      }
      focus(options) {
        return __async(this, null, function* () {
          return this._frame.focus(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      count() {
        return __async(this, null, function* () {
          return this._frame._queryCount(this._selector);
        });
      }
      getAttribute(name, options) {
        return __async(this, null, function* () {
          return this._frame.getAttribute(this._selector, name, __spreadValues({
            strict: true
          }, options));
        });
      }
      hover() {
        return __async(this, arguments, function* (options = {}) {
          return this._frame.hover(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      innerHTML(options) {
        return __async(this, null, function* () {
          return this._frame.innerHTML(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      innerText(options) {
        return __async(this, null, function* () {
          return this._frame.innerText(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      inputValue(options) {
        return __async(this, null, function* () {
          return this._frame.inputValue(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      isChecked(options) {
        return __async(this, null, function* () {
          return this._frame.isChecked(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      isDisabled(options) {
        return __async(this, null, function* () {
          return this._frame.isDisabled(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      isEditable(options) {
        return __async(this, null, function* () {
          return this._frame.isEditable(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      isEnabled(options) {
        return __async(this, null, function* () {
          return this._frame.isEnabled(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      isHidden(options) {
        return __async(this, null, function* () {
          return this._frame.isHidden(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      isVisible(options) {
        return __async(this, null, function* () {
          return this._frame.isVisible(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      press(_0) {
        return __async(this, arguments, function* (key, options = {}) {
          return this._frame.press(this._selector, key, __spreadValues({
            strict: true
          }, options));
        });
      }
      screenshot() {
        return __async(this, arguments, function* (options = {}) {
          return this._withElement((h, timeout) => h.screenshot(__spreadProps(__spreadValues({}, options), {
            timeout
          })), options.timeout);
        });
      }
      scrollIntoViewIfNeeded() {
        return __async(this, arguments, function* (options = {}) {
          return this._withElement((h, timeout) => h.scrollIntoViewIfNeeded(__spreadProps(__spreadValues({}, options), {
            timeout
          })), options.timeout);
        });
      }
      selectOption(_0) {
        return __async(this, arguments, function* (values, options = {}) {
          return this._frame.selectOption(this._selector, values, __spreadValues({
            strict: true
          }, options));
        });
      }
      selectText() {
        return __async(this, arguments, function* (options = {}) {
          return this._withElement((h, timeout) => h.selectText(__spreadProps(__spreadValues({}, options), {
            timeout
          })), options.timeout);
        });
      }
      setChecked(checked, options) {
        return __async(this, null, function* () {
          if (checked)
            yield this.check(options);
          else
            yield this.uncheck(options);
        });
      }
      setInputFiles(_0) {
        return __async(this, arguments, function* (files, options = {}) {
          return this._frame.setInputFiles(this._selector, files, __spreadValues({
            strict: true
          }, options));
        });
      }
      tap() {
        return __async(this, arguments, function* (options = {}) {
          return this._frame.tap(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      textContent(options) {
        return __async(this, null, function* () {
          return this._frame.textContent(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      type(_0) {
        return __async(this, arguments, function* (text, options = {}) {
          return this._frame.type(this._selector, text, __spreadValues({
            strict: true
          }, options));
        });
      }
      uncheck() {
        return __async(this, arguments, function* (options = {}) {
          return this._frame.uncheck(this._selector, __spreadValues({
            strict: true
          }, options));
        });
      }
      allInnerTexts() {
        return __async(this, null, function* () {
          return this._frame.$$eval(this._selector, (ee) => ee.map((e) => e.innerText));
        });
      }
      allTextContents() {
        return __async(this, null, function* () {
          return this._frame.$$eval(this._selector, (ee) => ee.map((e) => e.textContent || ""));
        });
      }
      waitFor(options) {
        return __async(this, null, function* () {
          yield this._frame._channel.waitForSelector(__spreadValues({
            selector: this._selector,
            strict: true,
            omitReturnValue: true
          }, options));
        });
      }
      _expect(customStackTrace, expression, options) {
        return __async(this, null, function* () {
          return this._frame._wrapApiCall(() => __async(this, null, function* () {
            const params = __spreadProps(__spreadValues({
              selector: this._selector,
              expression
            }, options), {
              isNot: !!options.isNot
            });
            if (options.expectedValue)
              params.expectedValue = (0, _jsHandle.serializeArgument)(options.expectedValue);
            const result = yield this._frame._channel.expect(params);
            if (result.received !== void 0)
              result.received = (0, _jsHandle.parseResult)(result.received);
            return result;
          }), false, customStackTrace);
        });
      }
      [_util$inspect$custom]() {
        return this.toString();
      }
      toString() {
        return `Locator@${this._selector}`;
      }
    };
    exports2.Locator = Locator;
    var FrameLocator = class {
      constructor(frame, selector) {
        this._frame = void 0;
        this._frameSelector = void 0;
        this._frame = frame;
        this._frameSelector = selector;
      }
      locator(selector, options) {
        return new Locator(this._frame, this._frameSelector + " >> control=enter-frame >> " + selector, options);
      }
      frameLocator(selector) {
        return new FrameLocator(this._frame, this._frameSelector + " >> control=enter-frame >> " + selector);
      }
      first() {
        return new FrameLocator(this._frame, this._frameSelector + " >> nth=0");
      }
      last() {
        return new FrameLocator(this._frame, this._frameSelector + ` >> nth=-1`);
      }
      nth(index) {
        return new FrameLocator(this._frame, this._frameSelector + ` >> nth=${index}`);
      }
    };
    exports2.FrameLocator = FrameLocator;
  }
});

// node_modules/playwright-core/lib/client/waiter.js
var require_waiter = __commonJS({
  "node_modules/playwright-core/lib/client/waiter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Waiter = void 0;
    var _stackTrace = require_stackTrace();
    var _errors = require_errors();
    var _utils = require_utils();
    var Waiter = class {
      constructor(channelOwner, event) {
        this._dispose = void 0;
        this._failures = [];
        this._immediateError = void 0;
        this._logs = [];
        this._channelOwner = void 0;
        this._waitId = void 0;
        this._error = void 0;
        this._waitId = (0, _utils.createGuid)();
        this._channelOwner = channelOwner;
        this._channelOwner._channel.waitForEventInfo({
          info: {
            waitId: this._waitId,
            phase: "before",
            event
          }
        }).catch(() => {
        });
        this._dispose = [() => this._channelOwner._wrapApiCall(() => __async(this, null, function* () {
          yield this._channelOwner._channel.waitForEventInfo({
            info: {
              waitId: this._waitId,
              phase: "after",
              error: this._error
            }
          });
        }), true).catch(() => {
        })];
      }
      static createForEvent(channelOwner, event) {
        return new Waiter(channelOwner, event);
      }
      waitForEvent(emitter, event, predicate) {
        return __async(this, null, function* () {
          const {
            promise,
            dispose
          } = waitForEvent(emitter, event, predicate);
          return this.waitForPromise(promise, dispose);
        });
      }
      rejectOnEvent(emitter, event, error, predicate) {
        const {
          promise,
          dispose
        } = waitForEvent(emitter, event, predicate);
        this._rejectOn(promise.then(() => {
          throw error;
        }), dispose);
      }
      rejectOnTimeout(timeout, message) {
        if (!timeout)
          return;
        const {
          promise,
          dispose
        } = waitForTimeout(timeout);
        this._rejectOn(promise.then(() => {
          throw new _errors.TimeoutError(message);
        }), dispose);
      }
      rejectImmediately(error) {
        this._immediateError = error;
      }
      dispose() {
        for (const dispose of this._dispose)
          dispose();
      }
      waitForPromise(promise, dispose) {
        return __async(this, null, function* () {
          try {
            if (this._immediateError)
              throw this._immediateError;
            const result = yield Promise.race([promise, ...this._failures]);
            if (dispose)
              dispose();
            return result;
          } catch (e) {
            if (dispose)
              dispose();
            this._error = e.message;
            this.dispose();
            (0, _stackTrace.rewriteErrorMessage)(e, e.message + formatLogRecording(this._logs));
            throw e;
          }
        });
      }
      log(s) {
        this._logs.push(s);
        this._channelOwner._wrapApiCall(() => __async(this, null, function* () {
          yield this._channelOwner._channel.waitForEventInfo({
            info: {
              waitId: this._waitId,
              phase: "log",
              message: s
            }
          }).catch(() => {
          });
        }), true);
      }
      _rejectOn(promise, dispose) {
        this._failures.push(promise);
        if (dispose)
          this._dispose.push(dispose);
      }
    };
    exports2.Waiter = Waiter;
    function waitForEvent(emitter, event, predicate) {
      let listener;
      const promise = new Promise((resolve, reject) => {
        listener = (eventArg) => __async(this, null, function* () {
          try {
            if (predicate && !(yield predicate(eventArg)))
              return;
            emitter.removeListener(event, listener);
            resolve(eventArg);
          } catch (e) {
            emitter.removeListener(event, listener);
            reject(e);
          }
        });
        emitter.addListener(event, listener);
      });
      const dispose = () => emitter.removeListener(event, listener);
      return {
        promise,
        dispose
      };
    }
    function waitForTimeout(timeout) {
      let timeoutId;
      const promise = new Promise((resolve) => timeoutId = setTimeout(resolve, timeout));
      const dispose = () => clearTimeout(timeoutId);
      return {
        promise,
        dispose
      };
    }
    function formatLogRecording(log) {
      if (!log.length)
        return "";
      const header = ` logs `;
      const headerLength = 60;
      const leftLength = (headerLength - header.length) / 2;
      const rightLength = headerLength - header.length - leftLength;
      return `
${"=".repeat(leftLength)}${header}${"=".repeat(rightLength)}
${log.join("\n")}
${"=".repeat(headerLength)}`;
    }
  }
});

// node_modules/playwright-core/lib/client/clientHelper.js
var require_clientHelper = __commonJS({
  "node_modules/playwright-core/lib/client/clientHelper.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.envObjectToArray = envObjectToArray;
    exports2.evaluationScript = evaluationScript;
    exports2.globToRegex = globToRegex;
    exports2.parsedURL = parsedURL;
    exports2.urlMatches = urlMatches;
    var _fs = _interopRequireDefault(require("fs"));
    var _utils = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function envObjectToArray(env) {
      const result = [];
      for (const name in env) {
        if (!Object.is(env[name], void 0))
          result.push({
            name,
            value: String(env[name])
          });
      }
      return result;
    }
    function evaluationScript(fun, arg, addSourceUrl = true) {
      return __async(this, null, function* () {
        if (typeof fun === "function") {
          const source = fun.toString();
          const argString = Object.is(arg, void 0) ? "undefined" : JSON.stringify(arg);
          return `(${source})(${argString})`;
        }
        if (arg !== void 0)
          throw new Error("Cannot evaluate a string with arguments");
        if ((0, _utils.isString)(fun))
          return fun;
        if (fun.content !== void 0)
          return fun.content;
        if (fun.path !== void 0) {
          let source = yield _fs.default.promises.readFile(fun.path, "utf8");
          if (addSourceUrl)
            source += "\n//# sourceURL=" + fun.path.replace(/\n/g, "");
          return source;
        }
        throw new Error("Either path or content property must be present");
      });
    }
    function parsedURL(url) {
      try {
        return new URL(url);
      } catch (e) {
        return null;
      }
    }
    function urlMatches(baseURL, urlString, match) {
      if (match === void 0 || match === "")
        return true;
      if ((0, _utils.isString)(match) && !match.startsWith("*"))
        match = (0, _utils.constructURLBasedOnBaseURL)(baseURL, match);
      if ((0, _utils.isString)(match))
        match = globToRegex(match);
      if ((0, _utils.isRegExp)(match))
        return match.test(urlString);
      if (typeof match === "string" && match === urlString)
        return true;
      const url = parsedURL(urlString);
      if (!url)
        return false;
      if (typeof match === "string")
        return url.pathname === match;
      if (typeof match !== "function")
        throw new Error("url parameter should be string, RegExp or function");
      return match(url);
    }
    var escapeGlobChars = /* @__PURE__ */ new Set(["/", "$", "^", "+", ".", "(", ")", "=", "!", "|"]);
    function globToRegex(glob) {
      const tokens = ["^"];
      let inGroup;
      for (let i = 0; i < glob.length; ++i) {
        const c = glob[i];
        if (escapeGlobChars.has(c)) {
          tokens.push("\\" + c);
          continue;
        }
        if (c === "*") {
          const beforeDeep = glob[i - 1];
          let starCount = 1;
          while (glob[i + 1] === "*") {
            starCount++;
            i++;
          }
          const afterDeep = glob[i + 1];
          const isDeep = starCount > 1 && (beforeDeep === "/" || beforeDeep === void 0) && (afterDeep === "/" || afterDeep === void 0);
          if (isDeep) {
            tokens.push("((?:[^/]*(?:/|$))*)");
            i++;
          } else {
            tokens.push("([^/]*)");
          }
          continue;
        }
        switch (c) {
          case "?":
            tokens.push(".");
            break;
          case "{":
            inGroup = true;
            tokens.push("(");
            break;
          case "}":
            inGroup = false;
            tokens.push(")");
            break;
          case ",":
            if (inGroup) {
              tokens.push("|");
              break;
            }
            tokens.push("\\" + c);
            break;
          default:
            tokens.push(c);
        }
      }
      tokens.push("$");
      return new RegExp(tokens.join(""));
    }
  }
});

// node_modules/playwright-core/lib/client/clientInstrumentation.js
var require_clientInstrumentation = __commonJS({
  "node_modules/playwright-core/lib/client/clientInstrumentation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createInstrumentation = createInstrumentation;
    function createInstrumentation() {
      const listeners = [];
      return new Proxy({}, {
        get: (obj, prop) => {
          if (prop === "addListener")
            return (listener) => listeners.push(listener);
          if (prop === "removeListener")
            return (listener) => listeners.splice(listeners.indexOf(listener), 1);
          if (prop === "removeAllListeners")
            return () => listeners.splice(0, listeners.length);
          if (!prop.startsWith("on"))
            return obj[prop];
          return (...params) => __async(this, null, function* () {
            for (const listener of listeners) {
              var _prop, _ref;
              yield (_prop = (_ref = listener)[prop]) === null || _prop === void 0 ? void 0 : _prop.call(_ref, ...params);
            }
          });
        }
      });
    }
  }
});

// node_modules/playwright-core/lib/client/stream.js
var require_stream = __commonJS({
  "node_modules/playwright-core/lib/client/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Stream = void 0;
    var _stream = require("stream");
    var _channelOwner = require_channelOwner();
    var Stream = class extends _channelOwner.ChannelOwner {
      static from(Stream2) {
        return Stream2._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      stream() {
        return new StreamImpl(this._channel);
      }
    };
    exports2.Stream = Stream;
    var StreamImpl = class extends _stream.Readable {
      constructor(channel) {
        super();
        this._channel = void 0;
        this._channel = channel;
      }
      _read(size) {
        return __async(this, null, function* () {
          const result = yield this._channel.read({
            size
          });
          if (result.binary)
            this.push(Buffer.from(result.binary, "base64"));
          else
            this.push(null);
        });
      }
      _destroy(error, callback) {
        this._channel.close().catch((e) => null);
        super._destroy(error, callback);
      }
    };
  }
});

// node_modules/playwright-core/lib/client/artifact.js
var require_artifact2 = __commonJS({
  "node_modules/playwright-core/lib/client/artifact.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Artifact = void 0;
    var fs = _interopRequireWildcard(require("fs"));
    var _stream = require_stream();
    var _fileUtils = require_fileUtils();
    var _channelOwner = require_channelOwner();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Artifact = class extends _channelOwner.ChannelOwner {
      static from(channel) {
        return channel._object;
      }
      pathAfterFinished() {
        return __async(this, null, function* () {
          if (this._connection.isRemote())
            throw new Error(`Path is not available when connecting remotely. Use saveAs() to save a local copy.`);
          return (yield this._channel.pathAfterFinished()).value || null;
        });
      }
      saveAs(path) {
        return __async(this, null, function* () {
          if (!this._connection.isRemote()) {
            yield this._channel.saveAs({
              path
            });
            return;
          }
          const result = yield this._channel.saveAsStream();
          const stream = _stream.Stream.from(result.stream);
          yield (0, _fileUtils.mkdirIfNeeded)(path);
          yield new Promise((resolve, reject) => {
            stream.stream().pipe(fs.createWriteStream(path)).on("finish", resolve).on("error", reject);
          });
        });
      }
      failure() {
        return __async(this, null, function* () {
          return (yield this._channel.failure()).error || null;
        });
      }
      createReadStream() {
        return __async(this, null, function* () {
          const result = yield this._channel.stream();
          if (!result.stream)
            return null;
          const stream = _stream.Stream.from(result.stream);
          return stream.stream();
        });
      }
      cancel() {
        return __async(this, null, function* () {
          return this._channel.cancel();
        });
      }
      delete() {
        return __async(this, null, function* () {
          return this._channel.delete();
        });
      }
    };
    exports2.Artifact = Artifact;
  }
});

// node_modules/playwright-core/lib/client/tracing.js
var require_tracing2 = __commonJS({
  "node_modules/playwright-core/lib/client/tracing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Tracing = void 0;
    var _artifact = require_artifact2();
    var _channelOwner = require_channelOwner();
    var Tracing = class extends _channelOwner.ChannelOwner {
      static from(channel) {
        return channel._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._localUtils = void 0;
      }
      start() {
        return __async(this, arguments, function* (options = {}) {
          yield this._wrapApiCall(() => __async(this, null, function* () {
            yield this._channel.tracingStart(options);
            yield this._channel.tracingStartChunk({
              title: options.title
            });
          }));
        });
      }
      startChunk() {
        return __async(this, arguments, function* (options = {}) {
          yield this._channel.tracingStartChunk(options);
        });
      }
      stopChunk() {
        return __async(this, arguments, function* (options = {}) {
          yield this._doStopChunk(options.path);
        });
      }
      stop() {
        return __async(this, arguments, function* (options = {}) {
          yield this._wrapApiCall(() => __async(this, null, function* () {
            yield this._doStopChunk(options.path);
            yield this._channel.tracingStop();
          }));
        });
      }
      _doStopChunk(filePath) {
        return __async(this, null, function* () {
          var _result$sourceEntries;
          const isLocal = !this._connection.isRemote();
          let mode = "doNotSave";
          if (filePath) {
            if (isLocal)
              mode = "compressTraceAndSources";
            else
              mode = "compressTrace";
          }
          const result = yield this._channel.tracingStopChunk({
            mode
          });
          if (!filePath) {
            return;
          }
          if (!result.artifact)
            return;
          const artifact = _artifact.Artifact.from(result.artifact);
          yield artifact.saveAs(filePath);
          yield artifact.delete();
          if ((_result$sourceEntries = result.sourceEntries) !== null && _result$sourceEntries !== void 0 && _result$sourceEntries.length)
            yield this._localUtils.zip(filePath, result.sourceEntries);
        });
      }
    };
    exports2.Tracing = Tracing;
  }
});

// node_modules/playwright-core/lib/client/fetch.js
var require_fetch2 = __commonJS({
  "node_modules/playwright-core/lib/client/fetch.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.APIResponse = exports2.APIRequestContext = exports2.APIRequest = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var util = _interopRequireWildcard(require("util"));
    var _errors = require_errors();
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _channelOwner = require_channelOwner();
    var network = _interopRequireWildcard(require_network2());
    var _clientInstrumentation = require_clientInstrumentation();
    var _tracing = require_tracing2();
    var _util$inspect$custom;
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var APIRequest = class {
      constructor(playwright) {
        this._playwright = void 0;
        this._contexts = /* @__PURE__ */ new Set();
        this._onDidCreateContext = void 0;
        this._onWillCloseContext = void 0;
        this._playwright = playwright;
      }
      newContext() {
        return __async(this, arguments, function* (options = {}) {
          var _this$_onDidCreateCon;
          const storageState = typeof options.storageState === "string" ? JSON.parse(yield _fs.default.promises.readFile(options.storageState, "utf8")) : options.storageState;
          const context = APIRequestContext.from((yield this._playwright._channel.newRequest(__spreadProps(__spreadValues({}, options), {
            extraHTTPHeaders: options.extraHTTPHeaders ? (0, _utils.headersObjectToArray)(options.extraHTTPHeaders) : void 0,
            storageState
          }))).request);
          context._tracing._localUtils = this._playwright._utils;
          this._contexts.add(context);
          context._request = this;
          yield (_this$_onDidCreateCon = this._onDidCreateContext) === null || _this$_onDidCreateCon === void 0 ? void 0 : _this$_onDidCreateCon.call(this, context);
          return context;
        });
      }
    };
    exports2.APIRequest = APIRequest;
    var APIRequestContext = class extends _channelOwner.ChannelOwner {
      static from(channel) {
        return channel._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer, (0, _clientInstrumentation.createInstrumentation)());
        this._request = void 0;
        this._tracing = void 0;
        this._tracing = _tracing.Tracing.from(initializer.tracing);
      }
      dispose() {
        return __async(this, null, function* () {
          var _this$_request, _this$_request$_onWil, _this$_request2;
          yield (_this$_request = this._request) === null || _this$_request === void 0 ? void 0 : (_this$_request$_onWil = _this$_request._onWillCloseContext) === null || _this$_request$_onWil === void 0 ? void 0 : _this$_request$_onWil.call(_this$_request, this);
          yield this._channel.dispose();
          (_this$_request2 = this._request) === null || _this$_request2 === void 0 ? void 0 : _this$_request2._contexts.delete(this);
        });
      }
      delete(url, options) {
        return __async(this, null, function* () {
          return this.fetch(url, __spreadProps(__spreadValues({}, options), {
            method: "DELETE"
          }));
        });
      }
      head(url, options) {
        return __async(this, null, function* () {
          return this.fetch(url, __spreadProps(__spreadValues({}, options), {
            method: "HEAD"
          }));
        });
      }
      get(url, options) {
        return __async(this, null, function* () {
          return this.fetch(url, __spreadProps(__spreadValues({}, options), {
            method: "GET"
          }));
        });
      }
      patch(url, options) {
        return __async(this, null, function* () {
          return this.fetch(url, __spreadProps(__spreadValues({}, options), {
            method: "PATCH"
          }));
        });
      }
      post(url, options) {
        return __async(this, null, function* () {
          return this.fetch(url, __spreadProps(__spreadValues({}, options), {
            method: "POST"
          }));
        });
      }
      put(url, options) {
        return __async(this, null, function* () {
          return this.fetch(url, __spreadProps(__spreadValues({}, options), {
            method: "PUT"
          }));
        });
      }
      fetch(_0) {
        return __async(this, arguments, function* (urlOrRequest, options = {}) {
          return this._wrapApiCall(() => __async(this, null, function* () {
            const request = urlOrRequest instanceof network.Request ? urlOrRequest : void 0;
            (0, _utils.assert)(request || typeof urlOrRequest === "string", "First argument must be either URL string or Request");
            (0, _utils.assert)((options.data === void 0 ? 0 : 1) + (options.form === void 0 ? 0 : 1) + (options.multipart === void 0 ? 0 : 1) <= 1, `Only one of 'data', 'form' or 'multipart' can be specified`);
            const url = request ? request.url() : urlOrRequest;
            const params = (0, _utils.objectToArray)(options.params);
            const method = options.method || (request === null || request === void 0 ? void 0 : request.method());
            const headersObj = options.headers || (request === null || request === void 0 ? void 0 : request.headers());
            const headers = headersObj ? (0, _utils.headersObjectToArray)(headersObj) : void 0;
            let jsonData;
            let formData;
            let multipartData;
            let postDataBuffer;
            if (options.data !== void 0) {
              if ((0, _utils.isString)(options.data)) {
                if (isJsonContentType(headers))
                  jsonData = options.data;
                else
                  postDataBuffer = Buffer.from(options.data, "utf8");
              } else if (Buffer.isBuffer(options.data)) {
                postDataBuffer = options.data;
              } else if (typeof options.data === "object" || typeof options.data === "number" || typeof options.data === "boolean") {
                jsonData = options.data;
              } else {
                throw new Error(`Unexpected 'data' type`);
              }
            } else if (options.form) {
              formData = (0, _utils.objectToArray)(options.form);
            } else if (options.multipart) {
              multipartData = [];
              for (const [name, value] of Object.entries(options.multipart)) {
                if ((0, _utils.isFilePayload)(value)) {
                  const payload = value;
                  if (!Buffer.isBuffer(payload.buffer))
                    throw new Error(`Unexpected buffer type of 'data.${name}'`);
                  multipartData.push({
                    name,
                    file: filePayloadToJson(payload)
                  });
                } else if (value instanceof _fs.default.ReadStream) {
                  multipartData.push({
                    name,
                    file: yield readStreamToJson(value)
                  });
                } else {
                  multipartData.push({
                    name,
                    value: String(value)
                  });
                }
              }
            }
            if (postDataBuffer === void 0 && jsonData === void 0 && formData === void 0 && multipartData === void 0)
              postDataBuffer = (request === null || request === void 0 ? void 0 : request.postDataBuffer()) || void 0;
            const postData = postDataBuffer ? postDataBuffer.toString("base64") : void 0;
            const result = yield this._channel.fetch({
              url,
              params,
              method,
              headers,
              postData,
              jsonData,
              formData,
              multipartData,
              timeout: options.timeout,
              failOnStatusCode: options.failOnStatusCode,
              ignoreHTTPSErrors: options.ignoreHTTPSErrors
            });
            return new APIResponse(this, result.response);
          }));
        });
      }
      storageState() {
        return __async(this, arguments, function* (options = {}) {
          const state = yield this._channel.storageState();
          if (options.path) {
            yield (0, _fileUtils.mkdirIfNeeded)(options.path);
            yield _fs.default.promises.writeFile(options.path, JSON.stringify(state, void 0, 2), "utf8");
          }
          return state;
        });
      }
    };
    exports2.APIRequestContext = APIRequestContext;
    _util$inspect$custom = util.inspect.custom;
    var APIResponse = class {
      constructor(context, initializer) {
        this._initializer = void 0;
        this._headers = void 0;
        this._request = void 0;
        this._request = context;
        this._initializer = initializer;
        this._headers = new network.RawHeaders(this._initializer.headers);
      }
      ok() {
        return this._initializer.status >= 200 && this._initializer.status <= 299;
      }
      url() {
        return this._initializer.url;
      }
      status() {
        return this._initializer.status;
      }
      statusText() {
        return this._initializer.statusText;
      }
      headers() {
        return this._headers.headers();
      }
      headersArray() {
        return this._headers.headersArray();
      }
      body() {
        return __async(this, null, function* () {
          try {
            const result = yield this._request._channel.fetchResponseBody({
              fetchUid: this._fetchUid()
            });
            if (result.binary === void 0)
              throw new Error("Response has been disposed");
            return Buffer.from(result.binary, "base64");
          } catch (e) {
            if (e.message.includes(_errors.kBrowserOrContextClosedError))
              throw new Error("Response has been disposed");
            throw e;
          }
        });
      }
      text() {
        return __async(this, null, function* () {
          const content = yield this.body();
          return content.toString("utf8");
        });
      }
      json() {
        return __async(this, null, function* () {
          const content = yield this.text();
          return JSON.parse(content);
        });
      }
      dispose() {
        return __async(this, null, function* () {
          yield this._request._channel.disposeAPIResponse({
            fetchUid: this._fetchUid()
          });
        });
      }
      [_util$inspect$custom]() {
        const headers = this.headersArray().map(({
          name,
          value
        }) => `  ${name}: ${value}`);
        return `APIResponse: ${this.status()} ${this.statusText()}
${headers.join("\n")}`;
      }
      _fetchUid() {
        return this._initializer.fetchUid;
      }
      _fetchLog() {
        return __async(this, null, function* () {
          const {
            log
          } = yield this._request._channel.fetchLog({
            fetchUid: this._fetchUid()
          });
          return log;
        });
      }
    };
    exports2.APIResponse = APIResponse;
    function filePayloadToJson(payload) {
      return {
        name: payload.name,
        mimeType: payload.mimeType,
        buffer: payload.buffer.toString("base64")
      };
    }
    function readStreamToJson(stream) {
      return __async(this, null, function* () {
        const buffer = yield new Promise((resolve, reject) => {
          const chunks = [];
          stream.on("data", (chunk) => chunks.push(chunk));
          stream.on("end", () => resolve(Buffer.concat(chunks)));
          stream.on("error", (err) => reject(err));
        });
        const streamPath = Buffer.isBuffer(stream.path) ? stream.path.toString("utf8") : stream.path;
        return {
          name: _path.default.basename(streamPath),
          buffer: buffer.toString("base64")
        };
      });
    }
    function isJsonContentType(headers) {
      if (!headers)
        return false;
      for (const {
        name,
        value
      } of headers) {
        if (name.toLocaleLowerCase() === "content-type")
          return value === "application/json";
      }
      return false;
    }
  }
});

// node_modules/playwright-core/lib/client/network.js
var require_network2 = __commonJS({
  "node_modules/playwright-core/lib/client/network.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WebSocket = exports2.RouteHandler = exports2.Route = exports2.Response = exports2.Request = exports2.RawHeaders = void 0;
    exports2.validateHeaders = validateHeaders;
    var _url = require("url");
    var _channelOwner = require_channelOwner();
    var _frame = require_frame();
    var _fs = _interopRequireDefault(require("fs"));
    var mime = _interopRequireWildcard(require_mime());
    var _utils = require_utils();
    var _manualPromise = require_manualPromise();
    var _events = require_events();
    var _waiter = require_waiter();
    var _clientHelper = require_clientHelper();
    var _multimap = require_multimap();
    var _fetch = require_fetch2();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Request = class extends _channelOwner.ChannelOwner {
      static from(request) {
        return request._object;
      }
      static fromNullable(request) {
        return request ? Request.from(request) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._redirectedFrom = null;
        this._redirectedTo = null;
        this._failureText = null;
        this._provisionalHeaders = void 0;
        this._actualHeadersPromise = void 0;
        this._postData = void 0;
        this._timing = void 0;
        this._redirectedFrom = Request.fromNullable(initializer.redirectedFrom);
        if (this._redirectedFrom)
          this._redirectedFrom._redirectedTo = this;
        this._provisionalHeaders = new RawHeaders(initializer.headers);
        this._postData = initializer.postData !== void 0 ? Buffer.from(initializer.postData, "base64") : null;
        this._timing = {
          startTime: 0,
          domainLookupStart: -1,
          domainLookupEnd: -1,
          connectStart: -1,
          secureConnectionStart: -1,
          connectEnd: -1,
          requestStart: -1,
          responseStart: -1,
          responseEnd: -1
        };
      }
      url() {
        return this._initializer.url;
      }
      resourceType() {
        return this._initializer.resourceType;
      }
      method() {
        return this._initializer.method;
      }
      postData() {
        return this._postData ? this._postData.toString("utf8") : null;
      }
      postDataBuffer() {
        return this._postData;
      }
      postDataJSON() {
        const postData = this.postData();
        if (!postData)
          return null;
        const contentType = this.headers()["content-type"];
        if (contentType === "application/x-www-form-urlencoded") {
          const entries = {};
          const parsed = new _url.URLSearchParams(postData);
          for (const [k, v] of parsed.entries())
            entries[k] = v;
          return entries;
        }
        try {
          return JSON.parse(postData);
        } catch (e) {
          throw new Error("POST data is not a valid JSON object: " + postData);
        }
      }
      headers() {
        return this._provisionalHeaders.headers();
      }
      _actualHeaders() {
        if (!this._actualHeadersPromise) {
          this._actualHeadersPromise = this._wrapApiCall(() => __async(this, null, function* () {
            return new RawHeaders((yield this._channel.rawRequestHeaders()).headers);
          }));
        }
        return this._actualHeadersPromise;
      }
      allHeaders() {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).headers();
        });
      }
      headersArray() {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).headersArray();
        });
      }
      headerValue(name) {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).get(name);
        });
      }
      response() {
        return __async(this, null, function* () {
          return Response.fromNullable((yield this._channel.response()).response);
        });
      }
      _internalResponse() {
        return __async(this, null, function* () {
          return this._wrapApiCall(() => __async(this, null, function* () {
            return Response.fromNullable((yield this._channel.response()).response);
          }), true);
        });
      }
      frame() {
        return _frame.Frame.from(this._initializer.frame);
      }
      isNavigationRequest() {
        return this._initializer.isNavigationRequest;
      }
      redirectedFrom() {
        return this._redirectedFrom;
      }
      redirectedTo() {
        return this._redirectedTo;
      }
      failure() {
        if (this._failureText === null)
          return null;
        return {
          errorText: this._failureText
        };
      }
      timing() {
        return this._timing;
      }
      sizes() {
        return __async(this, null, function* () {
          const response = yield this.response();
          if (!response)
            throw new Error("Unable to fetch sizes for failed request");
          return (yield response._channel.sizes()).sizes;
        });
      }
      _finalRequest() {
        return this._redirectedTo ? this._redirectedTo._finalRequest() : this;
      }
    };
    exports2.Request = Request;
    var Route = class extends _channelOwner.ChannelOwner {
      static from(route) {
        return route._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      request() {
        return Request.from(this._initializer.request);
      }
      _raceWithPageClose(promise) {
        const page = this.request().frame()._page;
        return Promise.race([promise, page ? page._closedOrCrashedPromise : Promise.resolve()]);
      }
      abort(errorCode) {
        return __async(this, null, function* () {
          yield this._raceWithPageClose(this._channel.abort({
            errorCode
          }));
        });
      }
      fulfill() {
        return __async(this, arguments, function* (options = {}) {
          let fetchResponseUid;
          let {
            status: statusOption,
            headers: headersOption,
            body
          } = options;
          if (options.response) {
            statusOption || (statusOption = options.response.status());
            headersOption || (headersOption = options.response.headers());
            if (options.body === void 0 && options.path === void 0 && options.response instanceof _fetch.APIResponse) {
              if (options.response._request._connection === this._connection)
                fetchResponseUid = options.response._fetchUid();
              else
                body = yield options.response.body();
            }
          }
          let isBase64 = false;
          let length = 0;
          if (options.path) {
            const buffer = yield _fs.default.promises.readFile(options.path);
            body = buffer.toString("base64");
            isBase64 = true;
            length = buffer.length;
          } else if ((0, _utils.isString)(body)) {
            isBase64 = false;
            length = Buffer.byteLength(body);
          } else if (body) {
            length = body.length;
            body = body.toString("base64");
            isBase64 = true;
          }
          const headers = {};
          for (const header of Object.keys(headersOption || {}))
            headers[header.toLowerCase()] = String(headersOption[header]);
          if (options.contentType)
            headers["content-type"] = String(options.contentType);
          else if (options.path)
            headers["content-type"] = mime.getType(options.path) || "application/octet-stream";
          if (length && !("content-length" in headers))
            headers["content-length"] = String(length);
          yield this._raceWithPageClose(this._channel.fulfill({
            status: statusOption || 200,
            headers: (0, _utils.headersObjectToArray)(headers),
            body,
            isBase64,
            fetchResponseUid
          }));
        });
      }
      continue() {
        return __async(this, arguments, function* (options = {}) {
          yield this._continue(options);
        });
      }
      _internalContinue() {
        return __async(this, arguments, function* (options = {}) {
          yield this._continue(options, true).catch(() => {
          });
        });
      }
      _continue(options, isInternal) {
        return __async(this, null, function* () {
          return yield this._wrapApiCall(() => __async(this, null, function* () {
            const postDataBuffer = (0, _utils.isString)(options.postData) ? Buffer.from(options.postData, "utf8") : options.postData;
            yield this._raceWithPageClose(this._channel.continue({
              url: options.url,
              method: options.method,
              headers: options.headers ? (0, _utils.headersObjectToArray)(options.headers) : void 0,
              postData: postDataBuffer ? postDataBuffer.toString("base64") : void 0
            }));
          }), isInternal);
        });
      }
    };
    exports2.Route = Route;
    var Response = class extends _channelOwner.ChannelOwner {
      static from(response) {
        return response._object;
      }
      static fromNullable(response) {
        return response ? Response.from(response) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._provisionalHeaders = void 0;
        this._actualHeadersPromise = void 0;
        this._request = void 0;
        this._finishedPromise = new _manualPromise.ManualPromise();
        this._provisionalHeaders = new RawHeaders(initializer.headers);
        this._request = Request.from(this._initializer.request);
        Object.assign(this._request._timing, this._initializer.timing);
      }
      url() {
        return this._initializer.url;
      }
      ok() {
        return this._initializer.status === 0 || this._initializer.status >= 200 && this._initializer.status <= 299;
      }
      status() {
        return this._initializer.status;
      }
      statusText() {
        return this._initializer.statusText;
      }
      headers() {
        return this._provisionalHeaders.headers();
      }
      _actualHeaders() {
        return __async(this, null, function* () {
          if (!this._actualHeadersPromise) {
            this._actualHeadersPromise = (() => __async(this, null, function* () {
              return new RawHeaders((yield this._channel.rawResponseHeaders()).headers);
            }))();
          }
          return this._actualHeadersPromise;
        });
      }
      allHeaders() {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).headers();
        });
      }
      headersArray() {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).headersArray().slice();
        });
      }
      headerValue(name) {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).get(name);
        });
      }
      headerValues(name) {
        return __async(this, null, function* () {
          return (yield this._actualHeaders()).getAll(name);
        });
      }
      finished() {
        return __async(this, null, function* () {
          return this._finishedPromise.then(() => null);
        });
      }
      body() {
        return __async(this, null, function* () {
          return Buffer.from((yield this._channel.body()).binary, "base64");
        });
      }
      text() {
        return __async(this, null, function* () {
          const content = yield this.body();
          return content.toString("utf8");
        });
      }
      json() {
        return __async(this, null, function* () {
          const content = yield this.text();
          return JSON.parse(content);
        });
      }
      request() {
        return this._request;
      }
      frame() {
        return this._request.frame();
      }
      serverAddr() {
        return __async(this, null, function* () {
          return (yield this._channel.serverAddr()).value || null;
        });
      }
      securityDetails() {
        return __async(this, null, function* () {
          return (yield this._channel.securityDetails()).value || null;
        });
      }
    };
    exports2.Response = Response;
    var WebSocket = class extends _channelOwner.ChannelOwner {
      static from(webSocket) {
        return webSocket._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._page = void 0;
        this._isClosed = void 0;
        this._isClosed = false;
        this._page = parent;
        this._channel.on("frameSent", (event) => {
          if (event.opcode === 1)
            this.emit(_events.Events.WebSocket.FrameSent, {
              payload: event.data
            });
          else if (event.opcode === 2)
            this.emit(_events.Events.WebSocket.FrameSent, {
              payload: Buffer.from(event.data, "base64")
            });
        });
        this._channel.on("frameReceived", (event) => {
          if (event.opcode === 1)
            this.emit(_events.Events.WebSocket.FrameReceived, {
              payload: event.data
            });
          else if (event.opcode === 2)
            this.emit(_events.Events.WebSocket.FrameReceived, {
              payload: Buffer.from(event.data, "base64")
            });
        });
        this._channel.on("socketError", ({
          error
        }) => this.emit(_events.Events.WebSocket.Error, error));
        this._channel.on("close", () => {
          this._isClosed = true;
          this.emit(_events.Events.WebSocket.Close, this);
        });
      }
      url() {
        return this._initializer.url;
      }
      isClosed() {
        return this._isClosed;
      }
      waitForEvent(_0) {
        return __async(this, arguments, function* (event, optionsOrPredicate = {}) {
          return this._wrapApiCall(() => __async(this, null, function* () {
            const timeout = this._page._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
            const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
            const waiter = _waiter.Waiter.createForEvent(this, event);
            waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
            if (event !== _events.Events.WebSocket.Error)
              waiter.rejectOnEvent(this, _events.Events.WebSocket.Error, new Error("Socket error"));
            if (event !== _events.Events.WebSocket.Close)
              waiter.rejectOnEvent(this, _events.Events.WebSocket.Close, new Error("Socket closed"));
            waiter.rejectOnEvent(this._page, _events.Events.Page.Close, new Error("Page closed"));
            const result = yield waiter.waitForEvent(this, event, predicate);
            waiter.dispose();
            return result;
          }));
        });
      }
    };
    exports2.WebSocket = WebSocket;
    function validateHeaders(headers) {
      for (const key of Object.keys(headers)) {
        const value = headers[key];
        if (!Object.is(value, void 0) && !(0, _utils.isString)(value))
          throw new Error(`Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
      }
    }
    var RouteHandler = class {
      constructor(baseURL, url, handler, times = Number.MAX_SAFE_INTEGER) {
        this.handledCount = 0;
        this._baseURL = void 0;
        this._times = void 0;
        this.url = void 0;
        this.handler = void 0;
        this._baseURL = baseURL;
        this._times = times;
        this.url = url;
        this.handler = handler;
      }
      matches(requestURL) {
        return (0, _clientHelper.urlMatches)(this._baseURL, requestURL, this.url);
      }
      handle(route, request) {
        ++this.handledCount;
        this.handler(route, request);
      }
      isActive() {
        return this.handledCount < this._times;
      }
    };
    exports2.RouteHandler = RouteHandler;
    var RawHeaders = class {
      constructor(headers) {
        this._headersArray = void 0;
        this._headersMap = new _multimap.MultiMap();
        this._headersArray = headers;
        for (const header of headers)
          this._headersMap.set(header.name.toLowerCase(), header.value);
      }
      get(name) {
        const values = this.getAll(name);
        if (!values || !values.length)
          return null;
        return values.join(name.toLowerCase() === "set-cookie" ? "\n" : ", ");
      }
      getAll(name) {
        return [...this._headersMap.get(name.toLowerCase())];
      }
      headers() {
        const result = {};
        for (const name of this._headersMap.keys())
          result[name] = this.get(name);
        return result;
      }
      headersArray() {
        return this._headersArray;
      }
    };
    exports2.RawHeaders = RawHeaders;
  }
});

// node_modules/playwright-core/lib/client/types.js
var require_types2 = __commonJS({
  "node_modules/playwright-core/lib/client/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.kLifecycleEvents = void 0;
    var kLifecycleEvents = /* @__PURE__ */ new Set(["load", "domcontentloaded", "networkidle", "commit"]);
    exports2.kLifecycleEvents = kLifecycleEvents;
  }
});

// node_modules/playwright-core/lib/client/frame.js
var require_frame = __commonJS({
  "node_modules/playwright-core/lib/client/frame.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Frame = void 0;
    exports2.verifyLoadState = verifyLoadState;
    var _utils = require_utils();
    var _channelOwner = require_channelOwner();
    var _locator = require_locator();
    var _elementHandle = require_elementHandle();
    var _jsHandle = require_jsHandle();
    var _fs = _interopRequireDefault(require("fs"));
    var network = _interopRequireWildcard(require_network2());
    var _events = require("events");
    var _waiter = require_waiter();
    var _events2 = require_events();
    var _types = require_types2();
    var _clientHelper = require_clientHelper();
    var _debugLogger = require_debugLogger();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Frame = class extends _channelOwner.ChannelOwner {
      static from(frame) {
        return frame._object;
      }
      static fromNullable(frame) {
        return frame ? Frame.from(frame) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._eventEmitter = void 0;
        this._loadStates = void 0;
        this._parentFrame = null;
        this._url = "";
        this._name = "";
        this._detached = false;
        this._childFrames = /* @__PURE__ */ new Set();
        this._page = void 0;
        this._eventEmitter = new _events.EventEmitter();
        this._eventEmitter.setMaxListeners(0);
        this._parentFrame = Frame.fromNullable(initializer.parentFrame);
        if (this._parentFrame)
          this._parentFrame._childFrames.add(this);
        this._name = initializer.name;
        this._url = initializer.url;
        this._loadStates = new Set(initializer.loadStates);
        this._channel.on("loadstate", (event) => {
          if (event.add) {
            this._loadStates.add(event.add);
            this._eventEmitter.emit("loadstate", event.add);
          }
          if (event.remove)
            this._loadStates.delete(event.remove);
        });
        this._channel.on("navigated", (event) => {
          this._url = event.url;
          this._name = event.name;
          this._eventEmitter.emit("navigated", event);
          if (!event.error && this._page)
            this._page.emit(_events2.Events.Page.FrameNavigated, this);
        });
      }
      page() {
        return this._page;
      }
      goto(_0) {
        return __async(this, arguments, function* (url, options = {}) {
          const waitUntil = verifyLoadState("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          return network.Response.fromNullable((yield this._channel.goto(__spreadProps(__spreadValues({
            url
          }, options), {
            waitUntil
          }))).response);
        });
      }
      _setupNavigationWaiter(options) {
        const waiter = new _waiter.Waiter(this._page, "");
        if (this._page.isClosed())
          waiter.rejectImmediately(new Error("Navigation failed because page was closed!"));
        waiter.rejectOnEvent(this._page, _events2.Events.Page.Close, new Error("Navigation failed because page was closed!"));
        waiter.rejectOnEvent(this._page, _events2.Events.Page.Crash, new Error("Navigation failed because page crashed!"));
        waiter.rejectOnEvent(this._page, _events2.Events.Page.FrameDetached, new Error("Navigating frame was detached!"), (frame) => frame === this);
        const timeout = this._page._timeoutSettings.navigationTimeout(options);
        waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded.`);
        return waiter;
      }
      waitForNavigation() {
        return __async(this, arguments, function* (options = {}) {
          return this._page._wrapApiCall(() => __async(this, null, function* () {
            const waitUntil = verifyLoadState("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
            const waiter = this._setupNavigationWaiter(options);
            const toUrl = typeof options.url === "string" ? ` to "${options.url}"` : "";
            waiter.log(`waiting for navigation${toUrl} until "${waitUntil}"`);
            const navigatedEvent = yield waiter.waitForEvent(this._eventEmitter, "navigated", (event) => {
              var _this$_page;
              if (event.error)
                return true;
              waiter.log(`  navigated to "${event.url}"`);
              return (0, _clientHelper.urlMatches)((_this$_page = this._page) === null || _this$_page === void 0 ? void 0 : _this$_page.context()._options.baseURL, event.url, options.url);
            });
            if (navigatedEvent.error) {
              const e = new Error(navigatedEvent.error);
              e.stack = "";
              yield waiter.waitForPromise(Promise.reject(e));
            }
            if (!this._loadStates.has(waitUntil)) {
              yield waiter.waitForEvent(this._eventEmitter, "loadstate", (s) => {
                waiter.log(`  "${s}" event fired`);
                return s === waitUntil;
              });
            }
            const request = navigatedEvent.newDocument ? network.Request.fromNullable(navigatedEvent.newDocument.request) : null;
            const response = request ? yield waiter.waitForPromise(request._finalRequest()._internalResponse()) : null;
            waiter.dispose();
            return response;
          }));
        });
      }
      waitForLoadState() {
        return __async(this, arguments, function* (state = "load", options = {}) {
          state = verifyLoadState("state", state);
          if (this._loadStates.has(state))
            return;
          return this._page._wrapApiCall(() => __async(this, null, function* () {
            const waiter = this._setupNavigationWaiter(options);
            yield waiter.waitForEvent(this._eventEmitter, "loadstate", (s) => {
              waiter.log(`  "${s}" event fired`);
              return s === state;
            });
            waiter.dispose();
          }));
        });
      }
      waitForURL(_0) {
        return __async(this, arguments, function* (url, options = {}) {
          var _this$_page2;
          if ((0, _clientHelper.urlMatches)((_this$_page2 = this._page) === null || _this$_page2 === void 0 ? void 0 : _this$_page2.context()._options.baseURL, this.url(), url))
            return yield this.waitForLoadState(options.waitUntil, options);
          yield this.waitForNavigation(__spreadValues({
            url
          }, options));
        });
      }
      frameElement() {
        return __async(this, null, function* () {
          return _elementHandle.ElementHandle.from((yield this._channel.frameElement()).element);
        });
      }
      evaluateHandle(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          const result = yield this._channel.evaluateExpressionHandle({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
      evaluate(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          const result = yield this._channel.evaluateExpression({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      $(selector, options) {
        return __async(this, null, function* () {
          const result = yield this._channel.querySelector(__spreadValues({
            selector
          }, options));
          return _elementHandle.ElementHandle.fromNullable(result.element);
        });
      }
      waitForSelector(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          if (options.visibility)
            throw new Error("options.visibility is not supported, did you mean options.state?");
          if (options.waitFor && options.waitFor !== "visible")
            throw new Error("options.waitFor is not supported, did you mean options.state?");
          const result = yield this._channel.waitForSelector(__spreadValues({
            selector
          }, options));
          return _elementHandle.ElementHandle.fromNullable(result.element);
        });
      }
      dispatchEvent(_0, _1, _2) {
        return __async(this, arguments, function* (selector, type, eventInit, options = {}) {
          yield this._channel.dispatchEvent(__spreadValues({
            selector,
            type,
            eventInit: (0, _jsHandle.serializeArgument)(eventInit)
          }, options));
        });
      }
      $eval(_0, _1, _2) {
        return __async(this, arguments, function* (selector, pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
          const result = yield this._channel.evalOnSelector({
            selector,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      $$eval(_0, _1, _2) {
        return __async(this, arguments, function* (selector, pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
          const result = yield this._channel.evalOnSelectorAll({
            selector,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      $$(selector) {
        return __async(this, null, function* () {
          const result = yield this._channel.querySelectorAll({
            selector
          });
          return result.elements.map((e) => _elementHandle.ElementHandle.from(e));
        });
      }
      _queryCount(selector) {
        return __async(this, null, function* () {
          return (yield this._channel.queryCount({
            selector
          })).value;
        });
      }
      content() {
        return __async(this, null, function* () {
          return (yield this._channel.content()).value;
        });
      }
      setContent(_0) {
        return __async(this, arguments, function* (html, options = {}) {
          const waitUntil = verifyLoadState("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          yield this._channel.setContent(__spreadProps(__spreadValues({
            html
          }, options), {
            waitUntil
          }));
        });
      }
      name() {
        return this._name || "";
      }
      url() {
        return this._url;
      }
      parentFrame() {
        return this._parentFrame;
      }
      childFrames() {
        return Array.from(this._childFrames);
      }
      isDetached() {
        return this._detached;
      }
      addScriptTag() {
        return __async(this, arguments, function* (options = {}) {
          const copy = __spreadValues({}, options);
          if (copy.path) {
            copy.content = (yield _fs.default.promises.readFile(copy.path)).toString();
            copy.content += "//# sourceURL=" + copy.path.replace(/\n/g, "");
          }
          return _elementHandle.ElementHandle.from((yield this._channel.addScriptTag(__spreadValues({}, copy))).element);
        });
      }
      addStyleTag() {
        return __async(this, arguments, function* (options = {}) {
          const copy = __spreadValues({}, options);
          if (copy.path) {
            copy.content = (yield _fs.default.promises.readFile(copy.path)).toString();
            copy.content += "/*# sourceURL=" + copy.path.replace(/\n/g, "") + "*/";
          }
          return _elementHandle.ElementHandle.from((yield this._channel.addStyleTag(__spreadValues({}, copy))).element);
        });
      }
      click(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return yield this._channel.click(__spreadValues({
            selector
          }, options));
        });
      }
      dblclick(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return yield this._channel.dblclick(__spreadValues({
            selector
          }, options));
        });
      }
      dragAndDrop(_0, _1) {
        return __async(this, arguments, function* (source, target, options = {}) {
          return yield this._channel.dragAndDrop(__spreadValues({
            source,
            target
          }, options));
        });
      }
      tap(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return yield this._channel.tap(__spreadValues({
            selector
          }, options));
        });
      }
      fill(_0, _1) {
        return __async(this, arguments, function* (selector, value, options = {}) {
          return yield this._channel.fill(__spreadValues({
            selector,
            value
          }, options));
        });
      }
      _highlight(selector) {
        return __async(this, null, function* () {
          return yield this._channel.highlight({
            selector
          });
        });
      }
      locator(selector, options) {
        return new _locator.Locator(this, selector, options);
      }
      frameLocator(selector) {
        return new _locator.FrameLocator(this, selector);
      }
      focus(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          yield this._channel.focus(__spreadValues({
            selector
          }, options));
        });
      }
      textContent(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          const value = (yield this._channel.textContent(__spreadValues({
            selector
          }, options))).value;
          return value === void 0 ? null : value;
        });
      }
      innerText(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.innerText(__spreadValues({
            selector
          }, options))).value;
        });
      }
      innerHTML(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.innerHTML(__spreadValues({
            selector
          }, options))).value;
        });
      }
      getAttribute(_0, _1) {
        return __async(this, arguments, function* (selector, name, options = {}) {
          const value = (yield this._channel.getAttribute(__spreadValues({
            selector,
            name
          }, options))).value;
          return value === void 0 ? null : value;
        });
      }
      inputValue(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.inputValue(__spreadValues({
            selector
          }, options))).value;
        });
      }
      isChecked(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.isChecked(__spreadValues({
            selector
          }, options))).value;
        });
      }
      isDisabled(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.isDisabled(__spreadValues({
            selector
          }, options))).value;
        });
      }
      isEditable(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.isEditable(__spreadValues({
            selector
          }, options))).value;
        });
      }
      isEnabled(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.isEnabled(__spreadValues({
            selector
          }, options))).value;
        });
      }
      isHidden(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.isHidden(__spreadValues({
            selector
          }, options))).value;
        });
      }
      isVisible(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          return (yield this._channel.isVisible(__spreadValues({
            selector
          }, options))).value;
        });
      }
      hover(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          yield this._channel.hover(__spreadValues({
            selector
          }, options));
        });
      }
      selectOption(_0, _1) {
        return __async(this, arguments, function* (selector, values, options = {}) {
          return (yield this._channel.selectOption(__spreadValues(__spreadValues({
            selector
          }, (0, _elementHandle.convertSelectOptionValues)(values)), options))).values;
        });
      }
      setInputFiles(_0, _1) {
        return __async(this, arguments, function* (selector, files, options = {}) {
          const converted = yield (0, _elementHandle.convertInputFiles)(files, this.page().context());
          if (converted.files) {
            yield this._channel.setInputFiles(__spreadValues({
              selector,
              files: converted.files
            }, options));
          } else {
            _debugLogger.debugLogger.log("api", "switching to large files mode");
            yield this._channel.setInputFilePaths(__spreadValues(__spreadValues({
              selector
            }, converted), options));
          }
        });
      }
      type(_0, _1) {
        return __async(this, arguments, function* (selector, text, options = {}) {
          yield this._channel.type(__spreadValues({
            selector,
            text
          }, options));
        });
      }
      press(_0, _1) {
        return __async(this, arguments, function* (selector, key, options = {}) {
          yield this._channel.press(__spreadValues({
            selector,
            key
          }, options));
        });
      }
      check(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          yield this._channel.check(__spreadValues({
            selector
          }, options));
        });
      }
      uncheck(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          yield this._channel.uncheck(__spreadValues({
            selector
          }, options));
        });
      }
      setChecked(selector, checked, options) {
        return __async(this, null, function* () {
          if (checked)
            yield this.check(selector, options);
          else
            yield this.uncheck(selector, options);
        });
      }
      waitForTimeout(timeout) {
        return __async(this, null, function* () {
          yield this._channel.waitForTimeout({
            timeout
          });
        });
      }
      waitForFunction(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg, options = {}) {
          if (typeof options.polling === "string")
            (0, _utils.assert)(options.polling === "raf", "Unknown polling option: " + options.polling);
          const result = yield this._channel.waitForFunction(__spreadProps(__spreadValues({}, options), {
            pollingInterval: options.polling === "raf" ? void 0 : options.polling,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          }));
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
      title() {
        return __async(this, null, function* () {
          return (yield this._channel.title()).value;
        });
      }
    };
    exports2.Frame = Frame;
    function verifyLoadState(name, waitUntil) {
      if (waitUntil === "networkidle0")
        waitUntil = "networkidle";
      if (!_types.kLifecycleEvents.has(waitUntil))
        throw new Error(`${name}: expected one of (load|domcontentloaded|networkidle|commit)`);
      return waitUntil;
    }
  }
});

// node_modules/playwright-core/lib/client/writableStream.js
var require_writableStream = __commonJS({
  "node_modules/playwright-core/lib/client/writableStream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.WritableStream = void 0;
    var _stream = require("stream");
    var _channelOwner = require_channelOwner();
    var WritableStream = class extends _channelOwner.ChannelOwner {
      static from(Stream) {
        return Stream._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      stream() {
        return new WritableStreamImpl(this._channel);
      }
    };
    exports2.WritableStream = WritableStream;
    var WritableStreamImpl = class extends _stream.Writable {
      constructor(channel) {
        super();
        this._channel = void 0;
        this._channel = channel;
      }
      _write(chunk, encoding, callback) {
        return __async(this, null, function* () {
          const error = yield this._channel.write({
            binary: chunk.toString("base64")
          }).catch((e) => e);
          callback(error || null);
        });
      }
      _final(callback) {
        return __async(this, null, function* () {
          const error = yield this._channel.close().catch((e) => e);
          callback(error || null);
        });
      }
    };
  }
});

// node_modules/playwright-core/lib/client/elementHandle.js
var require_elementHandle = __commonJS({
  "node_modules/playwright-core/lib/client/elementHandle.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ElementHandle = void 0;
    exports2.convertInputFiles = convertInputFiles;
    exports2.convertSelectOptionValues = convertSelectOptionValues;
    exports2.determineScreenshotType = determineScreenshotType;
    var _frame = require_frame();
    var _jsHandle = require_jsHandle();
    var _fs = _interopRequireDefault(require("fs"));
    var mime = _interopRequireWildcard(require_mime());
    var _path = _interopRequireDefault(require("path"));
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _writableStream = require_writableStream();
    var _stream = require("stream");
    var _util = require("util");
    var _debugLogger = require_debugLogger();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var pipelineAsync = (0, _util.promisify)(_stream.pipeline);
    var ElementHandle = class extends _jsHandle.JSHandle {
      static from(handle) {
        return handle._object;
      }
      static fromNullable(handle) {
        return handle ? ElementHandle.from(handle) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._elementChannel = void 0;
        this._elementChannel = this._channel;
      }
      asElement() {
        return this;
      }
      ownerFrame() {
        return __async(this, null, function* () {
          return _frame.Frame.fromNullable((yield this._elementChannel.ownerFrame()).frame);
        });
      }
      contentFrame() {
        return __async(this, null, function* () {
          return _frame.Frame.fromNullable((yield this._elementChannel.contentFrame()).frame);
        });
      }
      getAttribute(name) {
        return __async(this, null, function* () {
          const value = (yield this._elementChannel.getAttribute({
            name
          })).value;
          return value === void 0 ? null : value;
        });
      }
      inputValue() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.inputValue()).value;
        });
      }
      textContent() {
        return __async(this, null, function* () {
          const value = (yield this._elementChannel.textContent()).value;
          return value === void 0 ? null : value;
        });
      }
      innerText() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.innerText()).value;
        });
      }
      innerHTML() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.innerHTML()).value;
        });
      }
      isChecked() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.isChecked()).value;
        });
      }
      isDisabled() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.isDisabled()).value;
        });
      }
      isEditable() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.isEditable()).value;
        });
      }
      isEnabled() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.isEnabled()).value;
        });
      }
      isHidden() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.isHidden()).value;
        });
      }
      isVisible() {
        return __async(this, null, function* () {
          return (yield this._elementChannel.isVisible()).value;
        });
      }
      dispatchEvent(_0) {
        return __async(this, arguments, function* (type, eventInit = {}) {
          yield this._elementChannel.dispatchEvent({
            type,
            eventInit: (0, _jsHandle.serializeArgument)(eventInit)
          });
        });
      }
      scrollIntoViewIfNeeded() {
        return __async(this, arguments, function* (options = {}) {
          yield this._elementChannel.scrollIntoViewIfNeeded(options);
        });
      }
      hover() {
        return __async(this, arguments, function* (options = {}) {
          yield this._elementChannel.hover(options);
        });
      }
      click() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._elementChannel.click(options);
        });
      }
      dblclick() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._elementChannel.dblclick(options);
        });
      }
      tap() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._elementChannel.tap(options);
        });
      }
      selectOption(_0) {
        return __async(this, arguments, function* (values, options = {}) {
          const result = yield this._elementChannel.selectOption(__spreadValues(__spreadValues({}, convertSelectOptionValues(values)), options));
          return result.values;
        });
      }
      fill(_0) {
        return __async(this, arguments, function* (value, options = {}) {
          return yield this._elementChannel.fill(__spreadValues({
            value
          }, options));
        });
      }
      selectText() {
        return __async(this, arguments, function* (options = {}) {
          yield this._elementChannel.selectText(options);
        });
      }
      setInputFiles(_0) {
        return __async(this, arguments, function* (files, options = {}) {
          const frame = yield this.ownerFrame();
          if (!frame)
            throw new Error("Cannot set input files to detached element");
          const converted = yield convertInputFiles(files, frame.page().context());
          if (converted.files) {
            yield this._elementChannel.setInputFiles(__spreadValues({
              files: converted.files
            }, options));
          } else {
            _debugLogger.debugLogger.log("api", "switching to large files mode");
            yield this._elementChannel.setInputFilePaths(__spreadValues(__spreadValues({}, converted), options));
          }
        });
      }
      focus() {
        return __async(this, null, function* () {
          yield this._elementChannel.focus();
        });
      }
      type(_0) {
        return __async(this, arguments, function* (text, options = {}) {
          yield this._elementChannel.type(__spreadValues({
            text
          }, options));
        });
      }
      press(_0) {
        return __async(this, arguments, function* (key, options = {}) {
          yield this._elementChannel.press(__spreadValues({
            key
          }, options));
        });
      }
      check() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._elementChannel.check(options);
        });
      }
      uncheck() {
        return __async(this, arguments, function* (options = {}) {
          return yield this._elementChannel.uncheck(options);
        });
      }
      setChecked(checked, options) {
        return __async(this, null, function* () {
          if (checked)
            yield this.check(options);
          else
            yield this.uncheck(options);
        });
      }
      boundingBox() {
        return __async(this, null, function* () {
          const value = (yield this._elementChannel.boundingBox()).value;
          return value === void 0 ? null : value;
        });
      }
      screenshot() {
        return __async(this, arguments, function* (options = {}) {
          const copy = __spreadProps(__spreadValues({}, options), {
            mask: void 0
          });
          if (!copy.type)
            copy.type = determineScreenshotType(options);
          if (options.mask) {
            copy.mask = options.mask.map((locator) => ({
              frame: locator._frame._channel,
              selector: locator._selector
            }));
          }
          copy.fonts = options._fonts;
          const result = yield this._elementChannel.screenshot(copy);
          const buffer = Buffer.from(result.binary, "base64");
          if (options.path) {
            yield (0, _fileUtils.mkdirIfNeeded)(options.path);
            yield _fs.default.promises.writeFile(options.path, buffer);
          }
          return buffer;
        });
      }
      $(selector) {
        return __async(this, null, function* () {
          return ElementHandle.fromNullable((yield this._elementChannel.querySelector({
            selector
          })).element);
        });
      }
      $$(selector) {
        return __async(this, null, function* () {
          const result = yield this._elementChannel.querySelectorAll({
            selector
          });
          return result.elements.map((h) => ElementHandle.from(h));
        });
      }
      $eval(selector, pageFunction, arg) {
        return __async(this, null, function* () {
          const result = yield this._elementChannel.evalOnSelector({
            selector,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      $$eval(selector, pageFunction, arg) {
        return __async(this, null, function* () {
          const result = yield this._elementChannel.evalOnSelectorAll({
            selector,
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      waitForElementState(_0) {
        return __async(this, arguments, function* (state, options = {}) {
          return yield this._elementChannel.waitForElementState(__spreadValues({
            state
          }, options));
        });
      }
      waitForSelector(_0) {
        return __async(this, arguments, function* (selector, options = {}) {
          const result = yield this._elementChannel.waitForSelector(__spreadValues({
            selector
          }, options));
          return ElementHandle.fromNullable(result.element);
        });
      }
    };
    exports2.ElementHandle = ElementHandle;
    function convertSelectOptionValues(values) {
      if (values === null)
        return {};
      if (!Array.isArray(values))
        values = [values];
      if (!values.length)
        return {};
      for (let i = 0; i < values.length; i++)
        (0, _utils.assert)(values[i] !== null, `options[${i}]: expected object, got null`);
      if (values[0] instanceof ElementHandle)
        return {
          elements: values.map((v) => v._elementChannel)
        };
      if ((0, _utils.isString)(values[0]))
        return {
          options: values.map((value) => ({
            value
          }))
        };
      return {
        options: values
      };
    }
    function convertInputFiles(files, context) {
      return __async(this, null, function* () {
        const items = Array.isArray(files) ? files.slice() : [files];
        const sizeLimit = 50 * 1024 * 1024;
        const hasLargeBuffer = items.find((item) => typeof item === "object" && item.buffer && item.buffer.byteLength > sizeLimit);
        if (hasLargeBuffer)
          throw new Error("Cannot set buffer larger than 50Mb, please write it to a file and pass its path instead.");
        const stats = yield Promise.all(items.filter(_utils.isString).map((item) => _fs.default.promises.stat(item)));
        const hasLargeFile = !!stats.find((s) => s.size > sizeLimit);
        if (hasLargeFile) {
          if (context._connection.isRemote()) {
            const streams = yield Promise.all(items.map((item) => __async(this, null, function* () {
              (0, _utils.assert)((0, _utils.isString)(item));
              const {
                writableStream: stream
              } = yield context._channel.createTempFile({
                name: _path.default.basename(item)
              });
              const writable = _writableStream.WritableStream.from(stream);
              yield pipelineAsync(_fs.default.createReadStream(item), writable.stream());
              return stream;
            })));
            return {
              streams
            };
          }
          return {
            localPaths: items
          };
        }
        const filePayloads = yield Promise.all(items.map((item) => __async(this, null, function* () {
          if (typeof item === "string") {
            return {
              name: _path.default.basename(item),
              buffer: (yield _fs.default.promises.readFile(item)).toString("base64")
            };
          } else {
            return {
              name: item.name,
              mimeType: item.mimeType,
              buffer: item.buffer.toString("base64")
            };
          }
        })));
        return {
          files: filePayloads
        };
      });
    }
    function determineScreenshotType(options) {
      if (options.path) {
        const mimeType = mime.getType(options.path);
        if (mimeType === "image/png")
          return "png";
        else if (mimeType === "image/jpeg")
          return "jpeg";
        throw new Error(`path: unsupported mime type "${mimeType}"`);
      }
      return options.type;
    }
  }
});

// node_modules/playwright-core/lib/client/worker.js
var require_worker = __commonJS({
  "node_modules/playwright-core/lib/client/worker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Worker = void 0;
    var _events = require_events();
    var _channelOwner = require_channelOwner();
    var _jsHandle = require_jsHandle();
    var Worker = class extends _channelOwner.ChannelOwner {
      static from(worker) {
        return worker._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._page = void 0;
        this._context = void 0;
        this._channel.on("close", () => {
          if (this._page)
            this._page._workers.delete(this);
          if (this._context)
            this._context._serviceWorkers.delete(this);
          this.emit(_events.Events.Worker.Close, this);
        });
      }
      url() {
        return this._initializer.url;
      }
      evaluate(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          const result = yield this._channel.evaluateExpression({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      evaluateHandle(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          const result = yield this._channel.evaluateExpressionHandle({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
    };
    exports2.Worker = Worker;
  }
});

// node_modules/playwright-core/lib/client/input.js
var require_input2 = __commonJS({
  "node_modules/playwright-core/lib/client/input.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Touchscreen = exports2.Mouse = exports2.Keyboard = void 0;
    var Keyboard = class {
      constructor(page) {
        this._page = void 0;
        this._page = page;
      }
      down(key) {
        return __async(this, null, function* () {
          yield this._page._channel.keyboardDown({
            key
          });
        });
      }
      up(key) {
        return __async(this, null, function* () {
          yield this._page._channel.keyboardUp({
            key
          });
        });
      }
      insertText(text) {
        return __async(this, null, function* () {
          yield this._page._channel.keyboardInsertText({
            text
          });
        });
      }
      type(_0) {
        return __async(this, arguments, function* (text, options = {}) {
          yield this._page._channel.keyboardType(__spreadValues({
            text
          }, options));
        });
      }
      press(_0) {
        return __async(this, arguments, function* (key, options = {}) {
          yield this._page._channel.keyboardPress(__spreadValues({
            key
          }, options));
        });
      }
    };
    exports2.Keyboard = Keyboard;
    var Mouse = class {
      constructor(page) {
        this._page = void 0;
        this._page = page;
      }
      move(_0, _1) {
        return __async(this, arguments, function* (x, y, options = {}) {
          yield this._page._channel.mouseMove(__spreadValues({
            x,
            y
          }, options));
        });
      }
      down() {
        return __async(this, arguments, function* (options = {}) {
          yield this._page._channel.mouseDown(__spreadValues({}, options));
        });
      }
      up() {
        return __async(this, arguments, function* (options = {}) {
          yield this._page._channel.mouseUp(options);
        });
      }
      click(_0, _1) {
        return __async(this, arguments, function* (x, y, options = {}) {
          yield this._page._channel.mouseClick(__spreadValues({
            x,
            y
          }, options));
        });
      }
      dblclick(_0, _1) {
        return __async(this, arguments, function* (x, y, options = {}) {
          yield this.click(x, y, __spreadProps(__spreadValues({}, options), {
            clickCount: 2
          }));
        });
      }
      wheel(deltaX, deltaY) {
        return __async(this, null, function* () {
          yield this._page._channel.mouseWheel({
            deltaX,
            deltaY
          });
        });
      }
    };
    exports2.Mouse = Mouse;
    var Touchscreen = class {
      constructor(page) {
        this._page = void 0;
        this._page = page;
      }
      tap(x, y) {
        return __async(this, null, function* () {
          yield this._page._channel.touchscreenTap({
            x,
            y
          });
        });
      }
    };
    exports2.Touchscreen = Touchscreen;
  }
});

// node_modules/playwright-core/lib/client/fileChooser.js
var require_fileChooser2 = __commonJS({
  "node_modules/playwright-core/lib/client/fileChooser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FileChooser = void 0;
    var FileChooser = class {
      constructor(page, elementHandle, isMultiple) {
        this._page = void 0;
        this._elementHandle = void 0;
        this._isMultiple = void 0;
        this._page = page;
        this._elementHandle = elementHandle;
        this._isMultiple = isMultiple;
      }
      element() {
        return this._elementHandle;
      }
      isMultiple() {
        return this._isMultiple;
      }
      page() {
        return this._page;
      }
      setFiles(files, options) {
        return __async(this, null, function* () {
          return this._elementHandle.setInputFiles(files, options);
        });
      }
    };
    exports2.FileChooser = FileChooser;
  }
});

// node_modules/playwright-core/lib/client/coverage.js
var require_coverage = __commonJS({
  "node_modules/playwright-core/lib/client/coverage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Coverage = void 0;
    var Coverage = class {
      constructor(channel) {
        this._channel = void 0;
        this._channel = channel;
      }
      startJSCoverage() {
        return __async(this, arguments, function* (options = {}) {
          yield this._channel.startJSCoverage(options);
        });
      }
      stopJSCoverage() {
        return __async(this, null, function* () {
          return (yield this._channel.stopJSCoverage()).entries;
        });
      }
      startCSSCoverage() {
        return __async(this, arguments, function* (options = {}) {
          yield this._channel.startCSSCoverage(options);
        });
      }
      stopCSSCoverage() {
        return __async(this, null, function* () {
          return (yield this._channel.stopCSSCoverage()).entries;
        });
      }
    };
    exports2.Coverage = Coverage;
  }
});

// node_modules/playwright-core/lib/client/video.js
var require_video = __commonJS({
  "node_modules/playwright-core/lib/client/video.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Video = void 0;
    var Video = class {
      constructor(page, connection) {
        this._artifact = null;
        this._artifactCallback = (artifact) => {
        };
        this._isRemote = false;
        this._isRemote = connection.isRemote();
        this._artifact = Promise.race([new Promise((f) => this._artifactCallback = f), page._closedOrCrashedPromise.then(() => null)]);
      }
      _artifactReady(artifact) {
        this._artifactCallback(artifact);
      }
      path() {
        return __async(this, null, function* () {
          if (this._isRemote)
            throw new Error(`Path is not available when connecting remotely. Use saveAs() to save a local copy.`);
          const artifact = yield this._artifact;
          if (!artifact)
            throw new Error("Page did not produce any video frames");
          return artifact._initializer.absolutePath;
        });
      }
      saveAs(path) {
        return __async(this, null, function* () {
          const artifact = yield this._artifact;
          if (!artifact)
            throw new Error("Page did not produce any video frames");
          return artifact.saveAs(path);
        });
      }
      delete() {
        return __async(this, null, function* () {
          const artifact = yield this._artifact;
          if (artifact)
            yield artifact.delete();
        });
      }
    };
    exports2.Video = Video;
  }
});

// node_modules/playwright-core/lib/client/page.js
var require_page2 = __commonJS({
  "node_modules/playwright-core/lib/client/page.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Page = exports2.BindingCall = void 0;
    var _events = require_events();
    var _utils = require_utils();
    var _timeoutSettings = require_timeoutSettings();
    var _serializers = require_serializers();
    var _accessibility = require_accessibility2();
    var _channelOwner = require_channelOwner();
    var _consoleMessage = require_consoleMessage();
    var _dialog = require_dialog2();
    var _download = require_download3();
    var _elementHandle = require_elementHandle();
    var _worker = require_worker();
    var _frame = require_frame();
    var _input = require_input2();
    var _jsHandle = require_jsHandle();
    var _network = require_network2();
    var _fileChooser = require_fileChooser2();
    var _buffer = require("buffer");
    var _coverage = require_coverage();
    var _waiter = require_waiter();
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var _clientHelper = require_clientHelper();
    var _fileUtils = require_fileUtils();
    var _errors = require_errors();
    var _video = require_video();
    var _artifact = require_artifact2();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Page = class extends _channelOwner.ChannelOwner {
      static from(page) {
        return page._object;
      }
      static fromNullable(page) {
        return page ? Page.from(page) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._browserContext = void 0;
        this._ownedContext = void 0;
        this._mainFrame = void 0;
        this._frames = /* @__PURE__ */ new Set();
        this._workers = /* @__PURE__ */ new Set();
        this._closed = false;
        this._closedOrCrashedPromise = void 0;
        this._viewportSize = void 0;
        this._routes = [];
        this.accessibility = void 0;
        this.coverage = void 0;
        this.keyboard = void 0;
        this.mouse = void 0;
        this.request = void 0;
        this.touchscreen = void 0;
        this._bindings = /* @__PURE__ */ new Map();
        this._timeoutSettings = void 0;
        this._video = null;
        this._opener = void 0;
        this._browserContext = parent;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings(this._browserContext._timeoutSettings);
        this.accessibility = new _accessibility.Accessibility(this._channel);
        this.keyboard = new _input.Keyboard(this);
        this.mouse = new _input.Mouse(this);
        this.request = this._browserContext.request;
        this.touchscreen = new _input.Touchscreen(this);
        this._mainFrame = _frame.Frame.from(initializer.mainFrame);
        this._mainFrame._page = this;
        this._frames.add(this._mainFrame);
        this._viewportSize = initializer.viewportSize || null;
        this._closed = initializer.isClosed;
        this._opener = Page.fromNullable(initializer.opener);
        this._channel.on("bindingCall", ({
          binding
        }) => this._onBinding(BindingCall.from(binding)));
        this._channel.on("close", () => this._onClose());
        this._channel.on("console", ({
          message
        }) => this.emit(_events.Events.Page.Console, _consoleMessage.ConsoleMessage.from(message)));
        this._channel.on("crash", () => this._onCrash());
        this._channel.on("dialog", ({
          dialog
        }) => {
          const dialogObj = _dialog.Dialog.from(dialog);
          if (!this.emit(_events.Events.Page.Dialog, dialogObj)) {
            if (dialogObj.type() === "beforeunload")
              dialog.accept({}).catch(() => {
              });
            else
              dialog.dismiss().catch(() => {
              });
          }
        });
        this._channel.on("domcontentloaded", () => this.emit(_events.Events.Page.DOMContentLoaded, this));
        this._channel.on("download", ({
          url,
          suggestedFilename,
          artifact
        }) => {
          const artifactObject = _artifact.Artifact.from(artifact);
          this.emit(_events.Events.Page.Download, new _download.Download(this, url, suggestedFilename, artifactObject));
        });
        this._channel.on("fileChooser", ({
          element,
          isMultiple
        }) => this.emit(_events.Events.Page.FileChooser, new _fileChooser.FileChooser(this, _elementHandle.ElementHandle.from(element), isMultiple)));
        this._channel.on("frameAttached", ({
          frame
        }) => this._onFrameAttached(_frame.Frame.from(frame)));
        this._channel.on("frameDetached", ({
          frame
        }) => this._onFrameDetached(_frame.Frame.from(frame)));
        this._channel.on("load", () => this.emit(_events.Events.Page.Load, this));
        this._channel.on("pageError", ({
          error
        }) => this.emit(_events.Events.Page.PageError, (0, _serializers.parseError)(error)));
        this._channel.on("route", ({
          route,
          request
        }) => this._onRoute(_network.Route.from(route), _network.Request.from(request)));
        this._channel.on("video", ({
          artifact
        }) => {
          const artifactObject = _artifact.Artifact.from(artifact);
          this._forceVideo()._artifactReady(artifactObject);
        });
        this._channel.on("webSocket", ({
          webSocket
        }) => this.emit(_events.Events.Page.WebSocket, _network.WebSocket.from(webSocket)));
        this._channel.on("worker", ({
          worker
        }) => this._onWorker(_worker.Worker.from(worker)));
        this.coverage = new _coverage.Coverage(this._channel);
        this._closedOrCrashedPromise = Promise.race([new Promise((f) => this.once(_events.Events.Page.Close, f)), new Promise((f) => this.once(_events.Events.Page.Crash, f))]);
      }
      _onFrameAttached(frame) {
        frame._page = this;
        this._frames.add(frame);
        if (frame._parentFrame)
          frame._parentFrame._childFrames.add(frame);
        this.emit(_events.Events.Page.FrameAttached, frame);
      }
      _onFrameDetached(frame) {
        this._frames.delete(frame);
        frame._detached = true;
        if (frame._parentFrame)
          frame._parentFrame._childFrames.delete(frame);
        this.emit(_events.Events.Page.FrameDetached, frame);
      }
      _onRoute(route, request) {
        for (const routeHandler of this._routes) {
          if (routeHandler.matches(request.url())) {
            try {
              routeHandler.handle(route, request);
            } finally {
              if (!routeHandler.isActive()) {
                this._routes.splice(this._routes.indexOf(routeHandler), 1);
                if (!this._routes.length)
                  this._wrapApiCall(() => this._disableInterception(), true).catch(() => {
                  });
              }
            }
            return;
          }
        }
        this._browserContext._onRoute(route, request);
      }
      _onBinding(bindingCall) {
        return __async(this, null, function* () {
          const func = this._bindings.get(bindingCall._initializer.name);
          if (func) {
            yield bindingCall.call(func);
            return;
          }
          yield this._browserContext._onBinding(bindingCall);
        });
      }
      _onWorker(worker) {
        this._workers.add(worker);
        worker._page = this;
        this.emit(_events.Events.Page.Worker, worker);
      }
      _onClose() {
        this._closed = true;
        this._browserContext._pages.delete(this);
        this._browserContext._backgroundPages.delete(this);
        this.emit(_events.Events.Page.Close, this);
      }
      _onCrash() {
        this.emit(_events.Events.Page.Crash, this);
      }
      context() {
        return this._browserContext;
      }
      opener() {
        return __async(this, null, function* () {
          if (!this._opener || this._opener.isClosed())
            return null;
          return this._opener;
        });
      }
      mainFrame() {
        return this._mainFrame;
      }
      frame(frameSelector) {
        const name = (0, _utils.isString)(frameSelector) ? frameSelector : frameSelector.name;
        const url = (0, _utils.isObject)(frameSelector) ? frameSelector.url : void 0;
        (0, _utils.assert)(name || url, "Either name or url matcher should be specified");
        return this.frames().find((f) => {
          if (name)
            return f.name() === name;
          return (0, _clientHelper.urlMatches)(this._browserContext._options.baseURL, f.url(), url);
        }) || null;
      }
      frames() {
        return [...this._frames];
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
        this._wrapApiCall(() => __async(this, null, function* () {
          this._channel.setDefaultNavigationTimeoutNoReply({
            timeout
          });
        }), true);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._wrapApiCall(() => __async(this, null, function* () {
          this._channel.setDefaultTimeoutNoReply({
            timeout
          });
        }), true);
      }
      _forceVideo() {
        if (!this._video)
          this._video = new _video.Video(this, this._connection);
        return this._video;
      }
      video() {
        if (!this._browserContext._options.recordVideo)
          return null;
        return this._forceVideo();
      }
      $(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.$(selector, options);
        });
      }
      waitForSelector(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.waitForSelector(selector, options);
        });
      }
      dispatchEvent(selector, type, eventInit, options) {
        return __async(this, null, function* () {
          return this._mainFrame.dispatchEvent(selector, type, eventInit, options);
        });
      }
      evaluateHandle(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          return this._mainFrame.evaluateHandle(pageFunction, arg);
        });
      }
      $eval(_0, _1, _2) {
        return __async(this, arguments, function* (selector, pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
          return this._mainFrame.$eval(selector, pageFunction, arg);
        });
      }
      $$eval(_0, _1, _2) {
        return __async(this, arguments, function* (selector, pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 3);
          return this._mainFrame.$$eval(selector, pageFunction, arg);
        });
      }
      $$(selector) {
        return __async(this, null, function* () {
          return this._mainFrame.$$(selector);
        });
      }
      addScriptTag() {
        return __async(this, arguments, function* (options = {}) {
          return this._mainFrame.addScriptTag(options);
        });
      }
      addStyleTag() {
        return __async(this, arguments, function* (options = {}) {
          return this._mainFrame.addStyleTag(options);
        });
      }
      exposeFunction(name, callback) {
        return __async(this, null, function* () {
          yield this._channel.exposeBinding({
            name
          });
          const binding = (source, ...args) => callback(...args);
          this._bindings.set(name, binding);
        });
      }
      exposeBinding(_0, _1) {
        return __async(this, arguments, function* (name, callback, options = {}) {
          yield this._channel.exposeBinding({
            name,
            needsHandle: options.handle
          });
          this._bindings.set(name, callback);
        });
      }
      _removeExposedBindings() {
        return __async(this, null, function* () {
          this._bindings.clear();
          yield this._channel.removeExposedBindings();
        });
      }
      setExtraHTTPHeaders(headers) {
        return __async(this, null, function* () {
          (0, _network.validateHeaders)(headers);
          yield this._channel.setExtraHTTPHeaders({
            headers: (0, _utils.headersObjectToArray)(headers)
          });
        });
      }
      url() {
        return this._mainFrame.url();
      }
      content() {
        return __async(this, null, function* () {
          return this._mainFrame.content();
        });
      }
      setContent(html, options) {
        return __async(this, null, function* () {
          return this._mainFrame.setContent(html, options);
        });
      }
      goto(url, options) {
        return __async(this, null, function* () {
          return this._mainFrame.goto(url, options);
        });
      }
      reload() {
        return __async(this, arguments, function* (options = {}) {
          const waitUntil = (0, _frame.verifyLoadState)("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          return _network.Response.fromNullable((yield this._channel.reload(__spreadProps(__spreadValues({}, options), {
            waitUntil
          }))).response);
        });
      }
      waitForLoadState(state, options) {
        return __async(this, null, function* () {
          return this._mainFrame.waitForLoadState(state, options);
        });
      }
      waitForNavigation(options) {
        return __async(this, null, function* () {
          return this._mainFrame.waitForNavigation(options);
        });
      }
      waitForURL(url, options) {
        return __async(this, null, function* () {
          return this._mainFrame.waitForURL(url, options);
        });
      }
      waitForRequest(_0) {
        return __async(this, arguments, function* (urlOrPredicate, options = {}) {
          const predicate = (request) => {
            if ((0, _utils.isString)(urlOrPredicate) || (0, _utils.isRegExp)(urlOrPredicate))
              return (0, _clientHelper.urlMatches)(this._browserContext._options.baseURL, request.url(), urlOrPredicate);
            return urlOrPredicate(request);
          };
          const trimmedUrl = trimUrl(urlOrPredicate);
          const logLine = trimmedUrl ? `waiting for request ${trimmedUrl}` : void 0;
          return this._waitForEvent(_events.Events.Page.Request, {
            predicate,
            timeout: options.timeout
          }, logLine);
        });
      }
      waitForResponse(_0) {
        return __async(this, arguments, function* (urlOrPredicate, options = {}) {
          const predicate = (response) => {
            if ((0, _utils.isString)(urlOrPredicate) || (0, _utils.isRegExp)(urlOrPredicate))
              return (0, _clientHelper.urlMatches)(this._browserContext._options.baseURL, response.url(), urlOrPredicate);
            return urlOrPredicate(response);
          };
          const trimmedUrl = trimUrl(urlOrPredicate);
          const logLine = trimmedUrl ? `waiting for response ${trimmedUrl}` : void 0;
          return this._waitForEvent(_events.Events.Page.Response, {
            predicate,
            timeout: options.timeout
          }, logLine);
        });
      }
      waitForEvent(_0) {
        return __async(this, arguments, function* (event, optionsOrPredicate = {}) {
          return this._waitForEvent(event, optionsOrPredicate, `waiting for event "${event}"`);
        });
      }
      _waitForEvent(event, optionsOrPredicate, logLine) {
        return __async(this, null, function* () {
          return this._wrapApiCall(() => __async(this, null, function* () {
            const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
            const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
            const waiter = _waiter.Waiter.createForEvent(this, event);
            if (logLine)
              waiter.log(logLine);
            waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
            if (event !== _events.Events.Page.Crash)
              waiter.rejectOnEvent(this, _events.Events.Page.Crash, new Error("Page crashed"));
            if (event !== _events.Events.Page.Close)
              waiter.rejectOnEvent(this, _events.Events.Page.Close, new Error("Page closed"));
            const result = yield waiter.waitForEvent(this, event, predicate);
            waiter.dispose();
            return result;
          }));
        });
      }
      goBack() {
        return __async(this, arguments, function* (options = {}) {
          const waitUntil = (0, _frame.verifyLoadState)("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          return _network.Response.fromNullable((yield this._channel.goBack(__spreadProps(__spreadValues({}, options), {
            waitUntil
          }))).response);
        });
      }
      goForward() {
        return __async(this, arguments, function* (options = {}) {
          const waitUntil = (0, _frame.verifyLoadState)("waitUntil", options.waitUntil === void 0 ? "load" : options.waitUntil);
          return _network.Response.fromNullable((yield this._channel.goForward(__spreadProps(__spreadValues({}, options), {
            waitUntil
          }))).response);
        });
      }
      emulateMedia() {
        return __async(this, arguments, function* (options = {}) {
          yield this._channel.emulateMedia({
            media: options.media === null ? "null" : options.media,
            colorScheme: options.colorScheme === null ? "null" : options.colorScheme,
            reducedMotion: options.reducedMotion === null ? "null" : options.reducedMotion,
            forcedColors: options.forcedColors === null ? "null" : options.forcedColors
          });
        });
      }
      setViewportSize(viewportSize) {
        return __async(this, null, function* () {
          this._viewportSize = viewportSize;
          yield this._channel.setViewportSize({
            viewportSize
          });
        });
      }
      viewportSize() {
        return this._viewportSize;
      }
      evaluate(_0, _1) {
        return __async(this, arguments, function* (pageFunction, arg) {
          (0, _jsHandle.assertMaxArguments)(arguments.length, 2);
          return this._mainFrame.evaluate(pageFunction, arg);
        });
      }
      addInitScript(script, arg) {
        return __async(this, null, function* () {
          const source = yield (0, _clientHelper.evaluationScript)(script, arg);
          yield this._channel.addInitScript({
            source
          });
        });
      }
      _removeInitScripts() {
        return __async(this, null, function* () {
          yield this._channel.removeInitScripts();
        });
      }
      route(_0, _1) {
        return __async(this, arguments, function* (url, handler, options = {}) {
          this._routes.unshift(new _network.RouteHandler(this._browserContext._options.baseURL, url, handler, options.times));
          if (this._routes.length === 1)
            yield this._channel.setNetworkInterceptionEnabled({
              enabled: true
            });
        });
      }
      unroute(url, handler) {
        return __async(this, null, function* () {
          this._routes = this._routes.filter((route) => route.url !== url || handler && route.handler !== handler);
          if (!this._routes.length)
            yield this._disableInterception();
        });
      }
      _unrouteAll() {
        return __async(this, null, function* () {
          this._routes = [];
          yield this._disableInterception();
        });
      }
      _disableInterception() {
        return __async(this, null, function* () {
          yield this._channel.setNetworkInterceptionEnabled({
            enabled: false
          });
        });
      }
      screenshot() {
        return __async(this, arguments, function* (options = {}) {
          const copy = __spreadProps(__spreadValues({}, options), {
            mask: void 0
          });
          if (!copy.type)
            copy.type = (0, _elementHandle.determineScreenshotType)(options);
          if (options.mask) {
            copy.mask = options.mask.map((locator) => ({
              frame: locator._frame._channel,
              selector: locator._selector
            }));
          }
          copy.fonts = options._fonts;
          const result = yield this._channel.screenshot(copy);
          const buffer = _buffer.Buffer.from(result.binary, "base64");
          if (options.path) {
            yield (0, _fileUtils.mkdirIfNeeded)(options.path);
            yield _fs.default.promises.writeFile(options.path, buffer);
          }
          return buffer;
        });
      }
      _expectScreenshot(customStackTrace, options) {
        return __async(this, null, function* () {
          return this._wrapApiCall(() => __async(this, null, function* () {
            var _options$screenshotOp, _options$screenshotOp2;
            const mask = (_options$screenshotOp = options.screenshotOptions) !== null && _options$screenshotOp !== void 0 && _options$screenshotOp.mask ? (_options$screenshotOp2 = options.screenshotOptions) === null || _options$screenshotOp2 === void 0 ? void 0 : _options$screenshotOp2.mask.map((locator2) => ({
              frame: locator2._frame._channel,
              selector: locator2._selector
            })) : void 0;
            const locator = options.locator ? {
              frame: options.locator._frame._channel,
              selector: options.locator._selector
            } : void 0;
            const expected = options.expected ? options.expected.toString("base64") : void 0;
            const result = yield this._channel.expectScreenshot(__spreadProps(__spreadValues({}, options), {
              isNot: !!options.isNot,
              expected,
              locator,
              screenshotOptions: __spreadProps(__spreadValues({}, options.screenshotOptions), {
                mask
              })
            }));
            return {
              log: result.log,
              actual: result.actual ? _buffer.Buffer.from(result.actual, "base64") : void 0,
              previous: result.previous ? _buffer.Buffer.from(result.previous, "base64") : void 0,
              diff: result.diff ? _buffer.Buffer.from(result.diff, "base64") : void 0,
              errorMessage: result.errorMessage
            };
          }), false, customStackTrace);
        });
      }
      title() {
        return __async(this, null, function* () {
          return this._mainFrame.title();
        });
      }
      bringToFront() {
        return __async(this, null, function* () {
          yield this._channel.bringToFront();
        });
      }
      close() {
        return __async(this, arguments, function* (options = {
          runBeforeUnload: void 0
        }) {
          try {
            if (this._ownedContext)
              yield this._ownedContext.close();
            else
              yield this._channel.close(options);
          } catch (e) {
            if ((0, _errors.isSafeCloseError)(e))
              return;
            throw e;
          }
        });
      }
      isClosed() {
        return this._closed;
      }
      click(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.click(selector, options);
        });
      }
      dragAndDrop(source, target, options) {
        return __async(this, null, function* () {
          return this._mainFrame.dragAndDrop(source, target, options);
        });
      }
      dblclick(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.dblclick(selector, options);
        });
      }
      tap(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.tap(selector, options);
        });
      }
      fill(selector, value, options) {
        return __async(this, null, function* () {
          return this._mainFrame.fill(selector, value, options);
        });
      }
      locator(selector, options) {
        return this.mainFrame().locator(selector, options);
      }
      frameLocator(selector) {
        return this.mainFrame().frameLocator(selector);
      }
      focus(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.focus(selector, options);
        });
      }
      textContent(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.textContent(selector, options);
        });
      }
      innerText(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.innerText(selector, options);
        });
      }
      innerHTML(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.innerHTML(selector, options);
        });
      }
      getAttribute(selector, name, options) {
        return __async(this, null, function* () {
          return this._mainFrame.getAttribute(selector, name, options);
        });
      }
      inputValue(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.inputValue(selector, options);
        });
      }
      isChecked(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.isChecked(selector, options);
        });
      }
      isDisabled(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.isDisabled(selector, options);
        });
      }
      isEditable(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.isEditable(selector, options);
        });
      }
      isEnabled(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.isEnabled(selector, options);
        });
      }
      isHidden(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.isHidden(selector, options);
        });
      }
      isVisible(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.isVisible(selector, options);
        });
      }
      hover(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.hover(selector, options);
        });
      }
      selectOption(selector, values, options) {
        return __async(this, null, function* () {
          return this._mainFrame.selectOption(selector, values, options);
        });
      }
      setInputFiles(selector, files, options) {
        return __async(this, null, function* () {
          return this._mainFrame.setInputFiles(selector, files, options);
        });
      }
      type(selector, text, options) {
        return __async(this, null, function* () {
          return this._mainFrame.type(selector, text, options);
        });
      }
      press(selector, key, options) {
        return __async(this, null, function* () {
          return this._mainFrame.press(selector, key, options);
        });
      }
      check(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.check(selector, options);
        });
      }
      uncheck(selector, options) {
        return __async(this, null, function* () {
          return this._mainFrame.uncheck(selector, options);
        });
      }
      setChecked(selector, checked, options) {
        return __async(this, null, function* () {
          return this._mainFrame.setChecked(selector, checked, options);
        });
      }
      waitForTimeout(timeout) {
        return __async(this, null, function* () {
          return this._mainFrame.waitForTimeout(timeout);
        });
      }
      waitForFunction(pageFunction, arg, options) {
        return __async(this, null, function* () {
          return this._mainFrame.waitForFunction(pageFunction, arg, options);
        });
      }
      workers() {
        return [...this._workers];
      }
      on(event, listener) {
        if (event === _events.Events.Page.FileChooser && !this.listenerCount(event))
          this._channel.setFileChooserInterceptedNoReply({
            intercepted: true
          });
        super.on(event, listener);
        return this;
      }
      addListener(event, listener) {
        if (event === _events.Events.Page.FileChooser && !this.listenerCount(event))
          this._channel.setFileChooserInterceptedNoReply({
            intercepted: true
          });
        super.addListener(event, listener);
        return this;
      }
      off(event, listener) {
        super.off(event, listener);
        if (event === _events.Events.Page.FileChooser && !this.listenerCount(event))
          this._channel.setFileChooserInterceptedNoReply({
            intercepted: false
          });
        return this;
      }
      removeListener(event, listener) {
        super.removeListener(event, listener);
        if (event === _events.Events.Page.FileChooser && !this.listenerCount(event))
          this._channel.setFileChooserInterceptedNoReply({
            intercepted: false
          });
        return this;
      }
      pause() {
        return __async(this, null, function* () {
          if (!require("inspector").url())
            yield this.context()._channel.pause();
        });
      }
      pdf() {
        return __async(this, arguments, function* (options = {}) {
          const transportOptions = __spreadValues({}, options);
          if (transportOptions.margin)
            transportOptions.margin = __spreadValues({}, transportOptions.margin);
          if (typeof options.width === "number")
            transportOptions.width = options.width + "px";
          if (typeof options.height === "number")
            transportOptions.height = options.height + "px";
          for (const margin of ["top", "right", "bottom", "left"]) {
            const index = margin;
            if (options.margin && typeof options.margin[index] === "number")
              transportOptions.margin[index] = transportOptions.margin[index] + "px";
          }
          const result = yield this._channel.pdf(transportOptions);
          const buffer = _buffer.Buffer.from(result.pdf, "base64");
          if (options.path) {
            yield _fs.default.promises.mkdir(_path.default.dirname(options.path), {
              recursive: true
            });
            yield _fs.default.promises.writeFile(options.path, buffer);
          }
          return buffer;
        });
      }
      _resetForReuse() {
        return __async(this, null, function* () {
          yield this._unrouteAll();
          yield this._removeInitScripts();
          yield this._removeExposedBindings();
        });
      }
    };
    exports2.Page = Page;
    var BindingCall = class extends _channelOwner.ChannelOwner {
      static from(channel) {
        return channel._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      call(func) {
        return __async(this, null, function* () {
          try {
            const frame = _frame.Frame.from(this._initializer.frame);
            const source = {
              context: frame._page.context(),
              page: frame._page,
              frame
            };
            let result;
            if (this._initializer.handle)
              result = yield func(source, _jsHandle.JSHandle.from(this._initializer.handle));
            else
              result = yield func(source, ...this._initializer.args.map(_jsHandle.parseResult));
            this._channel.resolve({
              result: (0, _jsHandle.serializeArgument)(result)
            }).catch(() => {
            });
          } catch (e) {
            this._channel.reject({
              error: (0, _serializers.serializeError)(e)
            }).catch(() => {
            });
          }
        });
      }
    };
    exports2.BindingCall = BindingCall;
    function trimEnd(s) {
      if (s.length > 50)
        s = s.substring(0, 50) + "\u2026";
      return s;
    }
    function trimUrl(param) {
      if ((0, _utils.isRegExp)(param))
        return `/${trimEnd(param.source)}/${param.flags}`;
      if ((0, _utils.isString)(param))
        return `"${trimEnd(param)}"`;
    }
  }
});

// node_modules/playwright-core/lib/client/cdpSession.js
var require_cdpSession = __commonJS({
  "node_modules/playwright-core/lib/client/cdpSession.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CDPSession = void 0;
    var _channelOwner = require_channelOwner();
    var CDPSession = class extends _channelOwner.ChannelOwner {
      static from(cdpSession) {
        return cdpSession._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._channel.on("event", ({
          method,
          params
        }) => {
          this.emit(method, params);
        });
        this.on = super.on;
        this.addListener = super.addListener;
        this.off = super.removeListener;
        this.removeListener = super.removeListener;
        this.once = super.once;
      }
      send(method, params) {
        return __async(this, null, function* () {
          const result = yield this._channel.send({
            method,
            params
          });
          return result.result;
        });
      }
      detach() {
        return __async(this, null, function* () {
          return this._channel.detach();
        });
      }
    };
    exports2.CDPSession = CDPSession;
  }
});

// node_modules/playwright-core/lib/client/browserContext.js
var require_browserContext2 = __commonJS({
  "node_modules/playwright-core/lib/client/browserContext.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BrowserContext = void 0;
    exports2.prepareBrowserContextParams = prepareBrowserContextParams;
    var _page = require_page2();
    var _frame = require_frame();
    var network = _interopRequireWildcard(require_network2());
    var _fs = _interopRequireDefault(require("fs"));
    var _channelOwner = require_channelOwner();
    var _clientHelper = require_clientHelper();
    var _browser = require_browser4();
    var _worker = require_worker();
    var _events = require_events();
    var _timeoutSettings = require_timeoutSettings();
    var _waiter = require_waiter();
    var _utils = require_utils();
    var _fileUtils = require_fileUtils();
    var _errors = require_errors();
    var _cdpSession = require_cdpSession();
    var _tracing = require_tracing2();
    var _artifact = require_artifact2();
    var _fetch = require_fetch2();
    var _clientInstrumentation = require_clientInstrumentation();
    var _stackTrace = require_stackTrace();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var BrowserContext = class extends _channelOwner.ChannelOwner {
      static from(context) {
        return context._object;
      }
      static fromNullable(context) {
        return context ? BrowserContext.from(context) : null;
      }
      constructor(parent, type, guid, initializer) {
        var _this$_browser;
        super(parent, type, guid, initializer, (0, _clientInstrumentation.createInstrumentation)());
        this._pages = /* @__PURE__ */ new Set();
        this._routes = [];
        this._browser = null;
        this._browserType = void 0;
        this._bindings = /* @__PURE__ */ new Map();
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
        this._ownerPage = void 0;
        this._closedPromise = void 0;
        this._options = {};
        this.request = void 0;
        this.tracing = void 0;
        this._backgroundPages = /* @__PURE__ */ new Set();
        this._serviceWorkers = /* @__PURE__ */ new Set();
        this._isChromium = void 0;
        if (parent instanceof _browser.Browser)
          this._browser = parent;
        this._isChromium = ((_this$_browser = this._browser) === null || _this$_browser === void 0 ? void 0 : _this$_browser._name) === "chromium";
        this.tracing = _tracing.Tracing.from(initializer.tracing);
        this.request = _fetch.APIRequestContext.from(initializer.APIRequestContext);
        this._channel.on("bindingCall", ({
          binding
        }) => this._onBinding(_page.BindingCall.from(binding)));
        this._channel.on("close", () => this._onClose());
        this._channel.on("page", ({
          page
        }) => this._onPage(_page.Page.from(page)));
        this._channel.on("route", ({
          route,
          request
        }) => this._onRoute(network.Route.from(route), network.Request.from(request)));
        this._channel.on("backgroundPage", ({
          page
        }) => {
          const backgroundPage = _page.Page.from(page);
          this._backgroundPages.add(backgroundPage);
          this.emit(_events.Events.BrowserContext.BackgroundPage, backgroundPage);
        });
        this._channel.on("serviceWorker", ({
          worker
        }) => {
          const serviceWorker = _worker.Worker.from(worker);
          serviceWorker._context = this;
          this._serviceWorkers.add(serviceWorker);
          this.emit(_events.Events.BrowserContext.ServiceWorker, serviceWorker);
        });
        this._channel.on("request", ({
          request,
          page
        }) => this._onRequest(network.Request.from(request), _page.Page.fromNullable(page)));
        this._channel.on("requestFailed", ({
          request,
          failureText,
          responseEndTiming,
          page
        }) => this._onRequestFailed(network.Request.from(request), responseEndTiming, failureText, _page.Page.fromNullable(page)));
        this._channel.on("requestFinished", (params) => this._onRequestFinished(params));
        this._channel.on("response", ({
          response,
          page
        }) => this._onResponse(network.Response.from(response), _page.Page.fromNullable(page)));
        this._closedPromise = new Promise((f) => this.once(_events.Events.BrowserContext.Close, f));
      }
      _setBrowserType(browserType) {
        this._browserType = browserType;
        browserType._contexts.add(this);
      }
      _onPage(page) {
        this._pages.add(page);
        this.emit(_events.Events.BrowserContext.Page, page);
        if (page._opener && !page._opener.isClosed())
          page._opener.emit(_events.Events.Page.Popup, page);
      }
      _onRequest(request, page) {
        this.emit(_events.Events.BrowserContext.Request, request);
        if (page)
          page.emit(_events.Events.Page.Request, request);
      }
      _onResponse(response, page) {
        this.emit(_events.Events.BrowserContext.Response, response);
        if (page)
          page.emit(_events.Events.Page.Response, response);
      }
      _onRequestFailed(request, responseEndTiming, failureText, page) {
        request._failureText = failureText || null;
        if (request._timing)
          request._timing.responseEnd = responseEndTiming;
        this.emit(_events.Events.BrowserContext.RequestFailed, request);
        if (page)
          page.emit(_events.Events.Page.RequestFailed, request);
      }
      _onRequestFinished(params) {
        const {
          responseEndTiming
        } = params;
        const request = network.Request.from(params.request);
        const response = network.Response.fromNullable(params.response);
        const page = _page.Page.fromNullable(params.page);
        if (request._timing)
          request._timing.responseEnd = responseEndTiming;
        this.emit(_events.Events.BrowserContext.RequestFinished, request);
        if (page)
          page.emit(_events.Events.Page.RequestFinished, request);
        if (response)
          response._finishedPromise.resolve();
      }
      _onRoute(route, request) {
        for (const routeHandler of this._routes) {
          if (routeHandler.matches(request.url())) {
            try {
              routeHandler.handle(route, request);
            } finally {
              if (!routeHandler.isActive()) {
                this._routes.splice(this._routes.indexOf(routeHandler), 1);
                if (!this._routes.length)
                  this._wrapApiCall(() => this._disableInterception(), true).catch(() => {
                  });
              }
            }
            return;
          }
        }
        route._internalContinue();
      }
      _onBinding(bindingCall) {
        return __async(this, null, function* () {
          const func = this._bindings.get(bindingCall._initializer.name);
          if (!func)
            return;
          yield bindingCall.call(func);
        });
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
        this._wrapApiCall(() => __async(this, null, function* () {
          this._channel.setDefaultNavigationTimeoutNoReply({
            timeout
          });
        }), true);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._wrapApiCall(() => __async(this, null, function* () {
          this._channel.setDefaultTimeoutNoReply({
            timeout
          });
        }), true);
      }
      browser() {
        return this._browser;
      }
      pages() {
        return [...this._pages];
      }
      newPage() {
        return __async(this, null, function* () {
          if (this._ownerPage)
            throw new Error("Please use browser.newContext()");
          return _page.Page.from((yield this._channel.newPage()).page);
        });
      }
      cookies(urls) {
        return __async(this, null, function* () {
          if (!urls)
            urls = [];
          if (urls && typeof urls === "string")
            urls = [urls];
          return (yield this._channel.cookies({
            urls
          })).cookies;
        });
      }
      addCookies(cookies) {
        return __async(this, null, function* () {
          yield this._channel.addCookies({
            cookies
          });
        });
      }
      clearCookies() {
        return __async(this, null, function* () {
          yield this._channel.clearCookies();
        });
      }
      grantPermissions(permissions, options) {
        return __async(this, null, function* () {
          yield this._channel.grantPermissions(__spreadValues({
            permissions
          }, options));
        });
      }
      clearPermissions() {
        return __async(this, null, function* () {
          yield this._channel.clearPermissions();
        });
      }
      setGeolocation(geolocation) {
        return __async(this, null, function* () {
          yield this._channel.setGeolocation({
            geolocation: geolocation || void 0
          });
        });
      }
      setExtraHTTPHeaders(headers) {
        return __async(this, null, function* () {
          network.validateHeaders(headers);
          yield this._channel.setExtraHTTPHeaders({
            headers: (0, _utils.headersObjectToArray)(headers)
          });
        });
      }
      setOffline(offline) {
        return __async(this, null, function* () {
          yield this._channel.setOffline({
            offline
          });
        });
      }
      setHTTPCredentials(httpCredentials) {
        return __async(this, null, function* () {
          yield this._channel.setHTTPCredentials({
            httpCredentials: httpCredentials || void 0
          });
        });
      }
      addInitScript(script, arg) {
        return __async(this, null, function* () {
          const source = yield (0, _clientHelper.evaluationScript)(script, arg);
          yield this._channel.addInitScript({
            source
          });
        });
      }
      _removeInitScripts() {
        return __async(this, null, function* () {
          yield this._channel.removeInitScripts();
        });
      }
      exposeBinding(_0, _1) {
        return __async(this, arguments, function* (name, callback, options = {}) {
          yield this._channel.exposeBinding({
            name,
            needsHandle: options.handle
          });
          this._bindings.set(name, callback);
        });
      }
      _removeExposedBindings() {
        return __async(this, null, function* () {
          this._bindings.clear();
          yield this._channel.removeExposedBindings();
        });
      }
      exposeFunction(name, callback) {
        return __async(this, null, function* () {
          yield this._channel.exposeBinding({
            name
          });
          const binding = (source, ...args) => callback(...args);
          this._bindings.set(name, binding);
        });
      }
      route(_0, _1) {
        return __async(this, arguments, function* (url, handler, options = {}) {
          this._routes.unshift(new network.RouteHandler(this._options.baseURL, url, handler, options.times));
          if (this._routes.length === 1)
            yield this._channel.setNetworkInterceptionEnabled({
              enabled: true
            });
        });
      }
      unroute(url, handler) {
        return __async(this, null, function* () {
          this._routes = this._routes.filter((route) => route.url !== url || handler && route.handler !== handler);
          if (!this._routes.length)
            yield this._disableInterception();
        });
      }
      _unrouteAll() {
        return __async(this, null, function* () {
          this._routes = [];
          yield this._disableInterception();
        });
      }
      _disableInterception() {
        return __async(this, null, function* () {
          yield this._channel.setNetworkInterceptionEnabled({
            enabled: false
          });
        });
      }
      waitForEvent(_0) {
        return __async(this, arguments, function* (event, optionsOrPredicate = {}) {
          return this._wrapApiCall(() => __async(this, null, function* () {
            const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
            const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
            const waiter = _waiter.Waiter.createForEvent(this, event);
            waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
            if (event !== _events.Events.BrowserContext.Close)
              waiter.rejectOnEvent(this, _events.Events.BrowserContext.Close, new Error("Context closed"));
            const result = yield waiter.waitForEvent(this, event, predicate);
            waiter.dispose();
            return result;
          }));
        });
      }
      storageState() {
        return __async(this, arguments, function* (options = {}) {
          const state = yield this._channel.storageState();
          if (options.path) {
            yield (0, _fileUtils.mkdirIfNeeded)(options.path);
            yield _fs.default.promises.writeFile(options.path, JSON.stringify(state, void 0, 2), "utf8");
          }
          return state;
        });
      }
      backgroundPages() {
        return [...this._backgroundPages];
      }
      serviceWorkers() {
        return [...this._serviceWorkers];
      }
      newCDPSession(page) {
        return __async(this, null, function* () {
          if (!(page instanceof _page.Page) && !(page instanceof _frame.Frame))
            throw new Error("page: expected Page or Frame");
          const result = yield this._channel.newCDPSession(page instanceof _page.Page ? {
            page: page._channel
          } : {
            frame: page._channel
          });
          return _cdpSession.CDPSession.from(result.session);
        });
      }
      _onClose() {
        var _this$_browserType, _this$_browserType$_c;
        if (this._browser)
          this._browser._contexts.delete(this);
        (_this$_browserType = this._browserType) === null || _this$_browserType === void 0 ? void 0 : (_this$_browserType$_c = _this$_browserType._contexts) === null || _this$_browserType$_c === void 0 ? void 0 : _this$_browserType$_c.delete(this);
        this.emit(_events.Events.BrowserContext.Close, this);
      }
      close() {
        return __async(this, null, function* () {
          try {
            yield this._wrapApiCall(() => __async(this, null, function* () {
              var _this$_browserType2, _this$_browserType2$_;
              yield (_this$_browserType2 = this._browserType) === null || _this$_browserType2 === void 0 ? void 0 : (_this$_browserType2$_ = _this$_browserType2._onWillCloseContext) === null || _this$_browserType2$_ === void 0 ? void 0 : _this$_browserType2$_.call(_this$_browserType2, this);
              if (this._options.recordHar) {
                const har = yield this._channel.harExport();
                const artifact = _artifact.Artifact.from(har.artifact);
                yield artifact.saveAs(this._options.recordHar.path);
                yield artifact.delete();
              }
            }), true);
            yield this._channel.close();
            yield this._closedPromise;
          } catch (e) {
            if ((0, _errors.isSafeCloseError)(e))
              return;
            throw e;
          }
        });
      }
      _enableRecorder(params) {
        return __async(this, null, function* () {
          yield this._channel.recorderSupplementEnable(params);
        });
      }
      _resetForReuse() {
        return __async(this, null, function* () {
          yield this._unrouteAll();
          yield this._removeInitScripts();
          yield this._removeExposedBindings();
        });
      }
    };
    exports2.BrowserContext = BrowserContext;
    function prepareStorageState(options) {
      return __async(this, null, function* () {
        if (typeof options.storageState !== "string")
          return options.storageState;
        try {
          return JSON.parse(yield _fs.default.promises.readFile(options.storageState, "utf8"));
        } catch (e) {
          (0, _stackTrace.rewriteErrorMessage)(e, `Error reading storage state from ${options.storageState}:
` + e.message);
          throw e;
        }
      });
    }
    function prepareBrowserContextParams(options) {
      return __async(this, null, function* () {
        if (options.videoSize && !options.videosPath)
          throw new Error(`"videoSize" option requires "videosPath" to be specified`);
        if (options.extraHTTPHeaders)
          network.validateHeaders(options.extraHTTPHeaders);
        const contextParams = __spreadProps(__spreadValues({}, options), {
          viewport: options.viewport === null ? void 0 : options.viewport,
          noDefaultViewport: options.viewport === null,
          extraHTTPHeaders: options.extraHTTPHeaders ? (0, _utils.headersObjectToArray)(options.extraHTTPHeaders) : void 0,
          storageState: yield prepareStorageState(options)
        });
        if (!contextParams.recordVideo && options.videosPath) {
          contextParams.recordVideo = {
            dir: options.videosPath,
            size: options.videoSize
          };
        }
        return contextParams;
      });
    }
  }
});

// node_modules/playwright-core/lib/client/browser.js
var require_browser4 = __commonJS({
  "node_modules/playwright-core/lib/client/browser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Browser = void 0;
    var _browserContext = require_browserContext2();
    var _channelOwner = require_channelOwner();
    var _events = require_events();
    var _errors = require_errors();
    var _cdpSession = require_cdpSession();
    var Browser = class extends _channelOwner.ChannelOwner {
      static from(browser) {
        return browser._object;
      }
      static fromNullable(browser) {
        return browser ? Browser.from(browser) : null;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._contexts = /* @__PURE__ */ new Set();
        this._isConnected = true;
        this._closedPromise = void 0;
        this._shouldCloseConnectionOnClose = false;
        this._browserType = void 0;
        this._name = void 0;
        this._localUtils = void 0;
        this._name = initializer.name;
        this._channel.on("close", () => this._didClose());
        this._closedPromise = new Promise((f) => this.once(_events.Events.Browser.Disconnected, f));
      }
      _setBrowserType(browserType) {
        this._browserType = browserType;
        for (const context of this._contexts)
          context._setBrowserType(browserType);
      }
      newContext() {
        return __async(this, arguments, function* (options = {}) {
          var _this$_browserType$_o, _this$_browserType;
          options = __spreadValues(__spreadValues({}, this._browserType._defaultContextOptions), options);
          const contextOptions = yield (0, _browserContext.prepareBrowserContextParams)(options);
          const context = _browserContext.BrowserContext.from((yield this._channel.newContext(contextOptions)).context);
          context._options = contextOptions;
          this._contexts.add(context);
          context._logger = options.logger || this._logger;
          context._setBrowserType(this._browserType);
          context.tracing._localUtils = this._localUtils;
          yield (_this$_browserType$_o = (_this$_browserType = this._browserType)._onDidCreateContext) === null || _this$_browserType$_o === void 0 ? void 0 : _this$_browserType$_o.call(_this$_browserType, context);
          return context;
        });
      }
      contexts() {
        return [...this._contexts];
      }
      version() {
        return this._initializer.version;
      }
      newPage() {
        return __async(this, arguments, function* (options = {}) {
          const context = yield this.newContext(options);
          const page = yield context.newPage();
          page._ownedContext = context;
          context._ownerPage = page;
          return page;
        });
      }
      isConnected() {
        return this._isConnected;
      }
      newBrowserCDPSession() {
        return __async(this, null, function* () {
          return _cdpSession.CDPSession.from((yield this._channel.newBrowserCDPSession()).session);
        });
      }
      startTracing(_0) {
        return __async(this, arguments, function* (page, options = {}) {
          yield this._channel.startTracing(__spreadProps(__spreadValues({}, options), {
            page: page ? page._channel : void 0
          }));
        });
      }
      stopTracing() {
        return __async(this, null, function* () {
          return Buffer.from((yield this._channel.stopTracing()).binary, "base64");
        });
      }
      close() {
        return __async(this, null, function* () {
          try {
            if (this._shouldCloseConnectionOnClose)
              this._connection.close(_errors.kBrowserClosedError);
            else
              yield this._channel.close();
            yield this._closedPromise;
          } catch (e) {
            if ((0, _errors.isSafeCloseError)(e))
              return;
            throw e;
          }
        });
      }
      _didClose() {
        this._isConnected = false;
        this.emit(_events.Events.Browser.Disconnected, this);
      }
    };
    exports2.Browser = Browser;
  }
});

// node_modules/playwright-core/lib/client/browserType.js
var require_browserType2 = __commonJS({
  "node_modules/playwright-core/lib/client/browserType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BrowserType = void 0;
    var _browser3 = require_browser4();
    var _browserContext = require_browserContext2();
    var _channelOwner = require_channelOwner();
    var _connection = require_connection();
    var _events = require_events();
    var _clientHelper = require_clientHelper();
    var _utils = require_utils();
    var _errors = require_errors();
    var _timeoutRunner = require_timeoutRunner();
    var BrowserType = class extends _channelOwner.ChannelOwner {
      constructor(...args) {
        super(...args);
        this._serverLauncher = void 0;
        this._contexts = /* @__PURE__ */ new Set();
        this._playwright = void 0;
        this._defaultContextOptions = void 0;
        this._defaultLaunchOptions = void 0;
        this._onDidCreateContext = void 0;
        this._onWillCloseContext = void 0;
      }
      static from(browserType) {
        return browserType._object;
      }
      executablePath() {
        if (!this._initializer.executablePath)
          throw new Error("Browser is not supported on current platform");
        return this._initializer.executablePath;
      }
      name() {
        return this._initializer.name;
      }
      launch() {
        return __async(this, arguments, function* (options = {}) {
          var _this$_defaultLaunchO;
          const logger = options.logger || ((_this$_defaultLaunchO = this._defaultLaunchOptions) === null || _this$_defaultLaunchO === void 0 ? void 0 : _this$_defaultLaunchO.logger);
          (0, _utils.assert)(!options.userDataDir, "userDataDir option is not supported in `browserType.launch`. Use `browserType.launchPersistentContext` instead");
          (0, _utils.assert)(!options.port, "Cannot specify a port without launching as a server.");
          options = __spreadValues(__spreadValues({}, this._defaultLaunchOptions), options);
          const launchOptions = __spreadProps(__spreadValues({}, options), {
            ignoreDefaultArgs: Array.isArray(options.ignoreDefaultArgs) ? options.ignoreDefaultArgs : void 0,
            ignoreAllDefaultArgs: !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs),
            env: options.env ? (0, _clientHelper.envObjectToArray)(options.env) : void 0
          });
          const browser = _browser3.Browser.from((yield this._channel.launch(launchOptions)).browser);
          browser._logger = logger;
          browser._setBrowserType(this);
          browser._localUtils = this._playwright._utils;
          return browser;
        });
      }
      launchServer() {
        return __async(this, arguments, function* (options = {}) {
          if (!this._serverLauncher)
            throw new Error("Launching server is not supported");
          options = __spreadValues(__spreadValues({}, this._defaultLaunchOptions), options);
          return this._serverLauncher.launchServer(options);
        });
      }
      launchPersistentContext(_0) {
        return __async(this, arguments, function* (userDataDir, options = {}) {
          var _this$_defaultLaunchO2, _this$_onDidCreateCon;
          const logger = options.logger || ((_this$_defaultLaunchO2 = this._defaultLaunchOptions) === null || _this$_defaultLaunchO2 === void 0 ? void 0 : _this$_defaultLaunchO2.logger);
          (0, _utils.assert)(!options.port, "Cannot specify a port without launching as a server.");
          options = __spreadValues(__spreadValues(__spreadValues({}, this._defaultLaunchOptions), this._defaultContextOptions), options);
          const contextParams = yield (0, _browserContext.prepareBrowserContextParams)(options);
          const persistentParams = __spreadProps(__spreadValues({}, contextParams), {
            ignoreDefaultArgs: Array.isArray(options.ignoreDefaultArgs) ? options.ignoreDefaultArgs : void 0,
            ignoreAllDefaultArgs: !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs),
            env: options.env ? (0, _clientHelper.envObjectToArray)(options.env) : void 0,
            channel: options.channel,
            userDataDir
          });
          const result = yield this._channel.launchPersistentContext(persistentParams);
          const context = _browserContext.BrowserContext.from(result.context);
          context._options = contextParams;
          context._logger = logger;
          context._setBrowserType(this);
          context.tracing._localUtils = this._playwright._utils;
          yield (_this$_onDidCreateCon = this._onDidCreateContext) === null || _this$_onDidCreateCon === void 0 ? void 0 : _this$_onDidCreateCon.call(this, context);
          return context;
        });
      }
      connect(optionsOrWsEndpoint, options) {
        return __async(this, null, function* () {
          if (typeof optionsOrWsEndpoint === "string")
            return this._connect(optionsOrWsEndpoint, options);
          (0, _utils.assert)(optionsOrWsEndpoint.wsEndpoint, "options.wsEndpoint is required");
          return this._connect(optionsOrWsEndpoint.wsEndpoint, optionsOrWsEndpoint);
        });
      }
      _connect(_0) {
        return __async(this, arguments, function* (wsEndpoint, params = {}) {
          const logger = params.logger;
          return yield this._wrapApiCall(() => __async(this, null, function* () {
            const deadline = params.timeout ? (0, _utils.monotonicTime)() + params.timeout : 0;
            let browser;
            const headers = __spreadValues({
              "x-playwright-browser": this.name()
            }, params.headers);
            const connectParams = {
              wsEndpoint,
              headers,
              slowMo: params.slowMo,
              timeout: params.timeout
            };
            if (params.__testHookRedirectPortForwarding)
              connectParams.socksProxyRedirectPortForTest = params.__testHookRedirectPortForwarding;
            const {
              pipe
            } = yield this._channel.connect(connectParams);
            const closePipe = () => pipe.close().catch(() => {
            });
            const connection = new _connection.Connection();
            connection.markAsRemote();
            connection.on("close", closePipe);
            let closeError;
            const onPipeClosed = () => {
              var _browser2;
              for (const context of ((_browser = browser) === null || _browser === void 0 ? void 0 : _browser.contexts()) || []) {
                var _browser;
                for (const page of context.pages())
                  page._onClose();
                context._onClose();
              }
              (_browser2 = browser) === null || _browser2 === void 0 ? void 0 : _browser2._didClose();
              connection.close(closeError || _errors.kBrowserClosedError);
            };
            pipe.on("closed", onPipeClosed);
            connection.onmessage = (message) => pipe.send({
              message
            }).catch(onPipeClosed);
            pipe.on("message", ({
              message
            }) => {
              try {
                connection.dispatch(message);
              } catch (e) {
                closeError = e.toString();
                closePipe();
              }
            });
            const result = yield (0, _timeoutRunner.raceAgainstTimeout)(() => __async(this, null, function* () {
              if (params.__testHookBeforeCreateBrowser)
                yield params.__testHookBeforeCreateBrowser();
              const playwright = yield connection.initializePlaywright();
              if (!playwright._initializer.preLaunchedBrowser) {
                closePipe();
                throw new Error("Malformed endpoint. Did you use launchServer method?");
              }
              playwright._setSelectors(this._playwright.selectors);
              browser = _browser3.Browser.from(playwright._initializer.preLaunchedBrowser);
              browser._logger = logger;
              browser._shouldCloseConnectionOnClose = true;
              browser._setBrowserType(this);
              browser._localUtils = this._playwright._utils;
              browser.on(_events.Events.Browser.Disconnected, closePipe);
              return browser;
            }), deadline ? deadline - (0, _utils.monotonicTime)() : 0);
            if (!result.timedOut) {
              return result.result;
            } else {
              closePipe();
              throw new Error(`Timeout ${params.timeout}ms exceeded`);
            }
          }));
        });
      }
      connectOverCDP(endpointURLOrOptions, options) {
        if (typeof endpointURLOrOptions === "string")
          return this._connectOverCDP(endpointURLOrOptions, options);
        const endpointURL = "endpointURL" in endpointURLOrOptions ? endpointURLOrOptions.endpointURL : endpointURLOrOptions.wsEndpoint;
        (0, _utils.assert)(endpointURL, "Cannot connect over CDP without wsEndpoint.");
        return this.connectOverCDP(endpointURL, endpointURLOrOptions);
      }
      _connectOverCDP(_0) {
        return __async(this, arguments, function* (endpointURL, params = {}) {
          if (this.name() !== "chromium")
            throw new Error("Connecting over CDP is only supported in Chromium.");
          const headers = params.headers ? (0, _utils.headersObjectToArray)(params.headers) : void 0;
          const result = yield this._channel.connectOverCDP({
            endpointURL,
            headers,
            slowMo: params.slowMo,
            timeout: params.timeout
          });
          const browser = _browser3.Browser.from(result.browser);
          if (result.defaultContext)
            browser._contexts.add(_browserContext.BrowserContext.from(result.defaultContext));
          browser._logger = params.logger;
          browser._setBrowserType(this);
          browser._localUtils = this._playwright._utils;
          return browser;
        });
      }
    };
    exports2.BrowserType = BrowserType;
  }
});

// node_modules/playwright-core/lib/client/android.js
var require_android2 = __commonJS({
  "node_modules/playwright-core/lib/client/android.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.AndroidWebView = exports2.AndroidSocket = exports2.AndroidInput = exports2.AndroidDevice = exports2.Android = void 0;
    var _fs = _interopRequireDefault(require("fs"));
    var _utils = require_utils();
    var _events = require_events();
    var _browserContext = require_browserContext2();
    var _channelOwner = require_channelOwner();
    var _timeoutSettings = require_timeoutSettings();
    var _waiter = require_waiter();
    var _events2 = require("events");
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Android = class extends _channelOwner.ChannelOwner {
      static from(android) {
        return android._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._timeoutSettings = void 0;
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({
          timeout
        });
      }
      devices() {
        return __async(this, arguments, function* (options = {}) {
          const {
            devices
          } = yield this._channel.devices(options);
          return devices.map((d) => AndroidDevice.from(d));
        });
      }
    };
    exports2.Android = Android;
    var AndroidDevice = class extends _channelOwner.ChannelOwner {
      static from(androidDevice) {
        return androidDevice._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._timeoutSettings = void 0;
        this._webViews = /* @__PURE__ */ new Map();
        this.input = void 0;
        this.input = new AndroidInput(this);
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings(parent._timeoutSettings);
        this._channel.on("webViewAdded", ({
          webView
        }) => this._onWebViewAdded(webView));
        this._channel.on("webViewRemoved", ({
          pid
        }) => this._onWebViewRemoved(pid));
      }
      _onWebViewAdded(webView) {
        const view = new AndroidWebView(this, webView);
        this._webViews.set(webView.pid, view);
        this.emit(_events.Events.AndroidDevice.WebView, view);
      }
      _onWebViewRemoved(pid) {
        const view = this._webViews.get(pid);
        this._webViews.delete(pid);
        if (view)
          view.emit(_events.Events.AndroidWebView.Close);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
        this._channel.setDefaultTimeoutNoReply({
          timeout
        });
      }
      serial() {
        return this._initializer.serial;
      }
      model() {
        return this._initializer.model;
      }
      webViews() {
        return [...this._webViews.values()];
      }
      webView(selector, options) {
        return __async(this, null, function* () {
          const webView = [...this._webViews.values()].find((v) => v.pkg() === selector.pkg);
          if (webView)
            return webView;
          return this.waitForEvent("webview", __spreadProps(__spreadValues({}, options), {
            predicate: (view) => view.pkg() === selector.pkg
          }));
        });
      }
      wait(selector, options) {
        return __async(this, null, function* () {
          yield this._channel.wait(__spreadValues({
            selector: toSelectorChannel(selector)
          }, options));
        });
      }
      fill(selector, text, options) {
        return __async(this, null, function* () {
          yield this._channel.fill(__spreadValues({
            selector: toSelectorChannel(selector),
            text
          }, options));
        });
      }
      press(selector, key, options) {
        return __async(this, null, function* () {
          yield this.tap(selector, options);
          yield this.input.press(key);
        });
      }
      tap(selector, options) {
        return __async(this, null, function* () {
          yield this._channel.tap(__spreadValues({
            selector: toSelectorChannel(selector)
          }, options));
        });
      }
      drag(selector, dest, options) {
        return __async(this, null, function* () {
          yield this._channel.drag(__spreadValues({
            selector: toSelectorChannel(selector),
            dest
          }, options));
        });
      }
      fling(selector, direction, options) {
        return __async(this, null, function* () {
          yield this._channel.fling(__spreadValues({
            selector: toSelectorChannel(selector),
            direction
          }, options));
        });
      }
      longTap(selector, options) {
        return __async(this, null, function* () {
          yield this._channel.longTap(__spreadValues({
            selector: toSelectorChannel(selector)
          }, options));
        });
      }
      pinchClose(selector, percent, options) {
        return __async(this, null, function* () {
          yield this._channel.pinchClose(__spreadValues({
            selector: toSelectorChannel(selector),
            percent
          }, options));
        });
      }
      pinchOpen(selector, percent, options) {
        return __async(this, null, function* () {
          yield this._channel.pinchOpen(__spreadValues({
            selector: toSelectorChannel(selector),
            percent
          }, options));
        });
      }
      scroll(selector, direction, percent, options) {
        return __async(this, null, function* () {
          yield this._channel.scroll(__spreadValues({
            selector: toSelectorChannel(selector),
            direction,
            percent
          }, options));
        });
      }
      swipe(selector, direction, percent, options) {
        return __async(this, null, function* () {
          yield this._channel.swipe(__spreadValues({
            selector: toSelectorChannel(selector),
            direction,
            percent
          }, options));
        });
      }
      info(selector) {
        return __async(this, null, function* () {
          return (yield this._channel.info({
            selector: toSelectorChannel(selector)
          })).info;
        });
      }
      screenshot() {
        return __async(this, arguments, function* (options = {}) {
          const {
            binary
          } = yield this._channel.screenshot();
          const buffer = Buffer.from(binary, "base64");
          if (options.path)
            yield _fs.default.promises.writeFile(options.path, buffer);
          return buffer;
        });
      }
      close() {
        return __async(this, null, function* () {
          yield this._channel.close();
          this.emit(_events.Events.AndroidDevice.Close);
        });
      }
      shell(command) {
        return __async(this, null, function* () {
          const {
            result
          } = yield this._channel.shell({
            command
          });
          return Buffer.from(result, "base64");
        });
      }
      open(command) {
        return __async(this, null, function* () {
          return AndroidSocket.from((yield this._channel.open({
            command
          })).socket);
        });
      }
      installApk(file, options) {
        return __async(this, null, function* () {
          yield this._channel.installApk({
            file: yield loadFile(file),
            args: options && options.args
          });
        });
      }
      push(file, path, options) {
        return __async(this, null, function* () {
          yield this._channel.push({
            file: yield loadFile(file),
            path,
            mode: options ? options.mode : void 0
          });
        });
      }
      launchBrowser() {
        return __async(this, arguments, function* (options = {}) {
          const contextOptions = yield (0, _browserContext.prepareBrowserContextParams)(options);
          const {
            context
          } = yield this._channel.launchBrowser(contextOptions);
          return _browserContext.BrowserContext.from(context);
        });
      }
      waitForEvent(_0) {
        return __async(this, arguments, function* (event, optionsOrPredicate = {}) {
          return this._wrapApiCall(() => __async(this, null, function* () {
            const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
            const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
            const waiter = _waiter.Waiter.createForEvent(this, event);
            waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
            if (event !== _events.Events.AndroidDevice.Close)
              waiter.rejectOnEvent(this, _events.Events.AndroidDevice.Close, new Error("Device closed"));
            const result = yield waiter.waitForEvent(this, event, predicate);
            waiter.dispose();
            return result;
          }));
        });
      }
    };
    exports2.AndroidDevice = AndroidDevice;
    var AndroidSocket = class extends _channelOwner.ChannelOwner {
      static from(androidDevice) {
        return androidDevice._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._channel.on("data", ({
          data
        }) => this.emit(_events.Events.AndroidSocket.Data, Buffer.from(data, "base64")));
        this._channel.on("close", () => this.emit(_events.Events.AndroidSocket.Close));
      }
      write(data) {
        return __async(this, null, function* () {
          yield this._channel.write({
            data: data.toString("base64")
          });
        });
      }
      close() {
        return __async(this, null, function* () {
          yield this._channel.close();
        });
      }
    };
    exports2.AndroidSocket = AndroidSocket;
    function loadFile(file) {
      return __async(this, null, function* () {
        if ((0, _utils.isString)(file))
          return _fs.default.promises.readFile(file, {
            encoding: "base64"
          }).toString();
        return file.toString("base64");
      });
    }
    var AndroidInput = class {
      constructor(device) {
        this._device = void 0;
        this._device = device;
      }
      type(text) {
        return __async(this, null, function* () {
          yield this._device._channel.inputType({
            text
          });
        });
      }
      press(key) {
        return __async(this, null, function* () {
          yield this._device._channel.inputPress({
            key
          });
        });
      }
      tap(point) {
        return __async(this, null, function* () {
          yield this._device._channel.inputTap({
            point
          });
        });
      }
      swipe(from, segments, steps) {
        return __async(this, null, function* () {
          yield this._device._channel.inputSwipe({
            segments,
            steps
          });
        });
      }
      drag(from, to, steps) {
        return __async(this, null, function* () {
          yield this._device._channel.inputDrag({
            from,
            to,
            steps
          });
        });
      }
    };
    exports2.AndroidInput = AndroidInput;
    function toSelectorChannel(selector) {
      const {
        checkable,
        checked,
        clazz,
        clickable,
        depth,
        desc,
        enabled,
        focusable,
        focused,
        hasChild,
        hasDescendant,
        longClickable,
        pkg,
        res,
        scrollable,
        selected,
        text
      } = selector;
      const toRegex = (value) => {
        if (value === void 0)
          return void 0;
        if ((0, _utils.isRegExp)(value))
          return value.source;
        return "^" + value.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") + "$";
      };
      return {
        checkable,
        checked,
        clazz: toRegex(clazz),
        pkg: toRegex(pkg),
        desc: toRegex(desc),
        res: toRegex(res),
        text: toRegex(text),
        clickable,
        depth,
        enabled,
        focusable,
        focused,
        hasChild: hasChild ? {
          selector: toSelectorChannel(hasChild.selector)
        } : void 0,
        hasDescendant: hasDescendant ? {
          selector: toSelectorChannel(hasDescendant.selector),
          maxDepth: hasDescendant.maxDepth
        } : void 0,
        longClickable,
        scrollable,
        selected
      };
    }
    var AndroidWebView = class extends _events2.EventEmitter {
      constructor(device, data) {
        super();
        this._device = void 0;
        this._data = void 0;
        this._pagePromise = void 0;
        this._device = device;
        this._data = data;
      }
      pid() {
        return this._data.pid;
      }
      pkg() {
        return this._data.pkg;
      }
      page() {
        return __async(this, null, function* () {
          if (!this._pagePromise)
            this._pagePromise = this._fetchPage();
          return this._pagePromise;
        });
      }
      _fetchPage() {
        return __async(this, null, function* () {
          const {
            context
          } = yield this._device._channel.connectToWebView({
            pid: this._data.pid
          });
          return _browserContext.BrowserContext.from(context).pages()[0];
        });
      }
    };
    exports2.AndroidWebView = AndroidWebView;
  }
});

// node_modules/playwright-core/lib/client/electron.js
var require_electron3 = __commonJS({
  "node_modules/playwright-core/lib/client/electron.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ElectronApplication = exports2.Electron = void 0;
    var _timeoutSettings = require_timeoutSettings();
    var _utils = require_utils();
    var _browserContext = require_browserContext2();
    var _channelOwner = require_channelOwner();
    var _clientHelper = require_clientHelper();
    var _events = require_events();
    var _jsHandle = require_jsHandle();
    var _waiter = require_waiter();
    var Electron = class extends _channelOwner.ChannelOwner {
      static from(electron) {
        return electron._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      launch() {
        return __async(this, arguments, function* (options = {}) {
          const params = __spreadProps(__spreadValues({}, options), {
            extraHTTPHeaders: options.extraHTTPHeaders && (0, _utils.headersObjectToArray)(options.extraHTTPHeaders),
            env: (0, _clientHelper.envObjectToArray)(options.env ? options.env : process.env)
          });
          const app = ElectronApplication.from((yield this._channel.launch(params)).electronApplication);
          app._context._options = params;
          return app;
        });
      }
    };
    exports2.Electron = Electron;
    var ElectronApplication = class extends _channelOwner.ChannelOwner {
      static from(electronApplication) {
        return electronApplication._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._context = void 0;
        this._windows = /* @__PURE__ */ new Set();
        this._timeoutSettings = new _timeoutSettings.TimeoutSettings();
        this._context = _browserContext.BrowserContext.from(initializer.context);
        for (const page of this._context._pages)
          this._onPage(page);
        this._context.on(_events.Events.BrowserContext.Page, (page) => this._onPage(page));
        this._channel.on("close", () => this.emit(_events.Events.ElectronApplication.Close));
      }
      process() {
        return this._toImpl().process();
      }
      _onPage(page) {
        this._windows.add(page);
        this.emit(_events.Events.ElectronApplication.Window, page);
        page.once(_events.Events.Page.Close, () => this._windows.delete(page));
      }
      windows() {
        return [...this._windows];
      }
      firstWindow() {
        return __async(this, null, function* () {
          if (this._windows.size)
            return this._windows.values().next().value;
          return this.waitForEvent("window");
        });
      }
      context() {
        return this._context;
      }
      close() {
        return __async(this, null, function* () {
          yield this._channel.close();
        });
      }
      waitForEvent(_0) {
        return __async(this, arguments, function* (event, optionsOrPredicate = {}) {
          return this._wrapApiCall(() => __async(this, null, function* () {
            const timeout = this._timeoutSettings.timeout(typeof optionsOrPredicate === "function" ? {} : optionsOrPredicate);
            const predicate = typeof optionsOrPredicate === "function" ? optionsOrPredicate : optionsOrPredicate.predicate;
            const waiter = _waiter.Waiter.createForEvent(this, event);
            waiter.rejectOnTimeout(timeout, `Timeout ${timeout}ms exceeded while waiting for event "${event}"`);
            if (event !== _events.Events.ElectronApplication.Close)
              waiter.rejectOnEvent(this, _events.Events.ElectronApplication.Close, new Error("Electron application closed"));
            const result = yield waiter.waitForEvent(this, event, predicate);
            waiter.dispose();
            return result;
          }));
        });
      }
      browserWindow(page) {
        return __async(this, null, function* () {
          const result = yield this._channel.browserWindow({
            page: page._channel
          });
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
      evaluate(pageFunction, arg) {
        return __async(this, null, function* () {
          const result = yield this._channel.evaluateExpression({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return (0, _jsHandle.parseResult)(result.value);
        });
      }
      evaluateHandle(pageFunction, arg) {
        return __async(this, null, function* () {
          const result = yield this._channel.evaluateExpressionHandle({
            expression: String(pageFunction),
            isFunction: typeof pageFunction === "function",
            arg: (0, _jsHandle.serializeArgument)(arg)
          });
          return _jsHandle.JSHandle.from(result.handle);
        });
      }
    };
    exports2.ElectronApplication = ElectronApplication;
  }
});

// node_modules/playwright-core/lib/client/localUtils.js
var require_localUtils = __commonJS({
  "node_modules/playwright-core/lib/client/localUtils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LocalUtils = void 0;
    var _channelOwner = require_channelOwner();
    var LocalUtils = class extends _channelOwner.ChannelOwner {
      static from(channel) {
        return channel._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      zip(zipFile, entries) {
        return __async(this, null, function* () {
          yield this._channel.zip({
            zipFile,
            entries
          });
        });
      }
    };
    exports2.LocalUtils = LocalUtils;
  }
});

// node_modules/playwright-core/lib/client/selectors.js
var require_selectors2 = __commonJS({
  "node_modules/playwright-core/lib/client/selectors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SelectorsOwner = exports2.Selectors = void 0;
    var _clientHelper = require_clientHelper();
    var _channelOwner = require_channelOwner();
    var Selectors = class {
      constructor() {
        this._channels = /* @__PURE__ */ new Set();
        this._registrations = [];
      }
      register(_0, _1) {
        return __async(this, arguments, function* (name, script, options = {}) {
          const source = yield (0, _clientHelper.evaluationScript)(script, void 0, false);
          const params = __spreadProps(__spreadValues({}, options), {
            name,
            source
          });
          for (const channel of this._channels)
            yield channel._channel.register(params);
          this._registrations.push(params);
        });
      }
      _addChannel(channel) {
        this._channels.add(channel);
        for (const params of this._registrations) {
          channel._channel.register(params).catch((e) => {
          });
        }
      }
      _removeChannel(channel) {
        this._channels.delete(channel);
      }
    };
    exports2.Selectors = Selectors;
    var SelectorsOwner = class extends _channelOwner.ChannelOwner {
      static from(browser) {
        return browser._object;
      }
    };
    exports2.SelectorsOwner = SelectorsOwner;
  }
});

// node_modules/playwright-core/lib/client/playwright.js
var require_playwright2 = __commonJS({
  "node_modules/playwright-core/lib/client/playwright.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Playwright = void 0;
    var _errors = require_errors();
    var socks = _interopRequireWildcard(require_socksProxy());
    var _android = require_android2();
    var _browserType = require_browserType2();
    var _channelOwner = require_channelOwner();
    var _electron = require_electron3();
    var _fetch = require_fetch2();
    var _localUtils = require_localUtils();
    var _selectors = require_selectors2();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var Playwright = class extends _channelOwner.ChannelOwner {
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
        this._android = void 0;
        this._electron = void 0;
        this.chromium = void 0;
        this.firefox = void 0;
        this.webkit = void 0;
        this.devices = void 0;
        this.selectors = void 0;
        this.request = void 0;
        this.errors = void 0;
        this._utils = void 0;
        this._socksProxyHandler = void 0;
        this.request = new _fetch.APIRequest(this);
        this.chromium = _browserType.BrowserType.from(initializer.chromium);
        this.chromium._playwright = this;
        this.firefox = _browserType.BrowserType.from(initializer.firefox);
        this.firefox._playwright = this;
        this.webkit = _browserType.BrowserType.from(initializer.webkit);
        this.webkit._playwright = this;
        this._android = _android.Android.from(initializer.android);
        this._electron = _electron.Electron.from(initializer.electron);
        this.devices = {};
        for (const {
          name,
          descriptor
        } of initializer.deviceDescriptors)
          this.devices[name] = descriptor;
        this.selectors = new _selectors.Selectors();
        this.errors = {
          TimeoutError: _errors.TimeoutError
        };
        this._utils = _localUtils.LocalUtils.from(initializer.utils);
        const selectorsOwner = _selectors.SelectorsOwner.from(initializer.selectors);
        this.selectors._addChannel(selectorsOwner);
        this._connection.on("close", () => {
          var _this$_socksProxyHand;
          this.selectors._removeChannel(selectorsOwner);
          (_this$_socksProxyHand = this._socksProxyHandler) === null || _this$_socksProxyHand === void 0 ? void 0 : _this$_socksProxyHand.cleanup();
        });
        global._playwrightInstance = this;
      }
      _hideHighlight() {
        return __async(this, null, function* () {
          yield this._channel.hideHighlight();
        });
      }
      _setSelectors(selectors) {
        const selectorsOwner = _selectors.SelectorsOwner.from(this._initializer.selectors);
        this.selectors._removeChannel(selectorsOwner);
        this.selectors = selectors;
        this.selectors._addChannel(selectorsOwner);
      }
      _enablePortForwarding(redirectPortForTest) {
        const socksSupport = this._initializer.socksSupport;
        if (!socksSupport)
          return;
        const handler = new socks.SocksProxyHandler(redirectPortForTest);
        this._socksProxyHandler = handler;
        handler.on(socks.SocksProxyHandler.Events.SocksConnected, (payload) => socksSupport.socksConnected(payload).catch(() => {
        }));
        handler.on(socks.SocksProxyHandler.Events.SocksData, (payload) => socksSupport.socksData({
          uid: payload.uid,
          data: payload.data.toString("base64")
        }).catch(() => {
        }));
        handler.on(socks.SocksProxyHandler.Events.SocksError, (payload) => socksSupport.socksError(payload).catch(() => {
        }));
        handler.on(socks.SocksProxyHandler.Events.SocksFailed, (payload) => socksSupport.socksFailed(payload).catch(() => {
        }));
        handler.on(socks.SocksProxyHandler.Events.SocksEnd, (payload) => socksSupport.socksEnd(payload).catch(() => {
        }));
        socksSupport.on("socksRequested", (payload) => handler.socketRequested(payload));
        socksSupport.on("socksClosed", (payload) => handler.socketClosed(payload));
        socksSupport.on("socksData", (payload) => handler.sendSocketData({
          uid: payload.uid,
          data: Buffer.from(payload.data, "base64")
        }));
      }
      static from(channel) {
        return channel._object;
      }
    };
    exports2.Playwright = Playwright;
  }
});

// node_modules/playwright-core/lib/client/jsonPipe.js
var require_jsonPipe = __commonJS({
  "node_modules/playwright-core/lib/client/jsonPipe.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.JsonPipe = void 0;
    var _channelOwner = require_channelOwner();
    var JsonPipe = class extends _channelOwner.ChannelOwner {
      static from(jsonPipe) {
        return jsonPipe._object;
      }
      constructor(parent, type, guid, initializer) {
        super(parent, type, guid, initializer);
      }
      channel() {
        return this._channel;
      }
    };
    exports2.JsonPipe = JsonPipe;
  }
});

// node_modules/playwright-core/lib/client/connection.js
var require_connection = __commonJS({
  "node_modules/playwright-core/lib/client/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Connection = void 0;
    var _browser = require_browser4();
    var _browserContext = require_browserContext2();
    var _browserType = require_browserType2();
    var _channelOwner = require_channelOwner();
    var _elementHandle = require_elementHandle();
    var _frame = require_frame();
    var _jsHandle = require_jsHandle();
    var _network = require_network2();
    var _page = require_page2();
    var _worker = require_worker();
    var _consoleMessage = require_consoleMessage();
    var _dialog = require_dialog2();
    var _serializers = require_serializers();
    var _cdpSession = require_cdpSession();
    var _playwright = require_playwright2();
    var _electron = require_electron3();
    var _stream = require_stream();
    var _writableStream = require_writableStream();
    var _debugLogger = require_debugLogger();
    var _selectors = require_selectors2();
    var _android = require_android2();
    var _artifact = require_artifact2();
    var _events = require("events");
    var _jsonPipe = require_jsonPipe();
    var _fetch = require_fetch2();
    var _localUtils = require_localUtils();
    var _tracing = require_tracing2();
    var Root = class extends _channelOwner.ChannelOwner {
      constructor(connection) {
        super(connection, "Root", "", {});
      }
      initialize() {
        return __async(this, null, function* () {
          return _playwright.Playwright.from((yield this._channel.initialize({
            sdkLanguage: "javascript"
          })).playwright);
        });
      }
    };
    var DummyChannelOwner = class extends _channelOwner.ChannelOwner {
    };
    var Connection = class extends _events.EventEmitter {
      constructor() {
        super();
        this._objects = /* @__PURE__ */ new Map();
        this.onmessage = (message) => {
        };
        this._lastId = 0;
        this._callbacks = /* @__PURE__ */ new Map();
        this._rootObject = void 0;
        this._closedErrorMessage = void 0;
        this._isRemote = false;
        this.toImpl = void 0;
        this._rootObject = new Root(this);
      }
      markAsRemote() {
        this._isRemote = true;
      }
      isRemote() {
        return this._isRemote;
      }
      initializePlaywright() {
        return __async(this, null, function* () {
          return yield this._rootObject.initialize();
        });
      }
      pendingProtocolCalls() {
        return Array.from(this._callbacks.values()).map((callback) => callback.stackTrace).filter(Boolean);
      }
      getObjectWithKnownName(guid) {
        return this._objects.get(guid);
      }
      sendMessageToServer(object, method, params, stackTrace) {
        return __async(this, null, function* () {
          if (this._closedErrorMessage)
            throw new Error(this._closedErrorMessage);
          const {
            apiName,
            frames
          } = stackTrace || {
            apiName: "",
            frames: []
          };
          const guid = object._guid;
          const id = ++this._lastId;
          const converted = {
            id,
            guid,
            method,
            params
          };
          _debugLogger.debugLogger.log("channel:command", converted);
          const metadata = {
            stack: frames,
            apiName,
            internal: !apiName
          };
          this.onmessage(__spreadProps(__spreadValues({}, converted), {
            metadata
          }));
          return yield new Promise((resolve, reject) => this._callbacks.set(id, {
            resolve,
            reject,
            stackTrace
          }));
        });
      }
      _debugScopeState() {
        return this._rootObject._debugScopeState();
      }
      dispatch(message) {
        if (this._closedErrorMessage)
          return;
        const {
          id,
          guid,
          method,
          params,
          result,
          error
        } = message;
        if (id) {
          _debugLogger.debugLogger.log("channel:response", message);
          const callback = this._callbacks.get(id);
          if (!callback)
            throw new Error(`Cannot find command to respond: ${id}`);
          this._callbacks.delete(id);
          if (error && !result)
            callback.reject((0, _serializers.parseError)(error));
          else
            callback.resolve(this._replaceGuidsWithChannels(result));
          return;
        }
        _debugLogger.debugLogger.log("channel:event", message);
        if (method === "__create__") {
          this._createRemoteObject(guid, params.type, params.guid, params.initializer);
          return;
        }
        if (method === "__dispose__") {
          const object2 = this._objects.get(guid);
          if (!object2)
            throw new Error(`Cannot find object to dispose: ${guid}`);
          object2._dispose();
          return;
        }
        const object = this._objects.get(guid);
        if (!object)
          throw new Error(`Cannot find object to emit "${method}": ${guid}`);
        object._channel.emit(method, object._type === "JsonPipe" ? params : this._replaceGuidsWithChannels(params));
      }
      close(errorMessage = "Connection closed") {
        this._closedErrorMessage = errorMessage;
        for (const callback of this._callbacks.values())
          callback.reject(new Error(errorMessage));
        this._callbacks.clear();
        this.emit("close");
      }
      _replaceGuidsWithChannels(payload) {
        if (!payload)
          return payload;
        if (Array.isArray(payload))
          return payload.map((p) => this._replaceGuidsWithChannels(p));
        if (payload.guid && this._objects.has(payload.guid))
          return this._objects.get(payload.guid)._channel;
        if (typeof payload === "object") {
          const result = {};
          for (const key of Object.keys(payload))
            result[key] = this._replaceGuidsWithChannels(payload[key]);
          return result;
        }
        return payload;
      }
      _createRemoteObject(parentGuid, type, guid, initializer) {
        const parent = this._objects.get(parentGuid);
        if (!parent)
          throw new Error(`Cannot find parent object ${parentGuid} to create ${guid}`);
        let result;
        initializer = this._replaceGuidsWithChannels(initializer);
        switch (type) {
          case "Android":
            result = new _android.Android(parent, type, guid, initializer);
            break;
          case "AndroidSocket":
            result = new _android.AndroidSocket(parent, type, guid, initializer);
            break;
          case "AndroidDevice":
            result = new _android.AndroidDevice(parent, type, guid, initializer);
            break;
          case "APIRequestContext":
            result = new _fetch.APIRequestContext(parent, type, guid, initializer);
            break;
          case "Artifact":
            result = new _artifact.Artifact(parent, type, guid, initializer);
            break;
          case "BindingCall":
            result = new _page.BindingCall(parent, type, guid, initializer);
            break;
          case "Browser":
            result = new _browser.Browser(parent, type, guid, initializer);
            break;
          case "BrowserContext":
            result = new _browserContext.BrowserContext(parent, type, guid, initializer);
            break;
          case "BrowserType":
            result = new _browserType.BrowserType(parent, type, guid, initializer);
            break;
          case "CDPSession":
            result = new _cdpSession.CDPSession(parent, type, guid, initializer);
            break;
          case "ConsoleMessage":
            result = new _consoleMessage.ConsoleMessage(parent, type, guid, initializer);
            break;
          case "Dialog":
            result = new _dialog.Dialog(parent, type, guid, initializer);
            break;
          case "Electron":
            result = new _electron.Electron(parent, type, guid, initializer);
            break;
          case "ElectronApplication":
            result = new _electron.ElectronApplication(parent, type, guid, initializer);
            break;
          case "ElementHandle":
            result = new _elementHandle.ElementHandle(parent, type, guid, initializer);
            break;
          case "Frame":
            result = new _frame.Frame(parent, type, guid, initializer);
            break;
          case "JSHandle":
            result = new _jsHandle.JSHandle(parent, type, guid, initializer);
            break;
          case "JsonPipe":
            result = new _jsonPipe.JsonPipe(parent, type, guid, initializer);
            break;
          case "LocalUtils":
            result = new _localUtils.LocalUtils(parent, type, guid, initializer);
            break;
          case "Page":
            result = new _page.Page(parent, type, guid, initializer);
            break;
          case "Playwright":
            result = new _playwright.Playwright(parent, type, guid, initializer);
            break;
          case "Request":
            result = new _network.Request(parent, type, guid, initializer);
            break;
          case "Response":
            result = new _network.Response(parent, type, guid, initializer);
            break;
          case "Route":
            result = new _network.Route(parent, type, guid, initializer);
            break;
          case "Stream":
            result = new _stream.Stream(parent, type, guid, initializer);
            break;
          case "Selectors":
            result = new _selectors.SelectorsOwner(parent, type, guid, initializer);
            break;
          case "SocksSupport":
            result = new DummyChannelOwner(parent, type, guid, initializer);
            break;
          case "Tracing":
            result = new _tracing.Tracing(parent, type, guid, initializer);
            break;
          case "WebSocket":
            result = new _network.WebSocket(parent, type, guid, initializer);
            break;
          case "Worker":
            result = new _worker.Worker(parent, type, guid, initializer);
            break;
          case "WritableStream":
            result = new _writableStream.WritableStream(parent, type, guid, initializer);
            break;
          default:
            throw new Error("Missing type " + type);
        }
        return result;
      }
    };
    exports2.Connection = Connection;
  }
});

// node_modules/playwright-core/lib/remote/playwrightConnection.js
var require_playwrightConnection = __commonJS({
  "node_modules/playwright-core/lib/remote/playwrightConnection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PlaywrightConnection = void 0;
    var _server = require_server();
    var _browser = require_browser3();
    var _instrumentation = require_instrumentation();
    var _processLauncher = require_processLauncher();
    var _socksProxy = require_socksProxy();
    var PlaywrightConnection = class {
      constructor(ws, enableSocksProxy, browserAlias, headless, browser, log, onClose) {
        this._ws = void 0;
        this._onClose = void 0;
        this._dispatcherConnection = void 0;
        this._cleanups = [];
        this._debugLog = void 0;
        this._disconnected = false;
        this._ws = ws;
        this._onClose = onClose;
        this._debugLog = log;
        this._dispatcherConnection = new _server.DispatcherConnection();
        this._dispatcherConnection.onmessage = (message) => {
          if (ws.readyState !== ws.CLOSING)
            ws.send(JSON.stringify(message));
        };
        ws.on("message", (message) => {
          this._dispatcherConnection.dispatch(JSON.parse(Buffer.from(message).toString()));
        });
        ws.on("close", () => this._onDisconnect());
        ws.on("error", (error) => this._onDisconnect(error));
        new _server.Root(this._dispatcherConnection, (scope) => __async(this, null, function* () {
          if (browser)
            return yield this._initPreLaunchedBrowserMode(scope, browser);
          if (!browserAlias)
            return yield this._initPlaywrightConnectMode(scope, enableSocksProxy);
          return yield this._initLaunchBrowserMode(scope, enableSocksProxy, browserAlias, headless);
        }));
      }
      _initPlaywrightConnectMode(scope, enableSocksProxy) {
        return __async(this, null, function* () {
          this._debugLog(`engaged playwright.connect mode`);
          const playwright = (0, _server.createPlaywright)("javascript");
          this._cleanups.push(() => (0, _processLauncher.gracefullyCloseAll)());
          const socksProxy = enableSocksProxy ? yield this._enableSocksProxy(playwright) : void 0;
          return new _server.PlaywrightDispatcher(scope, playwright, socksProxy);
        });
      }
      _initLaunchBrowserMode(scope, enableSocksProxy, browserAlias, headless) {
        return __async(this, null, function* () {
          this._debugLog(`engaged launch mode for "${browserAlias}"`);
          const executable = _server.registry.findExecutable(browserAlias);
          if (!executable || !executable.browserName)
            throw new Error(`Unsupported browser "${browserAlias}`);
          const playwright = (0, _server.createPlaywright)("javascript");
          const socksProxy = enableSocksProxy ? yield this._enableSocksProxy(playwright) : void 0;
          const browser = yield playwright[executable.browserName].launch((0, _instrumentation.serverSideCallMetadata)(), {
            channel: executable.type === "browser" ? void 0 : executable.name,
            headless
          });
          this._cleanups.push(() => browser.close());
          browser.on(_browser.Browser.Events.Disconnected, () => {
            this.close({
              code: 1001,
              reason: "Browser closed"
            });
          });
          return new _server.PlaywrightDispatcher(scope, playwright, socksProxy, browser);
        });
      }
      _initPreLaunchedBrowserMode(scope, browser) {
        return __async(this, null, function* () {
          this._debugLog(`engaged pre-launched mode`);
          browser.on(_browser.Browser.Events.Disconnected, () => {
            this.close({
              code: 1001,
              reason: "Browser closed"
            });
          });
          const playwright = browser.options.rootSdkObject;
          const playwrightDispatcher = new _server.PlaywrightDispatcher(scope, playwright, void 0, browser);
          this._cleanups.push(() => playwrightDispatcher.cleanup());
          return playwrightDispatcher;
        });
      }
      _enableSocksProxy(playwright) {
        return __async(this, null, function* () {
          const socksProxy = new _socksProxy.SocksProxy();
          playwright.options.socksProxyPort = yield socksProxy.listen(0);
          this._debugLog(`started socks proxy on port ${playwright.options.socksProxyPort}`);
          this._cleanups.push(() => socksProxy.close());
          return socksProxy;
        });
      }
      _onDisconnect(error) {
        return __async(this, null, function* () {
          this._disconnected = true;
          this._debugLog(`disconnected. error: ${error}`);
          this._dispatcherConnection.onmessage = () => {
          };
          this._debugLog(`starting cleanup`);
          for (const cleanup of this._cleanups)
            yield cleanup().catch(() => {
            });
          this._onClose();
          this._debugLog(`finished cleanup`);
        });
      }
      close(reason) {
        return __async(this, null, function* () {
          if (this._disconnected)
            return;
          this._debugLog(`force closing connection: ${(reason === null || reason === void 0 ? void 0 : reason.reason) || ""} (${(reason === null || reason === void 0 ? void 0 : reason.code) || 0})`);
          try {
            this._ws.close(reason === null || reason === void 0 ? void 0 : reason.code, reason === null || reason === void 0 ? void 0 : reason.reason);
          } catch (e) {
          }
        });
      }
    };
    exports2.PlaywrightConnection = PlaywrightConnection;
  }
});

// node_modules/playwright-core/lib/remote/playwrightServer.js
var require_playwrightServer = __commonJS({
  "node_modules/playwright-core/lib/remote/playwrightServer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.PlaywrightServer = void 0;
    var _debug = _interopRequireDefault(require_src3());
    var http = _interopRequireWildcard(require("http"));
    var _ws = _interopRequireDefault(require("ws"));
    var _playwrightConnection = require_playwrightConnection();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var debugLog = (0, _debug.default)("pw:server");
    var lastConnectionId = 0;
    var kConnectionSymbol = Symbol("kConnection");
    function newLogger() {
      const id = ++lastConnectionId;
      return (message) => debugLog(`[id=${id}] ${message}`);
    }
    var PlaywrightServer = class {
      static startDefault() {
        return __async(this, arguments, function* (options = {}) {
          const {
            path = "/ws",
            maxClients = 1,
            enableSocksProxy = true
          } = options;
          return new PlaywrightServer(path, maxClients, enableSocksProxy);
        });
      }
      constructor(path, maxClients, enableSocksProxy, browser) {
        this._path = void 0;
        this._maxClients = void 0;
        this._enableSocksProxy = void 0;
        this._browser = void 0;
        this._wsServer = void 0;
        this._clientsCount = 0;
        this._path = path;
        this._maxClients = maxClients;
        this._enableSocksProxy = enableSocksProxy;
        this._browser = browser;
      }
      listen(port = 0) {
        return __async(this, null, function* () {
          const server = http.createServer((request, response) => {
            response.end("Running");
          });
          server.on("error", (error) => debugLog(error));
          const wsEndpoint = yield new Promise((resolve, reject) => {
            server.listen(port, () => {
              const address = server.address();
              if (!address) {
                reject(new Error("Could not bind server socket"));
                return;
              }
              const wsEndpoint2 = typeof address === "string" ? `${address}${this._path}` : `ws://127.0.0.1:${address.port}${this._path}`;
              resolve(wsEndpoint2);
            }).on("error", reject);
          });
          debugLog("Listening at " + wsEndpoint);
          this._wsServer = new _ws.default.Server({
            server,
            path: this._path
          });
          const originalShouldHandle = this._wsServer.shouldHandle.bind(this._wsServer);
          this._wsServer.shouldHandle = (request) => originalShouldHandle(request) && this._clientsCount < this._maxClients;
          this._wsServer.on("connection", (ws, request) => __async(this, null, function* () {
            if (this._clientsCount >= this._maxClients) {
              ws.close(1013, "Playwright Server is busy");
              return;
            }
            const url = new URL("http://localhost" + (request.url || ""));
            const browserHeader = request.headers["x-playwright-browser"];
            const browserAlias = url.searchParams.get("browser") || (Array.isArray(browserHeader) ? browserHeader[0] : browserHeader);
            const headlessHeader = request.headers["x-playwright-headless"];
            const headlessValue = url.searchParams.get("headless") || (Array.isArray(headlessHeader) ? headlessHeader[0] : headlessHeader);
            const proxyHeader = request.headers["x-playwright-proxy"];
            const proxyValue = url.searchParams.get("proxy") || (Array.isArray(proxyHeader) ? proxyHeader[0] : proxyHeader);
            const enableSocksProxy = this._enableSocksProxy && proxyValue === "*";
            this._clientsCount++;
            const log = newLogger();
            log(`serving connection: ${request.url}`);
            const connection = new _playwrightConnection.PlaywrightConnection(ws, enableSocksProxy, browserAlias, headlessValue !== "0", this._browser, log, () => this._clientsCount--);
            ws[kConnectionSymbol] = connection;
          }));
          return wsEndpoint;
        });
      }
      close() {
        return __async(this, null, function* () {
          const server = this._wsServer;
          if (!server)
            return;
          debugLog("closing websocket server");
          const waitForClose = new Promise((f) => server.close(f));
          yield Promise.all(Array.from(server.clients).map((ws) => __async(this, null, function* () {
            const connection = ws[kConnectionSymbol];
            if (connection)
              yield connection.close();
            try {
              ws.terminate();
            } catch (e) {
            }
          })));
          yield waitForClose;
          debugLog("closing http server");
          yield new Promise((f) => server.options.server.close(f));
          this._wsServer = void 0;
          debugLog("closed server");
        });
      }
    };
    exports2.PlaywrightServer = PlaywrightServer;
  }
});

// node_modules/playwright-core/lib/browserServerImpl.js
var require_browserServerImpl = __commonJS({
  "node_modules/playwright-core/lib/browserServerImpl.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BrowserServerLauncherImpl = void 0;
    var _ws = require("ws");
    var _clientHelper = require_clientHelper();
    var _utils = require_utils();
    var _instrumentation = require_instrumentation();
    var _playwright = require_playwright();
    var _playwrightServer = require_playwrightServer();
    var _helper = require_helper();
    var _stackTrace = require_stackTrace();
    var BrowserServerLauncherImpl = class {
      constructor(browserName) {
        this._browserName = void 0;
        this._browserName = browserName;
      }
      launchServer() {
        return __async(this, arguments, function* (options = {}) {
          const playwright = (0, _playwright.createPlaywright)("javascript");
          const metadata = (0, _instrumentation.serverSideCallMetadata)();
          const browser = yield playwright[this._browserName].launch(metadata, __spreadProps(__spreadValues({}, options), {
            ignoreDefaultArgs: Array.isArray(options.ignoreDefaultArgs) ? options.ignoreDefaultArgs : void 0,
            ignoreAllDefaultArgs: !!options.ignoreDefaultArgs && !Array.isArray(options.ignoreDefaultArgs),
            env: options.env ? (0, _clientHelper.envObjectToArray)(options.env) : void 0
          }), toProtocolLogger(options.logger)).catch((e) => {
            const log = _helper.helper.formatBrowserLogs(metadata.log);
            (0, _stackTrace.rewriteErrorMessage)(e, `${e.message} Failed to launch browser.${log}`);
            throw e;
          });
          let path = `/${(0, _utils.createGuid)()}`;
          if (options.wsPath)
            path = options.wsPath.startsWith("/") ? options.wsPath : `/${options.wsPath}`;
          const server = new _playwrightServer.PlaywrightServer(path, Infinity, false, browser);
          const wsEndpoint = yield server.listen(options.port);
          const browserServer = new _ws.EventEmitter();
          browserServer.process = () => browser.options.browserProcess.process;
          browserServer.wsEndpoint = () => wsEndpoint;
          browserServer.close = () => browser.options.browserProcess.close();
          browserServer.kill = () => browser.options.browserProcess.kill();
          browserServer._disconnectForTest = () => server.close();
          browser.options.browserProcess.onclose = (exitCode, signal) => __async(this, null, function* () {
            server.close();
            browserServer.emit("close", exitCode, signal);
          });
          return browserServer;
        });
      }
    };
    exports2.BrowserServerLauncherImpl = BrowserServerLauncherImpl;
    function toProtocolLogger(logger) {
      return logger ? (direction, message) => {
        if (logger.isEnabled("protocol", "verbose"))
          logger.log("protocol", "verbose", (direction === "send" ? "SEND \u25BA " : "\u25C0 RECV ") + JSON.stringify(message), [], {});
      } : void 0;
    }
  }
});

// node_modules/playwright-core/lib/inProcessFactory.js
var require_inProcessFactory = __commonJS({
  "node_modules/playwright-core/lib/inProcessFactory.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createInProcessPlaywright = createInProcessPlaywright;
    var _server = require_server();
    var _connection = require_connection();
    var _browserServerImpl = require_browserServerImpl();
    function createInProcessPlaywright() {
      const playwright = (0, _server.createPlaywright)("javascript");
      const clientConnection = new _connection.Connection();
      const dispatcherConnection = new _server.DispatcherConnection();
      dispatcherConnection.onmessage = (message) => clientConnection.dispatch(message);
      clientConnection.onmessage = (message) => dispatcherConnection.dispatch(message);
      const rootScope = new _server.Root(dispatcherConnection);
      new _server.PlaywrightDispatcher(rootScope, playwright);
      const playwrightAPI = clientConnection.getObjectWithKnownName("Playwright");
      playwrightAPI.chromium._serverLauncher = new _browserServerImpl.BrowserServerLauncherImpl("chromium");
      playwrightAPI.firefox._serverLauncher = new _browserServerImpl.BrowserServerLauncherImpl("firefox");
      playwrightAPI.webkit._serverLauncher = new _browserServerImpl.BrowserServerLauncherImpl("webkit");
      dispatcherConnection.onmessage = (message) => setImmediate(() => clientConnection.dispatch(message));
      clientConnection.onmessage = (message) => setImmediate(() => dispatcherConnection.dispatch(message));
      clientConnection.toImpl = (x) => dispatcherConnection._dispatchers.get(x._guid)._object;
      playwrightAPI._toImpl = clientConnection.toImpl;
      return playwrightAPI;
    }
  }
});

// node_modules/playwright-core/lib/inprocess.js
var require_inprocess = __commonJS({
  "node_modules/playwright-core/lib/inprocess.js"(exports2, module2) {
    "use strict";
    var _inProcessFactory = require_inProcessFactory();
    module2.exports = (0, _inProcessFactory.createInProcessPlaywright)();
  }
});

// node_modules/playwright-core/index.js
var require_playwright_core = __commonJS({
  "node_modules/playwright-core/index.js"(exports2, module2) {
    var currentNodeVersion = process.versions.node;
    var semver = currentNodeVersion.split(".");
    var [major] = [+semver[0]];
    if (major < 12) {
      console.error("You are running Node.js " + currentNodeVersion + ".\nPlaywright requires Node.js 12 or higher. \nPlease update your version of Node.js.");
      process.exit(1);
    }
    module2.exports = require_inprocess();
  }
});

// node_modules/playwright-core/api.json
var require_api = __commonJS({
  "node_modules/playwright-core/api.json"(exports2, module2) {
    module2.exports = {};
  }
});

// node_modules/playwright-core/lib/cli/driver.js
var require_driver = __commonJS({
  "node_modules/playwright-core/lib/cli/driver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.launchBrowserServer = launchBrowserServer;
    exports2.printApiJson = printApiJson;
    exports2.runDriver = runDriver;
    exports2.runServer = runServer;
    var _fs = _interopRequireDefault(require("fs"));
    var playwright = _interopRequireWildcard(require_playwright_core());
    var _server = require_server();
    var _transport = require_transport();
    var _playwrightServer = require_playwrightServer();
    var _processLauncher = require_processLauncher();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function printApiJson() {
      console.log(JSON.stringify(require_api()));
    }
    function runDriver() {
      const dispatcherConnection = new _server.DispatcherConnection();
      new _server.Root(dispatcherConnection, (_0, _1) => __async(this, [_0, _1], function* (rootScope, {
        sdkLanguage
      }) {
        const playwright2 = (0, _server.createPlaywright)(sdkLanguage);
        return new _server.PlaywrightDispatcher(rootScope, playwright2);
      }));
      const transport = process.send ? new _transport.IpcTransport(process) : new _transport.PipeTransport(process.stdout, process.stdin);
      transport.onmessage = (message) => dispatcherConnection.dispatch(JSON.parse(message));
      dispatcherConnection.onmessage = (message) => transport.send(JSON.stringify(message));
      transport.onclose = () => __async(this, null, function* () {
        dispatcherConnection.onmessage = () => {
        };
        setTimeout(() => process.exit(0), 3e4);
        yield (0, _processLauncher.gracefullyCloseAll)();
        process.exit(0);
      });
    }
    function runServer(port, path = "/", maxClients = Infinity, enableSocksProxy = true) {
      return __async(this, null, function* () {
        const server = yield _playwrightServer.PlaywrightServer.startDefault({
          path,
          maxClients,
          enableSocksProxy
        });
        const wsEndpoint = yield server.listen(port);
        process.on("exit", () => server.close().catch(console.error));
        console.log("Listening on " + wsEndpoint);
      });
    }
    function launchBrowserServer(browserName, configFile) {
      return __async(this, null, function* () {
        let options = {};
        if (configFile)
          options = JSON.parse(_fs.default.readFileSync(configFile).toString());
        const browserType = playwright[browserName];
        const server = yield browserType.launchServer(options);
        console.log(server.wsEndpoint());
      });
    }
  }
});

// node_modules/playwright-core/lib/utils/httpServer.js
var require_httpServer = __commonJS({
  "node_modules/playwright-core/lib/utils/httpServer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.HttpServer = void 0;
    var http = _interopRequireWildcard(require("http"));
    var _fs = _interopRequireDefault(require("fs"));
    var _path = _interopRequireDefault(require("path"));
    var _ws = require("ws");
    var mime = _interopRequireWildcard(require_mime());
    var _ = require_utils();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    var HttpServer = class {
      constructor(address = "") {
        this._server = void 0;
        this._urlPrefix = void 0;
        this._port = 0;
        this._started = false;
        this._routes = [];
        this._activeSockets = /* @__PURE__ */ new Set();
        this._urlPrefix = address;
        this._server = http.createServer(this._onRequest.bind(this));
      }
      createWebSocketServer() {
        return new _ws.Server({
          server: this._server
        });
      }
      routePrefix(prefix, handler) {
        this._routes.push({
          prefix,
          handler
        });
      }
      routePath(path, handler) {
        this._routes.push({
          exact: path,
          handler
        });
      }
      port() {
        return this._port;
      }
      start(port) {
        return __async(this, null, function* () {
          (0, _.assert)(!this._started, "server already started");
          this._started = true;
          this._server.on("connection", (socket) => {
            this._activeSockets.add(socket);
            socket.once("close", () => this._activeSockets.delete(socket));
          });
          this._server.listen(port);
          yield new Promise((cb) => this._server.once("listening", cb));
          const address = this._server.address();
          (0, _.assert)(address, "Could not bind server socket");
          if (!this._urlPrefix) {
            if (typeof address === "string") {
              this._urlPrefix = address;
            } else {
              this._port = address.port;
              this._urlPrefix = `http://127.0.0.1:${address.port}`;
            }
          }
          return this._urlPrefix;
        });
      }
      stop() {
        return __async(this, null, function* () {
          for (const socket of this._activeSockets)
            socket.destroy();
          yield new Promise((cb) => this._server.close(cb));
        });
      }
      urlPrefix() {
        return this._urlPrefix;
      }
      serveFile(request, response, absoluteFilePath, headers) {
        try {
          for (const [name, value] of Object.entries(headers || {}))
            response.setHeader(name, value);
          if (request.headers.range)
            this._serveRangeFile(request, response, absoluteFilePath);
          else
            this._serveFile(response, absoluteFilePath);
          return true;
        } catch (e) {
          return false;
        }
      }
      _serveFile(response, absoluteFilePath) {
        const content = _fs.default.readFileSync(absoluteFilePath);
        response.statusCode = 200;
        const contentType = mime.getType(_path.default.extname(absoluteFilePath)) || "application/octet-stream";
        response.setHeader("Content-Type", contentType);
        response.setHeader("Content-Length", content.byteLength);
        response.end(content);
      }
      _serveRangeFile(request, response, absoluteFilePath) {
        const range = request.headers.range;
        if (!range || !range.startsWith("bytes=") || range.includes(", ") || [...range].filter((char) => char === "-").length !== 1) {
          response.statusCode = 400;
          return response.end("Bad request");
        }
        const [startStr, endStr] = range.replace(/bytes=/, "").split("-");
        let start;
        let end;
        const size = _fs.default.statSync(absoluteFilePath).size;
        if (startStr !== "" && endStr === "") {
          start = +startStr;
          end = size - 1;
        } else if (startStr === "" && endStr !== "") {
          start = size - +endStr;
          end = size - 1;
        } else {
          start = +startStr;
          end = +endStr;
        }
        if (Number.isNaN(start) || Number.isNaN(end) || start >= size || end >= size || start > end) {
          response.writeHead(416, {
            "Content-Range": `bytes */${size}`
          });
          return response.end();
        }
        response.writeHead(206, {
          "Content-Range": `bytes ${start}-${end}/${size}`,
          "Accept-Ranges": "bytes",
          "Content-Length": end - start + 1,
          "Content-Type": mime.getType(_path.default.extname(absoluteFilePath))
        });
        const readable = _fs.default.createReadStream(absoluteFilePath, {
          start,
          end
        });
        readable.pipe(response);
      }
      _onRequest(request, response) {
        response.setHeader("Access-Control-Allow-Origin", "*");
        response.setHeader("Access-Control-Request-Method", "*");
        response.setHeader("Access-Control-Allow-Methods", "OPTIONS, GET");
        if (request.headers.origin)
          response.setHeader("Access-Control-Allow-Headers", request.headers.origin);
        if (request.method === "OPTIONS") {
          response.writeHead(200);
          response.end();
          return;
        }
        request.on("error", () => response.end());
        try {
          if (!request.url) {
            response.end();
            return;
          }
          const url = new URL("http://localhost" + request.url);
          for (const route of this._routes) {
            if (route.exact && url.pathname === route.exact && route.handler(request, response))
              return;
            if (route.prefix && url.pathname.startsWith(route.prefix) && route.handler(request, response))
              return;
          }
          response.statusCode = 404;
          response.end();
        } catch (e) {
          response.end();
        }
      }
    };
    exports2.HttpServer = HttpServer;
  }
});

// node_modules/playwright-core/lib/server/trace/viewer/traceViewer.js
var require_traceViewer = __commonJS({
  "node_modules/playwright-core/lib/server/trace/viewer/traceViewer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.showTraceViewer = showTraceViewer;
    var _path = _interopRequireDefault(require("path"));
    var _fs = _interopRequireDefault(require("fs"));
    var consoleApiSource = _interopRequireWildcard(require_consoleApiSource());
    var _httpServer = require_httpServer();
    var _registry = require_registry();
    var _utils = require_utils();
    var _crApp = require_crApp();
    var _instrumentation = require_instrumentation();
    var _playwright = require_playwright();
    var _progress = require_progress2();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function showTraceViewer(traceUrls, browserName, headless = false, port) {
      return __async(this, null, function* () {
        for (const traceUrl of traceUrls) {
          if (!traceUrl.startsWith("http://") && !traceUrl.startsWith("https://") && !_fs.default.existsSync(traceUrl)) {
            console.error(`Trace file ${traceUrl} does not exist!`);
            process.exit(1);
          }
        }
        const server = new _httpServer.HttpServer();
        server.routePrefix("/trace", (request, response) => {
          const url = new URL("http://localhost" + request.url);
          const relativePath = url.pathname.slice("/trace".length);
          if (relativePath.startsWith("/file")) {
            try {
              return server.serveFile(request, response, url.searchParams.get("path"));
            } catch (e) {
              return false;
            }
          }
          const absolutePath = _path.default.join(__dirname, "..", "..", "..", "webpack", "traceViewer", ...relativePath.split("/"));
          return server.serveFile(request, response, absolutePath);
        });
        const urlPrefix = yield server.start(port);
        const traceViewerPlaywright = (0, _playwright.createPlaywright)("javascript", true);
        const traceViewerBrowser = (0, _utils.isUnderTest)() ? "chromium" : browserName;
        const args = traceViewerBrowser === "chromium" ? ["--app=data:text/html,", "--window-size=1280,800", "--test-type="] : [];
        if ((0, _utils.isUnderTest)())
          args.push(`--remote-debugging-port=0`);
        const context = yield traceViewerPlaywright[traceViewerBrowser].launchPersistentContext((0, _instrumentation.serverSideCallMetadata)(), "", {
          channel: (0, _registry.findChromiumChannel)(traceViewerPlaywright.options.sdkLanguage),
          args,
          noDefaultViewport: true,
          ignoreDefaultArgs: ["--enable-automation"],
          headless,
          useWebSocket: (0, _utils.isUnderTest)()
        });
        const controller = new _progress.ProgressController((0, _instrumentation.serverSideCallMetadata)(), context._browser);
        yield controller.run((progress) => __async(this, null, function* () {
          yield context._browser._defaultContext._loadDefaultContextAsIs(progress);
        }));
        yield context.extendInjectedScript(consoleApiSource.source);
        const [page] = context.pages();
        if (traceViewerBrowser === "chromium")
          yield (0, _crApp.installAppIcon)(page);
        if ((0, _utils.isUnderTest)())
          page.on("close", () => context.close((0, _instrumentation.serverSideCallMetadata)()).catch(() => {
          }));
        else
          page.on("close", () => process.exit());
        const searchQuery = traceUrls.length ? "?" + traceUrls.map((t) => `trace=${t}`).join("&") : "";
        yield page.mainFrame().goto((0, _instrumentation.serverSideCallMetadata)(), urlPrefix + `/trace/index.html${searchQuery}`);
        return context;
      });
    }
  }
});

// node_modules/playwright-core/lib/grid/gridAgent.js
var require_gridAgent = __commonJS({
  "node_modules/playwright-core/lib/grid/gridAgent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.launchGridAgent = launchGridAgent;
    var _debug = _interopRequireDefault(require_src3());
    var _ws = _interopRequireDefault(require("ws"));
    var _child_process = require("child_process");
    var _userAgent = require_userAgent();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function launchGridAgent(agentId, gridURL) {
      const log = (0, _debug.default)(`pw:grid:agent:${agentId}`);
      log("created");
      const params = new URLSearchParams();
      params.set("pwVersion", (0, _userAgent.getPlaywrightVersion)(true));
      params.set("agentId", agentId);
      const ws = new _ws.default(gridURL.replace("http://", "ws://") + `/registerAgent?` + params.toString());
      ws.on("message", (message) => {
        log("worker requested " + message);
        const {
          workerId,
          browserAlias
        } = JSON.parse(message);
        if (browserAlias)
          (0, _child_process.fork)(require.resolve("./gridBrowserWorker.js"), [gridURL, agentId, workerId, browserAlias], {
            detached: true
          });
        else
          (0, _child_process.fork)(require.resolve("./gridWorker.js"), [gridURL, agentId, workerId], {
            detached: true
          });
      });
      ws.on("close", () => process.exit(0));
    }
  }
});

// node_modules/playwright-core/lib/grid/gridServer.js
var require_gridServer = __commonJS({
  "node_modules/playwright-core/lib/grid/gridServer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GridServer = void 0;
    var _debug = _interopRequireDefault(require_src3());
    var _events = require("events");
    var _url = require("url");
    var _httpServer = require_httpServer();
    var _utils = require_utils();
    var _userAgent = require_userAgent();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var WSErrors = {
      NO_ERROR: {
        code: 1e3,
        reason: ""
      },
      AUTH_FAILED: {
        code: 1008,
        reason: "Grid authentication failed"
      },
      AGENT_CREATION_FAILED: {
        code: 1013,
        reason: "Grid agent creation failed"
      },
      AGENT_NOT_FOUND: {
        code: 1013,
        reason: "Grid agent registration failed - agent with given ID not found"
      },
      AGENT_NOT_CONNECTED: {
        code: 1013,
        reason: "Grid worker registration failed - agent has unsupported status"
      },
      AGENT_CREATION_TIMED_OUT: {
        code: 1013,
        reason: "Grid agent creation timed out"
      },
      AGENT_RETIRED: {
        code: 1e3,
        reason: "Grid agent was retired"
      },
      CLIENT_SOCKET_ERROR: {
        code: 1011,
        reason: "Grid client socket error"
      },
      WORKER_SOCKET_ERROR: {
        code: 1011,
        reason: "Grid worker socket error"
      },
      CLIENT_PLAYWRIGHT_VERSION_MISMATCH: {
        code: 1013,
        reason: "Grid Playwright and grid client versions are different"
      },
      AGENT_PLAYWRIGHT_VERSION_MISMATCH: {
        code: 1013,
        reason: "Grid Playwright and grid agent versions are different"
      },
      GRID_SHUTDOWN: {
        code: 1e3,
        reason: "Grid was shutdown"
      },
      AGENT_MANUALLY_STOPPED: {
        code: 1e3,
        reason: "Grid agent was manually stopped"
      }
    };
    var GridWorker = class extends _events.EventEmitter {
      constructor(clientSocket, params) {
        super();
        this.workerId = (0, _utils.createGuid)();
        this.params = void 0;
        this._workerSocket = void 0;
        this._clientSocket = void 0;
        this._log = void 0;
        this._bufferedMessages = [];
        this._log = (0, _debug.default)(`pw:grid:worker:${this.workerId}`);
        this._clientSocket = clientSocket;
        this.params = params;
        clientSocket.on("close", (code, reason) => this.closeWorker(WSErrors.NO_ERROR));
        clientSocket.on("error", (error) => this.closeWorker(WSErrors.CLIENT_SOCKET_ERROR));
        this._clientSocket.on("message", (data) => {
          if (this._workerSocket)
            this._workerSocket.send(data);
          else
            this._bufferedMessages.push(data);
        });
      }
      workerConnected(workerSocket) {
        this._log("connected");
        this._workerSocket = workerSocket;
        workerSocket.on("close", (code, reason) => this.closeWorker(WSErrors.NO_ERROR));
        workerSocket.on("error", (error) => this.closeWorker(WSErrors.WORKER_SOCKET_ERROR));
        workerSocket.on("message", (data) => this._clientSocket.send(data));
        for (const data of this._bufferedMessages)
          workerSocket.send(data);
        this._bufferedMessages = [];
      }
      closeWorker(errorCode) {
        var _this$_workerSocket;
        this._log(`close ${errorCode.reason}`);
        (_this$_workerSocket = this._workerSocket) === null || _this$_workerSocket === void 0 ? void 0 : _this$_workerSocket.close(errorCode.code, errorCode.reason);
        this._clientSocket.close(errorCode.code, errorCode.reason);
        this.emit("close");
      }
      debugInfo() {
        return {
          worker: !!this._workerSocket,
          client: !!this._clientSocket
        };
      }
    };
    var GridAgent = class extends _events.EventEmitter {
      constructor(capacity = Infinity, creationTimeout = 5 * 6e4, retireTimeout = 3e4) {
        super();
        this._capacity = void 0;
        this.agentId = (0, _utils.createGuid)();
        this._ws = void 0;
        this._workers = /* @__PURE__ */ new Map();
        this._status = "none";
        this._workersWaitingForAgentConnected = /* @__PURE__ */ new Set();
        this._retireTimeout = 3e4;
        this._retireTimeoutId = void 0;
        this._log = void 0;
        this._agentCreationTimeoutId = void 0;
        this._capacity = capacity;
        this._log = (0, _debug.default)(`pw:grid:agent:${this.agentId}`);
        this.setStatus("created");
        this._retireTimeout = retireTimeout;
        this._agentCreationTimeoutId = setTimeout(() => {
          this.closeAgent(WSErrors.AGENT_CREATION_TIMED_OUT);
        }, creationTimeout);
      }
      status() {
        return this._status;
      }
      setStatus(status) {
        this._log(`status ${this._status} => ${status}`);
        this._status = status;
      }
      agentConnected(ws) {
        clearTimeout(this._agentCreationTimeoutId);
        this.setStatus("connected");
        this._ws = ws;
        for (const worker of this._workersWaitingForAgentConnected)
          this._sendStartWorkerMessage(worker);
        this._workersWaitingForAgentConnected.clear();
      }
      canCreateWorker() {
        return this._workers.size < this._capacity;
      }
      createWorker(clientSocket, params) {
        return __async(this, null, function* () {
          if (this._retireTimeoutId)
            clearTimeout(this._retireTimeoutId);
          if (this._ws)
            this.setStatus("connected");
          const worker = new GridWorker(clientSocket, params);
          this._log(`create worker: ${worker.workerId}`);
          this._workers.set(worker.workerId, worker);
          worker.on("close", () => {
            this._workers.delete(worker.workerId);
            this._workersWaitingForAgentConnected.delete(worker);
            if (!this._workers.size) {
              this.setStatus("retiring");
              if (this._retireTimeoutId)
                clearTimeout(this._retireTimeoutId);
              if (this._retireTimeout && isFinite(this._retireTimeout))
                this._retireTimeoutId = setTimeout(() => this.closeAgent(WSErrors.AGENT_RETIRED), this._retireTimeout);
            }
          });
          if (this._ws)
            this._sendStartWorkerMessage(worker);
          else
            this._workersWaitingForAgentConnected.add(worker);
        });
      }
      workerConnected(workerId, ws) {
        this._log(`worker connected: ${workerId}`);
        const worker = this._workers.get(workerId);
        worker.workerConnected(ws);
      }
      closeAgent(errorCode) {
        var _this$_ws;
        for (const worker of this._workersWaitingForAgentConnected)
          worker.closeWorker(errorCode);
        for (const worker of this._workers.values())
          worker.closeWorker(errorCode);
        this._log("close");
        (_this$_ws = this._ws) === null || _this$_ws === void 0 ? void 0 : _this$_ws.close(errorCode.code, errorCode.reason);
        this.emit("close");
      }
      _sendStartWorkerMessage(worker) {
        const message = JSON.stringify(__spreadProps(__spreadValues({}, worker.params), {
          "workerId": worker.workerId
        }));
        this._log(`start worker message: ${message}`);
        (0, _utils.assert)(this._ws);
        this._ws.send(message);
      }
    };
    var GridServer = class {
      constructor(factory, authToken = "", address = "") {
        this._server = void 0;
        this._wsServer = void 0;
        this._agents = /* @__PURE__ */ new Map();
        this._log = void 0;
        this._authToken = void 0;
        this._factory = void 0;
        this._pwVersion = void 0;
        this._log = (0, _debug.default)(`pw:grid:server`);
        this._log(`using factory ${factory.name}`);
        this._authToken = authToken || "";
        this._server = new _httpServer.HttpServer(address);
        this._factory = factory;
        this._pwVersion = (0, _userAgent.getPlaywrightVersion)(true);
        this._server.routePath(this._securePath("/"), (request, response) => {
          response.statusCode = 200;
          response.setHeader("Content-Type", "text/html");
          response.end(this._state());
          return true;
        });
        this._server.routePath(this._securePath("/stopAll"), (request, response) => {
          for (const agent of this._agents.values())
            agent.closeAgent(WSErrors.AGENT_MANUALLY_STOPPED);
          response.statusCode = 302;
          response.setHeader("Location", this._securePath("/"));
          response.end();
          return true;
        });
        this._wsServer = this._server.createWebSocketServer();
        this._wsServer.shouldHandle = (request) => {
          this._log(request.url);
          if (request.url.startsWith(this._securePath("/claimWorker"))) {
            return true;
          }
          if (request.url.startsWith("/registerAgent") || request.url.startsWith("/registerWorker")) {
            const params = new _url.URL("http://localhost/" + request.url).searchParams;
            const agentId = params.get("agentId");
            return !!agentId && this._agents.has(agentId);
          }
          return false;
        };
        this._wsServer.on("connection", (ws, request) => __async(this, null, function* () {
          var _request$url, _request$url2, _request$url3;
          if ((_request$url = request.url) !== null && _request$url !== void 0 && _request$url.startsWith(this._securePath("/claimWorker"))) {
            var _this$_createAgent;
            const params = new _url.URL("http://localhost/" + request.url).searchParams;
            const version = params.get("pwVersion");
            if (version !== this._pwVersion && !process.env.PWTEST_UNSAFE_GRID_VERSION) {
              this._log(`version mismatch: ${version} !== ${this._pwVersion}`);
              ws.close(WSErrors.CLIENT_PLAYWRIGHT_VERSION_MISMATCH.code, WSErrors.CLIENT_PLAYWRIGHT_VERSION_MISMATCH.reason);
              return;
            }
            const agent = [...this._agents.values()].find((w) => w.canCreateWorker()) || ((_this$_createAgent = this._createAgent()) === null || _this$_createAgent === void 0 ? void 0 : _this$_createAgent.agent);
            if (!agent) {
              this._log(`failed to get agent`);
              ws.close(WSErrors.AGENT_CREATION_FAILED.code, WSErrors.AGENT_CREATION_FAILED.reason);
              return;
            }
            agent.createWorker(ws, {
              browserAlias: request.headers["x-playwright-browser"],
              headless: request.headers["x-playwright-headless"] !== "0"
            });
            return;
          }
          if ((_request$url2 = request.url) !== null && _request$url2 !== void 0 && _request$url2.startsWith("/registerAgent")) {
            const params = new _url.URL("http://localhost/" + request.url).searchParams;
            if (params.get("pwVersion") !== this._pwVersion) {
              ws.close(WSErrors.AGENT_PLAYWRIGHT_VERSION_MISMATCH.code, WSErrors.AGENT_PLAYWRIGHT_VERSION_MISMATCH.reason);
              return;
            }
            const agentId = params.get("agentId");
            const agent = this._agents.get(agentId);
            if (!agent) {
              ws.close(WSErrors.AGENT_NOT_FOUND.code, WSErrors.AGENT_NOT_FOUND.reason);
              return;
            }
            agent.agentConnected(ws);
            return;
          }
          if ((_request$url3 = request.url) !== null && _request$url3 !== void 0 && _request$url3.startsWith("/registerWorker")) {
            const params = new _url.URL("http://localhost/" + request.url).searchParams;
            const agentId = params.get("agentId");
            const workerId = params.get("workerId");
            const agent = this._agents.get(agentId);
            if (!agent)
              ws.close(WSErrors.AGENT_NOT_FOUND.code, WSErrors.AGENT_NOT_FOUND.reason);
            else if (agent.status() !== "connected")
              ws.close(WSErrors.AGENT_NOT_CONNECTED.code, WSErrors.AGENT_NOT_CONNECTED.reason);
            else
              agent.workerConnected(workerId, ws);
            return;
          }
        }));
      }
      createAgent() {
        return __async(this, null, function* () {
          const {
            initPromise
          } = this._createAgent();
          return yield initPromise;
        });
      }
      _createAgent() {
        const agent = new GridAgent(this._factory.capacity, this._factory.launchTimeout, this._factory.retireTimeout);
        this._agents.set(agent.agentId, agent);
        agent.on("close", () => {
          this._agents.delete(agent.agentId);
        });
        const initPromise = Promise.resolve().then(() => this._factory.launch({
          agentId: agent.agentId,
          gridURL: this._server.urlPrefix(),
          playwrightVersion: (0, _userAgent.getPlaywrightVersion)()
        })).then(() => {
          this._log("created");
          return {
            error: void 0
          };
        }).catch((error) => {
          this._log("failed to launch agent " + agent.agentId);
          console.error(error);
          agent.closeAgent(WSErrors.AGENT_CREATION_FAILED);
          return {
            error
          };
        });
        return {
          agent,
          initPromise
        };
      }
      _securePath(suffix) {
        return this._authToken ? "/" + this._authToken + suffix : suffix;
      }
      _state() {
        return `
        <section style="display: flex; flex-direction: row">
          <div style="display: flex; flex-direction: column; align-items: end; margin-right: 1ex;">
            <span>Grid Playwright Version:</span>
            <span>Agent Factory:</span>
            <span>Agents:</span>
          </div>
          <div style="display: flex; flex-direction: column">
            <span>${this._pwVersion}</span>
            <span>${this._factory.name}</span>
            <span>${this._agents.size} <a href="./stopAll">(Stop All)</a></span>
          </div>
        </section>
        <hr/>
        <ul>
          ${[...this._agents].map(([agentId, agent]) => `
            <li>
              <div>Agent <code>${mangle(agentId)}</code>: ${agent.status()}</div>
              <div>Workers: ${agent._workers.size}</div>
              <ul>
                ${[...agent._workers].map(([workerId, worker]) => `
                  <li>worker <code>${mangle(workerId)}</code> - ${JSON.stringify(worker.debugInfo())}</li>
                `)}
              </ul>
            </li>
          `)}
        </ul>
    `;
      }
      start(port) {
        return __async(this, null, function* () {
          yield this._server.start(port);
        });
      }
      urlPrefix() {
        return this._server.urlPrefix() + this._securePath("/");
      }
      stop() {
        return __async(this, null, function* () {
          for (const agent of this._agents.values())
            agent.closeAgent(WSErrors.GRID_SHUTDOWN);
          (0, _utils.assert)(this._agents.size === 0);
          yield this._server.stop();
        });
      }
    };
    exports2.GridServer = GridServer;
    function mangle(sessionId) {
      return sessionId.replace(/\w{28}/, "x".repeat(28));
    }
  }
});

// node_modules/playwright-core/lib/cli/cli.js
var require_cli = __commonJS({
  "node_modules/playwright-core/lib/cli/cli.js"(exports2) {
    "use strict";
    var _fs = _interopRequireDefault(require("fs"));
    var _os = _interopRequireDefault(require("os"));
    var _path = _interopRequireDefault(require("path"));
    var _commander = require_commander();
    var _driver = require_driver();
    var _traceViewer = require_traceViewer();
    var playwright = _interopRequireWildcard(require_playwright_core());
    var _child_process = require("child_process");
    var _userAgent = require_userAgent();
    var _utils = require_utils();
    var _spawnAsync = require_spawnAsync();
    var _gridAgent = require_gridAgent();
    var _gridServer = require_gridServer();
    var _server = require_server();
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function")
        return null;
      var cacheBabelInterop = new WeakMap();
      var cacheNodeInterop = new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (!nodeInterop && obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return { default: obj };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var packageJSON = require_package();
    _commander.program.version("Version " + (process.env.PW_CLI_DISPLAY_VERSION || packageJSON.version)).name(buildBasePlaywrightCLICommand(process.env.PW_LANG_NAME));
    _commander.program.command("mark-docker-image > [args...]", {
      hidden: true
    }).description("mark docker image").allowUnknownOption(true).action(function(dockerImageNameTemplate) {
      (0, _server.writeDockerVersion)(dockerImageNameTemplate);
    });
    commandWithOpenOptions("open [url]", "open page in browser specified via -b, --browser", []).action(function(url, options) {
      open(options, url, language()).catch(logErrorAndExit);
    }).addHelpText("afterAll", `
Examples:

  $ open  $ open -b webkit https://example.com`);
    commandWithOpenOptions("codegen [url]", "open page and generate code for user actions", [["-o, --output <file name>", "saves the generated script to a file"], ["--target <language>", `language to generate, one of javascript, test, python, python-async, csharp`, language()]]).action(function(url, options) {
      codegen(options, url, options.target, options.output).catch(logErrorAndExit);
    }).addHelpText("afterAll", `
Examples:

  $ codegen
  $ codegen --target=python
  $ codegen -b webkit https://example.com`);
    _commander.program.command("debug <app> [args...]", {
      hidden: true
    }).description("run command in debug mode: disable timeout, open inspector").allowUnknownOption(true).action(function(app, options) {
      (0, _child_process.spawn)(app, options, {
        env: __spreadProps(__spreadValues({}, process.env), {
          PWDEBUG: "1"
        }),
        stdio: "inherit"
      });
    }).addHelpText("afterAll", `
Examples:

  $ debug node test.js
  $ debug npm run test`);
    function suggestedBrowsersToInstall() {
      return _server.registry.executables().filter((e) => e.installType !== "none" && e.type !== "tool").map((e) => e.name).join(", ");
    }
    function checkBrowsersToInstall(args) {
      const faultyArguments = [];
      const executables = [];
      for (const arg of args) {
        const executable = _server.registry.findExecutable(arg);
        if (!executable || executable.installType === "none")
          faultyArguments.push(arg);
        else
          executables.push(executable);
      }
      if (faultyArguments.length) {
        console.log(`Invalid installation targets: ${faultyArguments.map((name) => `'${name}'`).join(", ")}. Expecting one of: ${suggestedBrowsersToInstall()}`);
        process.exit(1);
      }
      return executables;
    }
    _commander.program.command("install [browser...]").description("ensure browsers necessary for this version of Playwright are installed").option("--with-deps", "install system dependencies for browsers").option("--force", "force reinstall of stable browser channels").action(function(args, options) {
      return __async(this, null, function* () {
        const isLikelyNpxGlobal = process.argv.length >= 2 && process.argv[1].includes("_npx");
        if (isLikelyNpxGlobal) {
          console.error((0, _utils.wrapInASCIIBox)([`WARNING: It looks like you are running 'npx playwright install' without first`, `installing your project's dependencies.`, ``, `To avoid unexpected behavior, please install your dependencies first, and`, `then run Playwright's install command:`, ``, `    npm install`, `    npx playwright install`, ``, `If your project does not yet depend on Playwright, first install the`, `applicable npm package (most commonly @playwright/test), and`, `then run Playwright's install command to download the browsers:`, ``, `    npm install @playwright/test`, `    npx playwright install`, ``].join("\n"), 1));
        }
        try {
          if (!args.length) {
            const executables = _server.registry.defaultExecutables();
            if (options.withDeps)
              yield _server.registry.installDeps(executables, false);
            yield _server.registry.install(executables, false);
          } else {
            const installDockerImage = args.some((arg) => arg === "docker-image");
            args = args.filter((arg) => arg !== "docker-image");
            if (installDockerImage) {
              const imageName = `mcr.microsoft.com/playwright:v${(0, _userAgent.getPlaywrightVersion)()}-focal`;
              const {
                code
              } = yield (0, _spawnAsync.spawnAsync)("docker", ["pull", imageName], {
                stdio: "inherit"
              });
              if (code !== 0) {
                console.log("Failed to pull docker image");
                process.exit(1);
              }
            }
            const executables = checkBrowsersToInstall(args);
            if (options.withDeps)
              yield _server.registry.installDeps(executables, false);
            yield _server.registry.install(executables, !!options.force);
          }
        } catch (e) {
          console.log(`Failed to install browsers
${e}`);
          process.exit(1);
        }
      });
    }).addHelpText("afterAll", `

Examples:
  - $ install
    Install default browsers.

  - $ install chrome firefox
    Install custom browsers, supports ${suggestedBrowsersToInstall()}.`);
    _commander.program.command("install-deps [browser...]").description("install dependencies necessary to run browsers (will ask for sudo permissions)").option("--dry-run", "Do not execute installation commands, only print them").action(function(args, options) {
      return __async(this, null, function* () {
        try {
          if (!args.length)
            yield _server.registry.installDeps(_server.registry.defaultExecutables(), !!options.dryRun);
          else
            yield _server.registry.installDeps(checkBrowsersToInstall(args), !!options.dryRun);
        } catch (e) {
          console.log(`Failed to install browser dependencies
${e}`);
          process.exit(1);
        }
      });
    }).addHelpText("afterAll", `
Examples:
  - $ install-deps
    Install dependencies for default browsers.

  - $ install-deps chrome firefox
    Install dependencies for specific browsers, supports ${suggestedBrowsersToInstall()}.`);
    var browsers = [{
      alias: "cr",
      name: "Chromium",
      type: "chromium"
    }, {
      alias: "ff",
      name: "Firefox",
      type: "firefox"
    }, {
      alias: "wk",
      name: "WebKit",
      type: "webkit"
    }];
    for (const {
      alias,
      name,
      type
    } of browsers) {
      commandWithOpenOptions(`${alias} [url]`, `open page in ${name}`, []).action(function(url, options) {
        open(__spreadProps(__spreadValues({}, options), {
          browser: type
        }), url, options.target).catch(logErrorAndExit);
      }).addHelpText("afterAll", `
Examples:

  $ ${alias} https://example.com`);
    }
    commandWithOpenOptions("screenshot <url> <filename>", "capture a page screenshot", [["--wait-for-selector <selector>", "wait for selector before taking a screenshot"], ["--wait-for-timeout <timeout>", "wait for timeout in milliseconds before taking a screenshot"], ["--full-page", "whether to take a full page screenshot (entire scrollable area)"]]).action(function(url, filename, command) {
      screenshot(command, command, url, filename).catch(logErrorAndExit);
    }).addHelpText("afterAll", `
Examples:

  $ screenshot -b webkit https://example.com example.png`);
    commandWithOpenOptions("pdf <url> <filename>", "save page as pdf", [["--wait-for-selector <selector>", "wait for given selector before saving as pdf"], ["--wait-for-timeout <timeout>", "wait for given timeout in milliseconds before saving as pdf"]]).action(function(url, filename, options) {
      pdf(options, options, url, filename).catch(logErrorAndExit);
    }).addHelpText("afterAll", `
Examples:

  $ pdf https://example.com example.pdf`);
    _commander.program.command("experimental-grid-server", {
      hidden: true
    }).option("--port <port>", "grid port; defaults to 3333").option("--address <address>", "address of the server").option("--agent-factory <factory>", "path to grid agent factory or npm package").option("--auth-token <authToken>", "optional authentication token").action(function(options) {
      launchGridServer(options.agentFactory, options.port || 3333, options.address, options.authToken);
    });
    _commander.program.command("experimental-grid-agent", {
      hidden: true
    }).requiredOption("--agent-id <agentId>", "agent ID").requiredOption("--grid-url <gridURL>", "grid URL").action(function(options) {
      (0, _gridAgent.launchGridAgent)(options.agentId, options.gridUrl);
    });
    _commander.program.command("run-driver", {
      hidden: true
    }).action(function(options) {
      (0, _driver.runDriver)();
    });
    _commander.program.command("run-server", {
      hidden: true
    }).option("--port <port>", "Server port").option("--path <path>", "Endpoint Path", "/").option("--max-clients <maxClients>", "Maximum clients").option("--no-socks-proxy", "Disable Socks Proxy").action(function(options) {
      (0, _driver.runServer)(options.port ? +options.port : void 0, options.path, options.maxClients ? +options.maxClients : Infinity, options.socksProxy).catch(logErrorAndExit);
    });
    _commander.program.command("print-api-json", {
      hidden: true
    }).action(function(options) {
      (0, _driver.printApiJson)();
    });
    _commander.program.command("launch-server", {
      hidden: true
    }).requiredOption("--browser <browserName>", 'Browser name, one of "chromium", "firefox" or "webkit"').option("--config <path-to-config-file>", "JSON file with launchServer options").action(function(options) {
      (0, _driver.launchBrowserServer)(options.browser, options.config);
    });
    _commander.program.command("show-trace [trace...]").option("-b, --browser <browserType>", "browser to use, one of cr, chromium, ff, firefox, wk, webkit", "chromium").description("Show trace viewer").action(function(traces, options) {
      if (options.browser === "cr")
        options.browser = "chromium";
      if (options.browser === "ff")
        options.browser = "firefox";
      if (options.browser === "wk")
        options.browser = "webkit";
      (0, _traceViewer.showTraceViewer)(traces, options.browser, false, 9322).catch(logErrorAndExit);
    }).addHelpText("afterAll", `
Examples:

  $ show-trace https://example.com/trace.zip`);
    if (!process.env.PW_LANG_NAME) {
      let playwrightTestPackagePath = null;
      try {
        playwrightTestPackagePath = require.resolve("@playwright/test/lib/cli", {
          paths: [__dirname, process.cwd()]
        });
      } catch (e) {
      }
      if (playwrightTestPackagePath) {
        require(playwrightTestPackagePath).addTestCommand(_commander.program);
        require(playwrightTestPackagePath).addShowReportCommand(_commander.program);
        require(playwrightTestPackagePath).addListFilesCommand(_commander.program);
      } else {
        {
          const command = _commander.program.command("test").allowUnknownOption(true);
          command.description("Run tests with Playwright Test. Available in @playwright/test package.");
          command.action(() => __async(exports2, null, function* () {
            console.error("Please install @playwright/test package to use Playwright Test.");
            console.error("  npm install -D @playwright/test");
            process.exit(1);
          }));
        }
        {
          const command = _commander.program.command("show-report").allowUnknownOption(true);
          command.description("Show Playwright Test HTML report. Available in @playwright/test package.");
          command.action(() => __async(exports2, null, function* () {
            console.error("Please install @playwright/test package to use Playwright Test.");
            console.error("  npm install -D @playwright/test");
            process.exit(1);
          }));
        }
      }
    }
    _commander.program.parse(process.argv);
    function launchContext(options, headless, executablePath) {
      return __async(this, null, function* () {
        validateOptions(options);
        const browserType = lookupBrowserType(options);
        const launchOptions = {
          headless,
          executablePath
        };
        if (options.channel)
          launchOptions.channel = options.channel;
        const contextOptions = options.device ? __spreadValues({}, playwright.devices[options.device]) : {};
        if (!headless)
          contextOptions.deviceScaleFactor = _os.default.platform() === "darwin" ? 2 : 1;
        if (browserType.name() === "webkit" && process.platform === "linux") {
          delete contextOptions.hasTouch;
          delete contextOptions.isMobile;
        }
        if (contextOptions.isMobile && browserType.name() === "firefox")
          contextOptions.isMobile = void 0;
        if (options.proxyServer) {
          launchOptions.proxy = {
            server: options.proxyServer
          };
          if (options.proxyBypass)
            launchOptions.proxy.bypass = options.proxyBypass;
        }
        const browser = yield browserType.launch(launchOptions);
        if (options.viewportSize) {
          try {
            const [width, height] = options.viewportSize.split(",").map((n) => parseInt(n, 10));
            contextOptions.viewport = {
              width,
              height
            };
          } catch (e) {
            console.log('Invalid window size format: use "width, height", for example --window-size=800,600');
            process.exit(0);
          }
        }
        if (options.geolocation) {
          try {
            const [latitude, longitude] = options.geolocation.split(",").map((n) => parseFloat(n.trim()));
            contextOptions.geolocation = {
              latitude,
              longitude
            };
          } catch (e) {
            console.log('Invalid geolocation format: user lat, long, for example --geolocation="37.819722,-122.478611"');
            process.exit(0);
          }
          contextOptions.permissions = ["geolocation"];
        }
        if (options.userAgent)
          contextOptions.userAgent = options.userAgent;
        if (options.lang)
          contextOptions.locale = options.lang;
        if (options.colorScheme)
          contextOptions.colorScheme = options.colorScheme;
        if (options.timezone)
          contextOptions.timezoneId = options.timezone;
        if (options.loadStorage)
          contextOptions.storageState = options.loadStorage;
        if (options.ignoreHttpsErrors)
          contextOptions.ignoreHTTPSErrors = true;
        const context = yield browser.newContext(contextOptions);
        let closingBrowser = false;
        function closeBrowser() {
          return __async(this, null, function* () {
            if (closingBrowser)
              return;
            closingBrowser = true;
            if (options.saveTrace)
              yield context.tracing.stop({
                path: options.saveTrace
              });
            if (options.saveStorage)
              yield context.storageState({
                path: options.saveStorage
              }).catch((e) => null);
            yield browser.close();
          });
        }
        context.on("page", (page) => {
          page.on("dialog", () => {
          });
          page.on("close", () => {
            const hasPage = browser.contexts().some((context2) => context2.pages().length > 0);
            if (hasPage)
              return;
            closeBrowser().catch((e) => null);
          });
        });
        if (options.timeout) {
          context.setDefaultTimeout(parseInt(options.timeout, 10));
          context.setDefaultNavigationTimeout(parseInt(options.timeout, 10));
        }
        if (options.saveTrace)
          yield context.tracing.start({
            screenshots: true,
            snapshots: true
          });
        delete launchOptions.headless;
        delete launchOptions.executablePath;
        delete contextOptions.deviceScaleFactor;
        return {
          browser,
          browserName: browserType.name(),
          context,
          contextOptions,
          launchOptions
        };
      });
    }
    function openPage(context, url) {
      return __async(this, null, function* () {
        const page = yield context.newPage();
        if (url) {
          if (_fs.default.existsSync(url))
            url = "file://" + _path.default.resolve(url);
          else if (!url.startsWith("http") && !url.startsWith("file://") && !url.startsWith("about:") && !url.startsWith("data:"))
            url = "http://" + url;
          yield page.goto(url);
        }
        return page;
      });
    }
    function open(options, url, language2) {
      return __async(this, null, function* () {
        const {
          context,
          launchOptions,
          contextOptions
        } = yield launchContext(options, !!process.env.PWTEST_CLI_HEADLESS, process.env.PWTEST_CLI_EXECUTABLE_PATH);
        yield context._enableRecorder({
          language: language2,
          launchOptions,
          contextOptions,
          device: options.device,
          saveStorage: options.saveStorage
        });
        yield openPage(context, url);
        if (process.env.PWTEST_CLI_EXIT)
          yield Promise.all(context.pages().map((p) => p.close()));
      });
    }
    function codegen(options, url, language2, outputFile) {
      return __async(this, null, function* () {
        const {
          context,
          launchOptions,
          contextOptions
        } = yield launchContext(options, !!process.env.PWTEST_CLI_HEADLESS, process.env.PWTEST_CLI_EXECUTABLE_PATH);
        yield context._enableRecorder({
          language: language2,
          launchOptions,
          contextOptions,
          device: options.device,
          saveStorage: options.saveStorage,
          startRecording: true,
          outputFile: outputFile ? _path.default.resolve(outputFile) : void 0
        });
        yield openPage(context, url);
        if (process.env.PWTEST_CLI_EXIT)
          yield Promise.all(context.pages().map((p) => p.close()));
      });
    }
    function waitForPage(page, captureOptions) {
      return __async(this, null, function* () {
        if (captureOptions.waitForSelector) {
          console.log(`Waiting for selector ${captureOptions.waitForSelector}...`);
          yield page.waitForSelector(captureOptions.waitForSelector);
        }
        if (captureOptions.waitForTimeout) {
          console.log(`Waiting for timeout ${captureOptions.waitForTimeout}...`);
          yield page.waitForTimeout(parseInt(captureOptions.waitForTimeout, 10));
        }
      });
    }
    function screenshot(options, captureOptions, url, path) {
      return __async(this, null, function* () {
        const {
          browser,
          context
        } = yield launchContext(options, true);
        console.log("Navigating to " + url);
        const page = yield openPage(context, url);
        yield waitForPage(page, captureOptions);
        console.log("Capturing screenshot into " + path);
        yield page.screenshot({
          path,
          fullPage: !!captureOptions.fullPage
        });
        yield browser.close();
      });
    }
    function pdf(options, captureOptions, url, path) {
      return __async(this, null, function* () {
        if (options.browser !== "chromium") {
          console.error("PDF creation is only working with Chromium");
          process.exit(1);
        }
        const {
          browser,
          context
        } = yield launchContext(__spreadProps(__spreadValues({}, options), {
          browser: "chromium"
        }), true);
        console.log("Navigating to " + url);
        const page = yield openPage(context, url);
        yield waitForPage(page, captureOptions);
        console.log("Saving as pdf into " + path);
        yield page.pdf({
          path
        });
        yield browser.close();
      });
    }
    function lookupBrowserType(options) {
      let name = options.browser;
      if (options.device) {
        const device = playwright.devices[options.device];
        name = device.defaultBrowserType;
      }
      let browserType;
      switch (name) {
        case "chromium":
          browserType = playwright.chromium;
          break;
        case "webkit":
          browserType = playwright.webkit;
          break;
        case "firefox":
          browserType = playwright.firefox;
          break;
        case "cr":
          browserType = playwright.chromium;
          break;
        case "wk":
          browserType = playwright.webkit;
          break;
        case "ff":
          browserType = playwright.firefox;
          break;
      }
      if (browserType)
        return browserType;
      _commander.program.help();
    }
    function validateOptions(options) {
      if (options.device && !(options.device in playwright.devices)) {
        console.log(`Device descriptor not found: '${options.device}', available devices are:`);
        for (const name in playwright.devices)
          console.log(`  "${name}"`);
        process.exit(0);
      }
      if (options.colorScheme && !["light", "dark"].includes(options.colorScheme)) {
        console.log('Invalid color scheme, should be one of "light", "dark"');
        process.exit(0);
      }
    }
    function logErrorAndExit(e) {
      console.error(e);
      process.exit(1);
    }
    function language() {
      return process.env.PW_LANG_NAME || "test";
    }
    function commandWithOpenOptions(command, description, options) {
      let result = _commander.program.command(command).description(description);
      for (const option of options)
        result = result.option(option[0], ...option.slice(1));
      return result.option("-b, --browser <browserType>", "browser to use, one of cr, chromium, ff, firefox, wk, webkit", "chromium").option("--channel <channel>", 'Chromium distribution channel, "chrome", "chrome-beta", "msedge-dev", etc').option("--color-scheme <scheme>", 'emulate preferred color scheme, "light" or "dark"').option("--device <deviceName>", 'emulate device, for example  "iPhone 11"').option("--geolocation <coordinates>", 'specify geolocation coordinates, for example "37.819722,-122.478611"').option("--ignore-https-errors", "ignore https errors").option("--load-storage <filename>", "load context storage state from the file, previously saved with --save-storage").option("--lang <language>", 'specify language / locale, for example "en-GB"').option("--proxy-server <proxy>", 'specify proxy server, for example "http://myproxy:3128" or "socks5://myproxy:8080"').option("--proxy-bypass <bypass>", 'comma-separated domains to bypass proxy, for example ".com,chromium.org,.domain.com"').option("--save-storage <filename>", "save context storage state at the end, for later use with --load-storage").option("--save-trace <filename>", "record a trace for the session and save it to a file").option("--timezone <time zone>", 'time zone to emulate, for example "Europe/Rome"').option("--timeout <timeout>", "timeout for Playwright actions in milliseconds", "10000").option("--user-agent <ua string>", "specify user agent string").option("--viewport-size <size>", 'specify browser viewport size in pixels, for example "1280, 720"');
    }
    function launchGridServer(factoryPathOrPackageName, port, address, authToken) {
      return __async(this, null, function* () {
        if (!factoryPathOrPackageName)
          factoryPathOrPackageName = _path.default.join("..", "grid", "simpleGridFactory");
        let factory;
        try {
          factory = require(_path.default.resolve(factoryPathOrPackageName));
        } catch (e) {
          factory = require(factoryPathOrPackageName);
        }
        if (factory && typeof factory === "object" && "default" in factory)
          factory = factory["default"];
        if (!factory || !factory.launch || typeof factory.launch !== "function")
          throw new Error("factory does not export `launch` method");
        factory.name = factory.name || factoryPathOrPackageName;
        const gridServer = new _gridServer.GridServer(factory, authToken, address);
        yield gridServer.start(port);
        console.log("Grid server is running at " + gridServer.urlPrefix());
      });
    }
    function buildBasePlaywrightCLICommand(cliTargetLang) {
      switch (cliTargetLang) {
        case "python":
          return `playwright`;
        case "java":
          return `mvn exec:java -e -Dexec.mainClass=com.microsoft.playwright.CLI -Dexec.args="...options.."`;
        case "csharp":
          return `pwsh bin\\Debug\\netX\\playwright.ps1`;
        default:
          return `npx playwright`;
      }
    }
  }
});

// node_modules/playwright-core/cli.js
var require_cli2 = __commonJS({
  "node_modules/playwright-core/cli.js"(exports2, module2) {
    module2.exports = require_cli();
  }
});

// node_modules/playwright/cli.js
module.exports = require_cli2();
/*!
 * node-progress
 * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */
